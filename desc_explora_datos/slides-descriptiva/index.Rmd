---
title: "GESTI√ìN DE BASES DE DATOS"
subtitle: "M√°ster en Bioestad√≠stica"
author:
  - "Javier √Ålvarez Li√©bana (Fac. Estudios Estad√≠sticos - UCM)"
date: "√öltima actualizaci√≥n: `r format(lubridate::today(), format = '%d-%m-%Y')`"
output:
  xaringan::moon_reader:
    css: xaringan-themer.css
    # css: [default, style.css]
    nature:
      slideNumberFormat: "%current%"
      highlightStyle: github
      highlightLines: true
      ratio: 16:9
      countIncrementalSlides: true
---


```{r settings, include = FALSE, warning = FALSE}
knitr::opts_chunk$set(fig.retina = 3, out.width = "100%",
                      cache = FALSE, comment = ">",
                      echo = TRUE, message = FALSE,
                      warning = FALSE, hiline = TRUE,
                      dpi = 100)
```

```{r xaringan-extra, include = FALSE, warning = FALSE}
# devtools::install_github("gadenbuie/xaringanExtra")
library(xaringanExtra)
use_xaringan_extra(c("tile_view", "animate_css", "tachyons"))
use_tile_view() # panel
use_extra_styles(hover_code_line = TRUE,
                 mute_unhighlighted_code = FALSE) # Hover triangle
# code line
use_clipboard( # About clipboard
  button_text = "Click para copiar c√≥digo",
  success_text = "C√≥digo copiado",
  error_text = "Ctrl+C para copiar"
)

# use_freezeframe() # restarting gifs
# use_animate_all("fade") # animates
use_panelset() # panels 
```

```{r xaringan-themer, include = FALSE, warning = FALSE}
# devtools::install_github("gadenbuie/xaringanthemer")
library(xaringanthemer)
style_duo_accent(primary_color = "#1F4257",
          secondary_color = "#EA9D8E", # #F97B64",
          background_color = "#FFFEFE",
          header_font_google = google_font("Josefin Sans"),
          text_font_google =
            google_font("Montserrat", "300", "300i", "400", "500", "600", "700", "800", "900"),
          code_font_google = google_font("Fira Mono"),
          black = "#1F4257",
          inverse_text_color = "#1F4257",
          inverse_header_color = "#1F4257",
          base_font_size = "21px",
          text_font_size = "1.1rem",
          code_font_size = "1rem",
          header_h1_font_size = "2.8rem",
          header_h2_font_size = "2.3rem",
          header_h3_font_size = "1.8rem",
          code_highlight_color = "rgba(248, 223, 88, 0.25)",
          code_inline_background_color = "rgba(248, 223, 88, 0.6)",
          code_inline_font_size = "1em",
          colors = c(purple = "#74688D",
                     yellow = "#F8DF58",
                     green = "#2c8475",
                     red = "#E54F4D",
                     orange = "#EA9D8E",
                     green_light = "rgba(44, 132, 117, 0.35)",
                     red_light = "rgba(229, 79, 77, 0.7)",
                     purple_light = "rgba(116, 104, 141, 0.5)"),
          text_bold_font_weight = 800,
          link_decoration = "underline dotted",
          link_color = "#74688D",
          inverse_link_color = "#1F4257"
)
```


class: inverse center middle

# ATAJOS DE LAS DIAPOSITIVAS


```{r packages, include = FALSE, warning = FALSE}
library(tidyverse)
library(lubridate)
library(glue)
```


$$\\[2in]$$

.left[Pulsa <kbd-black>O</kbd-black> para ver el **PANEL DE DIAPOSITIVAS**]
.left[Pulsa <kbd-black>H</kbd-black> para ver **OTROS ATAJOS**]

---

# .orange[MATERIAL] de las clases


.pull-left[

- **.bg-purple_light[Diapositivas]** del curso:
<https://dadosdelaplace.github.io/teaching/pca-clustering>

- **.bg-yellow[Scripts]** de la asignatura
<https://github.com/dadosdelaplace/teaching/tree/main/bdba-pca-clustering-2022/scripts>

- **.bg-orange[Bibliograf√≠a]**: <https://github.com/dadosdelaplace/teaching/tree/main/bdba-pca-clustering-2022/biblio>

&nbsp;

- **.bg-green_light[Manual de R]**: <https://dadosdelaplace.github.io/courses-intro-R/>

]

---

# Me presento: la turra

.pull-left[

```{r echo = FALSE,  out.width = "80%", fig.align = "left"}
knitr::include_graphics("./img/me.jpeg")
``` 

]

.pull-right[

* **.bg-purple_light[Javier √Ålvarez Li√©bana]**, nacido en 1989 en Carabanchel Bajo (Madrid)

* Licenciado (UCM) en **Matem√°ticas** (Erasmus en Bologna mediante). **M√°ster (UCM) en Ingenier√≠a Matem√°tica** (2013-2014)


* **.bg-orange[Doctorado en estad√≠stica]** por la Universidad de Granada


* Encargado de la **visualizaci√≥n y an√°lisis de datos covid** de la Consejer√≠a de Salud del **Principado de Asturias**

]


Intentando eso de la **.bg-yellow[divulgaci√≥n]** por **Twitter** (@dadosdelaplace) e **Instagram** (@javieralvarezliebana)

---

class: inverse center middle

# CLASES

&nbsp;

#### [CLASE 1](#clase-1)

#### [CLASE 2](#clase-2)

#### [CLASE 3](#clase-3)

#### [CLASE 4](#clase-4)

#### [CLASE 5](#clase-5)

---


class: inverse center middle
name: clase-1

# CLASE 1: introducci√≥n a R desde cero.

&nbsp;

### [Planificaci√≥n y objetivos](#objetivos)

### [Instalaci√≥n](#instalacion)

### [¬øQu√© es R?](#que-es-R)

### [Primeros pasos](#primeros-pasos)

### [Ejercicios](#ejercicios1)

---

name: objetivos

# .orange[OBJETIVOS] de la asignatura


El **.bg-purple_light[prop√≥sito]** de esta asignatura ser√° triple

- **.bg-orange[Quitarnos el miedo]** a programar: a programar se aprende programando, no hace falta ser Julian Assange para ello

--

- Aprender a **.bg-orange[abstraer ideas]** para implementarlas en un lenguaje de programaci√≥n, as√≠ como adquirir una base para el **.bg-orange[preprocesamiento, an√°lisis y visualizaci√≥n de datos]**.

--

- Am√©n de no tener miedo a hacerlo, encontrarle la **.bg-orange[utilidad]** y entender las facilidades que nos ofrece `R` frente a otras opciones como Excel o SPSS.


&nbsp;

üìö Estas **diapositivas** han sido elaboradas con el propio `R` haciendo uso de los paquetes `{xaringan}`, `{xaringanExtra}` y `{xaringanthemer}`.

---

# .orange[CASOS REALES] de uso de R


.pull-left[

```{r echo = FALSE,  out.width = "97%", fig.align = "left"}
knitr::include_graphics("./img/covid_isciii.jpg")
``` 

]

.pull-right[

```{r echo = FALSE,  out.width = "97%", fig.align = "left"}
knitr::include_graphics("./img/momo_isciii.jpg")
``` 


]

Las webs del Instituto de Salud Carlos III <https://cnecovid.isciii.es/covid19/> y <https://momo.isciii.es/panel_momo/> est√°n hechas con `R` (con `{shiny}` y `{plotly}` )

---

# .orange[CASOS REALES] de uso de R

.pull-left[

```{r echo = FALSE,  out.width = "99%", fig.align = "left"}
knitr::include_graphics("./img/elpais_R.jpg")
``` 

]

.pull-right[

El **.bg-purple_light[equipo de datos]** (Borja Andrino, Kiko Llaneras y Daniele Grasso) trabaja con `R` para elaborar sus an√°lisis, desde los datos electorales hasta el cambio clim√°tico.

Es una de las razones por las que son capaces de realizar brillantes an√°lisis de grandes vol√∫menes de datos de forma r√°pida y √°gil: la **.bg-purple_light[automatizaci√≥n de procesos]** que nos permite programar en `R` puede ser fundamental para analizar datos que hasta entonces no pod√≠amos.

]

---

name: instalacion

# Requisitos

Para la asignatura los √∫nicos **.bg-purple_light[requisitos]** ser√°n:

--

1. **.bg-orange[Conexi√≥n a internet]** (para la descarga de algunos datos y paquetes).

--

2. **.bg-orange[Instalar R]**: ser√° nuestro lenguaje, nuestro **.bg-yellow[castellano]** para poder ¬´comunicarnos con el ordenador. La descarga la haremos (gratuitamente) desde <https://cran.r-project.org/>

--

3. **.bg-orange[Instalar R Studio]**. De la misma manera que podemos escribir castellano en un Word o en un tuit, podemos usar **distintos IDE** (entornos de desarrollo integrados, nuestro Office), para que el trabajo sea m√°s c√≥modo. Nuestro **.bg-yellow[Word]** para nosotros ser√° **RStudio**.

.left[
  <img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/cran-R.jpg" alt = "cran-R" align = "left" width = "460" style = "margin-top: 2vh">
]

.right[
  <img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/R-studio.jpg" alt = "RStudio" align = "right" width = "460" style = "margin-top: 2vh;">
]


---

# Instalaci√≥n de R

El lenguaje `R` ser√° nuestra **.bg-purple_light[gram√°tica]**, nuestra ortograf√≠a y nuestro diccionario

.pull-left[



- **Paso 1**: entra en <https://cran.r-project.org/> y selecciona **.bg-purple_light[sistema operativo]**.

- **Paso 2**: para **.bg-purple_light[Mac]** basta con que hacer click en el archivo .pkg, y abrirlo una vez descargado. Para sistemas **.bg-purple_light[Windows]**, debemos clickar en `install R for the first time` y en la siguiente pantalla en `Download R for Windows`. Una vez descargado, abrirlo como cualquier archivo de instalaci√≥n.

- **Paso 3**: abrir el **ejecutable**.

]

.pull-right[

<img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/cran-R.jpg" alt = "cran-R" align = "left" width = "900" style = "margin-top: 1vh">

]

**.bg-green_light[Consejito]**: siempre que tengas que descargar algo de CRAN (ya sea el propio R o un paquete), aseg√∫rate de tener conexi√≥n a **.bg-orange[internet]**.


---

# Primera operaci√≥n

Para comprobar que se ha instalado correctamente, tras abrir `R`, deber√≠as ver una **pantalla blanca** similar a esta (en realidad se llama **.bg-purple_light[consola]**). Vamos a escribir nuestra **.bg-orange[primera operaci√≥n]** en la consola:

.pull-left[

* A una variable llamada `a` le asignaremos el valor 1 (asignamos con `<-`, como una flecha)

```{r eval = FALSE}
# Una variable a con valor --> 1
a <- 1 #<<
```

]

--

.pull-right[

* A otra variable llamada `b` le asignaremos el valor 2 (cambia a la izquierda el nombre, cambia a la derecha el valor).

```{r eval = FALSE}
# Una variable b con valor --> 2
b <- 2 #<<
```

]

--

.pull-left[

* Sumamos las variables haciendo `a + b`.

```{r eval = FALSE}
# Primera operaci√≥n
a <- 1 # Una variable a con valor --> 1
b <- 2 # Una variable b con valor --> 2
a + b #<<
```
]

--

.pull-right[

* El resultado que nos devuelve ser√° `3`.

```{r echo = FALSE}
a <- 1
b <- 2
a + b
```

]

---

# .orange[INSTALACI√ìN] de RStudio

El **.bg-purple_ligth[Word]** que usaremos para trabajar y escribir en nuestro lenguaje ser√° **.bg-purple_ligth[RStudio]** (lo que se conoce como un **IDE**, un entorno integrado de desarrollo).

.pull-left[

* **Paso 1**: entra en la [web oficial de RStudio](https://www.rstudio.com/products/rstudio/download/#download) y selecciona la **.bg-purple_light[descarga gratuita]**.

* **Paso 2**: selecciona el ejecutable que te aparezca, acorde a tu sistema operativo.

* **Paso 3**: tras descargar el ejecutable, hay que abrirlo como otro cualquier otro ejecutable y dejar que **.bg-purple_light[termine la instalaci√≥n]**.

]

.pull-right[

```{r echo = FALSE,  out.width = "80%", fig.align = "left"}
knitr::include_graphics("./img/R-studio.jpg")
``` 


]

---

# .orange[ORGANIZACI√ìN] de RStudio

.pull-left[

```{r echo = FALSE,  out.width = "95%", fig.align = "left"}
knitr::include_graphics("./img/inicio_rstudio_2.jpg")
``` 

]

.pull-right[

* **.bg-purple_light[Consola]**: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo c√≥digo que antes (la suma) en ella. La consola ser√° donde **.bg-orange[ejecutaremos √≥rdenes]** y **.bg-yellow[mostraremos resultados]**.
]

---

# .orange[ORGANIZACI√ìN] de RStudio

.pull-left[

```{r echo = FALSE,  out.width = "75%", fig.align = "left"}
knitr::include_graphics("./img/inicio_rstudio_3.jpg")
``` 

]

.pull-right[

* **.bg-purple_light[Environment]** (entorno de variables): la pantalla peque√±a (puedes ajustar los m√°rgenes con el rat√≥n) que tenemos en la parte superior derecha. Nos mostrar√° las **variables que tenemos definidas, el tipo y su valor**.

]

---

# .orange[ORGANIZACI√ìN] de RStudio

.pull-left[

```{r echo = FALSE,  out.width = "85%", fig.align = "left"}
knitr::include_graphics("./img/inicio_rstudio_4.jpg")
``` 

]

.pull-right[

* **.bg-purple_light[Panel multiusos]**: la ventana que tenemos en la parte inferior derecha no servir√° para buscar **.bg-orange[ayuda de funciones]**, adem√°s de para **.bg-yellow[visualizar gr√°ficos]**. 

]

---

name: que-es-R

# ¬øQu√© es R?


<img src = "https://logos.turbio.repl.co/rlang.svg" alt = "Rstudio" align = "left" width = "300" style = "margin-top: 1vh;margin-right: 2rem;">

`R` es un **.bg-purple_light[lenguaje estad√≠stico]**, creado por y para la estad√≠stica, con 4 ventajas fundamentales:

--

* **.bg-purple_light[Software libre]** (como C++, Python, etc). no solo es gratis, sino que permite **.bg-orange[acceder libremente a c√≥digo ajeno]**.

--

* **.bg-purple_light[Lenguaje modular]**: en la instalaci√≥n que hemos realizado solo se ha instalado el m√≠nimo para poder funcionar. Al ser software libre, existen **.bg-orange[trozos de c√≥digo]** hechos por otras personas (**.bg-yellow[paquetes]**) que podemos instalar seg√∫n necesidades.

--

* **.bg-purple_light[Gran comunidad de usuarios]**: `R` tiene una comunidad de usuarios gigante para hacer estad√≠stica (Python tiene una comunidad m√°s enfocada al Machine Learning), con m√°s de 18 000 paquetes.

--

* **.bg-purple_light[Lenguaje de alto nivel]**. Los lenguajes de alto nivel, como `R` o `Python`, facilitan la programaci√≥n al usuario (menor curva de aprendizaje, aunque m√°s lentos en ejecuci√≥n).

---

class: inverse center middle

**COMPRAR** libro --> instalar un paquete (una sola vez) `install.packages()`
<figure>
<img src = "https://cdn.cienradios.com/wp-content/uploads/sites/14/2020/09/Book-Depository-2.jpg" alt = "comprar-libros" align = "middle" width = "480" style = "margin-top: 1vh;">
</figure>

**SELECCIONAR** libro (ya comprado) --> acceder a un paquete instalado (en cada sesi√≥n que queramos usarlo) `library()`
<figure>
<img src = "https://cdn.sincroguia.tv/uploads/programs/l/a/-/la-biblioteca-de-los-libros-rechazados-704306_SPA-77.jpg" alt = "comprar-libros-2" align = "middle" width = "480" style = "margin-top: 1vh;">
</figure>


---

# Paquetes en R

A lo largo del curso usaremos varios de esos **.bg-purple_light[paquetes]**, como por ejemplo el paquete `{ggplot2}`, un paquete para la elaboraci√≥n de **.bg-purple_light[visualizaciones de datos]**. Vamos a instalarlo (necesitamos internet para ello) con la orden `install.packages("ggplot")`

```{r eval = FALSE}
install.packages("ggplot2")
```

&nbsp;


&nbsp;



La **.bg-purple_light[instalaci√≥n]** de un paquete es el equivalente a **.bg-orange[comprar a un libro]**: solo lo debemos hacer **la primera vez** que lo usemos en un ordenador. Una vez que tenemos comprado nuestro libro, para poder usarlo, simplemente debemos indicar al programa que nos lo **.bg-purple_light[acerque de la estanter√≠a]** con `library(ggplot2)`.

```{r eval = FALSE}
library(ggplot2)
```

---

class: center middle

# ¬øPor qu√© .orange[NO] usar Excel?

![](./img/meme_barco.jpg)

---

# ¬øPor qu√© .orange[NO] usar Excel?

Excel es una **.bg-purple_light[hoja de c√°lculo]**, ni m√°s ni menos, y el propio **Microsoft desaconseja su uso** para el an√°lisis de datos. El Excel es una herramienta maravillosa para ser usada como una sencilla hoja de c√°lculo (llevar cuentas de tu familia, declaraci√≥n de Renta, planificar viajes, etc).

&nbsp;

**.bg-red_light[NO EST√Å DISE√ëADO]** para ser una base de datos, y muchos menos pensado para generar un entorno flexible para el an√°lisis estad√≠stico:

* **.bg-red_light[Software de pago]**

* **.bg-red_light[Software cerrado]**: solo podemos hacer lo que Excel ha cre√≠do que interesante que podamos hacer.

* **.bg-red_light[Alto consumo de memoria]**.

* **.bg-red_light[No es universal]**: no solo es de pago sino que adem√°s, dependiendo de la versi√≥n que tengas de Excel, tendr√° un formato distinto para datos como fechas, teniendo incluso extensiones distintas.

---


# .red[EPIC FAILS] en Excel


.pull-left[

```{r echo = FALSE,  out.width = "80%", fig.align = "left"}
knitr::include_graphics("./img/excel_genes.jpg")
``` 

]

.pull-right[


## Problemas de **.red[versiones]**

]

---

# .red[EPIC FAILS] en Excel

.left[

```{r echo = FALSE,  out.width = "40%", fig.align = "left"}
knitr::include_graphics("./img/excel_uk.jpg")
``` 

]

.pull-right[

## Problemas de **.red[memoria]**

]

---

# .red[EPIC FAILS] en Excel

.left[

```{r echo = FALSE,  out.width = "40%", fig.align = "left"}
knitr::include_graphics("./img/excel_edades.jpg")
``` 

]

.pull-right[


## Problemas de **.red[codificaci√≥n]**


]

---

# .orange[Incel] vs excel

```{r echo = FALSE, out.width = '75%', fig.align = "center"}
knitr::include_graphics("./img/incel.jpg")
```

---

name: primeros-pasos

# Primeros pasos en R: .orange[CALCULADORA]

Empecemos por lo sencillo: **.bg-purple-light[¬øc√≥mo usar R como una calculadora?]** Si escribimos `2 + 1` en la consola y pulsamos ENTER, la consola nos mostrar√° el resultado de la suma.

```{r}
2 + 1
```

--

Si dicha suma la quisi√©ramos utilizar para un segundo c√°lculo: ¬øy si la **.bg-purple-light[almacenamos en alguna variable]**? Por ejemplo, vamos a guardar la suma en una variable `x`

```{r}
x <- 2 + 1 #<<
```

--

Si te fijas ahora `x` aparece definida en nuestro **.bg-yellow[environment]**, y puede ser usada de nuevo

```{r}
x + 3
```

---

# Primeros pasos en R: .orange[CALCULADORA]

### Multiplicaci√≥n

```{r eval = FALSE}
x * y #<<
```

### Elevar al cuadrado

```{r eval = FALSE}
x^2 #<<
```

### Valor absoluto

```{r eval = FALSE}
abs(x) #<<
```

---

# .red[Errores]

Durante tu aprendizaje va a ser **muy habitual** que las cosas no salgan a la primera, apareciendo en consola **.bg-purple_light[mensajes de error]** en un **.bg-red_light[color rojo]**. No te asustes: lo peor que puede pasar es que tengas que reiniciar `R`).

&nbsp;

* Mensajes de **.bg-red_light[ERROR]**: ir√°n precedidos de la frase **.bg-yellow[¬´Error in‚Ä¶¬ª]**, y ser√°n aquellos fallos que **impidan la ejecuci√≥n del c√≥digo** 

```{r error = TRUE}
"a" + 1 # intentando sumar 1 a un texto
```

&nbsp;

**.bg-green_light[CONSEJO]**: lee siempre los mensajes de error para aprender de ellos (ya que suelen dar pistas de c√≥mo resolverlos).

---

# .red[Errores]

Durante tu aprendizaje va a ser **muy habitual** que las cosas no salgan a la primera, apareciendo en consola **.bg-purple_light[mensajes de error]** en un **.bg-red_light[color rojo]**. No te asustes: lo peor que puede pasar es que tengas que reiniciar `R`).

&nbsp;
 
* Mensajes de **.bg-orange[WARNING]**: ir√°n precedidos de la frase **.bg-yellow[¬´Warning in‚Ä¶¬ª]**, y son los fallos m√°s delicados ya que son posibles incoherencias pero sin que tu c√≥digo deje de ejecutarse.

```{r warning = TRUE}
sqrt(-1) # raiz cuadrada de n√∫mero negativo
```

&nbsp;

**¬øHa ejecutado la orden?** S√≠, pero te advierte de que el resultado de la operaci√≥n es un `NaN`, **Not A Number**, un valor que no existe (al menos dentro de los n√∫meros reales).


---

# ¬øD√≥nde programamos? .orange[SCRIPTS]

Un **.bg-purple_light[script]** ser√° el documento en el que programamos, nuestro equivalente a un archivo .doc, pero aqu√≠ ser√° un archivo con extensi√≥n `.R`, donde **escribiremos las √≥rdenes**. Para **.bg-purple_light[abrir nuestro primero script]**, haz click en el men√∫ superior en `File << New File << R Script`.

&nbsp;


.pull-left[


```{r echo = FALSE,  out.width = "95%", fig.align = "left"}
knitr::include_graphics("./img/inicio_rstudio_5.jpg")
``` 

]

.pull-right[

**.bg-green_light[CONSEJO]**: intenta no abusar de la consola, ya que todo lo que no escribas en un script, cuando cierres `RStudio`, lo **habr√°s perdido** (c√≥mo si en lugar de escribir en un Word y guardarlo, nunca guardases el documento).

]

---

# .orange[EJECUTAR] nuestros scripts

Ahora tenemos una **cuarta ventana**: la ventana donde **escribiremos nuestros c√≥digos**


### **¬øC√≥mo ejecutar nuestro script?**

.pull-left[

```{r echo = FALSE,  out.width = "95%", fig.align = "left"}
knitr::include_graphics("./img/inicio_rstudio_6.jpg")
``` 

]

.pull-right[

1. **.bg-purple_light[Escribimos el c√≥digo]** a ejecutar.

2. **.bg-purple_light[Guardamos]** el archivo `.R` haciendo click en `Save current document`.

3. El c√≥digo **no se ejecuta salvo que se lo indiquemos**. Tenemos tres opciones:
  - **.orange[Copiar y pegar]** en consola.
  - **.orange[Seleccionar l√≠neas]** y clickar en `Run`.
  - Activar `Source on save` a la **derecha de guardar**: no solo guarda sino que ejecuta el c√≥digo completo.

]

---

name: ejercicios1

# Primeros ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: a√±ade debajo otra l√≠nea para definir una variable `b` con el valor `5`. Tras asignarles valores, multiplica los n√∫meros en consola.

```{r}
a <- 2
```

* üìù **Ejercicio 2**: modifica el c√≥digo inferior para definir dos variables `c` y `d`, con valores 3 y -1.

```{r eval = FALSE}
c <- # deber√≠as asignarle el valor 3
d <- # deber√≠as asignarle el valor -1
```

* üìù **Ejercicio 3**: con las variables `a` y `b` del ej. 1, crea una nueva variable `e` guardando el resultado de su multiplicaci√≥n `a * b`. Escribe `e` en consola para ver su resultado

]

.panel[.panel-name[Soluci√≥n ej. 1]

```{r}
# Para poner comentarios en el c√≥digo se usa #

# Definici√≥n de variables
a <- 2
b <- 5

# Multiplicaci√≥n
a * b
```
]

.panel[.panel-name[Soluci√≥n ej. 2]

```{r}
# Definici√≥n de variables
c <- 3
d <- -1
```
]

.panel[.panel-name[Soluci√≥n ej. 3]

```{r}
# Variables
a <- 2
b <- 5

# Resultado
e <- a * b

# Muestro en consola
e
```

]
]

---

# Primeros ejercicios


.panelset[
.panel[.panel-name[Ejercicios extra]


* üìù **Ejercicio 4**: asigna un valor positivo a `x` y calcula su ra√≠z cuadrada; asigna otro negativo y calcula su valor absoluto con la funci√≥n `abs()`.


* üìù **Ejercicio 5**: usando la variable `x` ya definida, completa/modifica el c√≥digo inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.

```{r eval = FALSE}
z <- ? - ? # completa el c√≥digo
z
```

* üìù **Ejercicio 6**: usando las variables `x` e `y` ya definidas, calcula el m√°ximo de ambas (funci√≥n `max()`), y gu√°rdalo en una nueva variable `t`.

]

.panel[.panel-name[Soluci√≥n ej. 4]

```{r}
# Ra√≠z cuadrada
x <- 73 # por ejemplo
sqrt(x)

# Valor absoluto
y <- -19 # por ejemplo
abs(y)
```
]

.panel[.panel-name[Soluci√≥n ej. 5]

```{r}
z <- x - 5
z
```
]

.panel[.panel-name[Soluci√≥n ej. 6]

```{r}
t <- max(x, y)
t
```

]
]


---

class: inverse center middle
name: clase-2

# CLASE 2: primeros datos en R

&nbsp;

### [Variables individuales: num√©ricas y caracteres](#variables)

### [Primer paquete y primera funci√≥n](#primer-paquete)

### [Vectores: num√©ricos y de caracteres](#vectores)

### [Variables de tipo l√≥gicas](#logicas)

### [Variables de tipo fecha](#fecha)

### [Ejercicios](#ejercicios2)

---

name: variables

# De la .orange[celda] a la .green[tabla]
 

¬øDe qu√© tipo pueden ser los datos que tenemos contenidos en cada celda de una ¬´tabla¬ª?


```{r echo = FALSE,  out.width = "55%", fig.align = "center"}
knitr::include_graphics("./img/celdas.jpg")
``` 

* **.bg-purple_light[Celda]**: un dato **.bg-orange[individual]** de un tipo concreto.
* **.bg-purple_light[Variable]**: una **.bg-orange[concatenaci√≥n de valores]** del mismo tipo (**vectores**).
* **.bg-purple_light[Matriz]**: **.bg-orange[concatenaci√≥n de variables]** del **.bg-yellow[mismo tipo]** y longitud.
* **.bg-purple_light[Tabla]**: **.bg-orange[concatenaci√≥n de variables]** de **.bg-yellow[distinto tipo]** pero igual longitud.

---

# .orange[Celdas]: tipos de datos individuales

¬øExisten **variables m√°s all√° de los n√∫meros**?

&nbsp;

Piensa por ejemplo en los **datos guardados de una persona**:

* La edad o el peso ser√° un **.bg-purple_light[n√∫mero]**.
* Su nombre ser√° una cadena de **.bg-purple_light[texto]**.
* Su fecha de nacimiento ser√° precisamente eso, una **.bg-purple_light[fecha]**.
* A la pregunta ¬´¬øest√° usted soltero/a?¬ª la respuesta ser√° lo que llamamos una **.bg-purple_light[variable l√≥gica]** (`TRUE` si est√° soltero/a o `FALSE` en otro caso).

```{r echo = FALSE,  out.width = "40%", fig.align = "center"}
knitr::include_graphics("./img/celdas.jpg")
``` 

---

# Variables .orange[NUM√âRICAS]

El **dato m√°s sencillo**, dato que ya hemos usado en nuestros primeros pasos como calculadora, ser√°n las variables que guardan simplemente n√∫meros

```{r}
a <- 1
b <- 2
a + b
```

--

En el c√≥digo anterior, tanto `a` como `b` como la suma `a + b` son de **.bg-purple_light[tipo num√©rico]**

```{r}
class(a) #<<
typeof(a) #<<
```


---

# Variables .orange[NUM√âRICAS]

Como ya hemos visto, con los datos num√©ricos podemos realizar todas las **.bg-purple_light[operaciones aritm√©ticas]** que se nos ocurrir√≠a hacer en una **calculadora** como sumar (`+`), restar (`-`), multiplicar (`+`), dividir (`/`), ra√≠z cuadrada (`sqrt()`), valor absoluto (`abs()`), elevar al cuadrado (`^2`), elevar al cubo (`^3`), etc.



```{r}
a <- 5
a^3 # Elevar al cubo
```

```{r}
b <- -43
abs(b) # valor absoluto
```

---

# Variables de .orange[TEXTO]

No solo de n√∫meros viven los datos: imagina que adem√°s de la edad de una persona queremos **guardar su nombre** (**.bg-purple_light[tipo caracter]**: una **cadena de texto**)

```{r}
nombre <- "Javier" #<<
class(nombre)
```

--

Las cadenas de texto son un **tipo especial de dato** con los que obviamente no podremos hacer operaciones aritm√©ticas (pero s√≠ **.bg-purple_light[otras operaciones]** como pegar o localizar patrones).

```{r error = TRUE}
nombre + 1 # error al sumar n√∫mero a texto
```

&nbsp;

--

**.bg-green_light[IMPORTANTE]**: las variables de tipo texto van **.bg-red_light[SIEMPRE ENTRE comillas]**.

---

name: primer-paquete

# .orange[PRIMERA FUNCI√ìN]: paste

Una **.bg-purple_light[funci√≥n]** es un **trozo de c√≥digo encapsulado** bajo un nombre, que depende de unos **.bg-purple_light[argumentos de entrada]**.

--

Nuestra primera funci√≥n ser√° `paste()`: dadas dos cadenas de texto como argumento de entrada nos permite pegarlas, indic√°ndole en el argumento `sep = ` el caracter que queremos entre medias.

```{r}
# todo junto, sin espacios, igual a paste0("Javier", "√Ålvarez")
paste("Javier", "√Ålvarez", sep = "") 
```



```{r}
paste("Javier", "√Ålvarez", sep = "?*?") # separados por un ?*?
```


---

# .orange[PRIMERA FUNCI√ìN]: paste


```{r}
paste("Javier", "√Ålvarez") #<<
```

Por defecto, `paste()` a√±ade un espacio, es decir, `sep = " "`. Muchas funciones en `R` tendr√°n lo que llamamos **.bg-purple_light[argumentos por defecto]**, el valor que tomar√° sino se le asigna otro. Puedes mirar la **.bg-green_light[ayuda de la funci√≥n]** escribiendo en consola `? paste`

Existe una funci√≥n similar llamada `paste0()` que pega por defecto con `sep = ""` (sin nada).

```{r}
paste0("Javier", "√Ålvarez") 
paste("Javier", "√Ålvarez", sep = "") 
```

---

# .orange[PRIMER PAQUETE]: glue

Otra forma **m√°s intuitiva de trabajar con textos** es usar el **paquete** `{glue}`.

```{r}
library(glue) # solo la 1¬™ vez install.packages("glue")
```

--

Con dicho paquete podemos **.bg-purple_light[usar variables dentro de cadenas]** de texto. Por ejemplo, la frase ¬´la edad es de ... a√±os¬ª, donde la edad concreta la tenemos guardada en una variable.

```{r}
edad <- 32
glue("La edad es de {edad} a√±os") #<<
```

Dentro de las llaves tambi√©n podemos ejecutar operaciones

```{r}
unidades <- "d√≠as"
glue("La edad es de {edad * 365} {unidades}") #<<
```

---


# .orange[VECTORES]: concatenaci√≥n

¬øY si en lugar de querer almacenar un solo elemento, por ejemplo , tenemos una **colecci√≥n de elementos**?

Hasta ahora solo hemos operado con el contenido de las **celdas**, pero cuando trabajamos con datos normalmente tendremos columnas que representan variables o caracter√≠sticas: llamaremos **.bg-purple_light[vectores]** a una **.bg-orange[concatenaci√≥n]** de variables del **.bg-orange[mismo tipo]**
 
--

La forma m√°s sencilla es con el comando `c()` (c de concatenar), y basta con introducir sus **elementos entre par√©ntesis y separados por comas** (por ejemplo, la edad de 4 personas).

```{r}
edades <- c(32, 27, 60, 61) #<<
edades
```


&nbsp;

--

**.bg-green_light[IMPORTANTE]**: un n√∫mero individual (`x <- 1`) es en realidad un vector de longitud uno. 

---

# .orange[VECTORES]: concatenaci√≥n


Como ves ahora en el `environment` tenemos una **.bg-purple_light[colecci√≥n de elementos]** guardada

.pull-left[

```{r}
edades
```

]


.pull-right[
```{r echo = FALSE,  out.width = "80%", fig.align = "left"}
knitr::include_graphics("./img/vectores_enviroment.jpg")
``` 
]

--

.pull-left[

La **.bg-purple_light[longitud de un vector]** se puede calcular con `length()`

```{r}
length(edades) #<<
```

]


.pull-right[

Tambi√©n podemos **.bg-purple_light[concatenar vectores]**

```{r}
c(edades, edades, 8)
```

]

---

# Vectores: .orange[SECUENCIAS NUM√âRICAS]

En muchas ocasiones querremos **.bg-purple_light[crear secuencias num√©ricas]** mucho m√°s r√°pido (por ejemplo, un vector con los d√≠as del mes). El comando `seq()` nos permite crear una **secuencia** desde un elemento inicial hasta un elemento final, avanzando de uno en uno.

```{r}
seq(1, 31)
```

--

El comando `1:n` nos devuelve lo mismo que la orden `seq(1, n)`. Adem√°s, si el elemento inicial es mayor que el final, `R` entender√° solo que la secuencia es **decreciente**.

```{r}
n <- 5
n:1
```

---

# Vectores: .orange[SECUENCIAS NUM√âRICAS]

Tambi√©n podemos definir **.bg-purple_light[otro tipo de distancia]** (**.bg-orange[paso de discretizaci√≥n]**) entre dos elementos consecutivos

```{r}
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
```

--

Otras veces nos interesar√° definir una **.bg-purple_light[secuencia con un n√∫mero concreto]** de elementos.

```{r}
seq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7
```

--

Tambi√©n podemos crear **.bg-purple_light[vectores de elementos repetidos]** con la funci√≥n `rep()`

```{r}
rep(0, 7) # vector de 7 ceros
```


---

# Vectores: .orange[CARACTERES]

Un vector es una **.bg-purple_light[concatenaci√≥n de elementos del mismo tipo]**, pero no tienen porque ser necesariamente n√∫meros. Vamos a crear una frase de ejemplo, con 4 elementos.

.pull-left[

```{r}
vector <- c("Me", "llamo", "Javi") #<<
vector
length(vector)
```

]

.pull-right[

```{r}
frase <- "Mi llamo Javi"
frase
length(frase)
```

]

F√≠jate la **diferencia** entre tenerlo guardado en un vector o tenerlo como una sola cadena de texto (unida).

---

# Vectores: .orange[CARACTERES]

Cuando usamos la funci√≥n `paste()` con variables diferentes, us√°bamos `sep = ...`. Cuando la funci√≥n `paste()` la aplicamos a un vector de caracteres, decidiremos que caracter queremos que vaya entre palabra con el argumento `collapse = ...`.

```{r}
paste(vector, collapse = ".") # separados por un punto
```

Podemos **combinar las secuencias de n√∫meros y un vector de caracteres** con `glue()`

```{r}
edad <- 10:12 # edades
glue("La edad es de {edad} a√±os")
```

---

name: logicas

# Datos de tipo .orange[L√ìGICO]

Un tipo de datos muy importante en todo lenguaje de programaci√≥n: los **.bg-purple_light[valores l√≥gicos]**. Un valor l√≥gico puede tomar **tres valores**:

* `TRUE` (guardado internamente como un `1`).
* `FALSE` (guardado internamente como un `0`).
* `NA` (**.bg-purple_light[dato ausente]**, son las siglas de **.bg-orange[not available]**).

--

Los valores l√≥gicos suelen ser resultado de evaluar **.bg-purple_light[condiciones l√≥gicas]** (preguntar a los datos). Por ejemplo, imaginemos que definimos un vector de temperaturas. ¬øQu√© d√≠as hizo menos de 22 grados?

```{r}
x <- c(15, 20, 31, 27, 15, 29)
x < 22 #<<
```

Nos devolver√° un **vector l√≥gico** con `TRUE` o `FALSE` en cada hueco, en funci√≥n de si cumple o no la condici√≥n pedida.

---

# Datos de tipo .orange[L√ìGICO]


Dicha condici√≥n l√≥gica puede hacerse con `<=` (menor o igual), `>` (mayor) o `>=` (mayor igual).

```{r}
x <= 22
```

--

```{r}
x > 30
```

--

```{r}
x >= 15
```

---

# Datos de tipo .orange[L√ìGICO]

Tambi√©n podemos comparar **.bg-purple_light[si es igual a otro elemento]**, para lo que usaremos el operador `==`, pudiendo usar tambi√©n su opuesto `!=` (¬´distinto de¬ª).

```{r}
x == 15
x != 15
```

--

Si tuvi√©ramos un **.bg-purple_light[dato ausente]** (por error del aparato ese d√≠a, marcado como `NA`), la condici√≥n evaluada tambi√©n ser√≠a `NA`

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

# Datos de tipo .orange[L√ìGICO]

Las **.bg-purple_light[condiciones pueden ser combinadas]**, principalmente de dos maneras:

.pull-left[

* **.bg-purple_light[Intersecci√≥n]**: **.bg-orange[TODAS]** las condiciones concatenadas se deben cumplir (conjunci√≥n y) para devolver un `TRUE`.

```{r}
x
x < 30 & x > 15
```

]

.pull-right[

* **.bg-purple_light[Uni√≥n]**: basta con que **.bg-orange[AL MENOS UNA]** de las condiciones se cumpla (conjunci√≥n o) para devolver un `TRUE`.

```{r}
x
x < 30 | x > 15
```

]

---

name: fecha

# Datos de tipo .orange[FECHA]


Un tipo de datos muy especial: los **.bg-purple_light[datos de tipo fecha]**. 

```{r}
# Cadena de texto
fecha_char <- "2021-04-21"
class(fecha_char)
```

Podr√≠amos pensar que no tiene nada de especial ya que parece una simple cadena de texto pero representa un **.bg-purple_light[instante en el tiempo]**, que deber√≠amos poder operar como tal.

--

¬øQu√© suceder√≠a si **sumamos un 1 (un d√≠a)** a una fecha definida como una cadena de texto?

```{r error = TRUE}
fecha_char + 1
```

--

Si guardamos las fechas como un cadena de texto **.bg-red_light[no podemos operar con ellas]**

---

# Datos de tipo .orange[FECHA]

Para trabajar con fechas tenemos el paquete `{lubridate}`, y su funci√≥n `as_date()`: nos **.bg-purple_light[convierte texto a fecha]**.

```{r}
library(lubridate)
fecha <- as_date(fecha_char) #<<
class(fecha)
```

--

```{r}
fecha + 1 # d√≠a siguiente
```

--

```{r}
fecha - 3 # 3 d√≠as antes
```

--

Al convertir texto a fecha, aunque se visualice como un texto, **.bg-purple_light[internamente es un n√∫mero]**. 

---

# Datos de tipo .orange[FECHA]

La funci√≥n `as_date()` tiene un argumento opcional, el **.bg-purple_light[formato]**, que por defecto ser√° `format = "yyyy-mm-dd"` (que podemos cambiar)


```{r}
as_date("10-03-2020", format = "%d-%m-%Y") #<<
```

--

```{r}
as_date("10-03-20", format = "%d-%m-%y")
```

--

```{r}
as_date("03-10-2020", format = "%m-%d-%Y")
```

--

```{r}
as_date("Octubre 21, 1995 21:24", format = "%B %d, %Y %H:%M")
```

---

# Datos de tipo .orange[FECHA]

Para facilitar conversiones de formatos habituales, el paquete tambi√©n tiene a nuestra disposici√≥n diferentes funciones preparadas para directamente **.bg-purple_light[convertir fechas en distintos formatos]**, como la funci√≥n `ymd_hms()` o `ydm_hms()`

```{r}
ymd_hms("2017-11-28 14:02:00") # convertir a fecha una cadena a√±o-mes-d√≠a + hora
ydm_hms("2017-22-12 10:00:00") # convertir a fecha una cadena a√±o-d√≠a-mes + hora
```

--

De la misma manera tenemos la funci√≥n `dmy_hms()`

```{r}
dmy_hms("1 Jan 2017 23:59:59") # convertir a fecha una cadena textual de fecha + hora
```

 
---

# Datos de tipo .orange[FECHA]


Tambi√©n podemos hacerlo de forma muy simplificada con `ymd()`

```{r}
ymd(20170131)
```

--

Otra de las funcionalidades que nos proporciona dicho paquete es obtener autom√°ticamente la **.bg-purple_light[fecha de hoy]**, haciendo uso de la funci√≥n `today()`

```{r}
hoy <- today() #<<
hoy
```

--

Tambi√©n podemos obtener el **.bg-purple_light[¬´hoy y ahora¬ª]** con la funci√≥n `now()`

```{r}
now() #<<
```
 
---

# Datos de tipo .orange[FECHA]

Tambi√©n tenemos disponibles funciones para **.bg-purple_light[extraer facilmente algunas variables]**.

.pull-left[

```{r}
year(fecha)
month(fecha)
hour(fecha)
second(fecha)
```

]

.pull-right[
```{r}
week(fecha)
wday(fecha)
wday(fecha, week_start = 1) # D√≠a de la semana 
```

]


---

# Datos de tipo .orange[FECHA]


Tambi√©n podemos **.bg-purple_light[realizar comparaciones]**

```{r}
fecha_actual <- today()
fecha_actual > ymd(20170131) # Actual vs 2017-01-31
fecha_actual > ymd(21000131) # Actual vs 2100-01-31
```
 
--

Con la funci√≥n `leap_year()` podremos saber si la fecha **.bg-purple_light[corresponde a un a√±o bisiesto]**

```{r}
leap_year(as_date(ymd(20190131)))
```

---

# Datos de tipo .orange[FECHA]

.pull-left[

```{r echo = FALSE,  out.width = "101%", fig.align = "right", fig.cap = "Chuleta de https://lubridate.tidyverse.org/"}
knitr::include_graphics("./img/lubridate.png")
``` 

]

.pull-right[

Tambi√©n podemos hacer uso de diferentes funciones para **.bg-purple_light[a√±adir intervalos]** de tiempo.

```{r}
fecha + weeks(0:2)
fecha + seconds(2)
```

]

---


name: ejercicios2

# Ejercicios


.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: define una variable `edad` que guarde tu edad y otra `nombre` con tu nombre.

* üìù **Ejercicio 2**: define otra variable con tus apellidos y junta las variables `nombre` y `apellidos` en una sola cadena de texto que guardes en `nombre_completo`.
 
* üìù **Ejercicio 3**: define un vector que contenga los n√∫meros `1`, `10`, `-1` y `2`, y gu√°rdalo en una variable llamada `vector_num`. Obt√©n la longitud del vector anterior.
 
* üìù **Ejercicio 4**: crea una secuencia de -2 a 17 de forma que salte de uno en uno (y tambi√©n de forma decreciente). Repite el proceso pero saltando de 3 en 3.


]

.panel[.panel-name[Soluci√≥n ej. 1]

```{r}
# variable num√©rica
edad <- 32
edad

# variable de tipo texto
nombre <- "Javi"
nombre
```
]

.panel[.panel-name[Soluci√≥n ej. 2]

```{r}
apellidos <- "√Ålvarez Li√©bana"

# Opci√≥n 1
nombre_completo <- glue("{nombre} {apellidos}")
nombre_completo

# Opci√≥n 2
nombre_completo <- paste(nombre, apellidos)
nombre_completo
```
]

.panel[.panel-name[Soluci√≥n ej. 3]

```{r}
vector_num <- c(1, 10, -1, 2)
vector_num

# longitud
length(vector_num)
```

]

.panel[.panel-name[Soluci√≥n ej. 4]

```{r}
secuencia <- -2:17
secuencia
# otra forma
secuencia <- seq(-2, 17, by = 1)

# decreciente
17:-2

# de 3 en 3
seq(-2, 17, by = 3)
```

]

]

---

# Ejercicios


.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 5**: crea una secuencia que repita 7 veces el patr√≥n -1, 2, 4. Despu√©s crea otra que repita dicho patr√≥n pero de forma intercalada.
 
* üìù **Ejercicio 6**: crea una secuencia de 7 valores l√≥gicos en los que haya 2 valores ciertos, 3 valores falsos y 2 valores ausentes.


* üìù **Ejercicio 7**: toma el vector `vector_num` del ejercicio 3 y obt√©n un vector l√≥gico que nos diga que valores son mayores de 0. Obt√©n otro vector l√≥gico que nos diga que valores est√°n entre 0 y 7. Obt√©n otro vector l√≥gico que nos diga que valores son distintos de 1 en valor absoluto.

* üìù **Ejercicio 8**: obt√©n la fecha de hoy, define la fecha de tu cumplea√±os, y calcula la diferencia de d√≠as.
 
* üìù **Ejercicio 9**: suma un mes y una semana a la fecha de tu cumplea√±os

 

]

.panel[.panel-name[Sol ej. 5]

```{r}
secuencia <- rep(c(-1, 2, 4), 7)
secuencia

# intercalada
rep(c(-1, 2, 4), each = 7)
```

]

.panel[.panel-name[Sol ej. 6]

```{r}
secuencia <- c(FALSE, TRUE, NA, FALSE, NA, TRUE, FALSE)
secuencia
```

]

.panel[.panel-name[Sol ej. 7]

```{r}
vector_num > 0
vector_num > 0 & vector_num < 7
abs(vector_num) != 1
```

]


.panel[.panel-name[Sol ej. 8]

```{r}
library(lubridate)
hoy <- today()
cumple <- as_date("1989-09-10")
hoy - cumple
```

]

.panel[.panel-name[Soluci√≥n ej. 9]

```{r}
cumple + months(1) + weeks(1)
```

]

]

---

# Ejercicios extras

.panelset[
.panel[.panel-name[Ejercicios extra]


* üìù **Ejercicio 10**: construye con `glue()` una frase que diga ¬´Hola, me llamo ‚Ä¶ y tengo ‚Ä¶ a√±os¬ª.

* üìù **Ejercicio 11**: modifica el c√≥digo inferior para crear un vector de nombre `vector_num` que contenga los n√∫meros 1, 5 y -7.

```{r eval = FALSE}
# Vector de n√∫meros
vector_num <- c(1)
vector_num
```

* üìù **Ejercicio 12**:  extrae el mes, a√±o y d√≠a de la semana de tu cumplea√±os

]

.panel[.panel-name[Soluci√≥n ej. 10]

```{r}
nombre <- "Javi"
edad <- 32
glue("Hola, me llamo {nombre} y tengo {edad} a√±os")
```
]

.panel[.panel-name[Soluci√≥n ej. 11]

```{r}
# Vector de n√∫meros
vector_num <- c(1, 5, -7)
vector_num

# longitud
length(vector_num)
```

]

.panel[.panel-name[Soluci√≥n ej. 12]

```{r}
library(lubridate)
cumple <- as_date("1989-09-10")
month(cumple)
day(cumple)
year(cumple)
wday(cumple, week_start = 1, label = TRUE)
```

]


]


---

class: inverse center middle
name: clase-3

# CLASE 3: operaciones con vectores y matrices

&nbsp;

### [Operaciones con vectores](#operaciones-vectores)

### [Ejercicios vectores](#ejercicios-vectores)

### [Matrices](#matrices)

### [Ejercicios matrices](#ejercicios-matrices)

---

name: operaciones-vectores

# .green[OPERACIONES] .orange[ARITM√âTICAS]
 
Dado que un **.bg-purple_light[n√∫mero es un vector]** de longitud 1, toda **.bg-orange[operaci√≥n aritm√©tica]** (suma, resta, multiplicaci√≥n, etc) que podamos hacer con un n√∫mero la vamos a poder a hacer con un vector de n√∫meros.

--

Si hacemos por ejemplo la operaci√≥n `2 * x`, siendo `x` un vector, lo que suceder√° es que la operaci√≥n se realizar√° en **.bg-purple_light[CADA ELEMENTO]** del vector (una sola l√≠nea de c√≥digo paro realizar operaciones en 10, 20, 1000 o 100000 elementos).

```{r}
# Multiplicamos por 2 a CADA ELEMENTO del vector
x <- c(2, 4, 6)
2 * x #<<
```

--

&nbsp;

**.bg-green_light[IMPORTANTE]**: el **.bg-purple_light[resultado]** de una operaci√≥n aritm√©tica sobre un vector ser√° **.bg-orange[otro vector]**.

---

# .green[OPERACIONES] .orange[ARITM√âTICAS]
 
 
De la misma manera podemos **.bg-purple_light[sumar o restar una constante]** al vector

```{r}
# Sumamos 3 a CADA ELEMENTO DEL VECTOR
x + 3
```

--

Los vectores tambi√©n pueden **.bg-purple_light[interactuar entre ellos]**, as√≠ que podemos definir sumas de vectores, como `x + y`

```{r}
y <- c(1, 3, 5)

# suma de vectores 
x + y #<< 
```

--

**.bg-green_light[IMPORTANTE]**: salvo que especifiquemos lo contrario, toda operaci√≥n aritm√©tica que hagas a un vector ser√° **.bg-purple_light[elemento a elemento]**.

 
---

# .green[OPERACIONES] .orange[ARITM√âTICAS]
 

Dado que la operaci√≥n (por ejemplo, una suma) se realiza elemento a elemento, ¬øqu√© suceder√° si **.bg-purple_light[sumamos dos vectores de distinta longitud]**?

--

Por ejemplo, definamos `z` con los 4 primeros impares, e intentemos hacer la suma `x + z`.

```{r}
z <- c(1, 3, 5, 7)
x + z
```

--

.pull-left[


```{r echo = FALSE,  out.width = "99%", fig.align = "left"}
knitr::include_graphics("./img/recycle.jpg")
``` 


]

.pull-right[

`R` intenta molestarte lo menos posible, as√≠ que lo que hace es **.bg-purple_light[reciclar elementos]**: si tiene un vector de 4 elementos y le intentas sumar uno de 3 elementos, lo que har√° ser√° reciclar elementos del vector con menor longitud: har√° `1 + 2`, `3 + 4`, `5 + 6` pero‚Ä¶ `7 + 2` (vuelve al primero).

]

---


# .green[OPERACIONES] .orange[ARITM√âTICAS]


Los **.bg-purple_light[valores l√≥gicos]** `TRUE` y `FALSE` son **.bg-orange[guardados internamente]** como `0` y `1`, por lo que podemos usar operaciones aritm√©ticas con ellos.

--

Por ejemplo, si queremos **.bg-purple_light[averiguar el n√∫mero de elementos que cumplen una condici√≥n]** (por ejemplo, `< 3`), los que lo hagan tendr√°n asignado un 1 y los que no un 0, por lo que basta con sumar dicho vector l√≥gico para obtener el n√∫mero de elementos que cumplen dicha condici√≥n (elementos que son `TRUE`).

```{r}
# sumamos el vector de TRUE/FALSE
x
sum(x < 3) 
```

---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

Tambi√©n podemos realizar **.bg-purple_light[operaciones estad√≠sticas]** con los vectores, como calcular su **suma**, su **media**, su **mediana**, entre otros.

--

Hagamos antes un **.bg-purple_light[breve repaso]** de algunos t√©rminos estad√≠sticos:

* **.bg-purple_light[Media]**: medida de **.bg-orange[centralizaci√≥n]** que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados (funci√≥n `mean()`). La m√°s conocida pero la menos robusta: dado un conjunto, si se introducen valores at√≠picos o outliers (valores muy grandes o muy peque√±os), la media se perturba con mucha facilidad.

$$\overline{x} = \frac{1}{n} \sum_{i=1}^{n} x_i$$

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
mean(x)
```

---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

Tambi√©n podemos realizar **.bg-purple_light[operaciones estad√≠sticas]** con los vectores, como calcular su **suma**, su **media**, su **mediana**, entre otros.


Hagamos antes un **.bg-purple_light[breve repaso]** de algunos t√©rminos estad√≠sticos:

* **.bg-purple_light[Mediana]**: medida de **.bg-orange[centralizaci√≥n]** (funci√≥n `median()`) que consiste en, tras **.bg-orange[ordenar]** los datos de menor a mayor, quedarnos con el valor que ocupa el medio (deja tantos n√∫meros por debajo como por encima). 


$$Me_{x} = \displaystyle \arg \min_{x_i} \left\lbrace F_i > 0.5 \right\rbrace, \quad F_i = \frac{\# \left\lbrace x_j \leq x_i \right\rbrace}{n}$$

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

Tambi√©n podemos realizar **.bg-purple_light[operaciones estad√≠sticas]** con los vectores, como calcular su **suma**, su **media**, su **mediana**, entre otros.


Hagamos antes un **.bg-purple_light[breve repaso]** de algunos t√©rminos estad√≠sticos:

* **.bg-purple_light[Moda]**: medida de **.bg-orange[centralizaci√≥n]** que consiste en encontrar el **.bg-orange[valor o valores m√°s repetidos]**. Es la medida de centralizaci√≥n m√°s robusta. 

$$Mo_{x} = \displaystyle \arg \max_{x_i}  f_i , \quad f_i = \frac{\# \left\lbrace x_j = x_i \right\rbrace}{n}$$

&nbsp;

**.bg-red_light[PROBLEMA]**: la moda no siempre es f√°cil de calcular (aunque existen paquetes para calcularla como `{modeest}`)


---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

Otra de las funciones m√°s √∫til es la **.bg-purple_light[suma de elementos]** de un vector con `sum()`

```{r}
# suma
sum(x) #<<
sum(x) / length(x) # media artesanal
```

--

Otra funci√≥n √∫til es la **.bg-purple_light[suma acumulada]** de un vector haciendo uso de `cumsum()`

```{r}
# suma acumulada
cumsum(c(1, 2, 4, 7, 7, 10)) #<<
```

---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

No solo de medidas de centralizaci√≥n vive la estad√≠stica: **.bg-purple_light[¬øc√≥mo calcular las medidas de dispersi√≥n?]**

* **.bg-purple_light[Varianza]**: definida como la media de desviaciones (respecto a la media) al cuadrado, tal que $s_{x}^{2} = \frac{1}{n} \sum_{i = 1}^{n} \left(x_i - \overline{x} \right)^2 = \overline{x^2} - \overline{x}^2$

```{r}
var(x)
```

--

**.bg-green_light[IMPORTANTE]**: las funciones de `R` (y de cualquier calculadora) nos devuelve la **.bg-red_light[cuasivarianza]** (dividido entre $n-1$)
 
```{r}
# Varianza real
mean((x - mean(x))^2)
```

---


# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

No solo de medidas de centralizaci√≥n vive la estad√≠stica: **.bg-purple_light[¬øc√≥mo calcular las medidas de dispersi√≥n?]**

* **.bg-purple_light[Desv. t√≠pica (standard deviation)]**: definida como la ra√≠z cuadrada de la varianza, tal que $s_{x} = \sqrt{s_{x}^{2} }$

```{r}
sd(x)
```

--

**.bg-green_light[IMPORTANTE]**: las funciones de `R` (y de cualquier calculadora) nos devuelve la **.bg-red_light[cuasidesviaci√≥n t√≠pica]** (ra√≠z de la cuasivarianza, dividida entre $n-1$)
 
```{r}
# Desv. t√≠pica real
sqrt(mean((x - mean(x))^2))
```


---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

Tambi√©n pueden sernos √∫tiles las **.bg-purple_light[medidas de posici√≥n/localizaci√≥n]**, como los **.bg-orange[percentiles]** (valores que nos dividen en partes iguales los datos).

```{r}
y <- c(1, 2, 5, 5, 10, 10, 10, 13, 15, 20, 25)

# Percentiles por defecto: cuartiles
quantile(y) #<<
```

--

En `quantile()` hay un argumento por defecto `probs = c(0, 0.25, 0.5, 0.75, 1)` (**percentiles** a calcular) que puede ser cambiado, por ejemplo, para percentiles 20%-30%-70%-90%.

```{r}
quantile(y, probs = c(0.2, 0.3, 0.7, 0.9))
```

---

# .green[OPERACIONES] con .orange[AUSENTES]

Imagina que tenemos un vector de temperaturas pero varios de los d√≠as el aparato de medici√≥n no funcionaba, por lo que tenemos un **.bg-purple_light[dato ausente]** marcado como `NA`.

```{r}
x <- c(21, NA, 13, NA, NA, 25, 36, 17, 19, 5)
sum(x)
```

--

Dado que hay d√≠as que no tenemos disponibles, la suma tampoco la podemos conocer.  Para evitar que nos impida hacer ciertas operaciones, en muchas funciones de `R` podemos a√±adir el **argumento** `na.rm = TRUE`: primero elimina ausentes, y luego ejecuta la funci√≥n.

```{r}
# eliminando datos ausentes antes de aplicar la funci√≥n
sum(x, na.rm = TRUE) #<<
mean(x, na.rm = TRUE)
```


---

# .green[OPERACIONES] con .orange[AUSENTES]

Para **comprobar** si tenemos un **dato ausente**  podemos hacer uso de la funci√≥n `is.na()`

```{r}
is.na(x)
```

--

Tambi√©n puede aparecernos un **.bg-purple_light[resultado no permitido]**, marcado como `NaN` (not a number): no es un dato ausente, es un dato resultado de una **operaci√≥n no permitida**.

```{r}
x <- c(1, NA, 3, 4, 6, 7, sqrt(-1), NA)
x
is.nan(x)
```


---

# .orange[SELECCIONAR] elementos

Otra operaci√≥n muy habitual es la **.bg-purple_light[extraer un subconjunto del mismo]**. La forma m√°s sencilla es **usar el operador de selecci√≥n** `[i]` para **acceder al elemento i-√©simo**

```{r}
edades <- c(20, 30, 32, NA, 61)

# accedemos a la edad de la tercera persona en la lista
edades[3] #<<

# accedemos a la edad de la cuarta persona
edades[4]
```

---

# .orange[SELECCIONAR] elementos

Un n√∫mero no es m√°s que un vector de longitud uno, as√≠ que esta operaci√≥n tambi√©n la podemos aplicar usando un **.bg-purple_light[vector de √≠ndices a seleccionar]**

```{r}
# Tercer y cuarto elemento
edades[c(3, 4)] #<<
```

--

Esta l√≥gica para acceder a elementos tambi√©n sirve para **vectores de caracteres**.

```{r}
y <- c("hola", "qu√©", "tal", "todo", "ok", "?")
y[1:2]
```

--

**.bg-green_light[TIP]**: para **.bg-purple_light[acceder al √∫ltimo elemento]** podemos pasarle como √≠ndice la longitud del vector 

```{r}
y[length(y)] 
```

---

# .orange[FILTRAR] elementos


Otras veces no querremos seleccionar un elemento en concreto sino **.bg-purple_light[filtrar algunos elementos en concreto]** y no extraerlos, **.bg-orange[eliminarlos]**.

Deberemos repetir la misma operaci√≥n pero con el signo `-` delante: el operador `[-i]` **no selecciona** el elemento i-√©simo del vector sino que lo **elimina**

```{r}
y
y[-2] 
```

---

# .orange[FILTRAR] elementos

Lo habitual es que dicho filtro lo hagamos **.bg-purple_light[en base a una condici√≥n l√≥gica]**. Supongamos que tenemos las edades de dos grupos de personas y que queremos quedarnos **solo con los mayores edad**: vamos a seleccionar los **elementos que cumplen una condici√≥n dada**.

```{r}
edades_1 <- c(7, 20, 18, 3, 19, 9, 13, 3, 45)
edades_2 <- c(17, 21, 58, 33, 15, 59, 13, 1, 45)
```

--

```{r}
edades_1[edades_1 >= 18] #<<
edades_2[edades_2 >= 18]
```

Lo que hemos hecho ha sido pasar como **√≠ndices a seleccionar un vector l√≥gico** `TRUE/FALSE`: solo filtrar√° los lugares donde se guarde un `TRUE`.

---

# .orange[FILTRAR] elementos

Esto tambi√©n nos puede servir para **.bg-purple_light[limpiar de datos ausentes]**, combinando la funci√≥n `is.na()`: nos localiza el lugar que ocupan los ausentes, con el operador `!` (**negar el valor l√≥gico** que venga detr√°s).

```{r}
x <- c(7, NA, 20, 3, 19, 21, 25, 80, NA)
x[is.na(x)] # solo valores ausentes
x[!is.na(x)] # sin valores ausentes: ! es el s√≠mbolo de 
```

--

Tambi√©n podemos probar a **combinar condiciones l√≥gicas** para nuestra selecci√≥n.

```{r}
x[x >= 18 & x <= 25] # los valores que cumplen ambas (&): entre 18 y 25 a√±os
```

---
 

# .green[SELECCIONAR] elementos: .orange[WHICH]

A veces no querremos el elemento en s√≠, sino el **.bg-purple_light[lugar que ocupa]**: ¬øqu√© valores de un vector cumplen una condici√≥n l√≥gica? Para obtener dicho √≠ndice usaremos la funci√≥n `which()`.

```{r}
x <- c(7, NA, 20, 3, 19, 21, 25, 80, NA)
which(x >= 18) # Obtenemos los lugares 
```

--

Esta funci√≥n es muy √∫til especialmente cuando queremos el valor que ocupa el **.bg-purple_light[m√°ximo/m√≠nimo]** de un vector, con las funciones `which.max()` y `which.min()`.

```{r}
max(x, na.rm = TRUE)
which.max(x) # Lugar que ocupa el m√°ximo
```


---

# .green[SELECCIONAR] elementos: .orange[any/all]
 

Existen dos funciones muy √∫tiles para saber si **.bg-purple_light[todos o alguno de los elementos]** de un vector cumple una condici√≥n: `all()` y `any()` nos devolver√° un √∫nico valor l√≥gico.

```{r}
x <- c(1, 2, 3, 4, 5, NA, 7)
all(x < 3) #<<
any(x < 3)
all(x > 0)
```


---

# .orange[NOMBRAR] elementos

`R` nos permite dar **.bg-purple_light[significado l√©xico a nuestros valores]** (significan algo, no solo n√∫meros), pudiendo poner **nombres a los elementos** de un vector.

```{r}
x <- c("edad" = 31, "tlf" = 613910687, "cp" = 33007)
x
```

--

Esto es una ventaja ya que nos permite su **.bg-purple_light[selecci√≥n usando dichos nombres]**

```{r}
x[c("edad", "cp")] # seleccionamos los elementos que tienen ese nombre asignado
```

--

Con la funci√≥n `names()` podemos, no solo **.bg-purple_light[consultar los nombres]** sino **cambiarlos**.

---

# .orange[ORDENAR] vectores


Una acci√≥n tambi√©n habitual al trabajar con datos es saber **.bg-purple_light[ordenarlos]**: de menor a mayor edad, datos m√°s recientes vs antiguos, etc. Para ello tenemos la funci√≥n `sort()`, que podemos usar directamente para ordenar de **menor a mayor**.

```{r}
edades <- c(81, 7, 25, 41, 65, 20, 32, 23, 77)

# orden de joven a mayor
sort(edades) #<<
```

--

Por defecto, `sort()` ordena de menor a mayor. Con el argumento opcional `decreasing = TRUE` podemos **ordenar de mayor a menor**.

```{r}
# orden de mayor a joven
sort(edades, decreasing = FALSE) #<<
```

---

# .orange[ORDENAR] vectores

Otra forma de ordenar es obtener los **√≠ndices de los elementos ordenados**, y luego usar dichos √≠ndices para **reorganizar los elementos**, con la funci√≥n `order()`.

```{r}
order(x) #<<
x[order(x)]
```

---


# .orange[MEDIR] tiempos de ejecuci√≥n

Hay un paquete muy √∫til para **.bg-purple_light[medir tiempos de distintas √≥rdenes]** que hacen lo mismo (el paquete `{microbenchmark}`). Vamos a comparar `order()` y `sort()`.

```{r}
library(microbenchmark) # instalar primera vez
x <- rnorm(1e3) # 1000 elementos aleatorias
microbenchmark(sort(x), x[order(x)], times = 1e3) #<<
```

--

# .orange[DIFERENCIA] de conjuntos
 
Por √∫ltimo, una funci√≥n muy √∫til para ver las **.bg-purple_light[diferencias entre dos conjuntos]** es `setdiff()`, una funci√≥n que nos devuelve los elementos distintos entre dos conjuntos.

```{r}
y <- 1:10
z <- c(1, 3, 7, 10)
setdiff(y, z)
```


---

name: ejercicios-vectores

# Ejercicios de vectores


.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: define el vector `x` como la concatenaci√≥n de los 5 primeros n√∫meros impares, y calcula su suma.
 
* üìù **Ejercicio 2**: obt√©n los elementos de `x` mayores que 4. Determina los lugares que ocupan. Calcula el n√∫mero de elementos de `x` mayores que 4.

* üìù **Ejercicio 3**: calcula el vector `1/x` y obt√©n la versi√≥n ordenada (de menor a mayor).

* üìù **Ejercicio 4**: define un vector con tu estatura y peso, y nombra cada elemento.

 
]

.panel[.panel-name[Soluci√≥n ej. 1]

```{r}
x <- c(1, 3, 5, 7, 9)

# otra forma
x <- seq(1, 9, by = 2)

# Suma
sum(x)
```
]

.panel[.panel-name[Soluci√≥n ej. 2]

```{r}
# Elementos mayores que 4
x[x > 4]

# Lugares que ocupan
which(x > 4)

# Cantidad de elementos mayores que 4
sum(x > 4)
```
]

.panel[.panel-name[Soluci√≥n ej. 3]

```{r}
y <- 1/x

# una forma
sort(y)

# otra forma
y[order(y)]
```

]


.panel[.panel-name[Soluci√≥n ej. 4]

```{r}
x <- c("estatura" = 180, "peso" = 80)
x
```

]

]

---

# Ejercicios de vectores

.panelset[
.panel[.panel-name[Ejercicios]

 
* üìù **Ejercicio 5**:  encuentra del vector `x` del ejerciio 1 los elementos mayores (estrictos) que 1 y menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.
 
 
* üìù **Ejercicio 6**: define el vector `x <- c(-1, 0, -2, 5, 3, 7)` y obt√©n los elementos que ocupan una posici√≥n impar.
 
 
* üìù **Ejercicio 7**: define el vector de los primeros n√∫meros impares (hasta el 21) y extrae los elementos que ocupan los lugares `1, 4, 5, 8`. Elimina del vector el segundo elemento

 
* üìù **Ejercicio 8**: define un vector de 8 valores y determina la media, la mediana y los cuartiles.

]

.panel[.panel-name[Soluci√≥n ej. 5]

```{r}
x <- c(1, 3, 5, 7, 9)
# valores >1 y <7
x[x > 1 & x < 7]

# ¬øTodos positivos?
all(x > 0)
sum(all(x <= 0)) # debe dar 0
```

]

 
 
.panel[.panel-name[Soluci√≥n ej. 6]

```{r}
x <- c(-1, 0, -2, 5, 3, 7)
x[seq(1, length(x), by = 2)]
```

]

.panel[.panel-name[Soluci√≥n ej. 7]

```{r}
x <- seq(1, 21, by = 2)

# posiciones pedidas
x[c(1, 4, 5, 8)]

# sin las posiciones pedidas
x[-c(1, 4, 5, 8)]

# eliminamos del vector el segundo elemento
x[-2]
```
]

.panel[.panel-name[Soluci√≥n ej. 8]

```{r}
x <- c(0, -2, 3, 7, -5, 9, 3, 1)
mean(x)
median(x)
quantile(x)
```
]


]

---

name: matrices

# De la .orange[celda] a la .green[tabla]
 

```{r echo = FALSE,  out.width = "55%", fig.align = "center"}
knitr::include_graphics("./img/celdas.jpg")
``` 

* **.bg-purple_light[Celda]**: un dato **.bg-orange[individual]** de un tipo concreto.

* **.bg-purple_light[Variable]**: una **.bg-orange[concatenaci√≥n de valores]** del mismo tipo (**vectores**).


&nbsp;

--

**.bg-purple_light[Matriz]**: **.bg-orange[concatenaci√≥n de variables]** del **.bg-yellow[mismo tipo]** y longitud.

---

# .orange[MATRICES]: concatenando variables


Cuando analizamos datos solemos tener varias **variables distintas** de cada individuo: necesitamos una ¬´tabla¬ª con **.bg-purple_light[distintas variables]** (de **.bg-orange[IGUAL longitud]**).

Las **.bg-purple_light[matrices]** son una concatenaci√≥n de variables, del **.bg-orange[mismo tipo e igual longitud]**, dispuestas en **p columnas** (datos p-dimensionales) 

--

&nbsp;

Vamos a empezar definiendo una **matriz sencilla**: imagina que tenemos las estaturas y pesos de 5 personas. ¬øC√≥mo juntar las dos variables creando nuestro primer conjunto de datos? F√≠jate que son del mismo tipo e igual longitud.

```{r}
estaturas <- c(150, 160, 170, 180, 190)
pesos <- c(60, 70, 80, 90, 100)
```

---

# .orange[MATRICES]: concatenando variables

```{r}
estaturas <- c(150, 160, 170, 180, 190)
pesos <- c(60, 70, 80, 90, 100)
```

¬øC√≥mo juntar las dos variables creando nuestro primer conjunto de datos? Vamos a **.bg-purple_light[crear una matriz]**, un conjunto de n√∫meros organizado en 2 columnas (una por variable) y 5 filas o registros (una por persona). Para ello usaremos la funci√≥n `cbind()`, que nos **concatena vectores de igual longitud en columnas**.

 
```{r}
# Construimos la matriz por columnas
datos_matriz <- cbind(estaturas, pesos) #<<
datos_matriz
```

---

# .orange[MATRICES]: concatenando variables


.pull-left[

```{r echo = FALSE,  out.width = "99%", fig.align = "left"}
knitr::include_graphics("./img/datos_matriz_1.jpg")
``` 


]


.pull-right[

```{r eval = FALSE}
View(datos_matriz)
```

Podemos **.bg-purple_light[visualizar la matriz]** en un formato ¬´excelizado¬ª con la funci√≥n `View()`.


Tambi√©n podemos **.bg-purple_light[construir la matriz por filas]** con la funci√≥n `rbind()` (aunque lo recomendable es tener cada variable en  columna y cada individuo en fila).

```{r}
# Construimos la matriz por filas
rbind(estaturas, pesos) 
```

]

---
 
 
# .orange[MATRICES]: concatenando variables

Podemos comprobar las **.bg-purple_light[dimensiones de una matriz]** con `dim()`, `nrow()` y `ncol()`: nuestros datos est√°n **.bg-orange[tabulados]**:

```{r}
dim(datos_matriz) # vector
nrow(datos_matriz)
ncol(datos_matriz)
```

---

# .orange[MATRICES]: concatenando variables


Veamos un ejemplo con **tres variables/columnas**: edades, tel√©fonos y c√≥digos postales.

```{r}
edades <- c(14, 24, 56, 31, 20, 87, 73) 
tlf <- c(NA, 683839390, 621539732, 618211286, NA, 914727164, NA)
cp <- c(33007, 28019, 37005, 18003, 33091, 25073, 17140)

# Construimos la matriz por columnas
datos_matriz <- cbind(edades, tlf, cp) #<<
datos_matriz
```


---

# .orange[MATRICES]: a√±adir registros/variables

Las funciones `cbind()` y `rbind()` no solo nos permiten crear matrices desde cero sino tambi√©n **.bg-purple_light[a√±adir filas o columnas]** a matrices existentes.

```{r}
# A√±adimos una fila
rbind(datos_matriz, c(27, 620125780, 28051))
```

---

# .orange[MATRICES]: transpuesta

Tambi√©n podemos ¬´darle vuelta¬ª (**.bg-purple_light[matriz transpuesta]**) con `t()`.

```{r}
datos_matriz
t(datos_matriz) #<<
```

---

# .orange[MATRICES]: valores repetidos

Podemos definir una **.bg-purple_light[matriz de n¬∫ repetidos]** con `matrix(..., nrow = ..., ncol = ...)`

```{r}
# matriz de ceros de 3 filas, 2 columnas,
matrix(0, nrow = 3, ncol = 2) #<<
```

--

Tambi√©n podemos definir una **.bg-purple_light[matriz a partir de un vector num√©rico]**, reorganizando los valores en forma de matriz (sabiendo que los elementos se van colocando por columnas).

```{r}
matrix(1:15, ncol = 5) # Matriz con el vector 1:15
```

---

# .green[OPERACIONES] con .orange[MATRICES]

Con las matrices sucede como con los vectores: cuando aplicamos una **.bg-purple_light[operaci√≥n aritm√©tica]** lo hacemos **.bg-orange[elemento a elemento]**

```{r}
z <- matrix(1:15, ncol = 5) 
z / 5
z + 3
```

---

# .orange[MATRICES] de .green[CARACTERES]

Tambi√©n podemos crear matrices de otros tipos de datos, siempre y cuando las **.bg-purple_light[columnas sean del mismo tipo e igual longitud]**, por ejemplo una **.bg-orange[matriz de caracteres]**.

```{r}
# matriz de caracteres
nombres <- c("Javier", "Carlos", "Mar√≠a")
apellidos <- c("√Ålvarez", "Garc√≠a", "P√©rez")
cbind(nombres, apellidos)
```

--

```{r}
# matriz de valores l√≥gicos
cbind(c(TRUE, FALSE), c(FALSE, TRUE))
```

---

# .orange[SELECCIONAR] elementos

Si recuerdas para los vectores, us√°bamos el operador `[i]` para **acceder al elemento i-√©simo**. En el caso de las matrices la l√≥gica ser√° la misma:

* para **.bg-purple_light[acceder a la fila i-√©sima]** se usa el operador `[i, ]` (dejando libre la columna).

```{r}
datos_matriz[1, ] # fila 1
```

---

# .orange[SELECCIONAR] elementos

Si recuerdas para los vectores, us√°bamos el operador `[i]` para **acceder al elemento i-√©simo**. En el caso de las matrices la l√≥gica ser√° la misma:

* para **.bg-purple_light[acceder a la columna j-√©sima]** se usa el operador `[, j]` (dejando libre la fila).

```{r}
datos_matriz[, 3] # columna 3
```


---

# .orange[SELECCIONAR] elementos

Si recuerdas para los vectores, us√°bamos el operador `[i]` para **acceder al elemento i-√©simo**. En el caso de las matrices la l√≥gica ser√° la misma:

* para **.bg-purple_light[acceder conjuntamente al elemento (i, j)]** se usa el operador `[i, j]`.

```{r}
datos_matriz[1, 3] # elemento (1, 3)
datos_matriz[2, 2] # elemento (1, 3)
```


---

# .orange[NOMBRAR] variables

Una matriz por defecto adopta los nombres de los vectores como los nombres de columnas, pero podemos 
**.bg-purple_light[personalizar los nombres de las variables]**

```{r}
estaturas <- c(150, 160, 170)
pesos <- c(60, 70, 80)
cbind("altura" = estaturas, "pesaje" = pesos)
```


--

Si las columnas tienen nombres podemos hacer uso de ellos para **acceder a las columnas**

```{r}
datos_matriz[, c("edades", "tlf")]
```

---

# .orange[NOMBRAR] variables

Tambi√©n podemos **.bg-purple_light[asignar nombres]** a las filas de una matriz con `row.names()` y acceder a filas y columnas por nombres.

```{r}
row.names(datos_matriz) <- c("Javi", "Laura", "Patricia", "Carlos", "Juan", "Luis", "Carla")
datos_matriz
datos_matriz["Javi", "edades"]
```

---

# .orange[OPERACIONES] por filas/columnas

Normalmente, para explicar las **operaciones con matrices** en un lenguaje de programaci√≥n al uso, necesitar√≠amos hablar de una **herramienta llamada bucles**. Lo mencionaremos m√°s adelante pero no los vamos a necesitar de momento (cu√°ntos menos los usemos en `R`, mejor)

--

Imagina que tuvi√©semos nuestra matriz de estaturas y pesos.

```{r}
datos_matriz <- cbind(estaturas, pesos)
datos_matriz
```

--

¬øC√≥mo podemos **.bg-purple_light[aplicar una operaci√≥n para cada una de las filas o columnas]** de una matriz?

---

# .orange[OPERACIONES] por filas/columnas

Imagina que queremos obtener la **.bg-purple_light[media de cada columna]**. Lo haremos con la funci√≥n `apply()`, y le indicaremos como argumentos la matriz, el **.bg-orange[sentido de la operaci√≥n]** (`MARGIN = 1` por filas, `MARGIN = 2` por columnas) y la **funci√≥n a aplicar**

```{r}
# Media (mean) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "mean")
```

--

Si la funci√≥n **requiere de argumentos extras** se lo podemos indicar al final.

```{r}
estaturas_bis <- c(150, NA, 170, 180, 190)
datos_matriz_bis <- cbind(estaturas_bis, pesos) 
apply(datos_matriz_bis, MARGIN = 2, FUN = "mean")
```

---

name: ejercicios-matrices

# Ejercicios de matrices

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: modifica el c√≥digo para definir una matriz `x` de ceros de 3 filas y 7 columnas.
 
```{r eval = FALSE}
# Matriz
x <- matrix(0, nrow = 2, ncol = 3)
x
```

* üìù **Ejercicio 2**: a la matriz anterior, suma un 1 a cada n√∫mero de la matriz y divide el resultado entre 5.
 

* üìù **Ejercicio 3**: tras definir la matriz `x` calcula su transpuesta y obt√©n sus dimensiones
 

]

.panel[.panel-name[Soluci√≥n ej. 1]

```{r}
x <- matrix(0, nrow = 3, ncol = 7)
x
```

]

.panel[.panel-name[Soluci√≥n ej. 2]

```{r}
# sumamos 1
x + 1

# dividimos entre 5
(x + 1) / 5
 
```

]

.panel[.panel-name[Soluci√≥n ej. 3]

```{r}
# dimensiones originales
dim(x)

# transpuesta
y <- t(x)
y
dim(y)
```

]


]

---

# Ejercicios de matrices

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 4**: define la matriz `x <- matrix(1:12, nrow = 4)`. Obt√©n la primera fila, la tercera columna, y el elemento (4, 1).

* üìù **Ejercicio 5**: en la matriz anterior, pon a cada fila `i` el nombre `fila_i` (fila_1, fila_2, fila_3, fila_4).

* üìù **Ejercicio 6**: con la matriz anterior definida como `matrix(1:12, nrow = 4)`, calcula la media de todos los elementos, la media de cada fila y la media de cada columna. Calcula la suma de de cada fila y de cada columna

]

.panel[.panel-name[Soluci√≥n ej. 4]

```{r}
x <- matrix(1:12, nrow = 4)

# primera fila
x[1, ]

# tercera columna
x[, 3]

# (4, 1)
x[4, 1]
```

]

.panel[.panel-name[Soluci√≥n ej. 5]

```{r}
x
row.names(x) <- glue("fila_{1:4}")
x
```

]

.panel[.panel-name[Soluci√≥n ej. 6]

```{r}
# media por filas
apply(x, MARGIN = 1, FUN = mean)

# media por columnas
apply(x, MARGIN = 2, FUN = mean)

# suma por filas
apply(x, MARGIN = 1, FUN = sum)

# suma por columnas
apply(x, MARGIN = 2, FUN = sum)
```

]

]


---

# Ejercicios extras (matrices y vectores)

.panelset[
.panel[.panel-name[Ejercicios extra]

* üìù **Ejercicio 1**: define un vector `y` que contenga los 5 primeros pares, y otro `x` con los 5 primeros impares. Haz la suma de `x` (ejercicio 1 anterior) e `y`.
 
* üìù **Ejercicio 2**: encuentra del vector `x <- c(-1, 0, -2, 5, 3, 7)` el lugar (el √≠ndice) que ocupa su m√≠nimo y su m√°ximo.
 

* üìù **Ejercicio 3**: define el vector `c(-1, 0, 4, 5, -2)`, calcula la ra√≠z cuadrada del vector y determina que lugares son de tipo `NaN`.

* üìù **Ejercicio 4**:  el siguiente c√≥digo define una matriz de dimensiones `4 x 3` y calcula la suma por columnas. Modifica el c√≥digo para que realice la suma por filas.
 
```{r eval = FALSE}
matriz <- matrix(1:12, nrow = 4)
apply(matriz, MARGIN = 2, FUN = "sum")
```

]

.panel[.panel-name[Soluci√≥n ej. 1]

```{r}
y <- c(0, 2, 4, 6, 8)
x <- y + 1 # forma m√°s r√°pida de (1, 3, 5, 7, 9)
x + y
```

]

.panel[.panel-name[Soluci√≥n ej. 2]

```{r}
x <- c(-1, 0, -2, 5, 3, 7)
which.max(x)
which.min(y)
```

]

.panel[.panel-name[Soluci√≥n ej. 3]

```{r}
x <- c(-1, 0, 4, 5, -2)
sqrt(x)
is.nan(sqrt(x))
```

]

.panel[.panel-name[Soluci√≥n ej. 4]

```{r}
matriz <- matrix(1:12, nrow = 4)
apply(matriz, MARGIN = 1, FUN = "sum")
```

]

]

---

class: inverse center middle
name: clase-4

# CLASE 4: primeros datos

&nbsp;

### [data.frame](#data.frame)

### [tibble](#tibble)

### [Ejercicios](#ejercicios-tibble)

---

name: data.frame

# .orange[TABLAS]: variables .green[data.frame]
 


```{r echo = FALSE,  out.width = "45%", fig.align = "center"}
knitr::include_graphics("./img/celdas.jpg")
``` 

* **.bg-purple_light[Celda]**: un dato **.bg-orange[individual]** de un tipo concreto.

* **.bg-purple_light[Variable]**: una **.bg-orange[concatenaci√≥n de valores]** del mismo tipo (**vectores**).

* **.bg-purple_light[Matriz]**: **.bg-orange[concatenaci√≥n de variables]** del **.bg-yellow[mismo tipo]** y longitud.

&nbsp;

--

* **.bg-purple_light[data.frame (tabla)]**: **.bg-orange[concatenaci√≥n de variables]** de **.bg-yellow[DISTINTO tipo]** e igual longitud.


---

# .red[PROBLEMAS] de las .green[MATRICES]


Retomemos nuestra matriz de edades, tel√©fonos y c√≥digos postales.

```{r}
edades <- c(14, 24, 56, 31, 20, 87) 
tlf <- c(NA, 683839390, 621539732, 618211286, NA, 914727164)
cp <- c(33007, 28019, 37005, 18003, 33091, 25073)

# Construimos la matriz por columnas
datos_matriz <- cbind(edades, tlf, cp) #<<
datos_matriz
```

--

¬øQu√© suceder√° si ahora **.bg-purple_light[a√±adimos una columna con los nombres]** (tipo caracter) de cada persona?

---


# .red[PROBLEMAS] de las .green[MATRICES]

```{r}
nombres <- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")
datos_matriz_nueva <- cbind(nombres, datos_matriz)
```

```{r echo = FALSE}
datos_matriz_nueva 
```

**.bg-red_light[¬øHas visto lo que ha sucedido?]**

--

Como una **.bg-purple_light[matriz solo puedes tener un tipo de dato]**, al a√±adir una variable de tipo texto, `R` se ha visto obligado a **convertir los n√∫meros en texto** (poni√©ndole **comillas**). 

```{r error = TRUE}
datos_matriz_nueva[, "edades"] + 1
```

---

# .red[PROBLEMAS] de las .green[MATRICES]

Las **.bg-purple_light[matrices]** nos permiten almacenar distintas variables SIEMPRE Y CUANDO tengan

* **.bg-orange[Misma longitud]**.
* **.bg-orange[Mismo tipo]** de dato (sin mezclar).

Esto es bastante limitante en la vida real nuestros datos tendr√°n variables de todo tipo: supongamos que queremos **guardar de 7 personas las siguientes variables**.


```{r}
# Nombres
nombres <- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")

# Apellidos
apellidos <- c(NA, "Gonz√°lez", "Fern√°ndez", "Mart√≠nez", "Li√©bana", "Garc√≠a", "Ortiz")

# C√≥digo postal
cp <- c(28019, 28001, 34005, 18410, 33007, 34500, 28017)

# Edades
edades <- c(45, 67, NA, 31, 27, 19, 50)
```

---


# .red[PROBLEMAS] de las .green[MATRICES]

Las **.bg-purple_light[matrices]** nos permiten almacenar distintas variables SIEMPRE Y CUANDO tengan

* **.bg-orange[Misma longitud]**.
* **.bg-orange[Mismo tipo]** de dato (sin mezclar).

Esto es bastante limitante en la vida real nuestros datos tendr√°n variables de todo tipo: supongamos que queremos **guardar de 7 personas las siguientes variables**.


```{r}
# Tel√©fono
tlf <- c(618910564, 914718475, 934567891, 620176565, NA, NA, 688921344)

# Estado civil (no lo sabemos de una persona)
casado <- c(TRUE, FALSE, FALSE, NA, TRUE, FALSE, FALSE)

# Fecha de creaci√≥n (fecha en el que esa persona entra en el sistema)
# lo convertimos a tipo fecha
fecha_creacion <-
  as_date(c("2021-03-04", "2020-10-12", "1990-04-05",
            "2019-09-10", "2017-03-21", "2020-07-07",
            "2000-01-28"))
```


---

# .red[PROBLEMAS] de las .green[MATRICES]

Aahora tenemos un **popurr√≠ de variables**, de la misma longitud pero de tipos distintos:

* `(edades, tlf, cp)` son variables **num√©ricas**.
* `(nombres, apellidos)` son variables de **texto**.
* `casado` es una variable **l√≥gica**.
* `fecha_creacion` de tipo **fecha**.

¬øQu√© suceder√≠a si **.bg-purple_light[intentamos mezclar todo en una matriz]**?

--

```{r}
# Juntamos por columnas
datos_matriz <-
  cbind(nombres, apellidos, edades, tlf, cp, casado, fecha_creacion)
datos_matriz
```

---

# .red[PROBLEMAS] de las .green[MATRICES]

```{r}
datos_matriz
```

Dado que en una **.bg-purple_light[matriz solo podemos almacenar datos del mismo tipo]**, los n√∫meros los convierte a texto, las variables l√≥gicas las convierte a texto (`TRUE` era un valor l√≥gico, `"TRUE"` es un texto, sin significado de verdadero/falso) y las fechas las ha convertido a texto.

```{r error = TRUE}
datos_matriz[1, "fecha_creacion"] - datos_matriz[2, "fecha_creacion"]
```

---

# .orange[TABLAS]: variables .green[data.frame]

Vamos a aprender c√≥mo juntar variables de distinto tipo, sin **modificar la integridad** del dato. El formato de **.bg-purple_light[tabla de datos]** que vamos a empezar a usar se llama `data.frame`: una **.bg-purple_light[colecci√≥n de variables de igual longitud]** pero cada una puede ser de un **.bg-orange[tipo distinto]**.

--

Para crearlo basta con usar la funci√≥n `data.frame()`, pas√°ndole como argumentos (separados por comas) las variables que queremos reunir.

```{r}
# Creamos nuestro primer data.frame
tabla <- data.frame(nombres, apellidos, edades, tlf,
                    cp, casado, fecha_creacion) #<<
tabla
```

---

# .orange[TABLAS]: variables .green[data.frame]

```{r}
tabla
class(tabla)
dim(tabla)
```

---

# .orange[TABLAS]: variables .green[data.frame]

Al igual que con matrices, podemos **.bg-purple_light[crear un data.frame]** indicando **nombre de columnas**

```{r}
tabla <- data.frame("nombre" = nombres, "apellido" = apellidos, "edad" = edades, "tel√©fono" = tlf, 
                    "cp" = cp, "casado" = casado, "fecha_registro" = fecha_creacion)
tabla
```

&nbsp;

**.bg-green_light[¬°TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!]** Puedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`

---

# .orange[TABLAS]: variables .green[data.frame]

Si tenemos uno ya creado y queremos **.bg-purple_light[a√±adir una columna]** es tan simple como usar la `funci√≥n data.frame()` que ya hemos visto para concatenar la columna. Vamos a√±adir por ejemplo una nueva variable, el **n√∫mero de hermanos** de cada individuo.

```{r}
# A√±adimos una nueva columna con n¬∫ de hermanos/as
hermanos <- c(0, 0, 1, 5, 2, 3, 0)
tabla <- data.frame(tabla, "n_hermanos" = hermanos)
tabla
```

---

# .orange[TABLAS]: variables .green[data.frame]

Si queremos **.bg-purple_light[acceder a una columna, fila o elemento]** en concreto, los `data.frame` tienen las mismas ventajas que una matriz, as√≠ que bastar√≠a con usar los mismos operadores.

```{r}
tabla[5, ] # Accedemos a la quinta fila
```

--

.pull-left[

```{r echo = FALSE,  out.width = "99%", fig.align = "left", fig.cap = "Men√∫ desplegable de variables (columnas)"}
knitr::include_graphics("./img/tabla_dolar.jpg")
``` 
]

.pull-right[

No solo tiene las ventajas de una matriz sino que tambi√©n tiene las **.bg-purple_light[ventajas de una ¬´base¬ª de datos]**: podemos aceder a las variables por el √≠ndice de columna que ocupan pero tambi√©n **.bg-purple_light[acceder por su nombre]**, poniendo el nombre de la tabla, el s√≠mbolo `$` y, con el tabulador, nos aparecer√° un men√∫ de columnas a elegir.

]

---

# Primer .orange[AN√ÅLISIS DE DATOS]

.panelset[
.panel[.panel-name[USArrests]

Nuestro primer conjunto ser√° `USArrests`, un dataset de **.bg-purple_light[arrestos en EE.UU.]** del paquete `{datasets}` (si escribimos `datasets::` y pulsamos tabulador, se nos abre un desplegable con distintos conjuntos de datos para ser usado)

```{r}
# install.packages("datasets") # Descomentar si nunca se ha instalado
library(datasets)
datasets::USArrests
```

Contiene **.bg-purple_light[estad√≠sticas de arrestos en 1973 (por cada 100 000 habitantes)]** por agresi√≥n, asesinato y violaci√≥n, en cada uno de los 50 estados de Estados Unidos.
]

.panel[.panel-name[Visualizar]

Con `View()` se nos abrir√° el conjunto en un formato ¬´excelizado¬ª. Adem√°s con `head()` podemos **.bg-purple_light[visualizar la cabecera]** (primeras) del conjunto de datos.

```{r}
head(USArrests)
```

]

.panel[.panel-name[Variables]

Con la funci√≥n `names()` podemos obtener directamente el **.bg-purple_light[nombre de las variables]** (tambi√©n podemos usarlo para renombrarlas)

```{r}
names(USArrests)
```

El conjunto contiene los **3 tipos de delito** mencionados (para cada estado), y adem√°s el **porcentaje de poblaci√≥n que vive en √°reas urbanas**. Esto lo podemos saber ejecutando la ayuda con `? datasets::USArrests`.

]

.panel[.panel-name[Individuos]

Con la funci√≥n `row.names()` podemos obtener el **.bg-purple_light[nombre de las filas]** (de los estados) para cada uno de ellos.

```{r}
row.names(USArrests)
```

]


.panel[.panel-name[Dimensiones]

¬øC√≥mo averiguar el **.bg-purple_light[n√∫mero de registros y el n√∫mero de variables]**?

```{r}
dim(USArrests)
nrow(USArrests)
ncol(USArrests)
```

]

.panel[.panel-name[Selecci√≥n]

Al igual que antes, podemos **.bg-purple_light[seleccionar filas por √≠ndices]** y **.bg-purple_light[variables nombre]**.


```{r}
USArrests[c(2, 10), c("Murder", "Assault")]
```

Tambi√©n podemos usar las ventajas de los `data.frame` para acceder a las variables.

```{r}
USArrests$Murder
```

]

.panel[.panel-name[subset]

En el caso de los `data.frame` tenemos adem√°s a nuestro disposici√≥n una **herramienta muy potente**: la funci√≥n `subset()`. Dicha funci√≥n nos va a permitir **.bg-purple_light[seleccionar filas y columnas a la vez]**, tomando de entrada la tabla, `subset = ...` igual a la **condici√≥n l√≥gica** para filtrar registros (filas) y `select = ...` igual al  nombre de las columnas que queremos seleccionar.

```{r}
subset(USArrests, subset = UrbanPop > 70, select = c("Murder"))
```

]

.panel[.panel-name[Caso pr√°ctico]

* üìù **Ejercicio**: filtra aquellos estados cuyo porcentaje de poblaci√≥n urbana sea inferior al 70% y donde las agresiones sean superiores a 250 por cada 100 000 habitantes, seleccionando solo las variables.

]

.panel[.panel-name[Caso pr√°ctico]

* üìù **Ejercicio**: filtra aquellos estados cuyo porcentaje de poblaci√≥n urbana sea inferior al 70% y donde las agresiones sean superiores a 250 por cada 100 000 habitantes, seleccionando solo las variables.

```{r}
subset(USArrests, subset = UrbanPop < 70 & Assault > 250,
       select = c("Murder", "Rape"))
```

]

]

---

name: tibble

# Mejorando los data.frame: .orange[TIBBLE]
 
Las tablas en formato `tibble` (con `tibble()` del paquete `{tibble}`, su clase ser√° `tbl_df`) son un tipo de `data.frame` mejorado, para una gesti√≥n **.bg-purple_light[m√°s √°gil, eficiente y coherente]**. Las tablas en formato `tibble` tienen **.bg-purple_light[4 ventajas principales]**

```{r echo = FALSE,  out.width = "30%", fig.align = "center"}
knitr::include_graphics("./img/tibble.svg")
``` 

---

# Mejorando los data.frame: .orange[TIBBLE]


*  Muestran **.bg-purple_light[metainformaci√≥n de las variables]**, y solo imprime por defecto las primeras filas.

```{r}
library(tibble)
tabla_tb <- tibble("x" = 1:50, "y" = rep(c("a", "b", "c", "d", "e"), 10),
                   "logica" = rep(c(TRUE, FALSE), 25))
tabla_tb
```



---

# Mejorando los data.frame: .orange[TIBBLE]
 
Puedes **imprimir las filas y columnas** que quieras con `print()`

```{r}
print(tabla_tb, n = 12, width = Inf) #<<
```

---

# Mejorando los data.frame: .orange[TIBBLE]
 

* La funci√≥n `tibble()` **.bg-purple_light[construye las variables secuencialmente]**, pudiendo hacer uso en la propia definici√≥n de variables reci√©n definidas en dicha definici√≥n.

```{r error = TRUE}
# data.frame
data.frame("x1" = 1:3, "x2" = 4:6, "y" = x1 * x2)
```

```{r}
# tibble
tibble("x1" = 1:3, "x2" = 4:6, "y" = x1 * x2)
```


---

# Mejorando los data.frame: .orange[TIBBLE]
 
* Si accedes a una **.bg-purple_light[columna que no existe]** avisa con un **.bg-red[warning]**.

```{r}
tabla_df <- data.frame("x" = 1:50, "y" = rep(c("a", "b", "c", "d", "e"), 10),
                   "logica" = rep(c(TRUE, FALSE), 25))
```

.pull-left[

```{r warning = TRUE}
# data.frame
tabla_df$variable_inexistente
```

]

.pull-right[

```{r warning = TRUE}
# tibble
tabla_tb$variable_inexistente
```

]

---


# Mejorando los data.frame: .orange[TIBBLE]

* No solo no te cambiar√° el tipo de datos sino que **.bg-purple_light[no te cambiar√° el nombre de las variables]**.

.pull-left[

```{r}
data.frame(":)" = "emoticono",
           " " = "en blanco",
           "2000" = "n√∫mero")
```

]

.pull-right[

```{r}
tibble(":)" = "emoticono",
       " " = "en blanco",
       "2000" = "n√∫mero")
```

]

---


# Mejorando los data.frame: .orange[TIBBLE]

Si ya tienes un `data.frame` es altamente recomendable **.bg-purple_light[convertirlo a tibble]** con `as_tibble()` (del paquete `{dplyr}`)

```{r}
library(dplyr)
as_tibble(USArrests)
```

Puedes consultar **m√°s funcionalidades** de dichos datos en <https://tibble.tidyverse.org/>

---

# Mejorando los data.frame: .orange[TIBBLE]

Una de las ventajas es la funci√≥n `glimpse()`, que nos permite obtener el **.bg-purple_light[resumen de columnas]** (no es para tener un resumen de los datos sino para ver las variables que tenemos y su tipo).

```{r}
glimpse(tabla_tb)
```

---

# Mejorando los data.frame: .orange[TIBBLE]

Am√©n de poder convetir con `as_tibble()` podemos **.bg-purple_light[crearlos por filas]** (como copiar y pegar de una tabla en documento) en lugar de por columnas con `tribble()`

```{r}
datos <- tribble(
  ~colA, ~colB,
  "a",   1,
  "b",   2)
datos
```

&nbsp;

--

**.bg-green_light[CONSEJO]**: prueba adem√°s el paquete `{datapasta}`, que nos permite **.bg-purple_light[copiar y pegar tablas de p√°ginas web]**


---

name: ejercicios-tibble

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: carga del paquete `{datasets}` el conjunto de datos `airquality` (contiene variables de la calidad del aire de la ciudad de Nueva York desde mayo hasta septiembre de 1973). ¬øEs el conjunto de datos airquality de tipo tibble? En caso negativo, convi√©rtelo a `tibble`.

* üìù **Ejercicio 2**: obt√©n el nombre de las variables y las dimensiones del conjunto de datos. ¬øCu√°ntas variables hay? ¬øCu√°ntos d√≠as se han medido?
 
* üìù **Ejercicio 3**:  modifica el c√≥digo inferior para que nos filtre solo los datos del mes de agosto.
 
```{r eval = FALSE}
# Filtramos filas
filtro_fila <- subset(., subset = Month < 6)
filtro_fila
```

]

.panel[.panel-name[Soluci√≥n ej. 1]

```{r}
library(datasets)
class(airquality) # no es data.frame

# Convertimos a tibble
airquality <- as_tibble(airquality)
class(airquality)
```

]

.panel[.panel-name[Soluci√≥n ej. 2]

```{r}
names(airquality)

dim(airquality)

# N√∫mero variables
ncol(airquality)

# N√∫mero d√≠as
nrow(airquality)
```

]


.panel[.panel-name[Soluci√≥n ej. 3]

```{r}
# Filtramos filas
filtro_fila <- subset(airquality, subset = Month == 8)
filtro_fila
```
]

]

---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 4**: del conjunto selecciona aquellos datos que no sean ni de julio ni de agosto.

* üìù **Ejercicio 5**: modifica el siguiente c√≥digo para quedarte solo con las variable de ozono y temperatura.
 
```{r eval = FALSE}
filtro_col <- subset(.,  select = c("Ozone"))
filtro_col
```

* üìù **Ejercicio 6**:  selecciona los datos de temperatura y viento de agosto. Traduce a castellano el nombre de las columnas del conjunto filtrado.


* üìù **Ejercicio 7**: a√±ade a los datos originales una columna con la fecha completa (recuerda que es del a√±o 1973 todas las observaciones).

]

.panel[.panel-name[Soluci√≥n ej. 4]

```{r}
subset(airquality, subset = !(Month %in% c(7, 8)))
```

]

.panel[.panel-name[Soluci√≥n ej. 5]

```{r}
# Filtramos columnas
filtro_col <- subset(airquality,  select = c("Ozone", "Temp"))
filtro_col
```

]

.panel[.panel-name[Soluci√≥n ej. 6]

```{r}
datos <- subset(airquality, subset = Month == 8, select = c("Temp", "Wind"))
datos 

# Traducimos a castellano el nombre
names(datos) <- c("temperatura", "viento")
glimpse(datos)
```

]

.panel[.panel-name[Soluci√≥n ej. 7]

```{r}
nuevos_datos <- 
  tibble(airquality, "fecha" = as_date(glue("1973-{Month}-{Day}")))
nuevos_datos
```

]


]

---

# Ejercicios extras

.panelset[
.panel[.panel-name[Ejercicios extras]


* üìù **Ejercicio 8**: define un `tibble` con tres variables num√©ricas `a, b, c`, tal que la tercera sea el producto de las dos primeras `c = a * b`.

* üìù **Ejercicio 9**:  define un tibble con tres variables de nombres `variable`, `2`, `tercera` y `:)`, e intenta acceder a ellas.
 
* üìù **Ejercicio 10**:  obten de los paquetes `{dplyr}` y `{gapminder}` los conjuntos de datos `starwars` y `gapminder`. Comprueba el n√∫mero de variables, de registros e imprime los datos

]

.panel[.panel-name[Soluci√≥n ej. 8]

```{r}
tibble("a" = 1:4, "b" = 11:14, "c" = a * b)
```

]

.panel[.panel-name[Soluci√≥n ej. 9]

```{r}
datos <- tibble("variable" = 1, "2" = "a", "tercera" = 3, ":)" = "b")

# Accedemos
datos$variable
datos$`2`
datos$tercera
datos$`:)`
```

]

.panel[.panel-name[Soluci√≥n ej. 10]

```{r}
library(dplyr)
dim(starwars)

library(gapminder)
dim(gapminder)
```

]

]

---

a


---

class: inverse center middle
name: clase-5

# CLASE 5: rmarkdown y casos pr√°cticos

&nbsp;

### [informes/apuntes: rmarkdown](#rmd)

### [Caso pr√°ctico I: ...](#clase5-caso-I)

### [Caso pr√°ctico II: ...](#clase5-caso-II)

---

a

---


# .orange[T√çTULO] de prueba

Este ser√° el color de **.bg-purple_light[resaltado principal]** aunque se puedan usar otros en la misma slide como **.bg-yellow[resaltado m√°s para c√≥digo]** y tambi√©n este otro de **.bg-orange[resaltado random extra]**...de los de lanza en astillero, adarga antigua, roc√≠n flaco y galgo corredor. 


- **.bg-yellow[Resaltado]** de algo con **negrita**, con c√≥digo cuando sea necesario `x <- 1` y web <https://www.linkrandom.com>


```{r}
x <- 1
y <- 2
x + y #<<
```

&nbsp;

**.bg-green_light[Consejito]**: no trabajes gratis

**.bg-red_light[¬°Cuidado, insensatos!]** No uses excel

---

# .orange[RECURSOS] y .green[BIBLIOGRAF√çA]

&nbsp;


#### üìö **.bg-purple_light[Art√≠culos o libros]** cient√≠ficos que han sido sometidos a revisi√≥n por pares.

&nbsp;

#### üîó **.bg-green_light[Recursos online]** recomendados

&nbsp;

#### üíª Recursos para la **.bg-orange[programaci√≥n en R]**

---

# Bibliograf√≠a general

üíª **Tidy Data Tutor**: para visualizar la mec√°nica interna de `{tidyverse}`. <https://tidydatatutor.com/>

üîó Web con recursos para la **introducci√≥n a la estad√≠stica y Machine Learning en R** <https://artofstat.com/>

üìö **¬´An Introduction to Multivariate Statistical Analysis¬ª**. Anderson (1958) <https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/introduction_mva_anderson_2003.pdf>

üìö **¬´A New Measure of Rank Correlation¬ª**. Kendall (1938) <https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/correlation_kendall_1938.pdf>

üìö **¬´The generalised product moment distribution in samples from a normal multivariate population¬ª**. Wishart (1928) <https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/multivariate_normal_wishart_1928.pdf>

üìö **¬´On lines and planes of closest fit to systems of points in space¬ª**. Pearson (1901) <https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/fit_pearson_1901.pdf>


---

# Recursos dataviz

### Dataviz

üìö **¬´Gram√°tica de las gr√°ficas: pistas para mejorar las representaciones de datos¬ª**. Sevilla (2005) <http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf>

üìö **¬´Quantitative Graphics in Statistics: A Brief History¬ª**. Beniger and Robyn <https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/graphics_beniger_robin_1978.pdf>
 
 
üíª **¬´Analizando datos, visualizando informaci√≥n, contando historias¬ª** (curso de dataviz en R). √Ålvarez-Li√©bana y Valverde-Castilla (2022) <https://dadosdelaplace.github.io/curso-dataviz-ECI-2022>

---

# Bibliograf√≠a componentes principales

üíª **Componentes principales** en `{tidymodels}`. <https://www.tmwr.org/dimensionality.html#beans>


üìö **¬´Principal Component Analysis¬ª**. Jolliffe (2002) <https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/pca_jolliffe_2002.pdf>

üìö **¬´Principal Component Analysis¬ª**. Herv√© and Lynne (2010) <http://staff.ustc.edu.cn/~zwp/teach/MVA/abdi-awPCA2010.pdf>

üìö **¬´Principal Component Analysis: a review and recent developments¬ª**. Jolliffe and Cadima (2016) <https://royalsocietypublishing.org/doi/10.1098/rsta.2015.0202>

üîó **¬´The Mathematics Behind Principal Component Analysis¬ª**. Dubey (2018).  <https://towardsdatascience.com/the-mathematics-behind-principal-component-analysis-fff2d7f4b643>


üîó **¬´A One-Stop Shop for Principal Component Analysis¬ª**. Brems (2017). <https://towardsdatascience.com/a-one-stop-shop-for-principal-component-analysis-5582fb7e0a9c>

üìö **¬´On the number of principal components: a test of dimensionality based on measurements of similarity between matrices¬ª**. Dray (2008) <https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/numer_pca_dray_2008.pdf>


---

# Bibliograf√≠a an√°lisis cl√∫ster

üìö **¬´Multiclass classification of dry beans using computer vision and machine learning techniques¬ª**. Koklu y Ozkan (2020) <https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/multiclass_classif_koklu_ozlan_2020.pdf>

üíª **¬´Clustering y heatmaps: aprendizaje no supervisado¬ª**. Amat (2017). <https://rpubs.com/Joaquin_AR/310338>

üíª **¬´K-means clustering with tidy data principles¬ª** <https://www.tidymodels.org/learn/statistics/k-means/>

üîó **¬´ISLR tidymodels Labs¬ª** <https://emilhvitfeldt.github.io/ISLR-tidymodels-labs/unsupervised-learning.html#kmeans-clustering>


üìö **¬´Algorithm AS 136: a K-Means Clustering Algorithm¬ª**. Hartigan y Wong (1979) <http://www.jstor.org/stable/2346830>

üîó **¬´Machine Learning for Social Scientists¬ª**. Cimentada (2020) <https://cimentadaj.github.io/ml_socsci/unsupervised-methods.html>

---

# Recursos y bibliograf√≠a

### Otras t√©cnicas de reducci√≥n de la dimensi√≥n

üîó Sobre **PCA y PLS**. Amat (2017). <https://www.cienciadedatos.net/documentos/35_principal_component_analysis#Introducci%C3%B3n>

üìö **¬´On the early history of the singular value decomposition¬ª**. Stewart (1993) <https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/svd_stewart_1993.pdf>

üìö **¬´UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction¬ª**. McInnes, healy and Melville (2020) <https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/umap_mcinnesetal_2020.pdf>

