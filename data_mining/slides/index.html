<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>T√©cnicas de miner√≠a de datos</title>
    <meta charset="utf-8" />
    <meta name="author" content="Javier √Ålvarez Li√©bana (Fac. Estudios Estad√≠sticos - UCM)" />
    <link href="index_files/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="index_files/tile-view-0.2.6/tile-view.js"></script>
    <link href="index_files/animate.css-3.7.2/animate.xaringan.css" rel="stylesheet" />
    <link href="index_files/tachyons-4.12.0/tachyons.min.css" rel="stylesheet" />
    <link href="index_files/xaringanExtra-extra-styles-0.2.6/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <script src="index_files/clipboard-2.0.6/clipboard.min.js"></script>
    <link href="index_files/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="index_files/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Click para copiar c√≥digo","success":"C√≥digo copiado","error":"Ctrl+C para copiar"})</script>
    <link href="index_files/panelset-0.2.6/panelset.css" rel="stylesheet" />
    <script src="index_files/panelset-0.2.6/panelset.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# T√©cnicas de miner√≠a de datos
## M√°ster en Miner√≠a de Datos e Inteligencia de Negocio
### Javier √Ålvarez Li√©bana (Fac. Estudios Estad√≠sticos - UCM)
### √öltima actualizaci√≥n: 02-10-2022

---










class: inverse center middle

# ATAJOS DE LAS DIAPOSITIVAS





`$$\\[2in]$$`

.left[Pulsa &lt;kbd-black&gt;O&lt;/kbd-black&gt; para ver el **PANEL DE DIAPOSITIVAS**]
.left[Pulsa &lt;kbd-black&gt;H&lt;/kbd-black&gt; para ver **OTROS ATAJOS**]

---

# .orange[MATERIAL] de las clases


.pull-left[

- **.bg-purple_light[Diapositivas]** del curso:
&lt;https://dadosdelaplace.github.io/teaching/data_mining/slides&gt;

- **.bg-red_light[Evaluaci√≥n]** de la asignatura
&lt;https://github.com/dadosdelaplace/teaching/tree/main/data_mining/eval&gt;

- **.bg-yellow[Scripts]** de la asignatura
&lt;https://github.com/dadosdelaplace/teaching/tree/main/data_mining/scripts&gt;

- **.bg-orange[Bibliograf√≠a]**: &lt;https://github.com/dadosdelaplace/teaching/tree/main/data_mining/biblio&gt;

&amp;nbsp;

- **.bg-green_light[Manual introductorio de R]**: &lt;https://dadosdelaplace.github.io/courses-intro-R/&gt;

]

---

# Me presento: la turra

.pull-left[

&lt;img src="./img/me.jpeg" width="80%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

* **.bg-purple_light[Javier √Ålvarez Li√©bana]**, nacido en 1989 en Carabanchel Bajo (Madrid)

* Licenciado (UCM) en **Matem√°ticas** (Erasmus en Bologna mediante). **M√°ster (UCM) en Ingenier√≠a Matem√°tica** (2013-2014)


* **.bg-orange[Doctorado en estad√≠stica]** por la Universidad de Granada


* Encargado de la **visualizaci√≥n y an√°lisis de datos covid** de la Consejer√≠a de Salud del **Principado de Asturias**

]


Intentando eso de la **.bg-yellow[divulgaci√≥n]** por **Twitter** (**.bg-yellow[@dadosdelaplace]**) e **Instagram** (**.bg-yellow[@javieralvarezliebana]**)

---

name: objetivos

# .orange[OBJETIVOS] de la asignatura


El **.bg-purple_light[prop√≥sito]** de esta asignatura ser√° cuadruple

- **.bg-orange[Quitarnos el miedo]** a programar: a programar se aprende programando, no hace falta ser Julian Assange.

--

- Aprender las **.bg-orange[t√©cnicas b√°sicas de depuraci√≥n y exploraci√≥n]** datos, aprendiendo a implementarlas en un software estad√≠stico.

--

- Aprender las **.bg-orange[t√©cnicas b√°sicas de miner√≠a de datos]**, centr√°ndonos en las t√©cnicas de **.bg-orange[aprendizaje supervisado]**.

--

- Ser capaces de **.bg-orange[interpretar y evaluar]** nuestros modelos.

&amp;nbsp;

üìö Estas **diapositivas** han sido elaboradas con el propio `R` haciendo uso de los paquetes `{xaringan}`, `{xaringanExtra}` y `{xaringanthemer}`.

---

# .orange[EVALUACI√ìN] de la asignatura


La **.bg-purple_light[evaluaci√≥n]** del curso se har√° mediante entregas:

* El **.bg-orange[40% de la nota]** final corresponder√° a peque√±as **.bg-green_light[pr√°cticas individuales]** (entre 2 y 4 pr√°cticas) que se empezar√°n en clase y se completar√°n en casa (se deber√°n entregar ambos archivos).

* El otro **.bg-orange[40% de la nota]** vendr√° determinado por la entrega de **.bg-green_light[1-2 pr√°cticas grupales]** (m√≠nimo 3, m√°ximo 5 personas). Se podr√° solicitar a cualquier persona del grupo que explique el trabajo realizado en una tutor√≠a individual.

*  El otro **.bg-orange[20% de la nota]** se asignar√° en funci√≥n de un **.bg-green_light[datathon final]** que se realizar√° de forma grupal (m√≠nimo 2, m√°ximo 4 personas).

---

# .orange[EVALUACI√ìN] de la asignatura


* Para poder promediar nota es **.bg-red_light[obligatorio]** entregar **.bg-purple_light[todas las entregas individuales]** con una **.bg-green_light[nota superior al 3]** sobre 10, am√©n de participar en **.bg-purple_light[al menos una entrega grupal]**.

* Adem√°s la nota media de las entregas **.bg-red_light[individuales no podr√° ser un 50% inferior]** a la media de notas grupales.


* En caso de **.bg-red_light[no cumplir dichos requisitos]**, y/o haya faltado a m√°s de un tercio de las clases, tendr√° que presentarse a un examen final, cuya
nota ser√° el 100% de la nota del curso.

---

# .orange[CONTENIDOS] de la asignatura


- Las **.bg-purple_light[primeras clases]** las dedicaremos a una **.bg-orange[introducci√≥n de la programaci√≥n]** en R (ya que necesitaremos algunas nociones b√°sicas para poder funcionar) as√≠ como **.bg-orange[algunos conceptos b√°sicos de estad√≠stica]** (medidas de centralizaci√≥n, dispersi√≥n, sesgo/varianza, supervisado vs no supervisado, metolodog√≠a SEMMA, etc).

--

- Metodolog√≠as de **.bg-purple_light[aprendizaje supervisado]**:
  - Algoritmo de los **.bg-orange[k-vecinos (knn)]**: clasificaremos elementos en funci√≥n de la moda/media de los elementos m√°s cercanos.
  
  - **.bg-orange[√Årboles de decisi√≥n]**: clasificaremos elementos en funci√≥n de la moda/media de una partici√≥n final (hoja) tras segmentar nuestro espacio de variables (reglas de decisi√≥n).
  
  - **.bg-orange[Regresi√≥n lineal]**: realizaremos una predicci√≥n (variable continua) teniendo como inputs una colecci√≥n de variables continuas, asumiendo una relaci√≥n lineal.
  
  - **.bg-orange[Regresi√≥n log√≠stica y GLM]**: realizaremos una predicci√≥n continua de la probabilidad de que una variable cualitativa tome cada una de las categor√≠as (probabilidad de estar sano o enfermo, por ejemplo).
  
---

# .orange[EJEMPLOS] reales de alumnos



‚úàÔ∏è **.bg-purple_light[Clasificaci√≥n de vuelos]**: usando, entre otras, variables de tr√°fico de aereo, tipolog√≠a de vuelo, variables meteorol√≥gicas, se consigui√≥ clasificar el retraso (o no) de 4 millones de vuelos (TFM de Almudena Mar√≠a Moreno Maderuelo)

--

üì∞ **.bg-purple_light[Clasificaci√≥n de Fake News]**: usando t√©cnicas de miner√≠a de datos aplicadas a textos (miner√≠a de textos), se propuso clasificar noticias en verdaderas o falsas, analizando la frecuencia y sentimientos de las palabras analizadas, as√≠ como la relaci√≥n entre las palabras (TFM de Iv√°n Guarionex de Fr√≠as Chireno)

--

ü©∫ **.bg-purple_light[Predicci√≥n de diabetes]**: haciendo uso de diferente variables m√©dicas y de h√°bitos de salud sacados de la encuesta de salud p√∫blica de EE.UU., se pretende predecir la aparici√≥n o no de diabetes en personas adultos, y determinar posibles factores de riesgo (TFM de Mar√≠a Mart√≠nez Ramudo).

--

üó≥ **.bg-purple_light[Predicci√≥n de encuestas electorales]**: usando el promedio de diferentes encuestas, y considerando diferentes variables sociol√≥gicos (como el sesgo de las casas encuestadores), conseguir una predicci√≥n del % de voto de cada partido promediando por tama√±o de muestra y ventana temporal (TFM de Enric Palau Payeras)

---


class: inverse center middle

# CLASES

&amp;nbsp;


#### [CLASE 1: INTRODUCCI√ìN A R](#clase-1)

#### [CLASE 2: PRIMEROS DATOS. PRIMEROS CONCEPTOS](#clase-2)

#### [CLASE 3: INTRO A LA METODOLOG√çA SEMMA. TIDYDATA](#clase-3)

---


class: inverse center middle
name: clase-1

# CLASE 1: introducci√≥n a R desde cero.

&amp;nbsp;

### [Instalaci√≥n](#instalacion)

### [¬øQu√© es R? Primeros pasos](#que-es-R)

### [Primeros ejercicios](#ejercicios1)

### [Variables num√©ricas y caracteres](#variables)

### [Variables l√≥gicas y de tipo fecha](#logicas)

### [Ejercicios](#ejercicios2)


---

name: instalacion

# Requisitos

Para la asignatura los √∫nicos **.bg-purple_light[requisitos]** ser√°n:

--

1. **.bg-orange[Conexi√≥n a internet]** (para la descarga de algunos datos y paquetes).

--

2. **.bg-orange[Instalar R]**: ser√° nuestro lenguaje, nuestro **.bg-yellow[castellano]** para poder ¬´comunicarnos con el ordenador. La descarga la haremos (gratuitamente) desde &lt;https://cran.r-project.org/&gt;

--

3. **.bg-orange[Instalar R Studio]**. De la misma manera que podemos escribir castellano en un Word o en un tuit, podemos usar **distintos IDE** (entornos de desarrollo integrados, nuestro Office), para que el trabajo sea m√°s c√≥modo. Nuestro **.bg-yellow[Word]** para nosotros ser√° **RStudio**.

.left[
  &lt;img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/cran-R.jpg" alt = "cran-R" align = "left" width = "460" style = "margin-top: 2vh"&gt;
]

.right[
  &lt;img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/R-studio.jpg" alt = "RStudio" align = "right" width = "460" style = "margin-top: 2vh;"&gt;
]


---

# Instalaci√≥n de R

El lenguaje `R` ser√° nuestra **.bg-purple_light[gram√°tica]**, nuestra ortograf√≠a y nuestro diccionario

.pull-left[



- **Paso 1**: entra en &lt;https://cran.r-project.org/&gt; y selecciona **.bg-purple_light[sistema operativo]**.

- **Paso 2**: para **.bg-purple_light[Mac]** basta con que hacer click en el archivo .pkg, y abrirlo una vez descargado. Para sistemas **.bg-purple_light[Windows]**, debemos clickar en `install R for the first time` y en la siguiente pantalla en `Download R for Windows`. Una vez descargado, abrirlo como cualquier archivo de instalaci√≥n.

- **Paso 3**: abrir el **ejecutable**.

]

.pull-right[

&lt;img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/cran-R.jpg" alt = "cran-R" align = "left" width = "900" style = "margin-top: 1vh"&gt;

]

**.bg-green_light[Consejito]**: siempre que tengas que descargar algo de CRAN (ya sea el propio R o un paquete), aseg√∫rate de tener conexi√≥n a **.bg-orange[internet]**.


---

# Primera operaci√≥n

Para comprobar que se ha instalado correctamente, tras abrir `R`, deber√≠as ver una **pantalla blanca** similar a esta (en realidad se llama **.bg-purple_light[consola]**). Vamos a escribir nuestra **.bg-orange[primera operaci√≥n]** en la consola:

.pull-left[

* A una variable llamada `a` le asignaremos el valor 1 (asignamos con `&lt;-`, como una flecha)


```r
# Una variable a con valor --&gt; 1
*a &lt;- 1
```

]

--

.pull-right[

* A otra variable llamada `b` le asignaremos el valor 2 (cambia a la izquierda el nombre, cambia a la derecha el valor).


```r
# Una variable b con valor --&gt; 2
*b &lt;- 2
```

]

--

.pull-left[

* Sumamos las variables haciendo `a + b`.


```r
# Primera operaci√≥n
a &lt;- 1 # Una variable a con valor --&gt; 1
b &lt;- 2 # Una variable b con valor --&gt; 2
*a + b
```
]

--

.pull-right[

* El resultado que nos devuelve ser√° `3`.


```
&gt; [1] 3
```

]

---

# .orange[INSTALACI√ìN] de RStudio

El **.bg-purple_ligth[Word]** que usaremos para trabajar y escribir en nuestro lenguaje ser√° **.bg-purple_ligth[RStudio]** (lo que se conoce como un **IDE**, un entorno integrado de desarrollo).

.pull-left[

* **Paso 1**: entra en la [web oficial de RStudio](https://www.rstudio.com/products/rstudio/download/#download) y selecciona la **.bg-purple_light[descarga gratuita]**.

* **Paso 2**: selecciona el ejecutable que te aparezca, acorde a tu sistema operativo.

* **Paso 3**: tras descargar el ejecutable, hay que abrirlo como otro cualquier otro ejecutable y dejar que **.bg-purple_light[termine la instalaci√≥n]**.

]

.pull-right[

&lt;img src="./img/R-studio.jpg" width="80%" style="display: block; margin: auto auto auto 0;" /&gt;


]

---

# .orange[ORGANIZACI√ìN] de RStudio

.pull-left[

&lt;img src="./img/inicio_rstudio_2.jpg" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

* **.bg-purple_light[Consola]**: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo c√≥digo que antes (la suma) en ella. La consola ser√° donde **.bg-orange[ejecutaremos √≥rdenes]** y **.bg-yellow[mostraremos resultados]**.
]

---

# .orange[ORGANIZACI√ìN] de RStudio

.pull-left[

&lt;img src="./img/inicio_rstudio_3.jpg" width="75%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

* **.bg-purple_light[Environment]** (entorno de variables): la pantalla peque√±a (puedes ajustar los m√°rgenes con el rat√≥n) que tenemos en la parte superior derecha. Nos mostrar√° las **variables que tenemos definidas, el tipo y su valor**.

]

---

# .orange[ORGANIZACI√ìN] de RStudio

.pull-left[

&lt;img src="./img/inicio_rstudio_4.jpg" width="85%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

* **.bg-purple_light[Panel multiusos]**: la ventana que tenemos en la parte inferior derecha no servir√° para buscar **.bg-orange[ayuda de funciones]**, adem√°s de para **.bg-yellow[visualizar gr√°ficos]**. 

]

---

name: que-es-R

# ¬øQu√© es R?


&lt;img src = "https://logos.turbio.repl.co/rlang.svg" alt = "Rstudio" align = "left" width = "300" style = "margin-top: 1vh;margin-right: 2rem;"&gt;

`R` es un **.bg-purple_light[lenguaje estad√≠stico]**, creado por y para la estad√≠stica, con 4 ventajas fundamentales:

--

* **.bg-purple_light[Software libre]** (como C++, Python, etc). no solo es gratis, sino que permite **.bg-orange[acceder libremente a c√≥digo ajeno]**.

--

* **.bg-purple_light[Lenguaje modular]**: en la instalaci√≥n que hemos realizado solo se ha instalado el m√≠nimo para poder funcionar. Al ser software libre, existen **.bg-orange[trozos de c√≥digo]** hechos por otras personas (**.bg-yellow[paquetes]**) que podemos instalar seg√∫n necesidades.

--

* **.bg-purple_light[Gran comunidad de usuarios]**: `R` tiene una comunidad de usuarios gigante para hacer estad√≠stica (Python tiene una comunidad m√°s enfocada al Machine Learning), con m√°s de 18 000 paquetes.

--

* **.bg-purple_light[Lenguaje de alto nivel]**. Los lenguajes de alto nivel, como `R` o `Python`, facilitan la programaci√≥n al usuario (menor curva de aprendizaje, aunque m√°s lentos en ejecuci√≥n).


---

# Paquetes en R

A lo largo del curso usaremos varios de esos **.bg-purple_light[paquetes]**, como por ejemplo el paquete `{ggplot2}`, un paquete para la elaboraci√≥n de **.bg-purple_light[visualizaciones de datos]**. Vamos a instalarlo (necesitamos internet para ello) con la orden `install.packages("ggplot")`


```r
install.packages("ggplot2")
```

&amp;nbsp;


&amp;nbsp;



La **.bg-purple_light[instalaci√≥n]** de un paquete es el equivalente a **.bg-orange[comprar a un libro]**: solo lo debemos hacer **la primera vez** que lo usemos en un ordenador. Una vez que tenemos comprado nuestro libro, para poder usarlo, simplemente debemos indicar al programa que nos lo **.bg-purple_light[acerque de la estanter√≠a]** con `library(ggplot2)`.


```r
library(ggplot2)
```

---

class: inverse center middle

**COMPRAR** libro --&gt; instalar un paquete (una sola vez) `install.packages()`
&lt;figure&gt;
&lt;img src = "https://cdn.cienradios.com/wp-content/uploads/sites/14/2020/09/Book-Depository-2.jpg" alt = "comprar-libros" align = "middle" width = "480" style = "margin-top: 1vh;"&gt;
&lt;/figure&gt;

**SELECCIONAR** libro (ya comprado) --&gt; acceder a un paquete instalado (en cada sesi√≥n que queramos usarlo) `library()`
&lt;figure&gt;
&lt;img src = "https://cdn.sincroguia.tv/uploads/programs/l/a/-/la-biblioteca-de-los-libros-rechazados-704306_SPA-77.jpg" alt = "comprar-libros-2" align = "middle" width = "480" style = "margin-top: 1vh;"&gt;
&lt;/figure&gt;


---

class: center middle

# .orange[CASOS REALES] de uso de R


.pull-left[

&lt;img src="./img/covid_isciii.jpg" width="97%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

&lt;img src="./img/momo_isciii.jpg" width="97%" style="display: block; margin: auto auto auto 0;" /&gt;


]

Las webs del Instituto de Salud Carlos III &lt;https://cnecovid.isciii.es/covid19/&gt; y &lt;https://momo.isciii.es/panel_momo/&gt; est√°n hechas con `R` (con `{shiny}` y `{plotly}` )

---

# .orange[CASOS REALES] de uso de R

.pull-left[

&lt;img src="./img/elpais_R.jpg" width="99%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

El **.bg-purple_light[equipo de datos]** (Borja Andrino, Kiko Llaneras y Daniele Grasso) trabaja con `R` para elaborar sus an√°lisis, desde los datos electorales hasta el cambio clim√°tico.

Es una de las razones por las que son capaces de realizar brillantes an√°lisis de grandes vol√∫menes de datos de forma r√°pida y √°gil: la **.bg-purple_light[automatizaci√≥n de procesos]** que nos permite programar en `R` puede ser fundamental para analizar datos que hasta entonces no pod√≠amos.

]


---

# .orange[Incel] vs excel

&lt;img src="./img/incel.jpg" width="75%" style="display: block; margin: auto;" /&gt;

---

class: inverse center middle

# ¬øPor qu√© .orange[NO] usamos Excel?

![](./img/meme_barco.jpg)

---

# ¬øPor qu√© .orange[NO] usamos Excel?

Excel es una **.bg-purple_light[hoja de c√°lculo]**, ni m√°s ni menos, y el propio **Microsoft desaconseja su uso** para el an√°lisis de datos. El Excel es una herramienta maravillosa para ser usada como una sencilla hoja de c√°lculo (llevar cuentas de tu familia, declaraci√≥n de Renta, planificar viajes, etc).

&amp;nbsp;

**.bg-red_light[NO EST√Å DISE√ëADO]** para ser una base de datos, y muchos menos pensado para generar un entorno flexible para el an√°lisis estad√≠stico:

* **.bg-red_light[Software de pago]**

* **.bg-red_light[Software cerrado]**: solo podemos hacer lo que Excel ha cre√≠do que interesante que podamos hacer.

* **.bg-red_light[Alto consumo de memoria]**.

* **.bg-red_light[No es universal]**: no solo es de pago sino que adem√°s, dependiendo de la versi√≥n que tengas de Excel, tendr√° un formato distinto para datos como fechas, teniendo incluso extensiones distintas.

---



# .red[EPIC FAILS] en Excel

Problemas de **.red[versiones]**


&lt;img src="./img/excel_genes.jpg" width="37%" style="display: block; margin: auto auto auto 0;" /&gt;


üìö Ver **.bg-green_light[bibliograf√≠a]** en &lt;https://github.com/dadosdelaplace/teaching/tree/main/data_mining/biblio&gt;


---

# .red[EPIC FAILS] en Excel

Problemas de **.red[memoria]**

&lt;img src="./img/excel_uk.jpg" width="50%" style="display: block; margin: auto auto auto 0;" /&gt;


üìö Ver **.bg-green_light[bibliograf√≠a]** en &lt;https://github.com/dadosdelaplace/teaching/tree/main/data_mining/biblio&gt;


---

# .red[EPIC FAILS] en Excel

Problemas de **.red[codificaci√≥n]**

&lt;img src="./img/excel_edades.jpg" width="50%" style="display: block; margin: auto auto auto 0;" /&gt;

üìö Ver **.bg-green_light[bibliograf√≠a]** en &lt;https://github.com/dadosdelaplace/teaching/tree/main/data_mining/biblio&gt;

---

name: primeros-pasos

# Primeros pasos en R: .orange[CALCULADORA]

Empecemos por lo sencillo: **.bg-purple-light[¬øc√≥mo usar R como una calculadora?]** Si escribimos `2 + 1` en la consola y pulsamos ENTER, la consola nos mostrar√° el resultado de la suma.


```r
2 + 1
```

```
&gt; [1] 3
```

--

Si dicha suma la quisi√©ramos utilizar para un segundo c√°lculo: ¬øy si la **.bg-purple-light[almacenamos en alguna variable]**? Por ejemplo, vamos a guardar la suma en una variable `x`


```r
*x &lt;- 2 + 1
```

--

Si te fijas ahora `x` aparece definida en nuestro **.bg-yellow[environment]**, y puede ser usada de nuevo


```r
x + 3
```

```
&gt; [1] 6
```

---

# Primeros pasos en R: .orange[CALCULADORA]

### Multiplicaci√≥n


```r
*x * y
```

### Elevar al cuadrado


```r
*x^2
```

### Valor absoluto


```r
*abs(x)
```

---

# .red[Errores]

Durante tu aprendizaje va a ser **muy habitual** que las cosas no salgan a la primera, apareciendo en consola **.bg-purple_light[mensajes de error]** en un **.bg-red_light[color rojo]**. No te asustes: lo peor que puede pasar es que tengas que reiniciar `R`).

&amp;nbsp;

* Mensajes de **.bg-red_light[ERROR]**: ir√°n precedidos de la frase **.bg-yellow[¬´Error in‚Ä¶¬ª]**, y ser√°n aquellos fallos que **impidan la ejecuci√≥n del c√≥digo** 


```r
"a" + 1 # intentando sumar 1 a un texto
```

```
&gt; Error in "a" + 1: argumento no-num√©rico para operador binario
```

&amp;nbsp;

**.bg-green_light[CONSEJO]**: lee siempre los mensajes de error para aprender de ellos (ya que suelen dar pistas de c√≥mo resolverlos).

---

# .red[Errores]

Durante tu aprendizaje va a ser **muy habitual** que las cosas no salgan a la primera, apareciendo en consola **.bg-purple_light[mensajes de error]** en un **.bg-red_light[color rojo]**. No te asustes: lo peor que puede pasar es que tengas que reiniciar `R`).

&amp;nbsp;
 
* Mensajes de **.bg-orange[WARNING]**: ir√°n precedidos de la frase **.bg-yellow[¬´Warning in‚Ä¶¬ª]**, y son los fallos m√°s delicados ya que son posibles incoherencias pero sin que tu c√≥digo deje de ejecutarse.


```r
sqrt(-1) # raiz cuadrada de n√∫mero negativo
```

```
&gt; Warning in sqrt(-1): Se han producido NaNs
```

```
&gt; [1] NaN
```

&amp;nbsp;

**¬øHa ejecutado la orden?** S√≠, pero te advierte de que el resultado de la operaci√≥n es un `NaN`, **Not A Number**, un valor que no existe (al menos dentro de los n√∫meros reales).


---

# ¬øD√≥nde programamos? .orange[SCRIPTS]

Un **.bg-purple_light[script]** ser√° el documento en el que programamos, nuestro equivalente a un archivo .doc, pero aqu√≠ ser√° un archivo con extensi√≥n `.R`, donde **escribiremos las √≥rdenes**. Para **.bg-purple_light[abrir nuestro primero script]**, haz click en el men√∫ superior en `File &lt;&lt; New File &lt;&lt; R Script`.

&amp;nbsp;


.pull-left[


&lt;img src="./img/inicio_rstudio_5.jpg" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

**.bg-green_light[CONSEJO]**: intenta no abusar de la consola, ya que todo lo que no escribas en un script, cuando cierres `RStudio`, lo **habr√°s perdido** (c√≥mo si en lugar de escribir en un Word y guardarlo, nunca guardases el documento).

]

---

# ¬øD√≥nde programamos? .orange[SCRIPTS]

Ahora tenemos una **cuarta ventana**: la ventana donde **escribiremos nuestros c√≥digos**


### **¬øC√≥mo ejecutar nuestro script?**

.pull-left[

&lt;img src="./img/inicio_rstudio_6.jpg" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

1. **.bg-purple_light[Escribimos el c√≥digo]** a ejecutar.

2. **.bg-purple_light[Guardamos]** el archivo `.R` haciendo click en `Save current document`.

3. El c√≥digo **no se ejecuta salvo que se lo indiquemos**. Tenemos tres opciones:
  - **.orange[Copiar y pegar]** en consola.
  - **.orange[Seleccionar l√≠neas]** y clickar en `Run`.
  - Activar `Source on save` a la **derecha de guardar**: no solo guarda sino que ejecuta el c√≥digo completo.

]

---

name: ejercicios1

# Primeros ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: a√±ade debajo otra l√≠nea para definir una variable `b` con el valor `5`. Tras asignarles valores, multiplica los n√∫meros en consola.


```r
a &lt;- 2
```

* üìù **Ejercicio 2**: modifica el c√≥digo inferior para definir dos variables `c` y `d`, con valores 3 y -1.


```r
c &lt;- # deber√≠as asignarle el valor 3
d &lt;- # deber√≠as asignarle el valor -1
```

* üìù **Ejercicio 3**: con las variables `a` y `b` del ej. 1, crea una nueva variable `e` guardando el resultado de su multiplicaci√≥n `a * b`. Escribe `e` en consola para ver su resultado

]

.panel[.panel-name[Soluci√≥n ej. 1]


```r
# Para poner comentarios en el c√≥digo se usa #

# Definici√≥n de variables
a &lt;- 2
b &lt;- 5

# Multiplicaci√≥n
a * b
```

```
&gt; [1] 10
```
]

.panel[.panel-name[Soluci√≥n ej. 2]


```r
# Definici√≥n de variables
c &lt;- 3
d &lt;- -1
```
]

.panel[.panel-name[Soluci√≥n ej. 3]


```r
# Variables
a &lt;- 2
b &lt;- 5

# Resultado
e &lt;- a * b

# Muestro en consola
e
```

```
&gt; [1] 10
```

]
]

---

# Primeros ejercicios


.panelset[
.panel[.panel-name[Ejercicios extra]


* üìù **Ejercicio 4**: asigna un valor positivo a `x` y calcula su ra√≠z cuadrada; asigna otro negativo y calcula su valor absoluto con la funci√≥n `abs()`.


* üìù **Ejercicio 5**: usando la variable `x` ya definida, completa/modifica el c√≥digo inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.


```r
z &lt;- ? - ? # completa el c√≥digo
z
```

* üìù **Ejercicio 6**: usando las variables `x` e `y` ya definidas, calcula el m√°ximo de ambas (funci√≥n `max()`), y gu√°rdalo en una nueva variable `t`.

]

.panel[.panel-name[Soluci√≥n ej. 4]


```r
# Ra√≠z cuadrada
x &lt;- 73 # por ejemplo
sqrt(x)
```

```
&gt; [1] 8.544004
```

```r
# Valor absoluto
y &lt;- -19 # por ejemplo
abs(y)
```

```
&gt; [1] 19
```
]

.panel[.panel-name[Soluci√≥n ej. 5]


```r
z &lt;- x - 5
z
```

```
&gt; [1] 68
```
]

.panel[.panel-name[Soluci√≥n ej. 6]


```r
t &lt;- max(x, y)
t
```

```
&gt; [1] 73
```

]
]


---


name: variables

# De la .orange[celda] a la .green[tabla]
 

¬øDe qu√© tipo pueden ser los datos que tenemos contenidos en cada celda de una ¬´tabla¬ª?


&lt;img src="./img/celdas.jpg" width="55%" style="display: block; margin: auto;" /&gt;

* **.bg-purple_light[Celda]**: un dato **.bg-orange[individual]** de un tipo concreto.
* **.bg-purple_light[Variable]**: una **.bg-orange[concatenaci√≥n de valores]** del mismo tipo (**vectores**).
* **.bg-purple_light[Matriz]**: **.bg-orange[concatenaci√≥n de variables]** del **.bg-yellow[mismo tipo]** y longitud.
* **.bg-purple_light[Tabla]**: **.bg-orange[concatenaci√≥n de variables]** de **.bg-yellow[distinto tipo]** pero igual longitud.

---

# .orange[Celdas]: tipos de datos individuales

¬øExisten **variables m√°s all√° de los n√∫meros**?

&amp;nbsp;

Piensa por ejemplo en los **datos guardados de una persona**:

* La edad o el peso ser√° un **.bg-purple_light[n√∫mero]**.
* Su nombre ser√° una cadena de **.bg-purple_light[texto]**.
* Su fecha de nacimiento ser√° precisamente eso, una **.bg-purple_light[fecha]**.
* A la pregunta ¬´¬øest√° usted soltero/a?¬ª la respuesta ser√° lo que llamamos una **.bg-purple_light[variable l√≥gica]** (`TRUE` si est√° soltero/a o `FALSE` en otro caso).

&lt;img src="./img/celdas.jpg" width="40%" style="display: block; margin: auto;" /&gt;

---

# Variables .orange[NUM√âRICAS]

El **dato m√°s sencillo**, dato que ya hemos usado en nuestros primeros pasos como calculadora, ser√°n las variables que guardan simplemente n√∫meros


```r
a &lt;- 1
b &lt;- 2
a + b
```

```
&gt; [1] 3
```

--

En el c√≥digo anterior, tanto `a` como `b` como la suma `a + b` son de **.bg-purple_light[tipo num√©rico]**


```r
*class(a)
```

```
&gt; [1] "numeric"
```

```r
*typeof(a)
```

```
&gt; [1] "double"
```


---

# Variables .orange[NUM√âRICAS]

Como ya hemos visto, con los datos num√©ricos podemos realizar todas las **.bg-purple_light[operaciones aritm√©ticas]** que se nos ocurrir√≠a hacer en una **calculadora** como sumar (`+`), restar (`-`), multiplicar (`+`), dividir (`/`), ra√≠z cuadrada (`sqrt()`), valor absoluto (`abs()`), elevar al cuadrado (`^2`), elevar al cubo (`^3`), etc.




```r
a &lt;- 5
a^3 # Elevar al cubo
```

```
&gt; [1] 125
```


```r
b &lt;- -43
abs(b) # valor absoluto
```

```
&gt; [1] 43
```

---

# Variables de .orange[TEXTO]

No solo de n√∫meros viven los datos: imagina que adem√°s de la edad de una persona queremos **guardar su nombre** (**.bg-purple_light[tipo caracter]**: una **cadena de texto**)


```r
*nombre &lt;- "Javier"
class(nombre)
```

```
&gt; [1] "character"
```

--

Las cadenas de texto son un **tipo especial de dato** con los que obviamente no podremos hacer operaciones aritm√©ticas (pero s√≠ **.bg-purple_light[otras operaciones]** como pegar o localizar patrones).


```r
nombre + 1 # error al sumar n√∫mero a texto
```

```
&gt; Error in nombre + 1: argumento no-num√©rico para operador binario
```

&amp;nbsp;

--

**.bg-green_light[IMPORTANTE]**: las variables de tipo texto van **.bg-red_light[SIEMPRE ENTRE comillas]**.


---

name: primer-paquete

# .orange[PRIMERA FUNCI√ìN]: paste

Una **.bg-purple_light[funci√≥n]** es un **trozo de c√≥digo encapsulado** bajo un nombre, que depende de unos **.bg-purple_light[argumentos de entrada]**.

--

Nuestra primera funci√≥n ser√° `paste()`: dadas dos cadenas de texto como argumento de entrada nos permite pegarlas, indic√°ndole en el argumento `sep = ` el caracter que queremos entre medias.


```r
# todo junto, sin espacios, igual a paste0("Javier", "√Ålvarez")
paste("Javier", "√Ålvarez", sep = "") 
```

```
&gt; [1] "Javier√Ålvarez"
```




```r
paste("Javier", "√Ålvarez", sep = "?*?") # separados por un ?*?
```

```
&gt; [1] "Javier?*?√Ålvarez"
```


---

# .orange[PRIMERA FUNCI√ìN]: paste



```r
*paste("Javier", "√Ålvarez")
```

```
&gt; [1] "Javier √Ålvarez"
```

Por defecto, `paste()` a√±ade un espacio, es decir, `sep = " "`. Muchas funciones en `R` tendr√°n lo que llamamos **.bg-purple_light[argumentos por defecto]**, el valor que tomar√° sino se le asigna otro. Puedes mirar la **.bg-green_light[ayuda de la funci√≥n]** escribiendo en consola `? paste`

Existe una funci√≥n similar llamada `paste0()` que pega por defecto con `sep = ""` (sin nada).


```r
paste0("Javier", "√Ålvarez") 
```

```
&gt; [1] "Javier√Ålvarez"
```

```r
paste("Javier", "√Ålvarez", sep = "") 
```

```
&gt; [1] "Javier√Ålvarez"
```

---

# .orange[PRIMER PAQUETE]: glue

Otra forma **m√°s intuitiva de trabajar con textos** es usar el **paquete** `{glue}`.


```r
library(glue) # solo la 1¬™ vez install.packages("glue")
```

--

Con dicho paquete podemos **.bg-purple_light[usar variables dentro de cadenas]** de texto. Por ejemplo, la frase ¬´la edad es de ... a√±os¬ª, donde la edad concreta la tenemos guardada en una variable.


```r
edad &lt;- 33
*glue("La edad es de {edad} a√±os")
```

```
&gt; La edad es de 33 a√±os
```

Dentro de las llaves tambi√©n podemos ejecutar operaciones


```r
unidades &lt;- "d√≠as"
*glue("La edad es de {edad * 365} {unidades}")
```

```
&gt; La edad es de 12045 d√≠as
```

---


# .orange[VECTORES]: concatenaci√≥n

¬øY si en lugar de querer almacenar un solo elemento, por ejemplo , tenemos una **colecci√≥n de elementos**?

Hasta ahora solo hemos operado con el contenido de las **celdas**, pero cuando trabajamos con datos normalmente tendremos columnas que representan variables o caracter√≠sticas: llamaremos **.bg-purple_light[vectores]** a una **.bg-orange[concatenaci√≥n]** de variables del **.bg-orange[mismo tipo]**
 
--

La forma m√°s sencilla es con el comando `c()` (c de concatenar), y basta con introducir sus **elementos entre par√©ntesis y separados por comas** (por ejemplo, la edad de 4 personas).


```r
*edades &lt;- c(33, 27, 60, 61)
edades
```

```
&gt; [1] 33 27 60 61
```


&amp;nbsp;

--

**.bg-green_light[IMPORTANTE]**: un n√∫mero individual (`x &lt;- 1`) es en realidad un vector de longitud uno. 

---

# .orange[VECTORES]: concatenaci√≥n


Como ves ahora en el `environment` tenemos una **.bg-purple_light[colecci√≥n de elementos]** guardada

.pull-left[


```r
edades
```

```
&gt; [1] 33 27 60 61
```

]


.pull-right[
&lt;img src="./img/vectores_enviroment.jpg" width="80%" style="display: block; margin: auto auto auto 0;" /&gt;
]

--

.pull-left[

La **.bg-purple_light[longitud de un vector]** se puede calcular con `length()`


```r
*length(edades)
```

```
&gt; [1] 4
```

]


.pull-right[

Tambi√©n podemos **.bg-purple_light[concatenar vectores]**


```r
c(edades, edades, 8)
```

```
&gt; [1] 33 27 60 61 33 27 60 61  8
```

]

---

# Vectores: .orange[SECUENCIAS NUM√âRICAS]

En muchas ocasiones querremos **.bg-purple_light[crear secuencias num√©ricas]** mucho m√°s r√°pido (por ejemplo, un vector con los d√≠as del mes). El comando `seq()` nos permite crear una **secuencia** desde un elemento inicial hasta un elemento final, avanzando de uno en uno.


```r
seq(1, 31)
```

```
&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
&gt; [26] 26 27 28 29 30 31
```

--

El comando `1:n` nos devuelve lo mismo que la orden `seq(1, n)`. Adem√°s, si el elemento inicial es mayor que el final, `R` entender√° solo que la secuencia es **decreciente**.


```r
n &lt;- 5
n:1
```

```
&gt; [1] 5 4 3 2 1
```

---

# Vectores: .orange[SECUENCIAS NUM√âRICAS]

Tambi√©n podemos definir **.bg-purple_light[otro tipo de distancia]** (**.bg-orange[paso de discretizaci√≥n]**) entre dos elementos consecutivos


```r
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
```

```
&gt;  [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0
```

--

Otras veces nos interesar√° definir una **.bg-purple_light[secuencia con un n√∫mero concreto]** de elementos.


```r
seq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7
```

```
&gt; [1]  1.000000  9.166667 17.333333 25.500000 33.666667 41.833333 50.000000
```

--

Tambi√©n podemos crear **.bg-purple_light[vectores de elementos repetidos]** con la funci√≥n `rep()`


```r
rep(0, 7) # vector de 7 ceros
```

```
&gt; [1] 0 0 0 0 0 0 0
```


---

# .green[OPERACIONES] .orange[ARITM√âTICAS]
 
Dado que un **.bg-purple_light[n√∫mero es un vector]** de longitud 1, toda **.bg-orange[operaci√≥n aritm√©tica]** (suma, resta, multiplicaci√≥n, etc) que podamos hacer con un n√∫mero la vamos a poder a hacer con un vector de n√∫meros.

--

Si hacemos por ejemplo la operaci√≥n `2 * x`, siendo `x` un vector, lo que suceder√° es que la operaci√≥n se realizar√° en **.bg-purple_light[CADA ELEMENTO]** del vector (una sola l√≠nea de c√≥digo paro realizar operaciones en 10, 20, 1000 o 100000 elementos).


```r
# Multiplicamos por 2 a CADA ELEMENTO del vector
x &lt;- c(2, 4, 6)
*2 * x
```

```
&gt; [1]  4  8 12
```

--

&amp;nbsp;

**.bg-green_light[IMPORTANTE]**: el **.bg-purple_light[resultado]** de una operaci√≥n aritm√©tica sobre un vector ser√° **.bg-orange[otro vector]**.

---

# .green[OPERACIONES] .orange[ARITM√âTICAS]
 
 
De la misma manera podemos **.bg-purple_light[sumar o restar una constante]** al vector


```r
# Sumamos 3 a CADA ELEMENTO DEL VECTOR
x + 3
```

```
&gt; [1] 5 7 9
```

--

Los vectores tambi√©n pueden **.bg-purple_light[interactuar entre ellos]**, as√≠ que podemos definir sumas de vectores, como `x + y`


```r
y &lt;- c(1, 3, 5)

# suma de vectores 
*x + y
```

```
&gt; [1]  3  7 11
```

--

**.bg-green_light[IMPORTANTE]**: salvo que especifiquemos lo contrario, toda operaci√≥n aritm√©tica que hagas a un vector ser√° **.bg-purple_light[elemento a elemento]**.

 
---


# .green[OPERACIONES] con .orange[AUSENTES]

Imagina que tenemos un vector de temperaturas pero varios de los d√≠as el aparato de medici√≥n no funcionaba, por lo que tenemos un **.bg-purple_light[dato ausente]** marcado como `NA`.


```r
x &lt;- c(21, NA, 13, NA, NA, 25, 36, 17, 19, 5)
sum(x)
```

```
&gt; [1] NA
```

--

Dado que hay d√≠as que no tenemos disponibles, la suma tampoco la podemos conocer.  Para evitar que nos impida hacer ciertas operaciones, en muchas funciones de `R` podemos a√±adir el **argumento** `na.rm = TRUE`: primero elimina ausentes, y luego ejecuta la funci√≥n.


```r
# eliminando datos ausentes antes de aplicar la funci√≥n
*sum(x, na.rm = TRUE)
```

```
&gt; [1] 136
```

```r
mean(x, na.rm = TRUE)
```

```
&gt; [1] 19.42857
```


---

# .green[OPERACIONES] con .orange[AUSENTES]

Para **comprobar** si tenemos un **dato ausente**  podemos hacer uso de la funci√≥n `is.na()`


```r
is.na(x)
```

```
&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE
```

--

Tambi√©n puede aparecernos un **.bg-purple_light[resultado no permitido]**, marcado como `NaN` (not a number): no es un dato ausente, es un dato resultado de una **operaci√≥n no permitida**.


```r
x &lt;- c(1, NA, 3, 4, 6, 7, sqrt(-1), NA)
x
```

```
&gt; [1]   1  NA   3   4   6   7 NaN  NA
```

```r
is.nan(x)
```

```
&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE
```


---

# .orange[SELECCIONAR] elementos

Otra operaci√≥n muy habitual es la **.bg-purple_light[extraer un subconjunto del mismo]**. La forma m√°s sencilla es **usar el operador de selecci√≥n** `[i]` para **acceder al elemento i-√©simo**


```r
edades &lt;- c(20, 30, 33, NA, 61)

# accedemos a la edad de la tercera persona en la lista
*edades[3]
```

```
&gt; [1] 33
```

```r
# accedemos a la edad de la cuarta persona
edades[4]
```

```
&gt; [1] NA
```

---

# .orange[SELECCIONAR] elementos

Un n√∫mero no es m√°s que un vector de longitud uno, as√≠ que esta operaci√≥n tambi√©n la podemos aplicar usando un **.bg-purple_light[vector de √≠ndices a seleccionar]**


```r
# Tercer y cuarto elemento
*edades[c(3, 4)]
```

```
&gt; [1] 33 NA
```

--

Esta l√≥gica para acceder a elementos tambi√©n sirve para **vectores de caracteres**.


```r
y &lt;- c("hola", "qu√©", "tal", "todo", "ok", "?")
y[1:2]
```

```
&gt; [1] "hola" "qu√©"
```

--

**.bg-green_light[TIP]**: para **.bg-purple_light[acceder al √∫ltimo elemento]** podemos pasarle como √≠ndice la longitud del vector 


```r
y[length(y)] 
```

```
&gt; [1] "?"
```

---

# .green[OPERACIONES] .orange[ARITM√âTICAS]
 

Dado que la operaci√≥n (por ejemplo, una suma) se realiza elemento a elemento, ¬øqu√© suceder√° si **.bg-purple_light[sumamos dos vectores de distinta longitud]**?

--

Por ejemplo, definamos `z` con los 4 primeros impares, e intentemos hacer la suma `x + z`.


```r
z &lt;- c(1, 3, 5, 7)
x + z
```

```
&gt; [1]   2  NA   8  11   7  10 NaN  NA
```

--

.pull-left[


&lt;img src="./img/recycle.jpg" width="99%" style="display: block; margin: auto auto auto 0;" /&gt;


]

.pull-right[

`R` intenta molestarte lo menos posible, as√≠ que lo que hace es **.bg-purple_light[reciclar elementos]**: si tiene un vector de 4 elementos y le intentas sumar uno de 3 elementos, lo que har√° ser√° reciclar elementos del vector con menor longitud: har√° `1 + 2`, `3 + 4`, `5 + 6` pero‚Ä¶ `7 + 2` (vuelve al primero).

]

---

# Vectores: .orange[CARACTERES]

Un vector es una **.bg-purple_light[concatenaci√≥n de elementos del mismo tipo]**, pero no tienen porque ser necesariamente n√∫meros. Vamos a crear una frase de ejemplo, con 4 elementos.

.pull-left[


```r
*vector &lt;- c("Me", "llamo", "Javi")
vector
```

```
&gt; [1] "Me"    "llamo" "Javi"
```

```r
length(vector)
```

```
&gt; [1] 3
```

]

.pull-right[


```r
frase &lt;- "Mi llamo Javi"
frase
```

```
&gt; [1] "Mi llamo Javi"
```

```r
length(frase)
```

```
&gt; [1] 1
```

]

F√≠jate la **diferencia** entre tenerlo guardado en un vector o tenerlo como una sola cadena de texto (unida).

---

# Vectores: .orange[CARACTERES]

Cuando usamos la funci√≥n `paste()` con variables diferentes, us√°bamos `sep = ...`. Cuando la funci√≥n `paste()` la aplicamos a un vector de caracteres, decidiremos que caracter queremos que vaya entre palabra con el argumento `collapse = ...`.


```r
paste(vector, collapse = ".") # separados por un punto
```

```
&gt; [1] "Me.llamo.Javi"
```

Podemos **combinar las secuencias de n√∫meros y un vector de caracteres** con `glue()`


```r
edad &lt;- 10:12 # edades
glue("La edad es de {edad} a√±os")
```

```
&gt; La edad es de 10 a√±os
&gt; La edad es de 11 a√±os
&gt; La edad es de 12 a√±os
```


---

name: logicas

# Datos de tipo .orange[L√ìGICO]

Un tipo de datos muy importante en todo lenguaje de programaci√≥n: los **.bg-purple_light[valores l√≥gicos]**. Un valor l√≥gico puede tomar **tres valores**:

* `TRUE` (guardado internamente como un `1`).
* `FALSE` (guardado internamente como un `0`).
* `NA` (**.bg-purple_light[dato ausente]**, son las siglas de **.bg-orange[not available]**).

--

Los valores l√≥gicos suelen ser resultado de evaluar **.bg-purple_light[condiciones l√≥gicas]** (preguntar a los datos). Por ejemplo, imaginemos que definimos un vector de temperaturas. ¬øQu√© d√≠as hizo menos de 22 grados?


```r
x &lt;- c(15, 20, 31, 27, 15, 29)
*x &lt; 22
```

```
&gt; [1]  TRUE  TRUE FALSE FALSE  TRUE FALSE
```

Nos devolver√° un **vector l√≥gico** con `TRUE` o `FALSE` en cada hueco, en funci√≥n de si cumple o no la condici√≥n pedida.

---

# Datos de tipo .orange[L√ìGICO]


Dicha condici√≥n l√≥gica puede hacerse con `&lt;=` (menor o igual), `&gt;` (mayor) o `&gt;=` (mayor igual).


```r
x &lt;= 22
```

```
&gt; [1]  TRUE  TRUE FALSE FALSE  TRUE FALSE
```

--


```r
x &gt; 30
```

```
&gt; [1] FALSE FALSE  TRUE FALSE FALSE FALSE
```

--


```r
x &gt;= 15
```

```
&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE
```

---

# Datos de tipo .orange[L√ìGICO]

Tambi√©n podemos comparar **.bg-purple_light[si es igual a otro elemento]**, para lo que usaremos el operador `==`, pudiendo usar tambi√©n su opuesto `!=` (¬´distinto de¬ª).


```r
x == 15
```

```
&gt; [1]  TRUE FALSE FALSE FALSE  TRUE FALSE
```

```r
x != 15
```

```
&gt; [1] FALSE  TRUE  TRUE  TRUE FALSE  TRUE
```

--

Si tuvi√©ramos un **.bg-purple_light[dato ausente]** (por error del aparato ese d√≠a, marcado como `NA`), la condici√≥n evaluada tambi√©n ser√≠a `NA`


```r
y &lt;- c(15, 20, NA, 31, 27, 7, 29, 10)
y &lt; 22
```

```
&gt; [1]  TRUE  TRUE    NA FALSE FALSE  TRUE FALSE  TRUE
```

---

# Datos de tipo .orange[L√ìGICO]

Las **.bg-purple_light[condiciones pueden ser combinadas]**, principalmente de dos maneras:

.pull-left[

* **.bg-purple_light[Intersecci√≥n]**: **.bg-orange[TODAS]** las condiciones concatenadas se deben cumplir (conjunci√≥n y) para devolver un `TRUE`.


```r
x
```

```
&gt; [1] 15 20 31 27 15 29
```

```r
x &lt; 30 &amp; x &gt; 15
```

```
&gt; [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE
```

]

.pull-right[

* **.bg-purple_light[Uni√≥n]**: basta con que **.bg-orange[AL MENOS UNA]** de las condiciones se cumpla (conjunci√≥n o) para devolver un `TRUE`.


```r
x
```

```
&gt; [1] 15 20 31 27 15 29
```

```r
x &lt; 30 | x &gt; 15
```

```
&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE
```

]

---

name: fecha

# Datos de tipo .orange[FECHA]


Un tipo de datos muy especial: los **.bg-purple_light[datos de tipo fecha]**. 


```r
# Cadena de texto
fecha_char &lt;- "2021-04-21"
class(fecha_char)
```

```
&gt; [1] "character"
```

Podr√≠amos pensar que no tiene nada de especial ya que parece una simple cadena de texto pero representa un **.bg-purple_light[instante en el tiempo]**, que deber√≠amos poder operar como tal.

--

¬øQu√© suceder√≠a si **sumamos un 1 (un d√≠a)** a una fecha definida como una cadena de texto?


```r
fecha_char + 1
```

```
&gt; Error in fecha_char + 1: argumento no-num√©rico para operador binario
```

--

Si guardamos las fechas como un cadena de texto **.bg-red_light[no podemos operar con ellas]**

---

# Datos de tipo .orange[FECHA]

Para trabajar con fechas tenemos el paquete `{lubridate}`, y su funci√≥n `as_date()`: nos **.bg-purple_light[convierte texto a fecha]**.


```r
library(lubridate)
*fecha &lt;- as_date(fecha_char)
class(fecha)
```

```
&gt; [1] "Date"
```

--


```r
fecha + 1 # d√≠a siguiente
```

```
&gt; [1] "2021-04-22"
```

--


```r
fecha - 3 # 3 d√≠as antes
```

```
&gt; [1] "2021-04-18"
```

--

Al convertir texto a fecha, aunque se visualice como un texto, **.bg-purple_light[internamente es un n√∫mero]**. 

---

# Datos de tipo .orange[FECHA]

La funci√≥n `as_date()` tiene un argumento opcional, el **.bg-purple_light[formato]**, que por defecto ser√° `format = "yyyy-mm-dd"` (que podemos cambiar)



```r
*as_date("10-03-2020", format = "%d-%m-%Y")
```

```
&gt; [1] "2020-03-10"
```

--


```r
as_date("10-03-20", format = "%d-%m-%y")
```

```
&gt; [1] "2020-03-10"
```

--


```r
as_date("03-10-2020", format = "%m-%d-%Y")
```

```
&gt; [1] "2020-03-10"
```

--


```r
as_date("Octubre 21, 1995 21:24", format = "%B %d, %Y %H:%M")
```

```
&gt; [1] "1995-10-21"
```

---

# Datos de tipo .orange[FECHA]

Para facilitar conversiones de formatos habituales, el paquete tambi√©n tiene a nuestra disposici√≥n diferentes funciones preparadas para directamente **.bg-purple_light[convertir fechas en distintos formatos]**, como la funci√≥n `ymd_hms()` o `ydm_hms()`


```r
ymd_hms("2017-11-28 14:02:00") # convertir a fecha una cadena a√±o-mes-d√≠a + hora
```

```
&gt; [1] "2017-11-28 14:02:00 UTC"
```

```r
ydm_hms("2017-22-12 10:00:00") # convertir a fecha una cadena a√±o-d√≠a-mes + hora
```

```
&gt; [1] "2017-12-22 10:00:00 UTC"
```

--

De la misma manera tenemos la funci√≥n `dmy_hms()`


```r
dmy_hms("1 Jan 2017 23:59:59") # convertir a fecha una cadena textual de fecha + hora
```

```
&gt; [1] "2017-01-01 23:59:59 UTC"
```

 
---

# Datos de tipo .orange[FECHA]


Tambi√©n podemos hacerlo de forma muy simplificada con `ymd()`


```r
ymd(20170131)
```

```
&gt; [1] "2017-01-31"
```

--

Otra de las funcionalidades que nos proporciona dicho paquete es obtener autom√°ticamente la **.bg-purple_light[fecha de hoy]**, haciendo uso de la funci√≥n `today()`


```r
*hoy &lt;- today()
hoy
```

```
&gt; [1] "2022-10-02"
```

--

Tambi√©n podemos obtener el **.bg-purple_light[¬´hoy y ahora¬ª]** con la funci√≥n `now()`


```r
*now()
```

```
&gt; [1] "2022-10-02 12:14:33 CEST"
```
 
---

# Datos de tipo .orange[FECHA]

Tambi√©n tenemos disponibles funciones para **.bg-purple_light[extraer facilmente algunas variables]**.

.pull-left[


```r
year(fecha)
```

```
&gt; [1] 2021
```

```r
month(fecha)
```

```
&gt; [1] 4
```

```r
hour(fecha)
```

```
&gt; [1] 0
```

```r
second(fecha)
```

```
&gt; [1] 0
```

]

.pull-right[

```r
week(fecha)
```

```
&gt; [1] 16
```

```r
wday(fecha)
```

```
&gt; [1] 4
```

```r
wday(fecha, week_start = 1) # D√≠a de la semana 
```

```
&gt; [1] 3
```

]


---

# Datos de tipo .orange[FECHA]


Tambi√©n podemos **.bg-purple_light[realizar comparaciones]**


```r
fecha_actual &lt;- today()
fecha_actual &gt; ymd(20170131) # Actual vs 2017-01-31
```

```
&gt; [1] TRUE
```

```r
fecha_actual &gt; ymd(21000131) # Actual vs 2100-01-31
```

```
&gt; [1] FALSE
```
 
--

Con la funci√≥n `leap_year()` podremos saber si la fecha **.bg-purple_light[corresponde a un a√±o bisiesto]**


```r
leap_year(as_date(ymd(20190131)))
```

```
&gt; [1] FALSE
```

---

# Datos de tipo .orange[FECHA]

.pull-left[

&lt;div class="figure" style="text-align: right"&gt;
&lt;img src="./img/lubridate.png" alt="Chuleta de https://lubridate.tidyverse.org/" width="101%" /&gt;
&lt;p class="caption"&gt;Chuleta de https://lubridate.tidyverse.org/&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

Tambi√©n podemos hacer uso de diferentes funciones para **.bg-purple_light[a√±adir intervalos]** de tiempo.


```r
fecha + weeks(0:2)
```

```
&gt; [1] "2021-04-21" "2021-04-28" "2021-05-05"
```

```r
fecha + seconds(2)
```

```
&gt; [1] "2021-04-21 00:00:02 UTC"
```

]

---


name: ejercicios2

# Ejercicios


.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: define una variable `edad` que guarde tu edad y otra `nombre` con tu nombre.

* üìù **Ejercicio 2**: define otra variable con tus apellidos y junta las variables `nombre` y `apellidos` en una sola cadena de texto que guardes en `nombre_completo`.
 
* üìù **Ejercicio 3**: define un vector que contenga los n√∫meros `1`, `10`, `-1` y `2`, y gu√°rdalo en una variable llamada `vector_num`. Obt√©n la longitud del vector anterior.
 
* üìù **Ejercicio 4**: crea una secuencia de -2 a 17 de forma que salte de uno en uno (y tambi√©n de forma decreciente). Repite el proceso pero saltando de 3 en 3.


]

.panel[.panel-name[Soluci√≥n ej. 1]


```r
# variable num√©rica
edad &lt;- 33
edad
```

```
&gt; [1] 33
```

```r
# variable de tipo texto
nombre &lt;- "Javi"
nombre
```

```
&gt; [1] "Javi"
```
]

.panel[.panel-name[Soluci√≥n ej. 2]


```r
apellidos &lt;- "√Ålvarez Li√©bana"

# Opci√≥n 1
nombre_completo &lt;- glue("{nombre} {apellidos}")
nombre_completo
```

```
&gt; Javi √Ålvarez Li√©bana
```

```r
# Opci√≥n 2
nombre_completo &lt;- paste(nombre, apellidos)
nombre_completo
```

```
&gt; [1] "Javi √Ålvarez Li√©bana"
```
]

.panel[.panel-name[Soluci√≥n ej. 3]


```r
vector_num &lt;- c(1, 10, -1, 2)
vector_num
```

```
&gt; [1]  1 10 -1  2
```

```r
# longitud
length(vector_num)
```

```
&gt; [1] 4
```

]

.panel[.panel-name[Soluci√≥n ej. 4]


```r
secuencia &lt;- -2:17
secuencia
```

```
&gt;  [1] -2 -1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
```

```r
# otra forma
secuencia &lt;- seq(-2, 17, by = 1)

# decreciente
17:-2
```

```
&gt;  [1] 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 -1 -2
```

```r
# de 3 en 3
seq(-2, 17, by = 3)
```

```
&gt; [1] -2  1  4  7 10 13 16
```

]

]

---

# Ejercicios


.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 5**: crea una secuencia que repita 7 veces el patr√≥n -1, 2, 4. Despu√©s crea otra que repita dicho patr√≥n pero de forma intercalada.
 
* üìù **Ejercicio 6**: crea una secuencia de 7 valores l√≥gicos en los que haya 2 valores ciertos, 3 valores falsos y 2 valores ausentes.


* üìù **Ejercicio 7**: toma el vector `vector_num` del ejercicio 3 y obt√©n un vector l√≥gico que nos diga que valores son mayores de 0. Obt√©n otro vector l√≥gico que nos diga que valores est√°n entre 0 y 7. Obt√©n otro vector l√≥gico que nos diga que valores son distintos de 1 en valor absoluto.

* üìù **Ejercicio 8**: obt√©n la fecha de hoy, define la fecha de tu cumplea√±os, y calcula la diferencia de d√≠as.
 
* üìù **Ejercicio 9**: suma un mes y una semana a la fecha de tu cumplea√±os

 

]

.panel[.panel-name[Sol ej. 5]


```r
secuencia &lt;- rep(c(-1, 2, 4), 7)
secuencia
```

```
&gt;  [1] -1  2  4 -1  2  4 -1  2  4 -1  2  4 -1  2  4 -1  2  4 -1  2  4
```

```r
# intercalada
rep(c(-1, 2, 4), each = 7)
```

```
&gt;  [1] -1 -1 -1 -1 -1 -1 -1  2  2  2  2  2  2  2  4  4  4  4  4  4  4
```

]

.panel[.panel-name[Sol ej. 6]


```r
secuencia &lt;- c(FALSE, TRUE, NA, FALSE, NA, TRUE, FALSE)
secuencia
```

```
&gt; [1] FALSE  TRUE    NA FALSE    NA  TRUE FALSE
```

]

.panel[.panel-name[Sol ej. 7]


```r
vector_num &gt; 0
```

```
&gt; [1]  TRUE  TRUE FALSE  TRUE
```

```r
vector_num &gt; 0 &amp; vector_num &lt; 7
```

```
&gt; [1]  TRUE FALSE FALSE  TRUE
```

```r
abs(vector_num) != 1
```

```
&gt; [1] FALSE  TRUE FALSE  TRUE
```

]


.panel[.panel-name[Sol ej. 8]


```r
library(lubridate)
hoy &lt;- today()
cumple &lt;- as_date("1989-09-10")
hoy - cumple
```

```
&gt; Time difference of 12075 days
```

]

.panel[.panel-name[Sol ej. 9]


```r
cumple + months(1) + weeks(1)
```

```
&gt; [1] "1989-10-17"
```

]

]

---

# Ejercicios extras

.panelset[
.panel[.panel-name[Ejercicios extra]


* üìù **Ejercicio 10**: construye con `glue()` una frase que diga ¬´Hola, me llamo ‚Ä¶ y tengo ‚Ä¶ a√±os¬ª.

* üìù **Ejercicio 11**: modifica el c√≥digo inferior para crear un vector de nombre `vector_num` que contenga los n√∫meros 1, 5 y -7.


```r
# Vector de n√∫meros
vector_num &lt;- c(1)
vector_num
```

* üìù **Ejercicio 12**:  extrae el mes, a√±o y d√≠a de la semana de tu cumplea√±os

]

.panel[.panel-name[Soluci√≥n ej. 10]


```r
nombre &lt;- "Javi"
edad &lt;- 33
glue("Hola, me llamo {nombre} y tengo {edad} a√±os")
```

```
&gt; Hola, me llamo Javi y tengo 33 a√±os
```
]

.panel[.panel-name[Soluci√≥n ej. 11]


```r
# Vector de n√∫meros
vector_num &lt;- c(1, 5, -7)
vector_num
```

```
&gt; [1]  1  5 -7
```

```r
# longitud
length(vector_num)
```

```
&gt; [1] 3
```

]

.panel[.panel-name[Soluci√≥n ej. 12]


```r
library(lubridate)
cumple &lt;- as_date("1989-09-10")
month(cumple)
```

```
&gt; [1] 9
```

```r
day(cumple)
```

```
&gt; [1] 10
```

```r
year(cumple)
```

```
&gt; [1] 1989
```

```r
wday(cumple, week_start = 1, label = TRUE)
```

```
&gt; [1] dom
&gt; Levels: lun &lt; mar &lt; mi√© &lt; jue &lt; vie &lt; s√°b &lt; dom
```

]


]


---

class: inverse center middle
name: clase-2

# CLASE 2: primeros datos. Primeros conceptos.

&amp;nbsp;

### [Operaciones con vectores](#operaciones-vectores)

### [Matrices](#matrices)

### [data.frame y tibble](#data.frame)

### [Ejercicios datasets](#ejercicios-tibble)

### [Intro estad√≠stica](#intro-estadistica)



---

name: operaciones-vectores


# .green[OPERACIONES] .orange[ARITM√âTICAS]


Los **.bg-purple_light[valores l√≥gicos]** `TRUE` y `FALSE` son **.bg-orange[guardados internamente]** como `0` y `1`, por lo que podemos usar operaciones aritm√©ticas con ellos.

--

Por ejemplo, si queremos **.bg-purple_light[averiguar el n√∫mero de elementos que cumplen una condici√≥n]** (por ejemplo, `&lt; 3`), los que lo hagan tendr√°n asignado un 1 y los que no un 0, por lo que basta con sumar dicho vector l√≥gico para obtener el n√∫mero de elementos que cumplen dicha condici√≥n (elementos que son `TRUE`).


```r
# sumamos el vector de TRUE/FALSE
x
```

```
&gt; [1] 15 20 31 27 15 29
```

```r
sum(x &lt; 3) 
```

```
&gt; [1] 0
```

---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

Tambi√©n podemos realizar **.bg-purple_light[operaciones estad√≠sticas]** con los vectores, como calcular su **suma**, su **media**, su **mediana**, entre otros.

--

Hagamos antes un **.bg-purple_light[breve repaso]** de algunos t√©rminos estad√≠sticos:

* **.bg-purple_light[Media]**: medida de **.bg-orange[centralizaci√≥n]** que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados (funci√≥n `mean()`). La m√°s conocida pero la menos robusta: dado un conjunto, si se introducen valores at√≠picos o outliers (valores muy grandes o muy peque√±os), la media se perturba con mucha facilidad.

`$$\overline{x} = \frac{1}{n} \sum_{i=1}^{n} x_i$$`


```r
x &lt;- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
mean(x)
```

```
&gt; [1] 169.8889
```

---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

Tambi√©n podemos realizar **.bg-purple_light[operaciones estad√≠sticas]** con los vectores, como calcular su **suma**, su **media**, su **mediana**, entre otros.


Hagamos antes un **.bg-purple_light[breve repaso]** de algunos t√©rminos estad√≠sticos:

* **.bg-purple_light[Mediana]**: medida de **.bg-orange[centralizaci√≥n]** (funci√≥n `median()`) que consiste en, tras **.bg-orange[ordenar]** los datos de menor a mayor, quedarnos con el valor que ocupa el medio (deja tantos n√∫meros por debajo como por encima). 


`$$Me_{x} = \displaystyle \arg \min_{x_i} \left\lbrace F_i &gt; 0.5 \right\rbrace, \quad F_i = \frac{\# \left\lbrace x_j \leq x_i \right\rbrace}{n}$$`


```r
x &lt;- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

```
&gt; [1] 170
```

---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

Tambi√©n podemos realizar **.bg-purple_light[operaciones estad√≠sticas]** con los vectores, como calcular su **suma**, su **media**, su **mediana**, entre otros.


Hagamos antes un **.bg-purple_light[breve repaso]** de algunos t√©rminos estad√≠sticos:

* **.bg-purple_light[Moda]**: medida de **.bg-orange[centralizaci√≥n]** que consiste en encontrar el **.bg-orange[valor o valores m√°s repetidos]**. Es la medida de centralizaci√≥n m√°s robusta. 

`$$Mo_{x} = \displaystyle \arg \max_{x_i}  f_i , \quad f_i = \frac{\# \left\lbrace x_j = x_i \right\rbrace}{n}$$`

&amp;nbsp;

**.bg-red_light[PROBLEMA]**: la moda no siempre es f√°cil de calcular (aunque existen paquetes para calcularla como `{modeest}`)


---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

Otra de las funciones m√°s √∫til es la **.bg-purple_light[suma de elementos]** de un vector con `sum()`


```r
# suma
*sum(x)
```

```
&gt; [1] 1529
```

```r
sum(x) / length(x) # media artesanal
```

```
&gt; [1] 169.8889
```

--

Otra funci√≥n √∫til es la **.bg-purple_light[suma acumulada]** de un vector haciendo uso de `cumsum()`


```r
# suma acumulada
*cumsum(c(1, 2, 4, 7, 7, 10))
```

```
&gt; [1]  1  3  7 14 21 31
```

---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

No solo de medidas de centralizaci√≥n vive la estad√≠stica: **.bg-purple_light[¬øc√≥mo calcular las medidas de dispersi√≥n?]**

* **.bg-purple_light[Varianza]**: definida como la media de desviaciones (respecto a la media) al cuadrado, tal que `\(s_{x}^{2} = \frac{1}{n} \sum_{i = 1}^{n} \left(x_i - \overline{x} \right)^2 = \overline{x^2} - \overline{x}^2\)`


```r
var(x)
```

```
&gt; [1] 159.8611
```

--

**.bg-green_light[IMPORTANTE]**: las funciones de `R` (y de cualquier calculadora) nos devuelve la **.bg-red_light[cuasivarianza]** (dividido entre `\(n-1\)`)
 

```r
# Varianza real
mean((x - mean(x))^2)
```

```
&gt; [1] 142.0988
```

---


# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

No solo de medidas de centralizaci√≥n vive la estad√≠stica: **.bg-purple_light[¬øc√≥mo calcular las medidas de dispersi√≥n?]**

* **.bg-purple_light[Desv. t√≠pica (standard deviation)]**: definida como la ra√≠z cuadrada de la varianza, tal que `\(s_{x} = \sqrt{s_{x}^{2} }\)`


```r
sd(x)
```

```
&gt; [1] 12.64362
```

--

**.bg-green_light[IMPORTANTE]**: las funciones de `R` (y de cualquier calculadora) nos devuelve la **.bg-red_light[cuasidesviaci√≥n t√≠pica]** (ra√≠z de la cuasivarianza, dividida entre `\(n-1\)`)
 

```r
# Desv. t√≠pica real
sqrt(mean((x - mean(x))^2))
```

```
&gt; [1] 11.92052
```


---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

Tambi√©n pueden sernos √∫tiles las **.bg-purple_light[medidas de posici√≥n/localizaci√≥n]**, como los **.bg-orange[percentiles]** (valores que nos dividen en partes iguales los datos).


```r
y &lt;- c(1, 2, 5, 5, 10, 10, 10, 13, 15, 20, 25)

# Percentiles por defecto: cuartiles
*quantile(y)
```

```
&gt;   0%  25%  50%  75% 100% 
&gt;    1    5   10   14   25
```

--

En `quantile()` hay un argumento por defecto `probs = c(0, 0.25, 0.5, 0.75, 1)` (**percentiles** a calcular) que puede ser cambiado, por ejemplo, para percentiles 20%-30%-70%-90%.


```r
quantile(y, probs = c(0.2, 0.3, 0.7, 0.9))
```

```
&gt; 20% 30% 70% 90% 
&gt;   5   5  13  20
```

---


# Valores .orange[√öNICOS]

Con la funci√≥n `unique()` podemos tambi√©n extraer los **.bg-purple_light[valores √∫nicos de una variable]**


```r
colores &lt;- c("azul", "azul", "verde", "amarillo",
             "azul", "rojo", "rojo", "azul", "rojo",
             "verde", "morado")
*unique(colores)
```

```
&gt; [1] "azul"     "verde"    "amarillo" "rojo"     "morado"
```

---



# .orange[FILTRAR] elementos


Otras veces no querremos seleccionar un elemento en concreto sino **.bg-purple_light[filtrar algunos elementos en concreto]** y no extraerlos, **.bg-orange[eliminarlos]**.

Deberemos repetir la misma operaci√≥n pero con el signo `-` delante: el operador `[-i]` **no selecciona** el elemento i-√©simo del vector sino que lo **elimina**


```r
y
```

```
&gt;  [1]  1  2  5  5 10 10 10 13 15 20 25
```

```r
y[-2] 
```

```
&gt;  [1]  1  5  5 10 10 10 13 15 20 25
```

---

# .orange[FILTRAR] elementos

Lo habitual es que dicho filtro lo hagamos **.bg-purple_light[en base a una condici√≥n l√≥gica]**. Supongamos que tenemos las edades de dos grupos de personas y que queremos quedarnos **solo con los mayores edad**: vamos a seleccionar los **elementos que cumplen una condici√≥n dada**.


```r
edades_1 &lt;- c(7, 20, 18, 3, 19, 9, 13, 3, 45)
edades_2 &lt;- c(17, 21, 58, 33, 15, 59, 13, 1, 45)
```

--


```r
*edades_1[edades_1 &gt;= 18]
```

```
&gt; [1] 20 18 19 45
```

```r
edades_2[edades_2 &gt;= 18]
```

```
&gt; [1] 21 58 33 59 45
```

Lo que hemos hecho ha sido pasar como **√≠ndices a seleccionar un vector l√≥gico** `TRUE/FALSE`: solo filtrar√° los lugares donde se guarde un `TRUE`.

---

# .orange[FILTRAR] elementos

Esto tambi√©n nos puede servir para **.bg-purple_light[limpiar de datos ausentes]**, combinando la funci√≥n `is.na()`: nos localiza el lugar que ocupan los ausentes, con el operador `!` (**negar el valor l√≥gico** que venga detr√°s).


```r
x &lt;- c(7, NA, 20, 3, 19, 21, 25, 80, NA)
x[is.na(x)] # solo valores ausentes
```

```
&gt; [1] NA NA
```

```r
x[!is.na(x)] # sin valores ausentes: ! es el s√≠mbolo de 
```

```
&gt; [1]  7 20  3 19 21 25 80
```

--

Tambi√©n podemos probar a **combinar condiciones l√≥gicas** para nuestra selecci√≥n.


```r
x[x &gt;= 18 &amp; x &lt;= 25] # los valores que cumplen ambas (&amp;): entre 18 y 25 a√±os
```

```
&gt; [1] NA 20 19 21 25 NA
```

---
 

# .green[SELECCIONAR] elementos: .orange[WHICH]

A veces no querremos el elemento en s√≠, sino el **.bg-purple_light[lugar que ocupa]**: ¬øqu√© valores de un vector cumplen una condici√≥n l√≥gica? Para obtener dicho √≠ndice usaremos la funci√≥n `which()`.


```r
x &lt;- c(7, NA, 20, 3, 19, 21, 25, 80, NA)
which(x &gt;= 18) # Obtenemos los lugares 
```

```
&gt; [1] 3 5 6 7 8
```

--

Esta funci√≥n es muy √∫til especialmente cuando queremos el valor que ocupa el **.bg-purple_light[m√°ximo/m√≠nimo]** de un vector, con las funciones `which.max()` y `which.min()`.


```r
max(x, na.rm = TRUE)
```

```
&gt; [1] 80
```

```r
which.max(x) # Lugar que ocupa el m√°ximo
```

```
&gt; [1] 8
```


---

# .green[SELECCIONAR] elementos: .orange[any/all]
 

Existen dos funciones muy √∫tiles para saber si **.bg-purple_light[todos o alguno de los elementos]** de un vector cumple una condici√≥n: `all()` y `any()` nos devolver√° un √∫nico valor l√≥gico.


```r
x &lt;- c(1, 2, 3, 4, 5, NA, 7)
*all(x &lt; 3)
```

```
&gt; [1] FALSE
```

```r
any(x &lt; 3)
```

```
&gt; [1] TRUE
```

```r
all(x &gt; 0)
```

```
&gt; [1] NA
```


---

# .orange[NOMBRAR] elementos

`R` nos permite dar **.bg-purple_light[significado l√©xico a nuestros valores]** (significan algo, no solo n√∫meros), pudiendo poner **nombres a los elementos** de un vector.


```r
x &lt;- c("edad" = 31, "tlf" = 613910687, "cp" = 33007)
x
```

```
&gt;      edad       tlf        cp 
&gt;        31 613910687     33007
```

--

Esto es una ventaja ya que nos permite su **.bg-purple_light[selecci√≥n usando dichos nombres]**


```r
x[c("edad", "cp")] # seleccionamos los elementos que tienen ese nombre asignado
```

```
&gt;  edad    cp 
&gt;    31 33007
```

--

Con la funci√≥n `names()` podemos, no solo **.bg-purple_light[consultar los nombres]** sino **cambiarlos**.

---

# .orange[ORDENAR] vectores


Una acci√≥n tambi√©n habitual al trabajar con datos es saber **.bg-purple_light[ordenarlos]**: de menor a mayor edad, datos m√°s recientes vs antiguos, etc. Para ello tenemos la funci√≥n `sort()`, que podemos usar directamente para ordenar de **menor a mayor**.


```r
edades &lt;- c(81, 7, 25, 41, 65, 20, 33, 23, 77)

# orden de joven a mayor
*sort(edades)
```

```
&gt; [1]  7 20 23 25 33 41 65 77 81
```

--

Por defecto, `sort()` ordena de menor a mayor. Con el argumento opcional `decreasing = TRUE` podemos **ordenar de mayor a menor**.


```r
# orden de mayor a joven
*sort(edades, decreasing = FALSE)
```

```
&gt; [1]  7 20 23 25 33 41 65 77 81
```

---

# .orange[ORDENAR] vectores

Otra forma de ordenar es obtener los **√≠ndices de los elementos ordenados**, y luego usar dichos √≠ndices para **reorganizar los elementos**, con la funci√≥n `order()`.


```r
*order(x)
```

```
&gt; [1] 1 3 2
```

```r
x[order(x)]
```

```
&gt;      edad        cp       tlf 
&gt;        31     33007 613910687
```

---


# .orange[MEDIR] tiempos de ejecuci√≥n

Hay un paquete muy √∫til para **.bg-purple_light[medir tiempos de distintas √≥rdenes]** que hacen lo mismo (el paquete `{microbenchmark}`). Vamos a comparar `order()` y `sort()`.


```r
library(microbenchmark) # instalar primera vez
x &lt;- rnorm(1e3) # 1000 elementos aleatorias
*microbenchmark(sort(x), x[order(x)], times = 1e3)
```

```
&gt; Unit: microseconds
&gt;         expr    min      lq     mean  median      uq     max neval cld
&gt;      sort(x) 42.782 47.3565 58.60325 52.4650 59.5275 252.562  1000   b
&gt;  x[order(x)] 29.630 33.6230 40.67155 37.0395 41.1895 162.381  1000  a
```


---

name: ejercicios-vectores

# Ejercicios de vectores


.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: define el vector `x` como la concatenaci√≥n de los 5 primeros n√∫meros impares, y calcula su suma.
 
* üìù **Ejercicio 2**: obt√©n los elementos de `x` mayores que 4. Determina los lugares que ocupan. Calcula el n√∫mero de elementos de `x` mayores que 4.

* üìù **Ejercicio 3**: calcula el vector `1/x` y obt√©n la versi√≥n ordenada (de menor a mayor).

* üìù **Ejercicio 4**: define un vector con tu estatura y peso, y nombra cada elemento.

 
]

.panel[.panel-name[Soluci√≥n ej. 1]


```r
x &lt;- c(1, 3, 5, 7, 9)

# otra forma
x &lt;- seq(1, 9, by = 2)

# Suma
sum(x)
```

```
&gt; [1] 25
```
]

.panel[.panel-name[Soluci√≥n ej. 2]


```r
# Elementos mayores que 4
x[x &gt; 4]
```

```
&gt; [1] 5 7 9
```

```r
# Lugares que ocupan
which(x &gt; 4)
```

```
&gt; [1] 3 4 5
```

```r
# Cantidad de elementos mayores que 4
sum(x &gt; 4)
```

```
&gt; [1] 3
```
]

.panel[.panel-name[Soluci√≥n ej. 3]


```r
y &lt;- 1/x

# una forma
sort(y)
```

```
&gt; [1] 0.1111111 0.1428571 0.2000000 0.3333333 1.0000000
```

```r
# otra forma
y[order(y)]
```

```
&gt; [1] 0.1111111 0.1428571 0.2000000 0.3333333 1.0000000
```

]


.panel[.panel-name[Soluci√≥n ej. 4]


```r
x &lt;- c("estatura" = 180, "peso" = 80)
x
```

```
&gt; estatura     peso 
&gt;      180       80
```

]

]

---

# Ejercicios de vectores

.panelset[
.panel[.panel-name[Ejercicios]

 
* üìù **Ejercicio 5**:  encuentra del vector `x` del ejercicio 1 los elementos mayores (estrictos) que 1 y menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.
 
 
* üìù **Ejercicio 6**: define el vector `x &lt;- c(-1, 0, -2, 5, 3, 7)` y obt√©n los elementos que ocupan una posici√≥n impar.
 
 
* üìù **Ejercicio 7**: define el vector de los primeros n√∫meros impares (hasta el 21) y extrae los elementos que ocupan los lugares `1, 4, 5, 8`. Elimina del vector el segundo elemento

 
* üìù **Ejercicio 8**: define un vector de 8 valores y determina la media, la mediana y los cuartiles.

]

.panel[.panel-name[Soluci√≥n ej. 5]


```r
x &lt;- c(1, 3, 5, 7, 9)
# valores &gt;1 y &lt;7
x[x &gt; 1 &amp; x &lt; 7]
```

```
&gt; [1] 3 5
```

```r
# ¬øTodos positivos?
all(x &gt; 0)
```

```
&gt; [1] TRUE
```

```r
sum(all(x &lt;= 0)) # debe dar 0
```

```
&gt; [1] 0
```

]

 
 
.panel[.panel-name[Soluci√≥n ej. 6]


```r
x &lt;- c(-1, 0, -2, 5, 3, 7)
x[seq(1, length(x), by = 2)]
```

```
&gt; [1] -1 -2  3
```

]

.panel[.panel-name[Soluci√≥n ej. 7]


```r
x &lt;- seq(1, 21, by = 2)

# posiciones pedidas
x[c(1, 4, 5, 8)]
```

```
&gt; [1]  1  7  9 15
```

```r
# sin las posiciones pedidas
x[-c(1, 4, 5, 8)]
```

```
&gt; [1]  3  5 11 13 17 19 21
```

```r
# eliminamos del vector el segundo elemento
x[-2]
```

```
&gt;  [1]  1  5  7  9 11 13 15 17 19 21
```
]

.panel[.panel-name[Soluci√≥n ej. 8]


```r
x &lt;- c(0, -2, 3, 7, -5, 9, 3, 1)
mean(x)
```

```
&gt; [1] 2
```

```r
median(x)
```

```
&gt; [1] 2
```

```r
quantile(x)
```

```
&gt;   0%  25%  50%  75% 100% 
&gt; -5.0 -0.5  2.0  4.0  9.0
```
]


]

---

name: matrices

# De la .orange[celda] a la .green[tabla]
 

&lt;img src="./img/celdas.jpg" width="55%" style="display: block; margin: auto;" /&gt;

* **.bg-purple_light[Celda]**: un dato **.bg-orange[individual]** de un tipo concreto.

* **.bg-purple_light[Variable]**: una **.bg-orange[concatenaci√≥n de valores]** del mismo tipo (**vectores**).


&amp;nbsp;

--

**.bg-purple_light[Matriz]**: **.bg-orange[concatenaci√≥n de variables]** del **.bg-yellow[mismo tipo]** y longitud.

---

# .orange[MATRICES]: concatenando variables


Cuando analizamos datos solemos tener varias **variables distintas** de cada individuo: necesitamos una ¬´tabla¬ª con **.bg-purple_light[distintas variables]** (de **.bg-orange[IGUAL longitud]**).

Las **.bg-purple_light[matrices]** son una concatenaci√≥n de variables, del **.bg-orange[mismo tipo e igual longitud]**, dispuestas en **p columnas** (datos p-dimensionales) 

--

&amp;nbsp;

Vamos a empezar definiendo una **matriz sencilla**: imagina que tenemos las estaturas y pesos de 5 personas. ¬øC√≥mo juntar las dos variables creando nuestro primer conjunto de datos? F√≠jate que son del mismo tipo e igual longitud.


```r
estaturas &lt;- c(150, 160, 170, 180, 190)
pesos &lt;- c(60, 70, 80, 90, 100)
```

---

# .orange[MATRICES]: concatenando variables


```r
estaturas &lt;- c(150, 160, 170, 180, 190)
pesos &lt;- c(60, 70, 80, 90, 100)
```

¬øC√≥mo juntar las dos variables creando nuestro primer conjunto de datos? Vamos a **.bg-purple_light[crear una matriz]**, un conjunto de n√∫meros organizado en 2 columnas (una por variable) y 5 filas o registros (una por persona). Para ello usaremos la funci√≥n `cbind()`, que nos **concatena vectores de igual longitud en columnas**.

 

```r
# Construimos la matriz por columnas
*datos_matriz &lt;- cbind(estaturas, pesos)
datos_matriz
```

```
&gt;      estaturas pesos
&gt; [1,]       150    60
&gt; [2,]       160    70
&gt; [3,]       170    80
&gt; [4,]       180    90
&gt; [5,]       190   100
```

---

# .orange[MATRICES]: concatenando variables


.pull-left[

&lt;img src="./img/datos_matriz_1.jpg" width="99%" style="display: block; margin: auto auto auto 0;" /&gt;


]


.pull-right[


```r
View(datos_matriz)
```

Podemos **.bg-purple_light[visualizar la matriz]** en un formato ¬´excelizado¬ª con la funci√≥n `View()`.


Tambi√©n podemos **.bg-purple_light[construir la matriz por filas]** con la funci√≥n `rbind()` (aunque lo recomendable es tener cada variable en  columna y cada individuo en fila).


```r
# Construimos la matriz por filas
rbind(estaturas, pesos) 
```

```
&gt;           [,1] [,2] [,3] [,4] [,5]
&gt; estaturas  150  160  170  180  190
&gt; pesos       60   70   80   90  100
```

]

---
 
 
# .orange[MATRICES]: concatenando variables

Podemos comprobar las **.bg-purple_light[dimensiones de una matriz]** con `dim()`, `nrow()` y `ncol()`: nuestros datos est√°n **.bg-orange[tabulados]**:


```r
dim(datos_matriz) # vector
```

```
&gt; [1] 5 2
```

```r
nrow(datos_matriz)
```

```
&gt; [1] 5
```

```r
ncol(datos_matriz)
```

```
&gt; [1] 2
```

---

# .orange[MATRICES]: concatenando variables


Veamos un ejemplo con **tres variables/columnas**: edades, tel√©fonos y c√≥digos postales.


```r
edades &lt;- c(14, 24, 56, 31, 20, 87, 73) 
tlf &lt;- c(NA, 683839390, 621539732, 618211286, NA, 914727164, NA)
cp &lt;- c(33007, 28019, 37005, 18003, 33091, 25073, 17140)

# Construimos la matriz por columnas
*datos_matriz &lt;- cbind(edades, tlf, cp)
datos_matriz
```

```
&gt;      edades       tlf    cp
&gt; [1,]     14        NA 33007
&gt; [2,]     24 683839390 28019
&gt; [3,]     56 621539732 37005
&gt; [4,]     31 618211286 18003
&gt; [5,]     20        NA 33091
&gt; [6,]     87 914727164 25073
&gt; [7,]     73        NA 17140
```


---

# .orange[MATRICES]: a√±adir registros/variables

Las funciones `cbind()` y `rbind()` no solo nos permiten crear matrices desde cero sino tambi√©n **.bg-purple_light[a√±adir filas o columnas]** a matrices existentes.


```r
# A√±adimos una fila
rbind(datos_matriz, c(27, 620125780, 28051))
```

```
&gt;      edades       tlf    cp
&gt; [1,]     14        NA 33007
&gt; [2,]     24 683839390 28019
&gt; [3,]     56 621539732 37005
&gt; [4,]     31 618211286 18003
&gt; [5,]     20        NA 33091
&gt; [6,]     87 914727164 25073
&gt; [7,]     73        NA 17140
&gt; [8,]     27 620125780 28051
```

---

# .orange[MATRICES]: valores repetidos

Podemos definir una **.bg-purple_light[matriz de n¬∫ repetidos]** con `matrix(..., nrow = ..., ncol = ...)`


```r
# matriz de ceros de 3 filas, 2 columnas,
*matrix(0, nrow = 3, ncol = 2)
```

```
&gt;      [,1] [,2]
&gt; [1,]    0    0
&gt; [2,]    0    0
&gt; [3,]    0    0
```

--

Tambi√©n podemos definir una **.bg-purple_light[matriz a partir de un vector num√©rico]**, reorganizando los valores en forma de matriz (sabiendo que los elementos se van colocando por columnas).


```r
matrix(1:15, ncol = 5) # Matriz con el vector 1:15
```

```
&gt;      [,1] [,2] [,3] [,4] [,5]
&gt; [1,]    1    4    7   10   13
&gt; [2,]    2    5    8   11   14
&gt; [3,]    3    6    9   12   15
```

---

# .green[OPERACIONES] con .orange[MATRICES]

Con las matrices sucede como con los vectores: cuando aplicamos una **.bg-purple_light[operaci√≥n aritm√©tica]** lo hacemos **.bg-orange[elemento a elemento]**


```r
z &lt;- matrix(1:15, ncol = 5) 
z / 5
```

```
&gt;      [,1] [,2] [,3] [,4] [,5]
&gt; [1,]  0.2  0.8  1.4  2.0  2.6
&gt; [2,]  0.4  1.0  1.6  2.2  2.8
&gt; [3,]  0.6  1.2  1.8  2.4  3.0
```

```r
z + 3
```

```
&gt;      [,1] [,2] [,3] [,4] [,5]
&gt; [1,]    4    7   10   13   16
&gt; [2,]    5    8   11   14   17
&gt; [3,]    6    9   12   15   18
```

---

# .orange[MATRICES] de .green[CARACTERES]

Tambi√©n podemos crear matrices de otros tipos de datos, siempre y cuando las **.bg-purple_light[columnas sean del mismo tipo e igual longitud]**, por ejemplo una **.bg-orange[matriz de caracteres]**.


```r
# matriz de caracteres
nombres &lt;- c("Javier", "Carlos", "Mar√≠a")
apellidos &lt;- c("√Ålvarez", "Garc√≠a", "P√©rez")
cbind(nombres, apellidos)
```

```
&gt;      nombres  apellidos
&gt; [1,] "Javier" "√Ålvarez"
&gt; [2,] "Carlos" "Garc√≠a" 
&gt; [3,] "Mar√≠a"  "P√©rez"
```

--


```r
# matriz de valores l√≥gicos
cbind(c(TRUE, FALSE), c(FALSE, TRUE))
```

```
&gt;       [,1]  [,2]
&gt; [1,]  TRUE FALSE
&gt; [2,] FALSE  TRUE
```

---

# .orange[SELECCIONAR] elementos

Si recuerdas para los vectores, us√°bamos el operador `[i]` para **acceder al elemento i-√©simo**. En el caso de las matrices la l√≥gica ser√° la misma:

* para **.bg-purple_light[acceder a la fila i-√©sima]** se usa el operador `[i, ]` (dejando libre la columna).


```r
datos_matriz[1, ] # fila 1
```

```
&gt; edades    tlf     cp 
&gt;     14     NA  33007
```

---

# .orange[SELECCIONAR] elementos

Si recuerdas para los vectores, us√°bamos el operador `[i]` para **acceder al elemento i-√©simo**. En el caso de las matrices la l√≥gica ser√° la misma:

* para **.bg-purple_light[acceder a la columna j-√©sima]** se usa el operador `[, j]` (dejando libre la fila).


```r
datos_matriz[, 3] # columna 3
```

```
&gt; [1] 33007 28019 37005 18003 33091 25073 17140
```


---

# .orange[SELECCIONAR] elementos

Si recuerdas para los vectores, us√°bamos el operador `[i]` para **acceder al elemento i-√©simo**. En el caso de las matrices la l√≥gica ser√° la misma:

* para **.bg-purple_light[acceder conjuntamente al elemento (i, j)]** se usa el operador `[i, j]`.


```r
datos_matriz[1, 3] # elemento (1, 3)
```

```
&gt;    cp 
&gt; 33007
```

```r
datos_matriz[2, 2] # elemento (1, 3)
```

```
&gt;       tlf 
&gt; 683839390
```


---

# .orange[NOMBRAR] variables

Una matriz por defecto adopta los nombres de los vectores como los nombres de columnas, pero podemos 
**.bg-purple_light[personalizar los nombres de las variables]**


```r
estaturas &lt;- c(150, 160, 170)
pesos &lt;- c(60, 70, 80)
cbind("altura" = estaturas, "pesaje" = pesos)
```

```
&gt;      altura pesaje
&gt; [1,]    150     60
&gt; [2,]    160     70
&gt; [3,]    170     80
```


--

Si las columnas tienen nombres podemos hacer uso de ellos para **acceder a las columnas**


```r
datos_matriz[, c("edades", "tlf")]
```

```
&gt;      edades       tlf
&gt; [1,]     14        NA
&gt; [2,]     24 683839390
&gt; [3,]     56 621539732
&gt; [4,]     31 618211286
&gt; [5,]     20        NA
&gt; [6,]     87 914727164
&gt; [7,]     73        NA
```

---

# .orange[NOMBRAR] variables

Tambi√©n podemos **.bg-purple_light[asignar nombres]** a las filas de una matriz con `row.names()` y acceder a filas y columnas por nombres.


```r
row.names(datos_matriz) &lt;- c("Javi", "Laura", "Patricia", "Carlos", "Juan", "Luis", "Carla")
datos_matriz
```

```
&gt;          edades       tlf    cp
&gt; Javi         14        NA 33007
&gt; Laura        24 683839390 28019
&gt; Patricia     56 621539732 37005
&gt; Carlos       31 618211286 18003
&gt; Juan         20        NA 33091
&gt; Luis         87 914727164 25073
&gt; Carla        73        NA 17140
```

```r
datos_matriz["Javi", "edades"]
```

```
&gt; [1] 14
```

---

# .orange[OPERACIONES] por filas/columnas

Normalmente, para explicar las **operaciones con matrices** en un lenguaje de programaci√≥n al uso, necesitar√≠amos hablar de una **herramienta llamada bucles**. Lo mencionaremos m√°s adelante pero no los vamos a necesitar de momento (cu√°ntos menos los usemos en `R`, mejor)

--

Imagina que tuvi√©semos nuestra matriz de estaturas y pesos.


```r
datos_matriz &lt;- cbind(estaturas, pesos)
datos_matriz
```

```
&gt;      estaturas pesos
&gt; [1,]       150    60
&gt; [2,]       160    70
&gt; [3,]       170    80
```

--

¬øC√≥mo podemos **.bg-purple_light[aplicar una operaci√≥n para cada una de las filas o columnas]** de una matriz?

---

# .orange[OPERACIONES] por filas/columnas

Imagina que queremos obtener la **.bg-purple_light[media de cada columna]**. Lo haremos con la funci√≥n `apply()`, y le indicaremos como argumentos la matriz, el **.bg-orange[sentido de la operaci√≥n]** (`MARGIN = 1` por filas, `MARGIN = 2` por columnas) y la **funci√≥n a aplicar**


```r
# Media (mean) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "mean")
```

```
&gt; estaturas     pesos 
&gt;       160        70
```

--

Si la funci√≥n **requiere de argumentos extras** se lo podemos indicar al final.


```r
estaturas_bis &lt;- c(150, NA, 170, 180, 190)
datos_matriz_bis &lt;- cbind(estaturas_bis, pesos) 
apply(datos_matriz_bis, MARGIN = 2, FUN = "mean")
```

```
&gt; estaturas_bis         pesos 
&gt;            NA            68
```

---

name: ejercicios-matrices

# Ejercicios de matrices

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: modifica el c√≥digo para definir una matriz `x` de ceros de 3 filas y 7 columnas.
 

```r
# Matriz
x &lt;- matrix(0, nrow = 2, ncol = 3)
x
```

* üìù **Ejercicio 2**: a la matriz anterior, suma un 1 a cada n√∫mero de la matriz y divide el resultado entre 5.
 

* üìù **Ejercicio 3**: tras definir la matriz `x` calcula su transpuesta y obt√©n sus dimensiones
 

]

.panel[.panel-name[Soluci√≥n ej. 1]


```r
x &lt;- matrix(0, nrow = 3, ncol = 7)
x
```

```
&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
&gt; [1,]    0    0    0    0    0    0    0
&gt; [2,]    0    0    0    0    0    0    0
&gt; [3,]    0    0    0    0    0    0    0
```

]

.panel[.panel-name[Soluci√≥n ej. 2]


```r
# sumamos 1
x + 1
```

```
&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
&gt; [1,]    1    1    1    1    1    1    1
&gt; [2,]    1    1    1    1    1    1    1
&gt; [3,]    1    1    1    1    1    1    1
```

```r
# dividimos entre 5
(x + 1) / 5
```

```
&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
&gt; [1,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2
&gt; [2,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2
&gt; [3,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2
```

]

.panel[.panel-name[Soluci√≥n ej. 3]


```r
# dimensiones originales
dim(x)
```

```
&gt; [1] 3 7
```

```r
# transpuesta
y &lt;- t(x)
y
```

```
&gt;      [,1] [,2] [,3]
&gt; [1,]    0    0    0
&gt; [2,]    0    0    0
&gt; [3,]    0    0    0
&gt; [4,]    0    0    0
&gt; [5,]    0    0    0
&gt; [6,]    0    0    0
&gt; [7,]    0    0    0
```

```r
dim(y)
```

```
&gt; [1] 7 3
```

]


]

---

# Ejercicios de matrices

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 4**: define la matriz `x &lt;- matrix(1:12, nrow = 4)`. Obt√©n la primera fila, la tercera columna, y el elemento (4, 1).

* üìù **Ejercicio 5**: en la matriz anterior, pon a cada fila `i` el nombre `fila_i` (fila_1, fila_2, fila_3, fila_4).

* üìù **Ejercicio 6**: con la matriz anterior definida como `matrix(1:12, nrow = 4)`, calcula la media de todos los elementos, la media de cada fila y la media de cada columna. Calcula la suma de de cada fila y de cada columna

]

.panel[.panel-name[Soluci√≥n ej. 4]


```r
x &lt;- matrix(1:12, nrow = 4)

# primera fila
x[1, ]
```

```
&gt; [1] 1 5 9
```

```r
# tercera columna
x[, 3]
```

```
&gt; [1]  9 10 11 12
```

```r
# (4, 1)
x[4, 1]
```

```
&gt; [1] 4
```

]

.panel[.panel-name[Soluci√≥n ej. 5]


```r
x
```

```
&gt;      [,1] [,2] [,3]
&gt; [1,]    1    5    9
&gt; [2,]    2    6   10
&gt; [3,]    3    7   11
&gt; [4,]    4    8   12
```

```r
row.names(x) &lt;- glue("fila_{1:4}")
x
```

```
&gt;        [,1] [,2] [,3]
&gt; fila_1    1    5    9
&gt; fila_2    2    6   10
&gt; fila_3    3    7   11
&gt; fila_4    4    8   12
```

]

.panel[.panel-name[Soluci√≥n ej. 6]


```r
# media por filas
apply(x, MARGIN = 1, FUN = mean)
```

```
&gt; fila_1 fila_2 fila_3 fila_4 
&gt;      5      6      7      8
```

```r
# media por columnas
apply(x, MARGIN = 2, FUN = mean)
```

```
&gt; [1]  2.5  6.5 10.5
```

```r
# suma por filas
apply(x, MARGIN = 1, FUN = sum)
```

```
&gt; fila_1 fila_2 fila_3 fila_4 
&gt;     15     18     21     24
```

```r
# suma por columnas
apply(x, MARGIN = 2, FUN = sum)
```

```
&gt; [1] 10 26 42
```

]

]



---

# Ejercicios extras (matrices y vectores)

.panelset[
.panel[.panel-name[Ejercicios extra]

* üìù **Ejercicio 1**: define un vector `y` que contenga los 5 primeros pares, y otro `x` con los 5 primeros impares. Haz la suma de `x` (ejercicio 1 anterior) e `y`.
 
* üìù **Ejercicio 2**: encuentra del vector `x &lt;- c(-1, 0, -2, 5, 3, 7)` el lugar (el √≠ndice) que ocupa su m√≠nimo y su m√°ximo.
 

* üìù **Ejercicio 3**: define el vector `c(-1, 0, 4, 5, -2)`, calcula la ra√≠z cuadrada del vector y determina que lugares son de tipo `NaN`.

* üìù **Ejercicio 4**:  el siguiente c√≥digo define una matriz de dimensiones `4 x 3` y calcula la suma por columnas. Modifica el c√≥digo para que realice la suma por filas.
 

```r
matriz &lt;- matrix(1:12, nrow = 4)
apply(matriz, MARGIN = 2, FUN = "sum")
```

]

.panel[.panel-name[Soluci√≥n ej. 1]


```r
y &lt;- c(0, 2, 4, 6, 8)
x &lt;- y + 1 # forma m√°s r√°pida de (1, 3, 5, 7, 9)
x + y
```

```
&gt; [1]  1  5  9 13 17
```

]

.panel[.panel-name[Soluci√≥n ej. 2]


```r
x &lt;- c(-1, 0, -2, 5, 3, 7)
which.max(x)
```

```
&gt; [1] 6
```

```r
which.min(y)
```

```
&gt; [1] 1
```

]

.panel[.panel-name[Soluci√≥n ej. 3]


```r
x &lt;- c(-1, 0, 4, 5, -2)
sqrt(x)
```

```
&gt; [1]      NaN 0.000000 2.000000 2.236068      NaN
```

```r
is.nan(sqrt(x))
```

```
&gt; [1]  TRUE FALSE FALSE FALSE  TRUE
```

]

.panel[.panel-name[Soluci√≥n ej. 4]


```r
matriz &lt;- matrix(1:12, nrow = 4)
apply(matriz, MARGIN = 1, FUN = "sum")
```

```
&gt; [1] 15 18 21 24
```

]

]

---

name: data.frame

# .orange[TABLAS]: variables .green[data.frame]
 


&lt;img src="./img/celdas.jpg" width="45%" style="display: block; margin: auto;" /&gt;

* **.bg-purple_light[Celda]**: un dato **.bg-orange[individual]** de un tipo concreto.

* **.bg-purple_light[Variable]**: una **.bg-orange[concatenaci√≥n de valores]** del mismo tipo (**vectores**).

* **.bg-purple_light[Matriz]**: **.bg-orange[concatenaci√≥n de variables]** del **.bg-yellow[mismo tipo]** y longitud.

&amp;nbsp;

--

* **.bg-purple_light[data.frame (tabla)]**: **.bg-orange[concatenaci√≥n de variables]** de **.bg-yellow[DISTINTO tipo]** e igual longitud.


---

# .red[PROBLEMAS] de las .green[MATRICES]


Retomemos nuestra matriz de edades, tel√©fonos y c√≥digos postales.


```r
edades &lt;- c(14, 24, 56, 31, 20, 87) 
tlf &lt;- c(NA, 683839390, 621539732, 618211286, NA, 914727164)
cp &lt;- c(33007, 28019, 37005, 18003, 33091, 25073)

# Construimos la matriz por columnas
*datos_matriz &lt;- cbind(edades, tlf, cp)
datos_matriz
```

```
&gt;      edades       tlf    cp
&gt; [1,]     14        NA 33007
&gt; [2,]     24 683839390 28019
&gt; [3,]     56 621539732 37005
&gt; [4,]     31 618211286 18003
&gt; [5,]     20        NA 33091
&gt; [6,]     87 914727164 25073
```

--

¬øQu√© suceder√° si ahora **.bg-purple_light[a√±adimos una columna con los nombres]** (tipo caracter) de cada persona?

---


# .red[PROBLEMAS] de las .green[MATRICES]


```r
nombres &lt;- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")
datos_matriz_nueva &lt;- cbind(nombres, datos_matriz)
```


```
&gt;      nombres  edades tlf         cp     
&gt; [1,] "Sonia"  "14"   NA          "33007"
&gt; [2,] "Carla"  "24"   "683839390" "28019"
&gt; [3,] "Pepito" "56"   "621539732" "37005"
&gt; [4,] "Carlos" "31"   "618211286" "18003"
&gt; [5,] "Lara"   "20"   NA          "33091"
&gt; [6,] "Sandra" "87"   "914727164" "25073"
```

**.bg-red_light[¬øHas visto lo que ha sucedido?]**

--

Como una **.bg-purple_light[matriz solo puedes tener un tipo de dato]**, al a√±adir una variable de tipo texto, `R` se ha visto obligado a **convertir los n√∫meros en texto** (poni√©ndole **comillas**). 


```r
datos_matriz_nueva[, "edades"] + 1
```

```
&gt; Error in datos_matriz_nueva[, "edades"] + 1: argumento no-num√©rico para operador binario
```

---

# .red[PROBLEMAS] de las .green[MATRICES]

Las **.bg-purple_light[matrices]** nos permiten almacenar distintas variables SIEMPRE Y CUANDO tengan

* **.bg-orange[Misma longitud]**.
* **.bg-orange[Mismo tipo]** de dato (sin mezclar).

Esto es bastante limitante en la vida real nuestros datos tendr√°n variables de todo tipo: supongamos que queremos **guardar de 7 personas las siguientes variables**.



```r
# Nombres
nombres &lt;- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")

# Apellidos
apellidos &lt;- c(NA, "Gonz√°lez", "Fern√°ndez", "Mart√≠nez", "Li√©bana", "Garc√≠a", "Ortiz")

# C√≥digo postal
cp &lt;- c(28019, 28001, 34005, 18410, 33007, 34500, 28017)

# Edades
edades &lt;- c(45, 67, NA, 31, 27, 19, 50)
```

---


# .red[PROBLEMAS] de las .green[MATRICES]

Las **.bg-purple_light[matrices]** nos permiten almacenar distintas variables SIEMPRE Y CUANDO tengan

* **.bg-orange[Misma longitud]**.
* **.bg-orange[Mismo tipo]** de dato (sin mezclar).

Esto es bastante limitante en la vida real nuestros datos tendr√°n variables de todo tipo: supongamos que queremos **guardar de 7 personas las siguientes variables**.



```r
# Tel√©fono
tlf &lt;- c(618910564, 914718475, 934567891, 620176565, NA, NA, 688921344)

# Estado civil (no lo sabemos de una persona)
casado &lt;- c(TRUE, FALSE, FALSE, NA, TRUE, FALSE, FALSE)

# Fecha de creaci√≥n (fecha en el que esa persona entra en el sistema)
# lo convertimos a tipo fecha
fecha_creacion &lt;-
  as_date(c("2021-03-04", "2020-10-12", "1990-04-05",
            "2019-09-10", "2017-03-21", "2020-07-07",
            "2000-01-28"))
```


---

# .red[PROBLEMAS] de las .green[MATRICES]

Aahora tenemos un **popurr√≠ de variables**, de la misma longitud pero de tipos distintos:

* `(edades, tlf, cp)` son variables **num√©ricas**.
* `(nombres, apellidos)` son variables de **texto**.
* `casado` es una variable **l√≥gica**.
* `fecha_creacion` de tipo **fecha**.

¬øQu√© suceder√≠a si **.bg-purple_light[intentamos mezclar todo en una matriz]**?

--


```r
# Juntamos por columnas
datos_matriz &lt;-
  cbind(nombres, apellidos, edades, tlf, cp, casado, fecha_creacion)
datos_matriz
```

```
&gt;      nombres  apellidos   edades tlf         cp      casado  fecha_creacion
&gt; [1,] "Sonia"  NA          "45"   "618910564" "28019" "TRUE"  "18690"       
&gt; [2,] "Carla"  "Gonz√°lez"  "67"   "914718475" "28001" "FALSE" "18547"       
&gt; [3,] "Pepito" "Fern√°ndez" NA     "934567891" "34005" "FALSE" "7399"        
&gt; [4,] "Carlos" "Mart√≠nez"  "31"   "620176565" "18410" NA      "18149"       
&gt; [5,] "Lara"   "Li√©bana"   "27"   NA          "33007" "TRUE"  "17246"       
&gt; [6,] "Sandra" "Garc√≠a"    "19"   NA          "34500" "FALSE" "18450"       
&gt; [7,] "Javi"   "Ortiz"     "50"   "688921344" "28017" "FALSE" "10984"
```

---

# .red[PROBLEMAS] de las .green[MATRICES]


```r
datos_matriz
```

```
&gt;      nombres  apellidos   edades tlf         cp      casado  fecha_creacion
&gt; [1,] "Sonia"  NA          "45"   "618910564" "28019" "TRUE"  "18690"       
&gt; [2,] "Carla"  "Gonz√°lez"  "67"   "914718475" "28001" "FALSE" "18547"       
&gt; [3,] "Pepito" "Fern√°ndez" NA     "934567891" "34005" "FALSE" "7399"        
&gt; [4,] "Carlos" "Mart√≠nez"  "31"   "620176565" "18410" NA      "18149"       
&gt; [5,] "Lara"   "Li√©bana"   "27"   NA          "33007" "TRUE"  "17246"       
&gt; [6,] "Sandra" "Garc√≠a"    "19"   NA          "34500" "FALSE" "18450"       
&gt; [7,] "Javi"   "Ortiz"     "50"   "688921344" "28017" "FALSE" "10984"
```

Dado que en una **.bg-purple_light[matriz solo podemos almacenar datos del mismo tipo]**, los n√∫meros los convierte a texto, las variables l√≥gicas las convierte a texto (`TRUE` era un valor l√≥gico, `"TRUE"` es un texto, sin significado de verdadero/falso) y las fechas las ha convertido a texto.


```r
datos_matriz[1, "fecha_creacion"] - datos_matriz[2, "fecha_creacion"]
```

```
&gt; Error in datos_matriz[1, "fecha_creacion"] - datos_matriz[2, "fecha_creacion"]: argumento no-num√©rico para operador binario
```

---

# .orange[TABLAS]: variables .green[data.frame]

Vamos a aprender c√≥mo juntar variables de distinto tipo, sin **modificar la integridad** del dato. El formato de **.bg-purple_light[tabla de datos]** que vamos a empezar a usar se llama `data.frame`: una **.bg-purple_light[colecci√≥n de variables de igual longitud]** pero cada una puede ser de un **.bg-orange[tipo distinto]**.

--

Para crearlo basta con usar la funci√≥n `data.frame()`, pas√°ndole como argumentos (separados por comas) las variables que queremos reunir.


```r
# Creamos nuestro primer data.frame
tabla &lt;- data.frame(nombres, apellidos, edades, tlf,
*                   cp, casado, fecha_creacion)
tabla
```

```
&gt;   nombres apellidos edades       tlf    cp casado fecha_creacion
&gt; 1   Sonia      &lt;NA&gt;     45 618910564 28019   TRUE     2021-03-04
&gt; 2   Carla  Gonz√°lez     67 914718475 28001  FALSE     2020-10-12
&gt; 3  Pepito Fern√°ndez     NA 934567891 34005  FALSE     1990-04-05
&gt; 4  Carlos  Mart√≠nez     31 620176565 18410     NA     2019-09-10
&gt; 5    Lara   Li√©bana     27        NA 33007   TRUE     2017-03-21
&gt; 6  Sandra    Garc√≠a     19        NA 34500  FALSE     2020-07-07
&gt; 7    Javi     Ortiz     50 688921344 28017  FALSE     2000-01-28
```

---

# .orange[TABLAS]: variables .green[data.frame]


```r
tabla
```

```
&gt;   nombres apellidos edades       tlf    cp casado fecha_creacion
&gt; 1   Sonia      &lt;NA&gt;     45 618910564 28019   TRUE     2021-03-04
&gt; 2   Carla  Gonz√°lez     67 914718475 28001  FALSE     2020-10-12
&gt; 3  Pepito Fern√°ndez     NA 934567891 34005  FALSE     1990-04-05
&gt; 4  Carlos  Mart√≠nez     31 620176565 18410     NA     2019-09-10
&gt; 5    Lara   Li√©bana     27        NA 33007   TRUE     2017-03-21
&gt; 6  Sandra    Garc√≠a     19        NA 34500  FALSE     2020-07-07
&gt; 7    Javi     Ortiz     50 688921344 28017  FALSE     2000-01-28
```

```r
class(tabla)
```

```
&gt; [1] "data.frame"
```

```r
dim(tabla)
```

```
&gt; [1] 7 7
```

---

# .orange[TABLAS]: variables .green[data.frame]

Al igual que con matrices, podemos **.bg-purple_light[crear un data.frame]** indicando **nombre de columnas**


```r
tabla &lt;- data.frame("nombre" = nombres, "apellido" = apellidos, "edad" = edades, "tel√©fono" = tlf, 
                    "cp" = cp, "casado" = casado, "fecha_registro" = fecha_creacion)
tabla
```

```
&gt;   nombre  apellido edad  tel√©fono    cp casado fecha_registro
&gt; 1  Sonia      &lt;NA&gt;   45 618910564 28019   TRUE     2021-03-04
&gt; 2  Carla  Gonz√°lez   67 914718475 28001  FALSE     2020-10-12
&gt; 3 Pepito Fern√°ndez   NA 934567891 34005  FALSE     1990-04-05
&gt; 4 Carlos  Mart√≠nez   31 620176565 18410     NA     2019-09-10
&gt; 5   Lara   Li√©bana   27        NA 33007   TRUE     2017-03-21
&gt; 6 Sandra    Garc√≠a   19        NA 34500  FALSE     2020-07-07
&gt; 7   Javi     Ortiz   50 688921344 28017  FALSE     2000-01-28
```

&amp;nbsp;

**.bg-green_light[¬°TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!]** Puedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`

---

# .orange[TABLAS]: variables .green[data.frame]

Si tenemos uno ya creado y queremos **.bg-purple_light[a√±adir una columna]** es tan simple como usar la `funci√≥n data.frame()` que ya hemos visto para concatenar la columna. Vamos a√±adir por ejemplo una nueva variable, el **n√∫mero de hermanos** de cada individuo.


```r
# A√±adimos una nueva columna con n¬∫ de hermanos/as
hermanos &lt;- c(0, 0, 1, 5, 2, 3, 0)
tabla &lt;- data.frame(tabla, "n_hermanos" = hermanos)
tabla
```

```
&gt;   nombre  apellido edad  tel√©fono    cp casado fecha_registro n_hermanos
&gt; 1  Sonia      &lt;NA&gt;   45 618910564 28019   TRUE     2021-03-04          0
&gt; 2  Carla  Gonz√°lez   67 914718475 28001  FALSE     2020-10-12          0
&gt; 3 Pepito Fern√°ndez   NA 934567891 34005  FALSE     1990-04-05          1
&gt; 4 Carlos  Mart√≠nez   31 620176565 18410     NA     2019-09-10          5
&gt; 5   Lara   Li√©bana   27        NA 33007   TRUE     2017-03-21          2
&gt; 6 Sandra    Garc√≠a   19        NA 34500  FALSE     2020-07-07          3
&gt; 7   Javi     Ortiz   50 688921344 28017  FALSE     2000-01-28          0
```

---

# .orange[TABLAS]: variables .green[data.frame]

Si queremos **.bg-purple_light[acceder a una columna, fila o elemento]** en concreto, los `data.frame` tienen las mismas ventajas que una matriz, as√≠ que bastar√≠a con usar los mismos operadores.


```r
tabla[5, ] # Accedemos a la quinta fila
```

```
&gt;   nombre apellido edad tel√©fono    cp casado fecha_registro n_hermanos
&gt; 5   Lara  Li√©bana   27       NA 33007   TRUE     2017-03-21          2
```

--

.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/tabla_dolar.jpg" alt="Men√∫ desplegable de variables (columnas)" width="99%" /&gt;
&lt;p class="caption"&gt;Men√∫ desplegable de variables (columnas)&lt;/p&gt;
&lt;/div&gt;
]

.pull-right[

No solo tiene las ventajas de una matriz sino que tambi√©n tiene las **.bg-purple_light[ventajas de una ¬´base¬ª de datos]**: podemos aceder a las variables por el √≠ndice de columna que ocupan pero tambi√©n **.bg-purple_light[acceder por su nombre]**, poniendo el nombre de la tabla, el s√≠mbolo `$` y, con el tabulador, nos aparecer√° un men√∫ de columnas a elegir.

]

---

# Primer .orange[AN√ÅLISIS DE DATOS]

.panelset[
.panel[.panel-name[USArrests]

Nuestro primer conjunto ser√° `USArrests`, un dataset de **.bg-purple_light[arrestos en EE.UU.]** del paquete `{datasets}` (si escribimos `datasets::` y pulsamos tabulador, se nos abre un desplegable con distintos conjuntos de datos para ser usado)


```r
# install.packages("datasets") # Descomentar si nunca se ha instalado
library(datasets)
datasets::USArrests
```

```
&gt;                Murder Assault UrbanPop Rape
&gt; Alabama          13.2     236       58 21.2
&gt; Alaska           10.0     263       48 44.5
&gt; Arizona           8.1     294       80 31.0
&gt; Arkansas          8.8     190       50 19.5
&gt; California        9.0     276       91 40.6
&gt; Colorado          7.9     204       78 38.7
&gt; Connecticut       3.3     110       77 11.1
&gt; Delaware          5.9     238       72 15.8
&gt; Florida          15.4     335       80 31.9
&gt; Georgia          17.4     211       60 25.8
&gt; Hawaii            5.3      46       83 20.2
&gt; Idaho             2.6     120       54 14.2
&gt; Illinois         10.4     249       83 24.0
&gt; Indiana           7.2     113       65 21.0
&gt; Iowa              2.2      56       57 11.3
&gt; Kansas            6.0     115       66 18.0
&gt; Kentucky          9.7     109       52 16.3
&gt; Louisiana        15.4     249       66 22.2
&gt; Maine             2.1      83       51  7.8
&gt; Maryland         11.3     300       67 27.8
&gt; Massachusetts     4.4     149       85 16.3
&gt; Michigan         12.1     255       74 35.1
&gt; Minnesota         2.7      72       66 14.9
&gt; Mississippi      16.1     259       44 17.1
&gt; Missouri          9.0     178       70 28.2
&gt; Montana           6.0     109       53 16.4
&gt; Nebraska          4.3     102       62 16.5
&gt; Nevada           12.2     252       81 46.0
&gt; New Hampshire     2.1      57       56  9.5
&gt; New Jersey        7.4     159       89 18.8
&gt; New Mexico       11.4     285       70 32.1
&gt; New York         11.1     254       86 26.1
&gt; North Carolina   13.0     337       45 16.1
&gt; North Dakota      0.8      45       44  7.3
&gt; Ohio              7.3     120       75 21.4
&gt; Oklahoma          6.6     151       68 20.0
&gt; Oregon            4.9     159       67 29.3
&gt; Pennsylvania      6.3     106       72 14.9
&gt; Rhode Island      3.4     174       87  8.3
&gt; South Carolina   14.4     279       48 22.5
&gt; South Dakota      3.8      86       45 12.8
&gt; Tennessee        13.2     188       59 26.9
&gt; Texas            12.7     201       80 25.5
&gt; Utah              3.2     120       80 22.9
&gt; Vermont           2.2      48       32 11.2
&gt; Virginia          8.5     156       63 20.7
&gt; Washington        4.0     145       73 26.2
&gt; West Virginia     5.7      81       39  9.3
&gt; Wisconsin         2.6      53       66 10.8
&gt; Wyoming           6.8     161       60 15.6
```

Contiene **.bg-purple_light[estad√≠sticas de arrestos en 1973 (por cada 100 000 habitantes)]** por agresi√≥n, asesinato y violaci√≥n, en cada uno de los 50 estados de Estados Unidos.
]

.panel[.panel-name[Visualizar]

Con `View()` se nos abrir√° el conjunto en un formato ¬´excelizado¬ª. Adem√°s con `head()` podemos **.bg-purple_light[visualizar la cabecera]** (primeras) del conjunto de datos.


```r
head(USArrests)
```

```
&gt;            Murder Assault UrbanPop Rape
&gt; Alabama      13.2     236       58 21.2
&gt; Alaska       10.0     263       48 44.5
&gt; Arizona       8.1     294       80 31.0
&gt; Arkansas      8.8     190       50 19.5
&gt; California    9.0     276       91 40.6
&gt; Colorado      7.9     204       78 38.7
```

]

.panel[.panel-name[Variables]

Con la funci√≥n `names()` podemos obtener directamente el **.bg-purple_light[nombre de las variables]** (tambi√©n podemos usarlo para renombrarlas)


```r
names(USArrests)
```

```
&gt; [1] "Murder"   "Assault"  "UrbanPop" "Rape"
```

El conjunto contiene los **3 tipos de delito** mencionados (para cada estado), y adem√°s el **porcentaje de poblaci√≥n que vive en √°reas urbanas**. Esto lo podemos saber ejecutando la ayuda con `? datasets::USArrests`.

]

.panel[.panel-name[Individuos]

Con la funci√≥n `row.names()` podemos obtener el **.bg-purple_light[nombre de las filas]** (de los estados) para cada uno de ellos.


```r
row.names(USArrests)
```

```
&gt;  [1] "Alabama"        "Alaska"         "Arizona"        "Arkansas"      
&gt;  [5] "California"     "Colorado"       "Connecticut"    "Delaware"      
&gt;  [9] "Florida"        "Georgia"        "Hawaii"         "Idaho"         
&gt; [13] "Illinois"       "Indiana"        "Iowa"           "Kansas"        
&gt; [17] "Kentucky"       "Louisiana"      "Maine"          "Maryland"      
&gt; [21] "Massachusetts"  "Michigan"       "Minnesota"      "Mississippi"   
&gt; [25] "Missouri"       "Montana"        "Nebraska"       "Nevada"        
&gt; [29] "New Hampshire"  "New Jersey"     "New Mexico"     "New York"      
&gt; [33] "North Carolina" "North Dakota"   "Ohio"           "Oklahoma"      
&gt; [37] "Oregon"         "Pennsylvania"   "Rhode Island"   "South Carolina"
&gt; [41] "South Dakota"   "Tennessee"      "Texas"          "Utah"          
&gt; [45] "Vermont"        "Virginia"       "Washington"     "West Virginia" 
&gt; [49] "Wisconsin"      "Wyoming"
```

]


.panel[.panel-name[Dimensiones]

¬øC√≥mo averiguar el **.bg-purple_light[n√∫mero de registros y el n√∫mero de variables]**?


```r
dim(USArrests)
```

```
&gt; [1] 50  4
```

```r
nrow(USArrests)
```

```
&gt; [1] 50
```

```r
ncol(USArrests)
```

```
&gt; [1] 4
```

]

.panel[.panel-name[Selecci√≥n]

Al igual que antes, podemos **.bg-purple_light[seleccionar filas por √≠ndices]** y **.bg-purple_light[variables nombre]**.



```r
USArrests[c(2, 10), c("Murder", "Assault")]
```

```
&gt;         Murder Assault
&gt; Alaska    10.0     263
&gt; Georgia   17.4     211
```

Tambi√©n podemos usar las ventajas de los `data.frame` para acceder a las variables.


```r
USArrests$Murder
```

```
&gt;  [1] 13.2 10.0  8.1  8.8  9.0  7.9  3.3  5.9 15.4 17.4  5.3  2.6 10.4  7.2  2.2
&gt; [16]  6.0  9.7 15.4  2.1 11.3  4.4 12.1  2.7 16.1  9.0  6.0  4.3 12.2  2.1  7.4
&gt; [31] 11.4 11.1 13.0  0.8  7.3  6.6  4.9  6.3  3.4 14.4  3.8 13.2 12.7  3.2  2.2
&gt; [46]  8.5  4.0  5.7  2.6  6.8
```

]

.panel[.panel-name[subset]

En el caso de los `data.frame` tenemos adem√°s a nuestro disposici√≥n una **herramienta muy potente**: la funci√≥n `subset()`. Dicha funci√≥n nos va a permitir **.bg-purple_light[seleccionar filas y columnas a la vez]**, tomando de entrada la tabla, `subset = ...` igual a la **condici√≥n l√≥gica** para filtrar registros (filas) y `select = ...` igual al  nombre de las columnas que queremos seleccionar.


```r
subset(USArrests, subset = UrbanPop &gt; 70, select = c("Murder"))
```

```
&gt;               Murder
&gt; Arizona          8.1
&gt; California       9.0
&gt; Colorado         7.9
&gt; Connecticut      3.3
&gt; Delaware         5.9
&gt; Florida         15.4
&gt; Hawaii           5.3
&gt; Illinois        10.4
&gt; Massachusetts    4.4
&gt; Michigan        12.1
&gt; Nevada          12.2
&gt; New Jersey       7.4
&gt; New York        11.1
&gt; Ohio             7.3
&gt; Pennsylvania     6.3
&gt; Rhode Island     3.4
&gt; Texas           12.7
&gt; Utah             3.2
&gt; Washington       4.0
```

]

.panel[.panel-name[Caso pr√°ctico]

* üìù **Ejercicio**: filtra aquellos estados cuyo porcentaje de poblaci√≥n urbana sea inferior al 70% y donde las agresiones sean superiores a 250 por cada 100 000 habitantes, seleccionando solo las variables `Murder` y `Rape`

]

.panel[.panel-name[Caso pr√°ctico]

* üìù **Ejercicio**: filtra aquellos estados cuyo porcentaje de poblaci√≥n urbana sea inferior al 70% y donde las agresiones sean superiores a 250 por cada 100 000 habitantes, seleccionando solo las variables.


```r
subset(USArrests, subset = UrbanPop &lt; 70 &amp; Assault &gt; 250,
       select = c("Murder", "Rape"))
```

```
&gt;                Murder Rape
&gt; Alaska           10.0 44.5
&gt; Maryland         11.3 27.8
&gt; Mississippi      16.1 17.1
&gt; North Carolina   13.0 16.1
&gt; South Carolina   14.4 22.5
```

]

]

---

name: tibble

# Mejorando los data.frame: .orange[TIBBLE]
 
Las tablas en formato `tibble` (con `tibble()` del paquete `{tibble}`, su clase ser√° `tbl_df`) son un tipo de `data.frame` mejorado, para una gesti√≥n **.bg-purple_light[m√°s √°gil, eficiente y coherente]**. Las tablas en formato `tibble` tienen **.bg-purple_light[4 ventajas principales]**

&lt;img src="./img/tibble.svg" width="30%" style="display: block; margin: auto;" /&gt;

---

# Mejorando los data.frame: .orange[TIBBLE]


*  Muestran **.bg-purple_light[metainformaci√≥n de las variables]**, y solo imprime por defecto las primeras filas.


```r
library(tibble)
tabla_tb &lt;- tibble("x" = 1:50, "y" = rep(c("a", "b", "c", "d", "e"), 10),
                   "logica" = rep(c(TRUE, FALSE), 25))
tabla_tb
```

```
&gt; # A tibble: 50 √ó 3
&gt;        x y     logica
&gt;    &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; 
&gt;  1     1 a     TRUE  
&gt;  2     2 b     FALSE 
&gt;  3     3 c     TRUE  
&gt;  4     4 d     FALSE 
&gt;  5     5 e     TRUE  
&gt;  6     6 a     FALSE 
&gt;  7     7 b     TRUE  
&gt;  8     8 c     FALSE 
&gt;  9     9 d     TRUE  
&gt; 10    10 e     FALSE 
&gt; # ‚Ä¶ with 40 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```



---

# Mejorando los data.frame: .orange[TIBBLE]
 
Puedes **imprimir las filas y columnas** que quieras con `print()`


```r
*print(tabla_tb, n = 12, width = Inf)
```

```
&gt; # A tibble: 50 √ó 3
&gt;        x y     logica
&gt;    &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; 
&gt;  1     1 a     TRUE  
&gt;  2     2 b     FALSE 
&gt;  3     3 c     TRUE  
&gt;  4     4 d     FALSE 
&gt;  5     5 e     TRUE  
&gt;  6     6 a     FALSE 
&gt;  7     7 b     TRUE  
&gt;  8     8 c     FALSE 
&gt;  9     9 d     TRUE  
&gt; 10    10 e     FALSE 
&gt; 11    11 a     TRUE  
&gt; 12    12 b     FALSE 
&gt; # ‚Ä¶ with 38 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---

# Mejorando los data.frame: .orange[TIBBLE]
 

* La funci√≥n `tibble()` **.bg-purple_light[construye las variables secuencialmente]**, pudiendo hacer uso en la propia definici√≥n de variables reci√©n definidas en dicha definici√≥n.


```r
# data.frame
data.frame("x1" = 1:3, "x2" = 4:6, "y" = x1 * x2)
```

```
&gt; Error in data.frame(x1 = 1:3, x2 = 4:6, y = x1 * x2): objeto 'x1' no encontrado
```


```r
# tibble
tibble("x1" = 1:3, "x2" = 4:6, "y" = x1 * x2)
```

```
&gt; # A tibble: 3 √ó 3
&gt;      x1    x2     y
&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;
&gt; 1     1     4     4
&gt; 2     2     5    10
&gt; 3     3     6    18
```


---

# Mejorando los data.frame: .orange[TIBBLE]
 
* Si accedes a una **.bg-purple_light[columna que no existe]** avisa con un **.bg-red[warning]**.


```r
tabla_df &lt;- data.frame("x" = 1:50, "y" = rep(c("a", "b", "c", "d", "e"), 10),
                   "logica" = rep(c(TRUE, FALSE), 25))
```

.pull-left[


```r
# data.frame
tabla_df$variable_inexistente
```

```
&gt; NULL
```

]

.pull-right[


```r
# tibble
tabla_tb$variable_inexistente
```

```
&gt; Warning: Unknown or uninitialised column: `variable_inexistente`.
```

```
&gt; NULL
```

]

---


# Mejorando los data.frame: .orange[TIBBLE]

* No solo no te cambiar√° el tipo de datos sino que **.bg-purple_light[no te cambiar√° el nombre de las variables]**.

.pull-left[


```r
data.frame(":)" = "emoticono",
           " " = "en blanco",
           "2000" = "n√∫mero")
```

```
&gt;         X..        X.  X2000
&gt; 1 emoticono en blanco n√∫mero
```

]

.pull-right[


```r
tibble(":)" = "emoticono",
       " " = "en blanco",
       "2000" = "n√∫mero")
```

```
&gt; # A tibble: 1 √ó 3
&gt;   `:)`      ` `       `2000`
&gt;   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt; 
&gt; 1 emoticono en blanco n√∫mero
```

]

---


# Mejorando los data.frame: .orange[TIBBLE]

Si ya tienes un `data.frame` es altamente recomendable **.bg-purple_light[convertirlo a tibble]** con `as_tibble()` (del paquete `{dplyr}`)


```r
library(dplyr)
as_tibble(USArrests)
```

```
&gt; # A tibble: 50 √ó 4
&gt;    Murder Assault UrbanPop  Rape
&gt;     &lt;dbl&gt;   &lt;int&gt;    &lt;int&gt; &lt;dbl&gt;
&gt;  1   13.2     236       58  21.2
&gt;  2   10       263       48  44.5
&gt;  3    8.1     294       80  31  
&gt;  4    8.8     190       50  19.5
&gt;  5    9       276       91  40.6
&gt;  6    7.9     204       78  38.7
&gt;  7    3.3     110       77  11.1
&gt;  8    5.9     238       72  15.8
&gt;  9   15.4     335       80  31.9
&gt; 10   17.4     211       60  25.8
&gt; # ‚Ä¶ with 40 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

Puedes consultar **m√°s funcionalidades** de dichos datos en &lt;https://tibble.tidyverse.org/&gt;

---

# Mejorando los data.frame: .orange[TIBBLE]

Una de las ventajas es la funci√≥n `glimpse()`, que nos permite obtener el **.bg-purple_light[resumen de columnas]** (no es para tener un resumen de los datos sino para ver las variables que tenemos y su tipo).


```r
glimpse(tabla_tb)
```

```
&gt; Rows: 50
&gt; Columns: 3
&gt; $ x      &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, ‚Ä¶
&gt; $ y      &lt;chr&gt; "a", "b", "c", "d", "e", "a", "b", "c", "d", "e", "a", "b", "c"‚Ä¶
&gt; $ logica &lt;lgl&gt; TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE‚Ä¶
```

---

# Mejorando los data.frame: .orange[TIBBLE]

Am√©n de poder convetir con `as_tibble()` podemos **.bg-purple_light[crearlos por filas]** (como copiar y pegar de una tabla en documento) en lugar de por columnas con `tribble()`


```r
datos &lt;- tribble(
  ~colA, ~colB,
  "a",   1,
  "b",   2)
datos
```

```
&gt; # A tibble: 2 √ó 2
&gt;   colA   colB
&gt;   &lt;chr&gt; &lt;dbl&gt;
&gt; 1 a         1
&gt; 2 b         2
```

&amp;nbsp;

--

**.bg-green_light[CONSEJO]**: prueba adem√°s el paquete `{datapasta}`, que nos permite **.bg-purple_light[copiar y pegar tablas de p√°ginas web]**


---

name: ejercicios-tibble

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: carga del paquete `{datasets}` el conjunto de datos `airquality` (contiene variables de la calidad del aire de la ciudad de Nueva York desde mayo hasta septiembre de 1973). ¬øEs el conjunto de datos airquality de tipo tibble? En caso negativo, convi√©rtelo a `tibble`.

* üìù **Ejercicio 2**: obt√©n el nombre de las variables y las dimensiones del conjunto de datos. ¬øCu√°ntas variables hay? ¬øCu√°ntos d√≠as se han medido?
 
* üìù **Ejercicio 3**:  modifica el c√≥digo inferior para que nos filtre solo los datos del mes de agosto.
 

```r
# Filtramos filas
filtro_fila &lt;- subset(., subset = Month &lt; 6)
filtro_fila
```

]

.panel[.panel-name[Soluci√≥n ej. 1]


```r
library(datasets)
class(airquality) # no es data.frame
```

```
&gt; [1] "data.frame"
```

```r
# Convertimos a tibble
airquality &lt;- as_tibble(airquality)
class(airquality)
```

```
&gt; [1] "tbl_df"     "tbl"        "data.frame"
```

]

.panel[.panel-name[Soluci√≥n ej. 2]


```r
names(airquality)
```

```
&gt; [1] "Ozone"   "Solar.R" "Wind"    "Temp"    "Month"   "Day"
```

```r
dim(airquality)
```

```
&gt; [1] 153   6
```

```r
# N√∫mero variables
ncol(airquality)
```

```
&gt; [1] 6
```

```r
# N√∫mero d√≠as
nrow(airquality)
```

```
&gt; [1] 153
```

]


.panel[.panel-name[Soluci√≥n ej. 3]


```r
# Filtramos filas
filtro_fila &lt;- subset(airquality, subset = Month == 8)
filtro_fila
```

```
&gt; # A tibble: 31 √ó 6
&gt;    Ozone Solar.R  Wind  Temp Month   Day
&gt;    &lt;int&gt;   &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
&gt;  1    39      83   6.9    81     8     1
&gt;  2     9      24  13.8    81     8     2
&gt;  3    16      77   7.4    82     8     3
&gt;  4    78      NA   6.9    86     8     4
&gt;  5    35      NA   7.4    85     8     5
&gt;  6    66      NA   4.6    87     8     6
&gt;  7   122     255   4      89     8     7
&gt;  8    89     229  10.3    90     8     8
&gt;  9   110     207   8      90     8     9
&gt; 10    NA     222   8.6    92     8    10
&gt; # ‚Ä¶ with 21 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```
]

]

---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 4**: del conjunto selecciona aquellos datos que no sean ni de julio ni de agosto.

* üìù **Ejercicio 5**: modifica el siguiente c√≥digo para quedarte solo con las variable de ozono y temperatura.
 

```r
filtro_col &lt;- subset(.,  select = c("Ozone"))
filtro_col
```

* üìù **Ejercicio 6**:  selecciona los datos de temperatura y viento de agosto. Traduce a castellano el nombre de las columnas del conjunto filtrado.


* üìù **Ejercicio 7**: a√±ade a los datos originales una columna con la fecha completa (recuerda que es del a√±o 1973 todas las observaciones).

]

.panel[.panel-name[Soluci√≥n ej. 4]


```r
subset(airquality, subset = !(Month %in% c(7, 8)))
```

```
&gt; # A tibble: 91 √ó 6
&gt;    Ozone Solar.R  Wind  Temp Month   Day
&gt;    &lt;int&gt;   &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
&gt;  1    41     190   7.4    67     5     1
&gt;  2    36     118   8      72     5     2
&gt;  3    12     149  12.6    74     5     3
&gt;  4    18     313  11.5    62     5     4
&gt;  5    NA      NA  14.3    56     5     5
&gt;  6    28      NA  14.9    66     5     6
&gt;  7    23     299   8.6    65     5     7
&gt;  8    19      99  13.8    59     5     8
&gt;  9     8      19  20.1    61     5     9
&gt; 10    NA     194   8.6    69     5    10
&gt; # ‚Ä¶ with 81 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

]

.panel[.panel-name[Soluci√≥n ej. 5]


```r
# Filtramos columnas
filtro_col &lt;- subset(airquality,  select = c("Ozone", "Temp"))
filtro_col
```

```
&gt; # A tibble: 153 √ó 2
&gt;    Ozone  Temp
&gt;    &lt;int&gt; &lt;int&gt;
&gt;  1    41    67
&gt;  2    36    72
&gt;  3    12    74
&gt;  4    18    62
&gt;  5    NA    56
&gt;  6    28    66
&gt;  7    23    65
&gt;  8    19    59
&gt;  9     8    61
&gt; 10    NA    69
&gt; # ‚Ä¶ with 143 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

]

.panel[.panel-name[Soluci√≥n ej. 6]


```r
datos &lt;- subset(airquality, subset = Month == 8, select = c("Temp", "Wind"))
datos 
```

```
&gt; # A tibble: 31 √ó 2
&gt;     Temp  Wind
&gt;    &lt;int&gt; &lt;dbl&gt;
&gt;  1    81   6.9
&gt;  2    81  13.8
&gt;  3    82   7.4
&gt;  4    86   6.9
&gt;  5    85   7.4
&gt;  6    87   4.6
&gt;  7    89   4  
&gt;  8    90  10.3
&gt;  9    90   8  
&gt; 10    92   8.6
&gt; # ‚Ä¶ with 21 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

```r
# Traducimos a castellano el nombre
names(datos) &lt;- c("temperatura", "viento")
glimpse(datos)
```

```
&gt; Rows: 31
&gt; Columns: 2
&gt; $ temperatura &lt;int&gt; 81, 81, 82, 86, 85, 87, 89, 90, 90, 92, 86, 86, 82, 80, 79‚Ä¶
&gt; $ viento      &lt;dbl&gt; 6.9, 13.8, 7.4, 6.9, 7.4, 4.6, 4.0, 10.3, 8.0, 8.6, 11.5, ‚Ä¶
```

]

.panel[.panel-name[Soluci√≥n ej. 7]


```r
nuevos_datos &lt;- 
  tibble(airquality, "fecha" = as_date(glue("1973-{Month}-{Day}")))
nuevos_datos
```

```
&gt; # A tibble: 153 √ó 7
&gt;    Ozone Solar.R  Wind  Temp Month   Day fecha     
&gt;    &lt;int&gt;   &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;date&gt;    
&gt;  1    41     190   7.4    67     5     1 1973-05-01
&gt;  2    36     118   8      72     5     2 1973-05-02
&gt;  3    12     149  12.6    74     5     3 1973-05-03
&gt;  4    18     313  11.5    62     5     4 1973-05-04
&gt;  5    NA      NA  14.3    56     5     5 1973-05-05
&gt;  6    28      NA  14.9    66     5     6 1973-05-06
&gt;  7    23     299   8.6    65     5     7 1973-05-07
&gt;  8    19      99  13.8    59     5     8 1973-05-08
&gt;  9     8      19  20.1    61     5     9 1973-05-09
&gt; 10    NA     194   8.6    69     5    10 1973-05-10
&gt; # ‚Ä¶ with 143 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

]


]

---

# Ejercicios extras

.panelset[
.panel[.panel-name[Ejercicios extras]


* üìù **Ejercicio 8**: define un `tibble` con tres variables num√©ricas `a, b, c`, tal que la tercera sea el producto de las dos primeras `c = a * b`.

* üìù **Ejercicio 9**:  define un tibble con tres variables de nombres `variable`, `2`, `tercera` y `:)`, e intenta acceder a ellas.
 
* üìù **Ejercicio 10**:  obten de los paquetes `{dplyr}` y `{gapminder}` los conjuntos de datos `starwars` y `gapminder`. Comprueba el n√∫mero de variables, de registros e imprime los datos

]

.panel[.panel-name[Soluci√≥n ej. 8]


```r
tibble("a" = 1:4, "b" = 11:14, "c" = a * b)
```

```
&gt; # A tibble: 4 √ó 3
&gt;       a     b     c
&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;
&gt; 1     1    11    11
&gt; 2     2    12    24
&gt; 3     3    13    39
&gt; 4     4    14    56
```

]

.panel[.panel-name[Soluci√≥n ej. 9]


```r
datos &lt;- tibble("variable" = 1, "2" = "a", "tercera" = 3, ":)" = "b")

# Accedemos
datos$variable
```

```
&gt; [1] 1
```

```r
datos$`2`
```

```
&gt; [1] "a"
```

```r
datos$tercera
```

```
&gt; [1] 3
```

```r
datos$`:)`
```

```
&gt; [1] "b"
```

]

.panel[.panel-name[Soluci√≥n ej. 10]


```r
library(dplyr)
dim(starwars)
```

```
&gt; [1] 87 14
```

```r
library(gapminder)
dim(gapminder)
```

```
&gt; [1] 1704    6
```

]

]

---

class: inverse center middle
name: intro-estadistica

# Introducci√≥n a la ESTAD√çSTICA

---



# Introducci√≥n a la .orange[ESTAD√çSTICA]

&lt;img src="./img/tellme.jpg" width="50%" style="display: block; margin: auto;" /&gt;


---

# Introducci√≥n a la .orange[ESTAD√çSTICA]

.pull-left[

**.bg-purple_light[¬øQu√© es la estad√≠stica?]** Seg√∫n la RAE...

* **.bg-purple_light[Estudio de los datos]** cuantitativos de la poblaci√≥n, de los recursos naturales e industriales, del tr√°fico o de cualquier otra manifestaci√≥n de las sociedades

* **.bg-purple_light[Rama de la matem√°tica]** que utiliza grandes conjuntos de datos num√©ricos para obtener inferencias basadas en el c√°lculo de probabilidades.

]

.pull-right[

&lt;img src="./img/perez_reverte.jpg" width="90%" style="display: block; margin: auto;" /&gt;

]

---

# Introducci√≥n a la .orange[ESTAD√çSTICA]

.pull-left[

**.bg-purple_light[¬øQu√© es la estad√≠stica?]** Seg√∫n la RAE...

* **.bg-purple_light[Estudio de los datos]** cuantitativos de la poblaci√≥n, de los recursos naturales e industriales, del tr√°fico o de cualquier otra manifestaci√≥n de las sociedades

* **.bg-purple_light[Rama de la matem√°tica]** que utiliza grandes conjuntos de datos num√©ricos para obtener inferencias basadas en el c√°lculo de probabilidades.

]

.pull-right[

&lt;img src="./img/perez_reverte.jpg" width="51%" style="display: block; margin: auto;" /&gt;

]


&gt; ¬´La estad√≠stica est√° caracterizada por una informaci√≥n acerca de un colectivo o universo, lo que constituye su objeto material; un modo propio de razonamiento, el m√©todo estad√≠stico, lo que constituye su objeto formal y unas previsiones de cara al futuro, lo que implica un ambiente de incertidumbre¬ª (Cabri√°, 1994). 

---

# Introducci√≥n a la .orange[ESTAD√çSTICA]

.pull-left[

La **.bg-purple_light[estad√≠stica]** como ciencia naci√≥ como una **.bg-purple_light[ciencia del Estado]**, de hecho nuestra palabra actual viene de dos palabras previas

* del t√©rmino (neo)latino ¬´statisticum collegium¬ª: consejo de Estado.
* del alem√°n **.bg-purple_light[¬´statistik¬ª]** (ciencia del Estado), t√©rmino introducido por G. Achenwall.

&amp;nbsp;

En su origen fue una desarrollada como una mera **.bg-purple_light[herramienta para la administraci√≥n eficiente]** de la sociedad.

]

.pull-right[

&lt;img src="./img/biblia.jpg" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]

---

# Introducci√≥n a la .orange[ESTAD√çSTICA]

.pull-left[

Los **.bg-purple_light[primeros usos]** documentados son de hecho para elaborar **.bg-purple_light[censos y de uso militar]** en Mesopotamia, China y Egipto, con el objetivo de tener un **.bg-purple_light[recuento y organizaci√≥n de recursos]**

* Cobrar **impuestos**
* Repartir **tierras**
* Reclutar **soldados**

&amp;nbsp;

Seg√∫n Tuc√≠dides, conceptos como la **.bg-purple_light[moda]** ya exist√≠an en el siglo V a.C.: para asaltar la muralla de Platea, se usaba la estad√≠stica para el recuento de ladrillos de la muralla y aproximar su altura.

]


.pull-right[

&lt;img src="./img/census.jpg" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]


---

# Introducci√≥n a la .orange[ESTAD√çSTICA]

El **.bg-purple_light[objetivo principal]** de la estad√≠stica, ayudada por la probabilidad, es **.bg-purple_light[analizar datos y fen√≥menos]** cuyo mecanismo subyacente suele ser un experimento aleatorio.

--

### Experimento .green[ALEATORIO]

Un experimento se puede clasificar principalmente en

* **.bg-purple_light[Determinista]**: con las mismas condiciones iniciales, se obtiene el mismo resultado. Por ejemplo, el movimiento parab√≥lico de un proyectil sin rozamiento.

* **.bg-purple_light[Aleatorio]**: con las mismas condiciones iniciales, se pueden obtener resultados diferentes. Por ejemplo, el tiempo entre clientes que entran en un establecimiento.

---

# Introducci√≥n a la .orange[ESTAD√çSTICA]


Un error muy habitual es interpretar lo ¬´aleatorio¬ª como **.bg-purple_light[equiprobable]**: un suceso aleatorio **.bg-red_light[NO IMPLICA]** que todas sus opciones tengan la misma probabilidad de suceder.

* **.bg-purple_light[Aleatorio]**: el resultado individual inmediato no se puede asegurar con total certeza (tenemos **.bg-orange[incertidumbre]**)

* **.bg-purple_light[Sucesos equiprobables]**: colecci√≥n de sucesos de una variable aleatoria cuya probabilidad de suceder es la misma para todos ellos.

--

**.bg-green_light[RECUERDA]**: un **dado trucado** sigue siendo aleatorio, igual de aleatorio que un dado sin trucar. No hay algo m√°s o menos aleatorio, solo **.bg-purple_light[diferentes distribuciones de probabilidad]** que modelizan los sucesos.

---

# .green[POBLACI√ìN] vs .orange[MUESTRA]

.pull-left[

**.bg-green_light[POBLACI√ìN]**

Una poblaci√≥n ser√° el conjunto total o **.bg-purple_light[colectivo de individuos factibles de estudiar]**, o de posibles elementos/eventos de los podr√≠amos tener observaciones (por ejemplo, 47 millones de espa√±oles). 

Es nuestro **.bg-purple_light[universo te√≥rico]**, y nuestro objetivo ser√° conocer algunas de las propiedades de esa poblaci√≥n.

&amp;nbsp;

**.bg-green_light[INDIVIDUO]**

Cada uno de los elementos o eventos de la poblaci√≥n.

]

.pull-right[

**.bg-orange[MUESTRA (SAMPLE)]**

Dado que la **.bg-red_light[poblaci√≥n suele ser inaccesible]** en su totalidad (no podemos medir a TODA la poblaci√≥n), debemos realizar una **.bg-purple_light[selecci√≥n]** de un conjunto de individuos

Dicho subconjunto ser√° siempre de **.bg-purple_light[tama√±o finito n]**, de forma que la muestra sea de alguna manera **.bg-purple_light[¬´representativa¬ª]** de la poblaci√≥n (bien a lo largo de los individuos, bien a lo largo del tiempo). Un estudio estad√≠stico realizado sobre la totalidad de una poblaci√≥n se denomina censo. 


]

---

# .green[POBLACI√ìN] vs .orange[MUESTRA]


&lt;img src="./img/poblacion_muestra.jpg" width="55%" style="display: block; margin: auto;" /&gt;

---

# .green[CARACTERES] y .orange[MODALIDADES]


.pull-left[

* **.bg-purple_light[Caracteres (variables)]**: cada una de las **caracter√≠sticas o cualidades** que se podr√≠an medir o analizar para cada individuo de la poblaci√≥n (y de los que disponemos el valor para cada individuo de la muestra).

* **.bg-purple_light[Modalidades]**: conjunto de los **diferentes valores** que puede adoptar una caracter√≠stica o variable.


]

.pull-right[

Un **.bg-purple_light[ejemplo]** (poblaci√≥n de alumnos de UCM)

* **.bg-orange[Caracteres o variables]**:
  - sexo
  - edad
  - carrera
  - estatura

* **.bg-orange[Modalidades]**:
  - sexo: hombre/mujer.
  - edad: 18, 19, 20, 21, 22, ..., 98, 99, 100
  - carrera: mates, filolog√≠a, historia, etc.
  - estatura: intervalo [130cm, 200cm].
  
* **.bg-orange[Muestra]**: conjunto de 300 estudiantes seleccionados al azar.
]

---

# .orange[TIPOS] de variables

Imagina las siguientes variables:

* ¬øTienes hermanos?
* Resultado de la tirada de un dado
* Color de zapatillas
* Nivel de estudios
* N√∫mero de hermanos
* N√∫mero de pelos en la cabeza
* Resultado de un dado dividido entre 10
* Temperatura ¬∫C
* G√©nero
* Estatura o peso
* Religi√≥n


**.bg-purple_light[¬øCU√ÅL ES LA DIFERENCIA ENTRE ELLAS?]**

---


# .orange[TIPOS] de variables

.pull-left[

Imagina las siguientes variables:

* ¬øTienes hermanos?
* Resultado de la tirada de un dado
* Color de zapatillas
* Nivel de estudios
* N√∫mero de hermanos
* N√∫mero de pelos en la cabeza
* Resultado de un dado dividido entre 10
* Temperatura ¬∫C
* G√©nero
* Estatura o peso
* Religi√≥n


**.bg-purple_light[¬øCU√ÅL ES LA DIFERENCIA ENTRE ELLAS?]**

]

.pull-right[

* **.bg-purple_light[Cualitativas]**: representan **.bg-orange[cualidades o categor√≠as]** no cuantificables num√©ricamente (sexo, estado civil, etc).

  - **.bg-purple_light[Ordinales]**: admiten **jerarqu√≠a** (suspenso-aprobado-notable).
  - **.bg-purple_light[Nominales]**: no tienen asociada una jerarqu√≠a (sexo, religi√≥n, color, etc).


* **.bg-purple_light[Cuantitativas]**: caracter√≠stica **.bg-orange[cuantificable num√©ricamente]**.

  - **.bg-purple_light[Discretas]**: se pueden contar y enumerar (aunque sean infinitos) (n¬∫ granos de arena, n¬∫ hermanos, etc).
  - **.bg-purple_light[Continuas]**: adem√°s de tomar infinitos valores, entre dos valores cualesquiera hay a su vez infinitas opciones (estatura, peso, etc).


]

---

# .orange[DISCRETA] vs .green[CONTINUAS]

&lt;img src="./img/discreta_continua.jpg" width="76%" style="display: block; margin: auto;" /&gt;

---

# Resumiendo informaci√≥n: .orange[MOMENTOS]

En estad√≠stica los **.bg-purple_light[momentos]** ser√°n par√°metros calculados a partir de los datos que, mediante una f√≥rmula, **.bg-purple_light[resumen num√©ricamente]** algunas caracter√≠sticas de nuestros datos:

--

* Medidas de **.bg-purple_light[centralizaci√≥n]**: en torno a qu√© valores se **concentran** los datos.

--

* Medidas de **.bg-purple_light[dispersi√≥n]**: cuantifican la **dispersi√≥n respecto al centro**.

--

* Medidas de **.bg-purple_light[posici√≥n/localizaci√≥n]**: c√≥mo se **localizan** los datos, valores que nos permiten segmentar nuestros datos en conjuntos de partes iguales (mismo % de datos, los famosos percentiles).

--

* Medidas de **.bg-purple_light[forma]**: nos complementan la caracterizaci√≥n de la distribuci√≥n, por ejemplo, indic√°ndonos la **direcci√≥n** en la que se desv√≠an los datos.


---

# Medidas de .orange[CENTRALIZACI√ìN]

Las **.bg-purple_light[medidas de centralizaci√≥n]** nos informan de los valores en torno a los que se **concentra** nuestra variable, un **.bg-purple_light[¬´representante¬ª]** de nuestra variable.

--

* **.bg-purple_light[Media]** (aritm√©tica, sin ponderar): definida como la suma de valores, dividida entre el tama√±o muestral. **.bg-red_light[Solo para cuantitativas]**

--

* **.bg-purple_light[Mediana]**: si ordenamos los datos de menor a mayor, el valor central (por debajo el 50%, por encima el 50%). **.bg-red_light[Solo si existe jerarqu√≠a de orden]**.

--

* **.bg-purple_light[Moda]**: el **valor o valores m√°s repetidos** de nuestra variable, lo m√°s frecuente. **.bg-red_light[Amodal]**: todos se repiten por igual -&gt; no hay moda.


---

# .orange[MEDIA] aritm√©tica

.pull-left[

Dada una muestra, la **.bg-purple_light[media (aritm√©tica) muestral]** `\(\overline{x}\)` se define como la suma de todos los valores dividida por el tama√±o muestral.

`$$\overline{x} = \frac{1}{N} \sum_{i=1}^{N} x_i$$`

Tambi√©n se puede definir como el **.bg-purple_light[valor ¬´m√°s cercano¬ª a todos los datos]** a la vez, minimizando las distancias (al cuadrado) de los datos a dicho valor.

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/media.jpg" alt="Extra√≠da de instagram.com/javieralvarezliebana" width="89%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de instagram.com/javieralvarezliebana&lt;/p&gt;
&lt;/div&gt;


]


---

# .orange[ROBUSTEZ] de la media

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/robustez.jpg" alt="Extra√≠da de instagram.com/javieralvarezliebana" width="43%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de instagram.com/javieralvarezliebana&lt;/p&gt;
&lt;/div&gt;

---


# .orange[MEDIANA]


.pull-left[

Dada una muestra, la **.bg-purple_light[mediana muestral]** se define como el valor que es mayor o igual que al menos el 50%, y menor igual que al menos el 50% de los datos

`$$Me_{x} = \displaystyle \arg \min_{x_i} \left\lbrace F_i &gt; 0.5 \right\rbrace$$`

En caso de `\(F_i = 0.5\)` en variables discretas, realizaremos la media de `\(x_i\)` y `\(x_{i+1}\)`.

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/mediana.jpg" alt="Extra√≠da de instagram.com/javieralvarezliebana" width="89%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de instagram.com/javieralvarezliebana&lt;/p&gt;
&lt;/div&gt;


]


---

# .orange[MODA]


.pull-left[

Dada una muestra, la **.bg-purple_light[moda muestral]** se define como el valor o valores m√°s repetidos (en caso de que existan)

`$$Mo_{x} = \displaystyle \arg \max_{x_i} f_i$$`

Podr√≠amos tener distribuciones **unimodales**, **bimodales**, **trimodales**...incluso **amodales**

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/moda.jpg" alt="Extra√≠da de instagram.com/javieralvarezliebana" width="89%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de instagram.com/javieralvarezliebana&lt;/p&gt;
&lt;/div&gt;


]

---

# .orange[ROBUSTEZ]

**.bg-green_light[¬øCu√°l es cu√°l?]**

&lt;img src="./img/ine_salarios.jpg" width="70%" style="display: block; margin: auto;" /&gt;


---

# Medidas de .orange[DISPERSI√ìN]

&lt;img src="./img/iker.jpg" width="45%" style="display: block; margin: auto;" /&gt;

--

El cambio clim√°tico, un problema de dispersi√≥n

---

# Medidas de .orange[DISPERSI√ìN]

&lt;img src="./img/fenom_extremos.jpg" width="70%" style="display: block; margin: auto;" /&gt;

El cambio clim√°tico, un **.bg-purple_light[problema de dispersi√≥n]**

---

# Medidas de .orange[DISPERSI√ìN]

.pull-left[

Una primera idea podr√≠a ser **.bg-purple_light[medir la distancia de cada dato al centro]**, es decir, restar cada dato de la media, y despu√©s realizar su promedio.

`$$\frac{1}{N} \sum_{i=1}^{N} \left(x_i - \overline{x} \right)$$`

**.bg-red_light[¬øProblema?]**

]

.pull-right[

&lt;img src="./img/distancia_var.jpg" width="99%" style="display: block; margin: auto;" /&gt;

]

--

&amp;nbsp;

Imagina que tenemos `\(X = \left\lbrace -5, -3, -1, 0, 1, 3, 5 \right\rbrace\)`: la media es 0, y el promedio de las distancias a la media tambi√©n ya que se **.bg-red_light[cancelan los signos]**.

**.bg-green_light[¬øSoluci√≥n?]**

---

# Medidas de .orange[DISPERSI√ìN]

En matem√°ticas suele ser **desaconsejable usar el valor absoluto** (dado que es una funci√≥n no derivable), as√≠ que lo que haremos ser√° calcula el **.bg-purple_light[promedio de las distancias al cuadrado]**


`$$s_{x}^{2} = \frac{1}{N} \sum_{i=1}^{N} \left(x_i - \overline{x} \right)^2 = \overline{x^2} - \overline{x}^2$$`

--

Esta medida de dispersi√≥n es lo que conocemos como **.bg-purple_light[VARIANZA muestral]**.

--

**.bg-red_light[CUIDADO]**: tanto `R` como el resto de software nos devolver√°n la cuasivarianza `\(S_{x}^{2}\)` (promedio entre `\(N-1\)`, no entre `\(N\)`), ya que es el **estimador insesgado** de la varianza poblacional `\(\sigma_{x}^2\)`: asumimos que los estimadores casi nunca coincidir√°n con su valor te√≥rico pero si repetimos el experimento un n√∫mero suficiente de veces, su promedio si tender√° a √©l.

`$${\rm E} [\overline{x}] = \mu, \quad {\rm E} [S_{x}^{}] = \sigma_{x}^{2}$$`



---

# Medidas de .orange[DISPERSI√ìN]


**.bg-red_light[¬øProblema?]**

--

&lt;img src="./img/albert_rivera.jpg" width="70%" style="display: block; margin: auto;" /&gt;

Necesitamos una medida de dispersi√≥n en las **unidades de los datos**.

---

# Medidas de .orange[DISPERSI√ìN]


Para tener una **.bg-purple_light[medida de dispersi√≥n en las unidades]** de los datos calcularemos la **.bg-purple_light[desviaci√≥n t√≠pica]**, como la ra√≠z cuadrada de la varianza


`$$s_{x} = \sqrt{s_{x}^{2}} = \sqrt{\frac{1}{N} \sum_{i=1}^{N} \left(x_i - \overline{x} \right)^2} = \sqrt{\overline{x^2} - \overline{x}^2}$$`
--

Imaginemos entonces que tenemos dos conjuntos de datos: estaturas (de 165 a 175 cm) y di√°metros de n√∫cleos de c√©lulas (de 3 a 7 micr√≥metros). Si obtenemos una  desviaci√≥n t√≠pica de 1 cm y 1.5 micr√≥metros, **.bg-purple_light[¬øcu√°l es m√°s dispersa?]**

--

&amp;nbsp;

¬ø**.bg-red_light[NO podemos comparar]** varianzas y desviaciones t√≠picas? 

---

# Medidas de .orange[DISPERSI√ìN]


&lt;img src="./img/sorry.jpg" width="80%" style="display: block; margin: auto;" /&gt;


**.bg-red_light[NO podemos comparar]** ni varianzas ni desviaciones t√≠picas: dependen de la magnitud y unidades de los datos.

---

# Medidas de .orange[DISPERSI√ìN]

Para tener una **.bg-purple_light[medida de dispersi√≥n adimensional]** que podamos comparar en distintos conjuntos de datos calcularemos el **.bg-purple_light[coeficiente de variaci√≥n]**, como la desv. t√≠pica entre el valor absoluto de la media


`$$CV_{x} = \frac{s_{x}}{\left| \overline{x} \right|}$$`

---

# Medidas de .orange[LOCALIZACI√ìN/POSICI√ìN]


Las **.bg-purple_light[medidas de posici√≥n]** nos **localizan** los datos: son **.bg-purple_light[valores que nos dividen]** un conjunto ordenado en un n√∫mero de tramos con el mismo tama√±o muestral. Ejemplo: la mediana es el percentil `\(P_{50}\)`, el decil `\(D_{5}\)` y el cuartil `\(C_{2}\)` o `\(q_2\)`.

* **.bg-purple_light[Percentil]**: valores `\(P_{\alpha}\)` del conjunto ordenado que dejan por debajo, al menos, el `\(\alpha  \%\)` de datos y el `\((100-\alpha) \%\)` por encima.   


* **.bg-purple_light[Decil]**: valores `\(D_{\alpha}\)` del conjunto ordenado que dividen los datos en 10 partes iguales, que dejan por debajo, al menos, el `\(10*\alpha  \%\)` de datos y el `\((100-10*\alpha) \%\)` por encima.   


* **.bg-purple_light[Cuartil]**: valores `\(C_{\alpha}\)` o `\(q_{\alpha}\)` del conjunto ordenado que dividen los datos en 4 partes iguales, que dejan por debajo, al menos, el `\(25*\alpha  \%\)` de datos y el `\((100-25*\alpha) \%\)` por encima.   

---

class: inverse center middle
name: clase-3

# CLASE 3: Tidydata. SEMMA.

&amp;nbsp;


### [Tidydata](#tidydata)

### [Caso pr√°ctico: datos de la OMS](#oms)

### [Introducci√≥n al aprendizaje estad√≠stico](#learning)

### [Introducci√≥n a miner√≠a: metodolog√≠a SEMMA](#data-mining)


---

name: tidydata

# Datos limpios: .orange[TIDY DATA]

.pull-left[

&lt;img src="./img/tidyverrse_universe.jpg" width="99%" style="display: block; margin: auto;" /&gt;

]

.pull-right[
&lt;img src="./img/flow_tidyverse.jpg" width="99%" style="display: block; margin: auto;" /&gt;
]

Universo de **.bg-purple_light[paquetes tidyverse]**: un conjunto de paquetes para un flujo de **trabajo eficiente, coherente y lexicogr√°ficamente** sencillo de entender.

---

# Datos limpios: .orange[TIDY DATA]

&gt; Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

Hasta ahora solo le hemos dado importancia al ¬´qu√©¬ª pero no al **.bg-purple_light[¬´c√≥mo¬ª manejamos los datos]**. La organizaci√≥n de nuestros datos es fundamental para que su **.bg-purple_light[preparaci√≥n y explotaci√≥n]** sea lo m√°s eficiente posible.

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/tidy_flow.jpg" alt="Flujo deseable de datos seg√∫n Hadley Wickham, extra√≠da de https://r4ds.had.co.nz/wrangle-intro.html" width="60%" /&gt;
&lt;p class="caption"&gt;Flujo deseable de datos seg√∫n Hadley Wickham, extra√≠da de https://r4ds.had.co.nz/wrangle-intro.html&lt;/p&gt;
&lt;/div&gt;


---

# Datos limpios: .orange[TIDY DATA]

El concepto **.bg-purple_light[tidy data]** fue introducido por **Hadley Wickham** (Wickham, 2014) como el primer paso de un flujo de trabajo eficiente. Para ello haremos uso del paquete `{tidyr}` (dentro de `{tidyverse}`) que nos proporciona herramientas eficientes y sencillaspara su manejo.

&amp;nbsp;

Los **.bg-purple_light[conjuntos tidy u ordenados]** tienen tres objetivos

* **.bg-orange[Estandarizaci√≥n]** en su estructura para una depuraci√≥n y an√°lisis eficiente.
* **.bg-orange[Sencillez]** en su manipulaci√≥n.
* Listos para ser **.bg-orange[modelizados y visualizados]**.

&amp;nbsp;

üìö Ver Wickham (2014) en **.bg-green_light[bibliograf√≠a]** en &lt;https://github.com/dadosdelaplace/teaching/tree/main/bioestad/biblio&gt;

---

# Datos limpios: .orange[TIDY DATA]



.pull-left[

Los **.bg-purple_light[datos ordenados o tidy data]** deben cumplir:

1. Cada **.bg-green_light[variable en una columna]**.

2. Cada **.bg-orange[observaci√≥n/individuo en una fila]** diferente.

3. Cada **.bg-green_light[celda con un √∫nico valor]**.

4. Cada **.bg-orange[conjunto en un tibble]** (tabla).

5. Si usamos m√∫ltiples tablas a la vez debemos tener una **.bg-green_light[columna com√∫n para poder cruzarlas]**.

]

.pull-right[

&lt;img src="./img/tidy_def.jpg" width="85%" style="display: block; margin: auto;" /&gt;

&amp;nbsp;

&lt;img src="./img/tidyr_1.jpg" width="53%" style="display: block; margin: auto;" /&gt;


]


---

# Tuber√≠a .orange[PIPE]

En este entorno de trabajo tendremos un **.bg-purple_light[operador clave]**: el **.bg-purple_light[operador pipeline]** `%&gt;%` (podemos usar el atajo con `ctrl+shift+M` o `command+shift+M`). Dicho operador lo debemos interpretar como una **.bg-purple_light[tuber√≠a]** que va pasando por los datos y los va transformando.


Por ejemplo, si tuvi√©semos tres funciones `first()`, `second()` y `third()`, la opci√≥n m√°s inmediata ser√≠a anidar las tres funciones tal que `third(second(first(x)))`, algo que dificulta la lectura posterior del c√≥digo

--

Con `%&gt;%` podremos escribir (y leer) la concetanci√≥n de acciones como una **.bg-purple_light[tuber√≠a de izquierda a derecha]**:


```r
first(x) %&gt;% second(x) %&gt;% third(x)
```

--

Dicho operador viene del paquete `{magrittr}`. Para **evitar esta dependencia** (cuantos menos paquetes tengamos que cargar, mejor), desde la versi√≥n 4.1.0 de R, disponemos de un pipeline nativo de R, el **operador** `|&gt;` (disponible adem√°s fuera del entorno tidyverse).

---

# Tuber√≠a .orange[PIPE]

.pull-left[


```r
datos %&gt;%
  limpio(...) %&gt;%
  selecciono(...) %&gt;%
  filtro(...) %&gt;%
  ordeno(...) %&gt;%
  agrupo(...) %&gt;%
  cuento(...) %&gt;%
  resumo(...) %&gt;% 
  pinto(...)
```


```r
datos |&gt;
  limpio(...) |&gt;
  selecciono(...) |&gt;
  filtro(...) |&gt;
  ordeno(...) |&gt;
  agrupo(...) |&gt;
  cuento(...) |&gt;
  resumo(...) |&gt;
  pinto(...)
```

]

.pull-right[

&lt;img src="./img/tuberia.jpg" width="90%" style="display: block; margin: auto;" /&gt;

]

---

# Datos .orange[SUCIOS]: messy data

Por ejemplo, vamos a cargar la tabla `table4a` del paquete `{tidyr}` (que ya lo tenemos cargado del entorno `{tidyverse}`).




```r
table4a
```

```
&gt; # A tibble: 3 √ó 3
&gt;   country     `1999` `2000`
&gt; * &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;
&gt; 1 Afghanistan    745   2666
&gt; 2 Brazil       37737  80488
&gt; 3 China       212258 213766
```

**.bg-purple_light[¬øQu√© falla?]**

---


# Datos .orange[SUCIOS]: messy data

.pull-left[




```r
table4a
```

```
&gt; # A tibble: 3 √ó 3
&gt;   country     `1999` `2000`
&gt; * &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;
&gt; 1 Afghanistan    745   2666
&gt; 2 Brazil       37737  80488
&gt; 3 China       212258 213766
```

**.bg-purple_light[¬øQu√© falla?]**

]

.pull-right[


‚ùé Cada **.bg-green_light[variable en una columna]**.

‚ùé Cada **.bg-orange[observaci√≥n/individuo en una fila]** diferente.

‚ùé Cada **.bg-green_light[celda con un √∫nico valor]**.

]

Aunque la columna `$country` representa una variable, las otras columnas no: **.bg-purple_light[ambas son la misma variable]**, solo que medida en a√±os distintos (que deber√≠a ser a su vez otra variable), de forma que **.bg-purple_light[cada fila est√° representando dos observaciones]** (1999, 2000). Tenemos datos en los nombres de las columnas.


---

# Datos .orange[SUCIOS]: messy data


.pull-left[

Lo que haremos ser√° incluir una nueva columna llamada (por ejemplo) `year` que nos marque el a√±o y otra llamada `cases` que nos diga el valor de la variable de inter√©s en cada uno de esos a√±os.

]

.pull-right[

&lt;img src="./img/table4a.jpg" width="65%" style="display: block; margin: auto;" /&gt;


]

--

Con la funci√≥n `pivot_longer()` pivotaremos la tabla para pasarla a **formato long**:


```r
table4a %&gt;%
* pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```

```
&gt; # A tibble: 6 √ó 3
&gt;   country     year   cases
&gt;   &lt;chr&gt;       &lt;chr&gt;  &lt;int&gt;
&gt; 1 Afghanistan 1999     745
&gt; 2 Afghanistan 2000    2666
&gt; 3 Brazil      1999   37737
&gt; 4 Brazil      2000   80488
&gt; 5 China       1999  212258
&gt; 6 China       2000  213766
```

---

# Datos .orange[SUCIOS]: messy data

.pull-left[


```r
table4a %&gt;%
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year", 
*              values_to = "cases")
```

]

.pull-right[

&lt;img src="./img/table4a_2.png" width="110%" style="display: block; margin: auto;" /&gt;


]


* `cols`: el **.bg-purple_light[nombre de las columnas a pivotar]** (con comillas por ser n√∫meros y no caracteres).
* `names_to`: el **.bg-purple_light[nombre de la nueva columna]** a la mandamos los **.bg-purple_light[nombres]** de las columnas.
* `values_to`: el **.bg-purple_light[nombre de la nueva columna]** a la que vamos a mandar los **.bg-purple_light[datos]**.


---

# Datos .orange[SUCIOS]: messy data

Echa un vistazo a la tabla `{table4b}`


```r
table4b
```

```
&gt; # A tibble: 3 √ó 3
&gt;   country         `1999`     `2000`
&gt; * &lt;chr&gt;            &lt;int&gt;      &lt;int&gt;
&gt; 1 Afghanistan   19987071   20595360
&gt; 2 Brazil       172006362  174504898
&gt; 3 China       1272915272 1280428583
```

**.bg-purple_light[TODO TUYO]**: ¬øes tidy o messy? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?


---

# Datos .orange[SUCIOS]: messy data

Echa un vistazo a la tabla `{relig_income}`


```r
relig_income
```

```
&gt; # A tibble: 18 √ó 11
&gt;    religion      `&lt;$10k` $10-2‚Ä¶¬π $20-3‚Ä¶¬≤ $30-4‚Ä¶¬≥ $40-5‚Ä¶‚Å¥ $50-7‚Ä¶‚Åµ $75-1‚Ä¶‚Å∂ $100-‚Ä¶‚Å∑
&gt;    &lt;chr&gt;           &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
&gt;  1 Agnostic           27      34      60      81      76     137     122     109
&gt;  2 Atheist            12      27      37      52      35      70      73      59
&gt;  3 Buddhist           27      21      30      34      33      58      62      39
&gt;  4 Catholic          418     617     732     670     638    1116     949     792
&gt;  5 Don‚Äôt know/r‚Ä¶      15      14      15      11      10      35      21      17
&gt;  6 Evangelical ‚Ä¶     575     869    1064     982     881    1486     949     723
&gt;  7 Hindu               1       9       7       9      11      34      47      48
&gt;  8 Historically‚Ä¶     228     244     236     238     197     223     131      81
&gt;  9 Jehovah's Wi‚Ä¶      20      27      24      24      21      30      15      11
&gt; 10 Jewish             19      19      25      25      30      95      69      87
&gt; 11 Mainline Prot     289     495     619     655     651    1107     939     753
&gt; 12 Mormon             29      40      48      51      56     112      85      49
&gt; 13 Muslim              6       7       9      10       9      23      16       8
&gt; 14 Orthodox           13      17      23      32      32      47      38      42
&gt; 15 Other Christ‚Ä¶       9       7      11      13      13      14      18      14
&gt; 16 Other Faiths       20      33      40      46      49      63      46      40
&gt; 17 Other World ‚Ä¶       5       2       3       4       2       7       3       4
&gt; 18 Unaffiliated      217     299     374     365     341     528     407     321
&gt; # ‚Ä¶ with 2 more variables: `&gt;150k` &lt;dbl&gt;, `Don't know/refused` &lt;dbl&gt;, and
&gt; #   abbreviated variable names ¬π‚Äã`$10-20k`, ¬≤‚Äã`$20-30k`, ¬≥‚Äã`$30-40k`, ‚Å¥‚Äã`$40-50k`,
&gt; #   ‚Åµ‚Äã`$50-75k`, ‚Å∂‚Äã`$75-100k`, ‚Å∑‚Äã`$100-150k`
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```

**.bg-purple_light[TODO TUYO]**: ¬øes tidy o messy? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?

---

# Datos .orange[SUCIOS]: messy data

Veamos un segundo tipo de dato sucio: vamos a cargar la tabla `table2` del paquete `{tidyr}` (que ya lo tenemos cargado del entorno `{tidyverse}`). **.bg-purple_light[¬øQu√© falla?]**



```r
table2
```

```
&gt; # A tibble: 12 √ó 4
&gt;    country      year type            count
&gt;    &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;           &lt;int&gt;
&gt;  1 Afghanistan  1999 cases             745
&gt;  2 Afghanistan  1999 population   19987071
&gt;  3 Afghanistan  2000 cases            2666
&gt;  4 Afghanistan  2000 population   20595360
&gt;  5 Brazil       1999 cases           37737
&gt;  6 Brazil       1999 population  172006362
&gt;  7 Brazil       2000 cases           80488
&gt;  8 Brazil       2000 population  174504898
&gt;  9 China        1999 cases          212258
&gt; 10 China        1999 population 1272915272
&gt; 11 China        2000 cases          213766
&gt; 12 China        2000 population 1280428583
```


---

# Datos .orange[SUCIOS]: messy data

.pull-left[



```r
head(table2)
```

```
&gt; # A tibble: 6 √ó 4
&gt;   country      year type           count
&gt;   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;          &lt;int&gt;
&gt; 1 Afghanistan  1999 cases            745
&gt; 2 Afghanistan  1999 population  19987071
&gt; 3 Afghanistan  2000 cases           2666
&gt; 4 Afghanistan  2000 population  20595360
&gt; 5 Brazil       1999 cases          37737
&gt; 6 Brazil       1999 population 172006362
```

]

.pull-right[


&lt;img src="./img/table2.jpg" width="69%" style="display: block; margin: auto;" /&gt;
]


‚ùé Cada **.bg-orange[observaci√≥n/individuo en una fila]** diferente.


F√≠jate en las cuatro primeras filas: los registros con el mismo a√±o deber√≠an ser el mismo, es la misma informaci√≥n, **.bg-purple_light[deber√≠a estar en la misma fila]**, pero est√° dividada en dos. 

---


# Datos .orange[SUCIOS]: messy data

Lo que haremos ser√° lo opuesto a antes: con `pivot_wider()` ¬´ampliaremos¬ª la **.bg-purple_light[tabla a lo ancho]**, con menos filas pero con m√°s columnas.


```r
table2 %&gt;%
* pivot_wider(names_from = type, values_from = count)
```

```
&gt; # A tibble: 6 √ó 4
&gt;   country      year  cases population
&gt;   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
&gt; 1 Afghanistan  1999    745   19987071
&gt; 2 Afghanistan  2000   2666   20595360
&gt; 3 Brazil       1999  37737  172006362
&gt; 4 Brazil       2000  80488  174504898
&gt; 5 China        1999 212258 1272915272
&gt; 6 China        2000 213766 1280428583
```

* `names_from`: el **.bg-purple_light[nombre de la columna original]** de la que vamos a sacar las **.bg-purple_light[nuevas columnas]** que vamos a crear (`cases` y `population`).
* `values_from`: el **.bg-purple_light[nombre de la columna orignal]** de la que vamos a sacar los **.bg-purple_light[datos]**.


---

# Datos .orange[SUCIOS]: messy data


Por √∫ltimo veamos un tercer tipo de dato sucio: vamos a cargar la tabla `table3` del paquete `{tidyr}` (que ya lo tenemos cargado del entorno `{tidyverse}`). **.bg-purple_light[¬øQu√© falla?]**



```r
table3
```

```
&gt; # A tibble: 6 √ó 3
&gt;   country      year rate             
&gt; * &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;            
&gt; 1 Afghanistan  1999 745/19987071     
&gt; 2 Afghanistan  2000 2666/20595360    
&gt; 3 Brazil       1999 37737/172006362  
&gt; 4 Brazil       2000 80488/174504898  
&gt; 5 China        1999 212258/1272915272
&gt; 6 China        2000 213766/1280428583
```

--

‚ùé Cada **.bg-green_light[celda con un √∫nico valor]**.


---

# Datos .orange[SUCIOS]: messy data

Lo que haremos ser√° usar `separate()` para mandar **.bg-purple_light[cada valor a una columna diferente]**.


```r
*table3 %&gt;% separate(rate, into = c("cases", "pop"))
```

```
&gt; # A tibble: 6 √ó 4
&gt;   country      year cases  pop       
&gt;   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     
&gt; 1 Afghanistan  1999 745    19987071  
&gt; 2 Afghanistan  2000 2666   20595360  
&gt; 3 Brazil       1999 37737  172006362 
&gt; 4 Brazil       2000 80488  174504898 
&gt; 5 China        1999 212258 1272915272
&gt; 6 China        2000 213766 1280428583
```

* `into`: **.bg-purple_light[nombre de nuevas columnas]** donde separaremos valores.


&lt;img src="./img/seperate.jpg" width="40%" style="display: block; margin: auto;" /&gt;


---

# Datos .orange[SUCIOS]: messy data


Por defecto lo que hace es **.bg-purple_light[localizar como separador cualquier caracter que no sea alfa-num√©rico]**. Si queremos un caracter concreto para dividir podemos indic√°rselo expl√≠citamente. Si usas un separador que no est√° en los datos te devolver√° dichas columnas vac√≠as ya que no ha podido dividirlas.



```r
table3 %&gt;% separate(rate, into = c("cases", "population"), sep = ".")
```

```
&gt; Warning: Expected 2 pieces. Additional pieces discarded in 6 rows [1, 2, 3, 4,
&gt; 5, 6].
```

```
&gt; # A tibble: 6 √ó 4
&gt;   country      year cases population
&gt;   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt; &lt;chr&gt;     
&gt; 1 Afghanistan  1999 ""    ""        
&gt; 2 Afghanistan  2000 ""    ""        
&gt; 3 Brazil       1999 ""    ""        
&gt; 4 Brazil       2000 ""    ""        
&gt; 5 China        1999 ""    ""        
&gt; 6 China        2000 ""    ""
```

---

# Datos .orange[SUCIOS]: messy data

De la misma manera que podemos separar columnas tambi√©n podemos **.bg-purple_light[unir columnas]**. Para ello vamos a usar la tabla `table5` del ya mencionado paquete.


```r
table5
```

```
&gt; # A tibble: 6 √ó 4
&gt;   country     century year  rate             
&gt; * &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;            
&gt; 1 Afghanistan 19      99    745/19987071     
&gt; 2 Afghanistan 20      00    2666/20595360    
&gt; 3 Brazil      19      99    37737/172006362  
&gt; 4 Brazil      20      00    80488/174504898  
&gt; 5 China       19      99    212258/1272915272
&gt; 6 China       20      00    213766/1280428583
```

---

# Datos .orange[SUCIOS]: messy data

.pull-left[

Con la funci√≥n `unite()` vamos a **.bg-purple_light[unir]** el siglo (en `century`) y el a√±o (en `year`), y al inicio le indicaremos como se llamar√° la nueva variable `year_ok`


```r
table5 %&gt;%
  unite(col = year_ok,
        century, year, sep = "")
```

```
&gt; # A tibble: 6 √ó 3
&gt;   country     year_ok rate             
&gt;   &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt;            
&gt; 1 Afghanistan 1999    745/19987071     
&gt; 2 Afghanistan 2000    2666/20595360    
&gt; 3 Brazil      1999    37737/172006362  
&gt; 4 Brazil      2000    80488/174504898  
&gt; 5 China       1999    212258/1272915272
&gt; 6 China       2000    213766/1280428583
```

]

.pull-right[

&lt;img src="./img/unite.jpg" width="99%" style="display: block; margin: auto;" /&gt;

]


---

# Eliminando .orange[AUSENTES]

El paquete `{tidyr}` tambi√©n dispone de algunas herramientas √∫tiles para **.bg-purple_light[quitar ausentes]**


```r
datos &lt;- tibble(x = c(1, 2, NA), y = c("a", NA, "b"))
datos
```

```
&gt; # A tibble: 3 √ó 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 &lt;NA&gt; 
&gt; 3    NA b
```

---

# Eliminando .orange[AUSENTES]


Con `drop_na()` podemos indicarle que nos **.bg-purple_light[elimine las filas con alg√∫n ausente]** en alguna de las variables (o especificarle la variable concreta).


.pull-left[


```r
datos %&gt;% drop_na()
```

```
&gt; # A tibble: 1 √ó 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a
```

]


.pull-right[


```r
datos %&gt;% drop_na(x)
```

```
&gt; # A tibble: 2 √ó 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 &lt;NA&gt;
```

]

---

# Eliminando .orange[AUSENTES]

A veces no querremos eliminarlos sino **.bg-purple_light[imputar por el valor previo/siguiente]**  con `fill()`

.pull-left[


```r
datos %&gt;% fill(x)
```

```
&gt; # A tibble: 3 √ó 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 &lt;NA&gt; 
&gt; 3     2 b
```

```r
datos %&gt;% fill(x, .direction = c("up"))
```

```
&gt; # A tibble: 3 √ó 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 &lt;NA&gt; 
&gt; 3    NA b
```

]

.pull-right[


```r
datos %&gt;% fill(y)
```

```
&gt; # A tibble: 3 √ó 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 a    
&gt; 3    NA b
```

```r
datos %&gt;% fill(y, .direction = c("up"))
```

```
&gt; # A tibble: 3 √ó 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 b    
&gt; 3    NA b
```

]


---

# Eliminando .orange[AUSENTES]

Los **.bg-purple_light[ausentes]** tambi√©n pueden ser **.bg-purple_light[eliminados al pivotar]** con `values_drop_na`.



```r
stocks &lt;-
  tibble(qtr = 1:4,
         "2015" = c(1.88, 0.59, 0.35, NA),
         "2016" = c(NA, 0.92, 0.17, 2.66))
stocks
```

```
&gt; # A tibble: 4 √ó 3
&gt;     qtr `2015` `2016`
&gt;   &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;
&gt; 1     1   1.88  NA   
&gt; 2     2   0.59   0.92
&gt; 3     3   0.35   0.17
&gt; 4     4  NA      2.66
```

---

# Eliminando .orange[AUSENTES]

Los **.bg-purple_light[ausentes]** tambi√©n pueden ser **.bg-purple_light[eliminados al pivotar]** con `values_drop_na`.


```r
stocks %&gt;%
  pivot_longer(cols = c("2015", "2016"), names_to = "year",
               values_to = "return", values_drop_na = TRUE)
```

```
&gt; # A tibble: 6 √ó 3
&gt;     qtr year  return
&gt;   &lt;int&gt; &lt;chr&gt;  &lt;dbl&gt;
&gt; 1     1 2015    1.88
&gt; 2     2 2015    0.59
&gt; 3     2 2016    0.92
&gt; 4     3 2015    0.35
&gt; 5     3 2016    0.17
&gt; 6     4 2016    2.66
```

---

# Reemplazando .orange[AUSENTES]

Otras veces querremos **.bg-purple_light[imputar los ausentes por un valor fijo]**, algo que podemos hacer con `replace_na()`

.pull-left[


```r
datos
```

```
&gt; # A tibble: 3 √ó 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 &lt;NA&gt; 
&gt; 3    NA b
```

]

.pull-right[


```r
datos %&gt;%
  replace_na(list(x = -1,
                  y = "unknown"))
```

```
&gt; # A tibble: 3 √ó 2
&gt;       x y      
&gt;   &lt;dbl&gt; &lt;chr&gt;  
&gt; 1     1 a      
&gt; 2     2 unknown
&gt; 3    -1 b
```

]

---


# Completando .orange[AUSENTES]

Por √∫ltimo, tambi√©n podemos **.bg-purple_light[crear todas las combinaciones posibles de variables]** (para completar datos ausentes que se hayan podido eliminar).



```r
stocks &lt;- tibble(year = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),
                 qtr = c(1, 2, 3, 4, 2, 3, 4),
                 return = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66))
```

.pull-left[


```r
stocks
```

```
&gt; # A tibble: 7 √ó 3
&gt;    year   qtr return
&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
&gt; 1  2015     1   1.88
&gt; 2  2015     2   0.59
&gt; 3  2015     3   0.35
&gt; 4  2015     4  NA   
&gt; 5  2016     2   0.92
&gt; 6  2016     3   0.17
&gt; 7  2016     4   2.66
```

]

.pull-right[


```r
stocks %&gt;% complete(year, qtr)
```

```
&gt; # A tibble: 8 √ó 3
&gt;    year   qtr return
&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
&gt; 1  2015     1   1.88
&gt; 2  2015     2   0.59
&gt; 3  2015     3   0.35
&gt; 4  2015     4  NA   
&gt; 5  2016     1  NA   
&gt; 6  2016     2   0.92
&gt; 7  2016     3   0.17
&gt; 8  2016     4   2.66
```

]

---

name: oms

# .orange[CASO PR√ÅCTICO]: datos de la OMS

Instala el paquete `{tidyr}` y usa el conjunto `who` contenido en √©l mismo (sobre casos de tuberculosis). Lee la ayuda `? who` para detalles de los datos. Convierte a tidydata.


```r
# install.packages("tidyr")
library(tidyr)
who
```

```
&gt; # A tibble: 7,240 √ó 60
&gt;    country     iso2  iso3   year new_s‚Ä¶¬π new_s‚Ä¶¬≤ new_s‚Ä¶¬≥ new_s‚Ä¶‚Å¥ new_s‚Ä¶‚Åµ new_s‚Ä¶‚Å∂
&gt;    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;
&gt;  1 Afghanistan AF    AFG    1980      NA      NA      NA      NA      NA      NA
&gt;  2 Afghanistan AF    AFG    1981      NA      NA      NA      NA      NA      NA
&gt;  3 Afghanistan AF    AFG    1982      NA      NA      NA      NA      NA      NA
&gt;  4 Afghanistan AF    AFG    1983      NA      NA      NA      NA      NA      NA
&gt;  5 Afghanistan AF    AFG    1984      NA      NA      NA      NA      NA      NA
&gt;  6 Afghanistan AF    AFG    1985      NA      NA      NA      NA      NA      NA
&gt;  7 Afghanistan AF    AFG    1986      NA      NA      NA      NA      NA      NA
&gt;  8 Afghanistan AF    AFG    1987      NA      NA      NA      NA      NA      NA
&gt;  9 Afghanistan AF    AFG    1988      NA      NA      NA      NA      NA      NA
&gt; 10 Afghanistan AF    AFG    1989      NA      NA      NA      NA      NA      NA
&gt; # ‚Ä¶ with 7,230 more rows, 50 more variables: new_sp_m65 &lt;int&gt;,
&gt; #   new_sp_f014 &lt;int&gt;, new_sp_f1524 &lt;int&gt;, new_sp_f2534 &lt;int&gt;,
&gt; #   new_sp_f3544 &lt;int&gt;, new_sp_f4554 &lt;int&gt;, new_sp_f5564 &lt;int&gt;,
&gt; #   new_sp_f65 &lt;int&gt;, new_sn_m014 &lt;int&gt;, new_sn_m1524 &lt;int&gt;,
&gt; #   new_sn_m2534 &lt;int&gt;, new_sn_m3544 &lt;int&gt;, new_sn_m4554 &lt;int&gt;,
&gt; #   new_sn_m5564 &lt;int&gt;, new_sn_m65 &lt;int&gt;, new_sn_f014 &lt;int&gt;,
&gt; #   new_sn_f1524 &lt;int&gt;, new_sn_f2534 &lt;int&gt;, new_sn_f3544 &lt;int&gt;, ‚Ä¶
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

name: learning

&lt;img src="./img/ml_maths.jpg" width="80%" style="display: block; margin: auto;" /&gt;


---

# .orange[CIENCIA DE DATOS]


De lo general a la particular, **.bg-purple_light[¬øqu√© es la ciencia de datos]** ¬øQu√© incluye?

La conocida como Data Science (Ciencia de Datos) es un campo muy extenso en el que, seg√∫n algunos autores, se podr√≠a incluir (o intersecar con) campos como la **Miner√≠a de Datos**, el **Machine Learning** o el **Big Data**


&lt;img src="./img/stats_IA.jpg" width="40%" style="display: block; margin: auto;" /&gt;

üìö Ver definiciones en **.bg-green_light[Fern√°ndez-Casal et al. (2021)]** en &lt;https://rubenfcasal.github.io/aprendizaje_estadistico&gt;

---

# .orange[APRENDIZAJE] estad√≠stico

Uno de los conceptos clave es la idea de **.bg-purple_light[aprendizaje estad√≠stico]**: formularemos modelos que buscan **.bg-purple_light[aprender]** de los datos (teniendo en cuenta la incertidumbre subyacente), mejorando los resultados si **.bg-purple_light[aumentamos la calidad de la informaci√≥n]** (!= aumentar su tama√±o).

&amp;nbsp;

En ese aprendizaje normalmente realizaremos una **.bg-purple_light[partici√≥n preliminar de los datos]**:

--

- **.bg-purple_light[Entrenamiento]**: conjunto del que modelo **.bg-orange[aprender√° para su construcci√≥n]** (por ej., 70%).

--

- **.bg-purple_light[Validaci√≥n]**: conjunto que usaremos para **.bg-orange[evaluar nuestras decisiones]** (el modelo no ha podido aprender de √©l) y poder afinar los hiperpar√°metros (por ej., 20%).

--

- **.bg-purple_light[Test]**: conjunto final que nos proporcionar√° una **.bg-orange[evaluaci√≥n insesgada]** (por ej., 10%).

üìö Ver explicaci√≥n detallada en &lt;https://mlu-explain.github.io/train-test-validation/&gt;

---


# .orange[APRENDIZAJE] estad√≠stico

.pull-left[

Veamos un ejemplo: imagina que queremos construir un m√©todo que nos permita **.bg-purple_light[clasificar]** si un animal es un **.bg-purple_light[gato o perro]** en funci√≥n de dos variables: **suavidad** y **peso**. En concreto el aprendizaje ser√° **.bg-purple_light[supervisado]** (s√© a priori en mi dataset cu√°l es gato o perro).

]

.pull-right[

&lt;img src="./img/dogs_cats.jpg" width="85%" style="display: block; margin: auto auto auto 0;" /&gt;

]

üìö Ver explicaci√≥n en &lt;https://mlu-explain.github.io/train-test-validation/&gt;


---

# .orange[APRENDIZAJE] estad√≠stico


&lt;img src="./img/train_valid_test.jpg" width="45%" style="display: block; margin: auto;" /&gt;

.pull-left[


- **.bg-orange[Conjunto train]**: datos que el **modelo conocer√°** para **.bg-purple_light[aprender patrones]**, siendo lo m√°s representativo de mi conjunto global (para evitar la propagaci√≥n de sesgos)

]

.pull-right[

&lt;img src="./img/train_dataset.jpg" width="55%" style="display: block; margin: auto;" /&gt;

]

---

# .orange[APRENDIZAJE] estad√≠stico

.pull-left[

El aprendizaje no solo depender√° de los datos, tambi√©n de **.bg-purple_light[nuestras decisiones]**: cada decisi√≥n es un sesgo que acumulamos.

* un clasificador tonto (**.bg-green_light[dummy]**) que diga que todos son la moda (gatos)
* usar solo la variable suavidad
* usar solo la variable peso
* un clasificador que use ambas variables

**.bg-purple_light[¬øCu√°l elegir?]** Y si tuvi√©ramos m√°s variables, ¬øcon cu√°ntas?

&amp;nbsp;

**.bg-green_light[Clasificador dummy]**: asigna la moda (cuali)/media (cuanti) o bien un valor al azar, sin asumir patr√≥n alguno en los datos.

]

.pull-right[


.pull-left[

&lt;img src="./img/model_1.jpg" width="125%" style="display: block; margin: auto;" /&gt;

&lt;img src="./img/model_3.jpg" width="125%" style="display: block; margin: auto;" /&gt;

]

.pull-right[

&lt;img src="./img/model_2.jpg" width="135%" style="display: block; margin: auto;" /&gt;

&lt;img src="./img/model_4.jpg" width="145%" style="display: block; margin: auto;" /&gt;

]

]

---

# .orange[APRENDIZAJE] estad√≠stico


&lt;img src="./img/train_valid_test.jpg" width="45%" style="display: block; margin: auto;" /&gt;


.pull-left[


- **.bg-orange[Conjunto validation]**: datos que el modelo **no ha conocido** para aprender pero que usaremos para **.bg-purple_light[afinar y calibrar nuestras decisiones]**, de forma que sea **.bg-purple_light[independiente del entrenamiento]**

]

.pull-right[

&lt;img src="./img/validation_dataset.jpg" width="99%" style="display: block; margin: auto;" /&gt;

]

---

# .orange[APRENDIZAJE] estad√≠stico


&lt;img src="./img/train_valid_test.jpg" width="45%" style="display: block; margin: auto;" /&gt;


.pull-left[


- **.bg-orange[Conjunto test]**: datos que el **modelo no ha conocido**

‚ùé ni para aprender

‚ùé ni para afinar hiperpar√°metros/decisiones

Es un modelo que SOLO ser√° usado para una **.bg-purple_light[evaluaci√≥n final]** (insesgada): **.bg-red_light[NUNCA se usar√° en el proceso]**, solo cuando ya se ha terminado (simulando un cliente final).

]

.pull-right[

&lt;img src="./img/test_dataset.jpg" width="99%" style="display: block; margin: auto;" /&gt;

]


---

# .orange[APRENDIZAJE] estad√≠stico


.pull-left[


Si te fijas en este ejemplo, la **.bg-purple_light[m√©trica (tasa de bien clasificados)]** es superior en el conjunto de test que en el conjunto de validaci√≥n. **.bg-red_light[¬øEs malo? ¬øExtra√±o?]**

]

.pull-right[

&lt;img src="./img/test_vs_validation.jpg" width="97%" style="display: block; margin: auto;" /&gt;

]

--

No, no es ni malo ni extra√±o. Es m√°s, es un s√≠ntoma de que el conjunto de test no est√° sesgado a ninguna otra de las particiones

**.bg-green_light[RECUERDA]**: el √©xito del conjunto test **.bg-purple_light[NO es algo a optimizar]**, es simplemente una **.bg-purple_light[estimaci√≥n de c√≥mo funcionar√°]** nuestro modelo en datos reales.


---

# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]

En el campo del aprendizaje estad√≠stico (y por tanto en la miner√≠a de datos) ser√° recurrente un t√©rmino a evitar: **.bg-purple_light[sobrejauste]**.

&lt;img src="./img/bustamante.jpg" width="80%" style="display: block; margin: auto;" /&gt;

---

# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]

En el campo del aprendizaje estad√≠stico (y por tanto en la miner√≠a de datos) ser√° recurrente un t√©rmino a evitar: **.bg-purple_light[sobrejauste]**.


&amp;nbsp;

üìö Ver bibliograf√≠a en 

* ¬´The bias-variance tradeoff¬ª: &lt;https://mlu-explain.github.io/bias-variance/&gt;

* ¬´Understanding the bias-variance tradeoff¬ª:  &lt;https://towardsdatascience.com/understanding-the-bias-variance-tradeoff-165e6942b229&gt;

* ¬´Bias‚Äìvariance tradeoff¬ª: &lt;https://daviddalpiaz.github.io/r4sl/biasvariance-tradeoff.html&gt;

* ¬´Understanding the Bias-Variance Tradeoff¬ª: &lt;https://scott.fortmann-roe.com/docs/BiasVariance.html&gt;



---

# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]

Imagina que tenemos los siguientes ingredientes

* **.bg-purple_light[Modelo real]** `\(f(X)\)` donde `\(X\)` ser√°n los datos, con `\(\hat{f}(X)\)` las estimaciones.

--

* **.bg-purple_light[Output real]** que llamaremos `\(Y\)`

--

* **.bg-purple_light[Output estimada]** que llamaremos `\(\hat{Y}\)`, definido como `\(\hat{Y} = \hat{f}(X)\)`

--

* **.bg-purple_light[Error]** tras aplicar el modelo que llamaremos `\(E(x, f)\)`, y que podr√≠amos definir como la **.bg-purple_light[media de las equivocaciones al cuadrado]**

--

`$$Error := E(x, f) := {\rm E} \left[ \left(realidad - estimado\right)^2 \right] = {\rm E} \left[ \left(Y - \hat{Y}\right)^2 \right] = {\rm E}\left[\left(Y - \hat{f}(X)\right)^2  \right]$$`

&amp;nbsp;

--

¬øC√≥mo podemos **.bg-purple_light[descomponer el error]**?

---


# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]


* **Paso 1**: a√±adir y restar `\({\rm E} \left[ \hat{Y} \right]\)` dentro del par√©ntesis.

$$E(x, f) := {\rm E}\left[\left(Y - \hat{f}(X)\right)^2  \right] = {\rm E}\left[\left(\left(Y - {\rm E} \left[ \hat{Y} \right] \right) + \left( {\rm E} \left[ \hat{Y} \right] - \hat{f}(X)\right)^2 \right)  \right] $$

--

* **Paso 2**: resolver `\((a-c+c-b)^2 = ((a-c)+(c-b))^2 = (a-c)^2 + (c-b)^2 - 2*(a-c)(c-b)\)` 

$$E(x, f) := \left(Y - {\rm E} \left[ \hat{Y} \right] \right)^2  + {\rm E}\left[ \left( {\rm E} \left[ \hat{Y} \right] - \hat{f}(X)\right)^2 \right] + 2 {\rm E} \left[\left(Y - {\rm E} \left[ \hat{Y} \right] \right) \left( {\rm E} \left[ \hat{Y} \right] - \hat{f}(X)\right) \right] $$
--

* **Paso 3**: identificar t√©rminos

`$$E(x, f) := {\rm E}\left[\left(Y - \hat{f}(X)\right)^2  \right] = sesgo^2 + varianza + ruido$$`

---


# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]


* **.bg-red_light[Sesgo (bias)]** ser√° igual a `\(\left(Y - {\rm E} \left[ \hat{Y} \right] \right)^2\)` (diferencia - media - entre la predicci√≥n media del modelo y el valor correcto a predecir).

* **.bg-green_light[Varianza (variance)]** ser√° igual a `\({\rm E}\left[ \left( {\rm E} \left[ \hat{Y} \right] - \hat{f}(X)\right)^2 \right]\)` (la  dispersi√≥n/variaci√≥n entre las predicci√≥n individuales y la predicci√≥n media).

* **Ruido**: error aleatorio **irreducible** (depende de la variabilidad de los datos) de media nula.

--

&amp;nbsp;

El **.bg-red_light[sesgo]** ser√° por tanto lo que nos **.bg-red_light[equivocamos/desviamos de forma sistem√°tica]** y la **.bg-green_light[varianza]** del modelo ser√° la **.bg-green_light[dispersi√≥n entre las predicciones]** de un valor, como si repitieramos el modelo con distintas muestras aleatorias obtenidas de la misma poblaci√≥n. 

---

# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/bias_variance.jpg" alt="Extra√≠da de https://scott.fortmann-roe.com/docs/BiasVariance.html" width="40%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://scott.fortmann-roe.com/docs/BiasVariance.html&lt;/p&gt;
&lt;/div&gt;

---

# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]



.pull-left[

* **.bg-red_light[Bajoajuste (underfitting)]**: modelos **muy simples** proporcionan un **.bg-red_light[sesgo muy grande]**, y poca varianza ya que la predicci√≥n siempre ser√° muy parecida (errores altos en train).

* **.bg-green_light[Sobreajuste (overfitting)]**: modelos **muy complicados**  proporcionan un **.bg-green_light[sesgo bajo]** pero al ser tan complejas proporcionar√°n una **.bg-green_light[mayor varianza]** para cada intento (errores altos en test).

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/bias_varianc_tradeoff.jpg" alt="Extra√≠da de https://mlu-explain.github.io/bias-variance/" width="99%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://mlu-explain.github.io/bias-variance/&lt;/p&gt;
&lt;/div&gt;

Lo deseable ser√° encontrar ese **.bg-purple_light[punto √≥ptimo de equilibrio]** en el que el error ser√° m√≠nimo.

]

---

# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/train_test_underfitting.jpg" alt="Extra√≠da de https://mlu-explain.github.io/bias-variance/" width="99%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://mlu-explain.github.io/bias-variance/&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/simple_model.jpg" alt="Extra√≠da de https://mlu-explain.github.io/bias-variance/" width="99%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://mlu-explain.github.io/bias-variance/&lt;/p&gt;
&lt;/div&gt;

]

---

# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/train_test_overfitting.jpg" alt="Extra√≠da de https://mlu-explain.github.io/bias-variance/" width="99%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://mlu-explain.github.io/bias-variance/&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/complex_model.jpg" alt="Extra√≠da de https://mlu-explain.github.io/bias-variance/" width="99%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://mlu-explain.github.io/bias-variance/&lt;/p&gt;
&lt;/div&gt;

]


---

# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/overfitting.jpg" alt="Extra√≠da de https://365datascience.com/tutorials/machine-learning-tutorials/overfitting-underfitting/" width="60%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://365datascience.com/tutorials/machine-learning-tutorials/overfitting-underfitting/&lt;/p&gt;
&lt;/div&gt;

Un **.bg-purple_light[modelo muy simple no captura los patrones]** subyancetes en los datos mientras que un **.bg-purple_light[modelo muy complejo solo memoriza]**, no aprende.


---

# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]

&lt;img src="./img/meme_overfitting.jpg" width="45%" style="display: block; margin: auto;" /&gt;

---

# .green[SUPERVISADO] vs .orange[NO SUPERVISADO]

&lt;img src="./img/non_supervised.jpg" width="47%" style="display: block; margin: auto;" /&gt;


---

# .green[SUPERVISADO] vs .orange[NO SUPERVISADO]


.pull-left[

* **.bg-purple_light[Aprendizaje supervisado]**: tendremos dos tipos de variables, la **.bg-orange[variable dependiente (output/target)]** que se quiere predecir/clasificar (con su valor conocido en el conjunto de entrenamiento) y las **.bg-orange[variables independientes (inputs)]** o variables explicativas, que contienen la informaci√≥n disponible.

&amp;nbsp;

Todo lo que veremos en esta asignatura entra dentro de la idea de **aprendizaje supervisado**

]


.pull-right[


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/esquema_supervised.jpg" alt="Extra√≠da de https://realpython.com/knn-python/basics-of-machine-learning" width="110%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://realpython.com/knn-python/basics-of-machine-learning&lt;/p&gt;
&lt;/div&gt;


]

---

# .green[SUPERVISADO] vs .orange[NO SUPERVISADO]


.pull-left[


* **.bg-purple_light[Aprendizaje no supervisado]**: no existe la distinci√≥n entre target y variables explicativas ya que **.bg-orange[no tenemos etiquetados los datos]**, no sabemos a priori la respuesta correcta. El aprendizaje no supervisado buscar√° **.bg-orange[similitudes/diferencias]**.

]


.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/esquema_nonsupervised.jpg" alt="Extra√≠da de https://realpython.com/knn-python/basics-of-machine-learning" width="110%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://realpython.com/knn-python/basics-of-machine-learning&lt;/p&gt;
&lt;/div&gt;


]


---


hastie

---

name: data-mining

# .orange[DATA MINING]: ¬øqu√© es?

No hay una definici√≥n √∫nica o formal pero podemos ayudarnos de las definiciones dadas por algunos de los m√°ximos gigantes tecnol√≥gicos.

--

Seg√∫n **.bg-purple_light[IBM]**...

&gt; La miner√≠a de datos es una forma innovadora de obtener informaci√≥n comercial valiosa mediante el an√°lisis de los datos contenidos en la base de datos de la empresa (IBM)

--

&amp;nbsp;

Seg√∫n **.bg-purple_light[Microsoft]**...

&gt; La miner√≠a de datos es el proceso de detectar informaci√≥n procesable de grandes conjuntos de datos para deducir los patrones y tendencias que existen. Normalmente,
estos patrones no se pueden detectar mediante la exploraci√≥n tradicional de los datos
porque las relaciones son demasiado complejas o hay demasiados datos (Microsoft)

---

# .orange[DATA MINING]: ¬øqu√© es?

.pull-left[

La miner√≠a de datos tiene como objetivo  **.bg-purple_light[descubrir patrones]** de forma autom√°tica o semiautom√°tica, patrones que a simple vista (o con estad√≠stica b√°sica) no podemos aflorar, bien por contar con **.bg-orange[grandes conjuntos de datos]**, bien por existir **.bg-green_light[relaciones muy complejas]**.

&amp;nbsp;

No solo comprende la exploraci√≥n y el modelado, sino tambi√©n la **.bg-purple_light[evaluaci√≥n]** y la **.bg-purple_light[transformaci√≥n de la informaci√≥n]** para su uso posterior.

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/proceso-mineria-de-datos.png.webp" alt="Extra√≠da de https://www.masterdatascienceucm.com" width="90%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://www.masterdatascienceucm.com&lt;/p&gt;
&lt;/div&gt;


El **gran tama√±o muestral** suele hacer inviable la aplicaci√≥n de t√©cnicas de inferencia cl√°sica (problemas de potencia).

]

---

# .orange[DATA MINING]: ejemplos de uso


* **.bg-purple_light[Clasificaci√≥n de vuelos]**: usando, entre otras, variables de tr√°fico de aereo, tipolog√≠a de vuelo, variables meteorol√≥gicas, las aerol√≠neas pueden calcular la probabilidad de retraso en un vuelo.

* **.bg-purple_light[Marketing y ventas]**: conocer el perfil de p√∫blico objetivo para enfocar campa√±as personalizadas, en funci√≥n de patrones en su comportamiento, y predecir futuras bajas.

* **.bg-purple_light[Miner√≠a de textos]**: extracci√≥n de patrones en textos para clasificar, por ejemplo, noticias (detecci√≥n de Fake News).

* **.bg-purple_light[Supermercados]**: pueden analizar el conjunto de compras masivas que hacen sus clientes, para identificar asociaciones de productos o las ofertas que mejor han funcionado.

* **.bg-purple_light[Predicci√≥n de enfermedades]**: haciendo uso de diferente variables m√©dicas y de h√°bitos de salud se puede predecir la probabilidad de aparici√≥n de ciertas enfermedades, as√≠ como encontrar factores explicativos que nos puedan ayudar a su prevenci√≥n.


---



# SEMMA

En miner√≠a de datos tendremos habitualmente una variable con un rol especial


 In a typical scenario, we have
an outcome measurement, usually quantitative (such as a stock price) or
categorical (such as heart attack/no heart attack), that we wish to predict
based on a set of features (such as diet and clinical measurements). We
have a training set of data, in which we observe the outcome and feature

measurements for a set of objects (such as people). Using this data we build
a prediction model, or learner, which will enable us to predict the outcome
for new unseen objects. A good learner is one that accurately predicts such
an outcome.
The examples above describe what is called the supervised learning problem. It is called ‚Äúsupervised‚Äù because of the presence of the outcome variable to guide the learning process. In the unsupervised learning problem,
we observe only the features and have no measurements of the outcome.
Our task is rather to describe how the data are organized or clustered.

ejemplo mail libro hastie

Example 1: Email Spam
The data for this example consists of information from 4601 email messages, in a study to try to predict whether the email was junk email, or
‚Äúspam.‚Äù The objective was to design an automatic spam detector that
could filter out spam before clogging the users‚Äô mailboxes. For all 4601
email messages, the true outcome (email type) email or spam is available,
along with the relative frequencies of 57 of the most commonly occurring
words and punctuation marks in the email message. This is a supervised
learning problem, with the outcome the class variable email/spam. It is also
called a classification problem.
Table 1.1 lists the words and characters showing the largest average
difference between spam and email.
Our learning method has to decide which features to use and how: for
example, we might use a rule such as


---

# SEMMA 

La metodolog√≠a que se emplear√° en este proyecto ser√° la metodolog√≠a SEMMA. Es-
ta metodolog√≠a fue propuesta por el SAS Institute, el cual la define como el proceso de

selecci√≥n, exploraci√≥n y modelado aplicado a cantidades significativas de datos almace-
nados que permitan el descubrimiento de patrones como herramientas de apoyo para el

negocio. Esta metodolog√≠a est√° dividida en 5 fases detalladas a continuaci√≥n:


2.2. Metodolog√≠a
La metodolog√≠a SEMMA fue propuesta por el SAS Institute con la finalidad de
esquematizar el proceso de miner√≠a de datos (SAS Institute, 2018). El nombre es un
acr√≥nimo que recoge las iniciales de las siguientes cinco fases que propone esta t√©cnica
(ver tambi√©n Hern√°ndez y Due√±as, 2019):

* Sample (muestreo): extraer (si fuese necesario) un subconjunto representativo de nuestros datos con los que se realizar√° el estudio y, si fuese tambi√©n necesario, extraer una
muestra representativa con el fin de reducir la dimensi√≥n de los datos y optimizar el
proceso de modelizaci√≥n.


- Explore (Exploraci√≥n). Segunda fase de la metodolog√≠a en la que se realiza un estudio
de los datos obtenidos a trav√©s de t√©cnicas estad√≠sticas, con el objetivo de entender
mejor el problema, detectar datos an√≥malos o ausentes, as√≠ como de inconsistencias
en la base de datos.
- Modify (Transformaci√≥n). Tercera etapa del proceso en la que se modifican y tratan
los datos para solventar los problemas detectados en la etapa previa.

6
- Model (Modelizaci√≥n). Cuarta fase de la metodolog√≠a SEMMA en la que se utilizan
t√©cnicas y herramientas estad√≠sticas o de aprendizaje autom√°tico con la finalidad de
descubrir similitudes en los datos y lograr una predicci√≥n/clasificaci√≥n de la variable
objetivo (si la hubiera).
- Assess (Evaluaci√≥n). Es la √∫ltima etapa del proceso, en la que se debe valorar la
calidad del resultado obtenido en la fase de modelaje, haciendo uso de
metodolog√≠as de validaci√≥n o de submuestras de validaci√≥n o test, si fuese necesario.

Fig. 4: diagrama de las etapas de la metodolog√≠a SEMMA. Fuente: Blogdatlas

A continuaci√≥n se describen brevemente las t√©cnicas utilizadas y los objetivos a
conseguir en cada una de las etapas de la metodolog√≠a SEMMA en el trabajo.
2.2.1. Muestreo
En esta primera etapa de la metodolog√≠a SEMMA se ha realizado la extracci√≥n de los
datos con los que se realizar√° la clasificaci√≥n del retraso de los vuelos nacionales de
EE.UU. Para ello, se ha extra√≠do informaci√≥n de diversas fuentes y se ha monitorizado su
obtenci√≥n mediante la implementaci√≥n de funciones de R, combinadas con diferentes
API y t√©cnicas de web scrapping haciendo uso de Python. En un primer lugar se
obtuvieron 7 422 037 observaciones, pertenecientes a todos los vuelos nacionales en
Estados Unidos en el a√±o 2019 (ver detalles y fuente en la Secci√≥n 3), pero debido a la
uni√≥n de diferentes fuentes de informaci√≥n y procesos de depuraci√≥n, finalmente se
mantuvieron en la tabla 4 408 503 observaciones. Dicha reducci√≥n de la dimensi√≥n se
ha hecho imprescindible debido al alto volumen de datos y a la capacidad computacional
de los sistemas utilizados (toda la informaci√≥n sobre las funciones utilizadas se puede
consultar en el Anexo II). Como se indica adem√°s en futuras secciones, se han realizado
diferentes muestreos estratificados a posteriori, con el objetivo de reducir la
dimensionalidad del problema (y que pudiera ser abarcable con los medios inform√°ticos
disponibles).

[aida]

Existen distintas metodolog√≠as/esquemas dentro de la miner√≠a de datos. Destacan la
metodolog√≠a SEMMA (Sample-Explore-Modify-Model-Assess), desarrollada principalmente por
la empresa de software SAS, y CRISP-DM (Cross Industry Standard Process for Data Mining),
desarrollada, entre otros, por la empresa IBM. En este curso, nos centraremos en SEMMA:
SAMPLE (muestrear): Si la base de datos es demasiado grande, ser√° necesario tomar
una muestra lo suficientemente grande para contener toda la informaci√≥n y lo
suficientemente peque√±a para poder ser procesada.
EXPLORE (explorar): Es necesario explorar los datos para detectar relaciones,
anomalias y tendencias.
MODIFIY (modificar): Es recomendable modificar los datos creando, seleccionando y
transformando variables para facilitar la modelizaci√≥n.
MODEL (modelizar): Hallar el modelo que nos permita predecir la variable objetivo.
ASSESS (evaluar): Comprobar la calidad de las predicciones y comparar los modelos
obtenidos.
No siempre intervienen todas las fases del proceso. Adem√°s, las fases pueden repetirse y el
orden de las mismas puede modificarse.

---

name: sample

---

class: inverse center middle
name: clase-4

# CLASE 4:

---

# .orange[RECURSOS] y .green[BIBLIOGRAF√çA]

&amp;nbsp;


#### üìö **.bg-purple_light[Art√≠culos o libros]** cient√≠ficos que han sido sometidos a revisi√≥n por pares.

&amp;nbsp;

#### üîó **.bg-green_light[Recursos online]** recomendados

&amp;nbsp;

#### üíª Recursos para la **.bg-orange[programaci√≥n en R]**

---

# Bibliograf√≠a general

üìö **¬´Statistical tests, P values, confidence intervals, and power: a guide to misinterpretations¬ª**. Greenland et al. (2016) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bioestad/biblio/p-value_Greenland_etal_2016.pdf&gt;

üíª **Tidy Data Tutor**: para visualizar la mec√°nica interna de `{tidyverse}`. &lt;https://tidydatatutor.com/&gt;

üîó Web con recursos para la **introducci√≥n a la estad√≠stica y Machine Learning en R** &lt;https://artofstat.com/&gt;

üíª **Manual introductorio de R** (Javier √Ålvarez Li√©bana): &lt;https://dadosdelaplace.github.io/courses-intro-R/&gt;


---

# Bibliograf√≠a general

üìö **¬´The reproducibility of research and the misinterpretation of p-values¬ª**. Colquhoun (2017) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bioestad/biblio/p-values_Colquhoun_2017.pdf&gt;


üìö **¬´An Introduction to Multivariate Statistical Analysis¬ª**. Anderson (1958) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bioestad/biblio/introduction_mva_anderson_2003.pdf&gt;

üìö **¬´A New Measure of Rank Correlation¬ª**. Kendall (1938) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bioestad/biblio/correlation_kendall_1938.pdf&gt;

üìö **¬´The generalised product moment distribution in samples from a normal multivariate population¬ª**. Wishart (1928) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bioestad/biblio/multivariate_normal_wishart_1928.pdf&gt;

üìö **¬´On lines and planes of closest fit to systems of points in space¬ª**. Pearson (1901) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bioestad/biblio/fit_pearson_1901.pdf&gt;


---

# Recursos dataviz

### Dataviz

üìö **¬´Gram√°tica de las gr√°ficas: pistas para mejorar las representaciones de datos¬ª**. Sevilla (2005) &lt;http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf&gt;

üìö **¬´Quantitative Graphics in Statistics: A Brief History¬ª**. Beniger and Robyn (1978) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/graphics_beniger_robin_1978.pdf&gt;
 
 
üíª **¬´Analizando datos, visualizando informaci√≥n, contando historias¬ª** (curso de dataviz en R). √Ålvarez-Li√©bana y Valverde-Castilla (2022) &lt;https://dadosdelaplace.github.io/curso-dataviz-ECI-2022&gt;

üìö **¬´40 years of boxplots¬ª**. Wickham and Stryjewski (2011) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/boxplot_Wickham_Stryjewski_2011.pdf&gt;
 
 


---

# Bibliograf√≠a componentes principales

üíª **Componentes principales** en `{tidymodels}`. &lt;https://www.tmwr.org/dimensionality.html#beans&gt;


üìö **¬´Principal Component Analysis¬ª**. Jolliffe (2002) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/pca_jolliffe_2002.pdf&gt;

üìö **¬´Principal Component Analysis¬ª**. Herv√© and Lynne (2010) &lt;http://staff.ustc.edu.cn/~zwp/teach/MVA/abdi-awPCA2010.pdf&gt;

üìö **¬´Principal Component Analysis: a review and recent developments¬ª**. Jolliffe and Cadima (2016) &lt;https://royalsocietypublishing.org/doi/10.1098/rsta.2015.0202&gt;

üîó **¬´The Mathematics Behind Principal Component Analysis¬ª**. Dubey (2018).  &lt;https://towardsdatascience.com/the-mathematics-behind-principal-component-analysis-fff2d7f4b643&gt;


üîó **¬´A One-Stop Shop for Principal Component Analysis¬ª**. Brems (2017). &lt;https://towardsdatascience.com/a-one-stop-shop-for-principal-component-analysis-5582fb7e0a9c&gt;

üìö **¬´On the number of principal components: a test of dimensionality based on measurements of similarity between matrices¬ª**. Dray (2008) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/numer_pca_dray_2008.pdf&gt;


---

# Bibliograf√≠a an√°lisis cl√∫ster

üìö **¬´Multiclass classification of dry beans using computer vision and machine learning techniques¬ª**. Koklu y Ozkan (2020) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/multiclass_classif_koklu_ozlan_2020.pdf&gt;

üíª **¬´Clustering y heatmaps: aprendizaje no supervisado¬ª**. Amat (2017). &lt;https://rpubs.com/Joaquin_AR/310338&gt;

üíª **¬´K-means clustering with tidy data principles¬ª** &lt;https://www.tidymodels.org/learn/statistics/k-means/&gt;

üîó **¬´ISLR tidymodels Labs¬ª** &lt;https://emilhvitfeldt.github.io/ISLR-tidymodels-labs/unsupervised-learning.html#kmeans-clustering&gt;


üìö **¬´Algorithm AS 136: a K-Means Clustering Algorithm¬ª**. Hartigan y Wong (1979) &lt;http://www.jstor.org/stable/2346830&gt;

üîó **¬´Machine Learning for Social Scientists¬ª**. Cimentada (2020) &lt;https://cimentadaj.github.io/ml_socsci/unsupervised-methods.html&gt;

---
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"slideNumberFormat": "%current%",
"highlightStyle": "github",
"highlightLines": true,
"ratio": "16:9",
"countIncrementalSlides": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
