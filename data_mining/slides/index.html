<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>T√©cnicas de miner√≠a de datos</title>
    <meta charset="utf-8" />
    <meta name="author" content="Javier √Ålvarez Li√©bana (Fac. Estudios Estad√≠sticos - UCM)" />
    <link href="index_files/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="index_files/tile-view-0.2.6/tile-view.js"></script>
    <link href="index_files/animate.css-3.7.2/animate.xaringan.css" rel="stylesheet" />
    <link href="index_files/tachyons-4.12.0/tachyons.min.css" rel="stylesheet" />
    <link href="index_files/xaringanExtra-extra-styles-0.2.6/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <script src="index_files/clipboard-2.0.6/clipboard.min.js"></script>
    <link href="index_files/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="index_files/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Click para copiar c√≥digo","success":"C√≥digo copiado","error":"Ctrl+C para copiar"})</script>
    <link href="index_files/panelset-0.2.6/panelset.css" rel="stylesheet" />
    <script src="index_files/panelset-0.2.6/panelset.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# T√©cnicas de miner√≠a de datos
## M√°ster en Miner√≠a de Datos e Inteligencia de Negocio
### Javier √Ålvarez Li√©bana (Fac. Estudios Estad√≠sticos - UCM)
### √öltima actualizaci√≥n: 17-11-2022

---










class: inverse center middle

# ATAJOS DE LAS DIAPOSITIVAS





`$$\\[2in]$$`

.left[Pulsa &lt;kbd-black&gt;O&lt;/kbd-black&gt; para ver el **PANEL DE DIAPOSITIVAS**]
.left[Pulsa &lt;kbd-black&gt;H&lt;/kbd-black&gt; para ver **OTROS ATAJOS**]

---

# .orange[MATERIAL] de las clases


.pull-left[

- **.bg-purple_light[Diapositivas]** del curso:
&lt;https://dadosdelaplace.github.io/teaching/data_mining/slides&gt;

- **.bg-red_light[Evaluaci√≥n]** de la asignatura
&lt;https://github.com/dadosdelaplace/teaching/tree/main/data_mining/eval&gt;

- **.bg-yellow[Scripts]** de la asignatura
&lt;https://github.com/dadosdelaplace/teaching/tree/main/data_mining/scripts&gt;

- **.bg-orange[Bibliograf√≠a]**: &lt;https://github.com/dadosdelaplace/teaching/tree/main/data_mining/biblio&gt;

&amp;nbsp;

- **.bg-green_light[Manual introductorio de R]**: &lt;https://dadosdelaplace.github.io/courses-intro-R/&gt;

]

---

# Me presento: la turra

.pull-left[

&lt;img src="./img/me.jpeg" width="80%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

* **.bg-purple_light[Javier √Ålvarez Li√©bana]**, nacido en 1989 en Carabanchel Bajo (Madrid)

* Licenciado (UCM) en **Matem√°ticas** (Erasmus en Bologna mediante). **M√°ster (UCM) en Ingenier√≠a Matem√°tica** (2013-2014)


* **.bg-orange[Doctorado en estad√≠stica]** por la Universidad de Granada


* Encargado de la **visualizaci√≥n y an√°lisis de datos covid** de la Consejer√≠a de Salud del **Principado de Asturias**

]


Intentando eso de la **.bg-yellow[divulgaci√≥n]** por **Twitter** (**.bg-yellow[@dadosdelaplace]**) e **Instagram** (**.bg-yellow[@javieralvarezliebana]**)

---

name: objetivos

# .orange[OBJETIVOS] de la asignatura


El **.bg-purple_light[prop√≥sito]** de esta asignatura ser√° cuadruple

- **.bg-orange[Quitarnos el miedo]** a programar: a programar se aprende programando, no hace falta ser Julian Assange.

--

- Aprender las **.bg-orange[t√©cnicas b√°sicas de depuraci√≥n y exploraci√≥n]** datos, aprendiendo a implementarlas en un software estad√≠stico.

--

- Aprender las **.bg-orange[t√©cnicas b√°sicas de miner√≠a de datos]**, centr√°ndonos en las t√©cnicas de **.bg-orange[aprendizaje supervisado]**.

--

- Ser capaces de **.bg-orange[interpretar y evaluar]** nuestros modelos.

&amp;nbsp;

üìö Estas **diapositivas** han sido elaboradas con el propio `R` haciendo uso de los paquetes `{xaringan}`, `{xaringanExtra}` y `{xaringanthemer}`.

---

# .orange[EVALUACI√ìN] de la asignatura


La **.bg-purple_light[evaluaci√≥n]** del curso se har√° mediante entregas:

* El **.bg-orange[40% de la nota]** final corresponder√° a peque√±as **.bg-green_light[pr√°cticas individuales]** (entre 2 y 4 pr√°cticas) que se empezar√°n en clase y se completar√°n en casa (se deber√°n entregar ambos archivos).

* El otro **.bg-orange[40% de la nota]** vendr√° determinado por la entrega de **.bg-green_light[1-2 pr√°cticas grupales]** (m√≠nimo 3, m√°ximo 5 personas). Se podr√° solicitar a cualquier persona del grupo que explique el trabajo realizado en una tutor√≠a individual.

*  El otro **.bg-orange[20% de la nota]** se asignar√° en funci√≥n de un **.bg-green_light[datathon final]** que se realizar√° de forma grupal (m√≠nimo 2, m√°ximo 4 personas).

---

# .orange[EVALUACI√ìN] de la asignatura


* Para poder promediar nota es **.bg-red_light[obligatorio]** entregar **.bg-purple_light[todas las entregas individuales]** con una **.bg-green_light[nota superior al 3]** sobre 10, am√©n de participar en **.bg-purple_light[al menos una entrega grupal]**.

* Adem√°s la nota media de las entregas **.bg-red_light[individuales no podr√° ser un 50% inferior]** a la media de notas grupales.


* En caso de **.bg-red_light[no cumplir dichos requisitos]**, y/o haya faltado a m√°s de un tercio de las clases, tendr√° que presentarse a un examen final, cuya
nota ser√° el 100% de la nota del curso.

---

# .orange[CONTENIDOS] de la asignatura


- Las **.bg-purple_light[primeras clases]** las dedicaremos a una **.bg-orange[introducci√≥n de la programaci√≥n]** en R (ya que necesitaremos algunas nociones b√°sicas para poder funcionar) as√≠ como **.bg-orange[algunos conceptos b√°sicos de estad√≠stica]** (medidas de centralizaci√≥n, dispersi√≥n, sesgo/varianza, supervisado vs no supervisado, metolodog√≠a SEMMA, etc).

--

- Metodolog√≠as de **.bg-purple_light[aprendizaje supervisado]**:
  - Algoritmo de los **.bg-orange[k-vecinos (knn)]**: clasificaremos elementos en funci√≥n de la moda/media de los elementos m√°s cercanos.
  
  - **.bg-orange[√Årboles de decisi√≥n]**: clasificaremos elementos en funci√≥n de la moda/media de una partici√≥n final (hoja) tras segmentar nuestro espacio de variables (reglas de decisi√≥n).
  
  - **.bg-orange[Regresi√≥n lineal]**: realizaremos una predicci√≥n (variable continua) teniendo como inputs una colecci√≥n de variables continuas, asumiendo una relaci√≥n lineal.
  
  - **.bg-orange[Regresi√≥n log√≠stica y GLM]**: realizaremos una predicci√≥n continua de la probabilidad de que una variable cualitativa tome cada una de las categor√≠as (probabilidad de estar sano o enfermo, por ejemplo).
  
---

# .orange[EJEMPLOS] reales de alumnos



‚úàÔ∏è **.bg-purple_light[Clasificaci√≥n de vuelos]**: usando, entre otras, variables de tr√°fico de aereo, tipolog√≠a de vuelo, variables meteorol√≥gicas, se consigui√≥ clasificar el retraso (o no) de 4 millones de vuelos (TFM de Almudena Mar√≠a Moreno Maderuelo)

--

üì∞ **.bg-purple_light[Clasificaci√≥n de Fake News]**: usando t√©cnicas de miner√≠a de datos aplicadas a textos (miner√≠a de textos), se propuso clasificar noticias en verdaderas o falsas, analizando la frecuencia y sentimientos de las palabras analizadas, as√≠ como la relaci√≥n entre las palabras (TFM de Iv√°n Guarionex de Fr√≠as Chireno)

--

ü©∫ **.bg-purple_light[Predicci√≥n de diabetes]**: haciendo uso de diferente variables m√©dicas y de h√°bitos de salud sacados de la encuesta de salud p√∫blica de EE.UU., se pretende predecir la aparici√≥n o no de diabetes en personas adultos, y determinar posibles factores de riesgo (TFM de Mar√≠a Mart√≠nez Ramudo).

--

üó≥ **.bg-purple_light[Predicci√≥n de encuestas electorales]**: usando el promedio de diferentes encuestas, y considerando diferentes variables sociol√≥gicos (como el sesgo de las casas encuestadores), conseguir una predicci√≥n del % de voto de cada partido promediando por tama√±o de muestra y ventana temporal (TFM de Enric Palau Payeras)

---


class: inverse center middle

# CLASES

&amp;nbsp;

.pull-left[

#### [CLASE 1: INTRODUCCI√ìN A R](#clase-1)

#### [CLASE 2: PRIMEROS DATOS Y CONCEPTOS](#clase-2)

#### [CLASE 3: TIDYDATA](#clase-3)

#### [CLASE 4: INTRO A LA MINER√çA (SEMMA)](#clase-4)

#### [CLASE 5: PRIMER ALGORITMO (KNN)](#clase-5)

#### [CLASE 6: DEPURACI√ìN PARA KNN](#clase-6)

]

.pull-right[

#### [CLASE 7: MODELIZANDO CON TIDYMODELS (KNN)](#clase-7)

#### [CLASE 8: PROFUNDIZANDO EN TIDYMODELS (KNN)](#clase-8)

#### [CLASE 9: VALIDACI√ìN CRUZADA, SOBREMUESTREO Y DATAVIZ](#clase-9)

#### [CLASE 10: √ÅRBOLES DE CLASIFICACI√ìN/REGRESI√ìN](#clase-10)

]


---

class: inverse center middle
name: clase-1

# CLASE 1: introducci√≥n a R desde cero.

&amp;nbsp;

### [Instalaci√≥n](#instalacion)

### [¬øQu√© es R? Primeros pasos](#que-es-R)

### [Primeros ejercicios](#ejercicios1)

### [Variables num√©ricas y caracteres](#variables)

### [Variables l√≥gicas y de tipo fecha](#logicas)

### [Ejercicios](#ejercicios2)


---

name: instalacion

# Requisitos

Para la asignatura los √∫nicos **.bg-purple_light[requisitos]** ser√°n:

--

1. **.bg-orange[Conexi√≥n a internet]** (para la descarga de algunos datos y paquetes).

--

2. **.bg-orange[Instalar R]**: ser√° nuestro lenguaje, nuestro **.bg-yellow[castellano]** para poder ¬´comunicarnos con el ordenador. La descarga la haremos (gratuitamente) desde &lt;https://cran.r-project.org/&gt;

--

3. **.bg-orange[Instalar R Studio]**. De la misma manera que podemos escribir castellano en un Word o en un tuit, podemos usar **distintos IDE** (entornos de desarrollo integrados, nuestro Office), para que el trabajo sea m√°s c√≥modo. Nuestro **.bg-yellow[Word]** para nosotros ser√° **RStudio**.

.left[
  &lt;img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/cran-R.jpg" alt = "cran-R" align = "left" width = "460" style = "margin-top: 2vh"&gt;
]

.right[
  &lt;img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/R-studio.jpg" alt = "RStudio" align = "right" width = "460" style = "margin-top: 2vh;"&gt;
]


---

# Instalaci√≥n de R

El lenguaje `R` ser√° nuestra **.bg-purple_light[gram√°tica]**, nuestra ortograf√≠a y nuestro diccionario

.pull-left[



- **Paso 1**: entra en &lt;https://cran.r-project.org/&gt; y selecciona **.bg-purple_light[sistema operativo]**.

- **Paso 2**: para **.bg-purple_light[Mac]** basta con que hacer click en el archivo .pkg, y abrirlo una vez descargado. Para sistemas **.bg-purple_light[Windows]**, debemos clickar en `install R for the first time` y en la siguiente pantalla en `Download R for Windows`. Una vez descargado, abrirlo como cualquier archivo de instalaci√≥n.

- **Paso 3**: abrir el **ejecutable**.

]

.pull-right[

&lt;img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/cran-R.jpg" alt = "cran-R" align = "left" width = "900" style = "margin-top: 1vh"&gt;

]

**.bg-green_light[Consejito]**: siempre que tengas que descargar algo de CRAN (ya sea el propio R o un paquete), aseg√∫rate de tener conexi√≥n a **.bg-orange[internet]**.


---

# Primera operaci√≥n

Para comprobar que se ha instalado correctamente, tras abrir `R`, deber√≠as ver una **pantalla blanca** similar a esta (en realidad se llama **.bg-purple_light[consola]**). Vamos a escribir nuestra **.bg-orange[primera operaci√≥n]** en la consola:

.pull-left[

* A una variable llamada `a` le asignaremos el valor 1 (asignamos con `&lt;-`, como una flecha)


```r
# Una variable a con valor --&gt; 1
*a &lt;- 1
```

]

--

.pull-right[

* A otra variable llamada `b` le asignaremos el valor 2 (cambia a la izquierda el nombre, cambia a la derecha el valor).


```r
# Una variable b con valor --&gt; 2
*b &lt;- 2
```

]

--

.pull-left[

* Sumamos las variables haciendo `a + b`.


```r
# Primera operaci√≥n
a &lt;- 1 # Una variable a con valor --&gt; 1
b &lt;- 2 # Una variable b con valor --&gt; 2
*a + b
```
]

--

.pull-right[

* El resultado que nos devuelve ser√° `3`.


```
&gt; [1] 3
```

]

---

# .orange[INSTALACI√ìN] de RStudio

El **.bg-purple_ligth[Word]** que usaremos para trabajar y escribir en nuestro lenguaje ser√° **.bg-purple_ligth[RStudio]** (lo que se conoce como un **IDE**, un entorno integrado de desarrollo).

.pull-left[

* **Paso 1**: entra en la [web oficial de RStudio](https://www.rstudio.com/products/rstudio/download/#download) y selecciona la **.bg-purple_light[descarga gratuita]**.

* **Paso 2**: selecciona el ejecutable que te aparezca, acorde a tu sistema operativo.

* **Paso 3**: tras descargar el ejecutable, hay que abrirlo como otro cualquier otro ejecutable y dejar que **.bg-purple_light[termine la instalaci√≥n]**.

]

.pull-right[

&lt;img src="./img/R-studio.jpg" width="80%" style="display: block; margin: auto auto auto 0;" /&gt;


]

---

# .orange[ORGANIZACI√ìN] de RStudio

.pull-left[

&lt;img src="./img/inicio_rstudio_2.jpg" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

* **.bg-purple_light[Consola]**: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo c√≥digo que antes (la suma) en ella. La consola ser√° donde **.bg-orange[ejecutaremos √≥rdenes]** y **.bg-yellow[mostraremos resultados]**.
]

---

# .orange[ORGANIZACI√ìN] de RStudio

.pull-left[

&lt;img src="./img/inicio_rstudio_3.jpg" width="75%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

* **.bg-purple_light[Environment]** (entorno de variables): la pantalla peque√±a (puedes ajustar los m√°rgenes con el rat√≥n) que tenemos en la parte superior derecha. Nos mostrar√° las **variables que tenemos definidas, el tipo y su valor**.

]

---

# .orange[ORGANIZACI√ìN] de RStudio

.pull-left[

&lt;img src="./img/inicio_rstudio_4.jpg" width="85%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

* **.bg-purple_light[Panel multiusos]**: la ventana que tenemos en la parte inferior derecha no servir√° para buscar **.bg-orange[ayuda de funciones]**, adem√°s de para **.bg-yellow[visualizar gr√°ficos]**. 

]

---

name: que-es-R

# ¬øQu√© es R?


&lt;img src = "https://logos.turbio.repl.co/rlang.svg" alt = "Rstudio" align = "left" width = "300" style = "margin-top: 1vh;margin-right: 2rem;"&gt;

`R` es un **.bg-purple_light[lenguaje estad√≠stico]**, creado por y para la estad√≠stica, con 4 ventajas fundamentales:

--

* **.bg-purple_light[Software libre]** (como C++, Python, etc). no solo es gratis, sino que permite **.bg-orange[acceder libremente a c√≥digo ajeno]**.

--

* **.bg-purple_light[Lenguaje modular]**: en la instalaci√≥n que hemos realizado solo se ha instalado el m√≠nimo para poder funcionar. Al ser software libre, existen **.bg-orange[trozos de c√≥digo]** hechos por otras personas (**.bg-yellow[paquetes]**) que podemos instalar seg√∫n necesidades.

--

* **.bg-purple_light[Gran comunidad de usuarios]**: `R` tiene una comunidad de usuarios gigante para hacer estad√≠stica (Python tiene una comunidad m√°s enfocada al Machine Learning), con m√°s de 18 000 paquetes.

--

* **.bg-purple_light[Lenguaje de alto nivel]**. Los lenguajes de alto nivel, como `R` o `Python`, facilitan la programaci√≥n al usuario (menor curva de aprendizaje, aunque m√°s lentos en ejecuci√≥n).


---

# Paquetes en R

A lo largo del curso usaremos varios de esos **.bg-purple_light[paquetes]**, como por ejemplo el paquete `{ggplot2}`, un paquete para la elaboraci√≥n de **.bg-purple_light[visualizaciones de datos]**. Vamos a instalarlo (necesitamos internet para ello) con la orden `install.packages("ggplot")`


```r
install.packages("ggplot2")
```

&amp;nbsp;


&amp;nbsp;



La **.bg-purple_light[instalaci√≥n]** de un paquete es el equivalente a **.bg-orange[comprar a un libro]**: solo lo debemos hacer **la primera vez** que lo usemos en un ordenador. Una vez que tenemos comprado nuestro libro, para poder usarlo, simplemente debemos indicar al programa que nos lo **.bg-purple_light[acerque de la estanter√≠a]** con `library(ggplot2)`.


```r
library(ggplot2)
```

---

class: inverse center middle

**COMPRAR** libro --&gt; instalar un paquete (una sola vez) `install.packages()`
&lt;figure&gt;
&lt;img src = "https://cdn.cienradios.com/wp-content/uploads/sites/14/2020/09/Book-Depository-2.jpg" alt = "comprar-libros" align = "middle" width = "480" style = "margin-top: 1vh;"&gt;
&lt;/figure&gt;

**SELECCIONAR** libro (ya comprado) --&gt; acceder a un paquete instalado (en cada sesi√≥n que queramos usarlo) `library()`
&lt;figure&gt;
&lt;img src = "https://cdn.sincroguia.tv/uploads/programs/l/a/-/la-biblioteca-de-los-libros-rechazados-704306_SPA-77.jpg" alt = "comprar-libros-2" align = "middle" width = "480" style = "margin-top: 1vh;"&gt;
&lt;/figure&gt;


---

class: center middle

# .orange[CASOS REALES] de uso de R


.pull-left[

&lt;img src="./img/covid_isciii.jpg" width="97%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

&lt;img src="./img/momo_isciii.jpg" width="97%" style="display: block; margin: auto auto auto 0;" /&gt;


]

Las webs del Instituto de Salud Carlos III &lt;https://cnecovid.isciii.es/covid19/&gt; y &lt;https://momo.isciii.es/panel_momo/&gt; est√°n hechas con `R` (con `{shiny}` y `{plotly}` )

---

# .orange[CASOS REALES] de uso de R

.pull-left[

&lt;img src="./img/elpais_R.jpg" width="99%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

El **.bg-purple_light[equipo de datos]** (Borja Andrino, Kiko Llaneras y Daniele Grasso) trabaja con `R` para elaborar sus an√°lisis, desde los datos electorales hasta el cambio clim√°tico.

Es una de las razones por las que son capaces de realizar brillantes an√°lisis de grandes vol√∫menes de datos de forma r√°pida y √°gil: la **.bg-purple_light[automatizaci√≥n de procesos]** que nos permite programar en `R` puede ser fundamental para analizar datos que hasta entonces no pod√≠amos.

]


---

# .orange[Incel] vs excel

&lt;img src="./img/incel.jpg" width="75%" style="display: block; margin: auto;" /&gt;

---

class: inverse center middle

# ¬øPor qu√© .orange[NO] usamos Excel?

![](./img/meme_barco.jpg)

---

# ¬øPor qu√© .orange[NO] usamos Excel?

Excel es una **.bg-purple_light[hoja de c√°lculo]**, ni m√°s ni menos, y el propio **Microsoft desaconseja su uso** para el an√°lisis de datos. El Excel es una herramienta maravillosa para ser usada como una sencilla hoja de c√°lculo (llevar cuentas de tu familia, declaraci√≥n de Renta, planificar viajes, etc).

&amp;nbsp;

**.bg-red_light[NO EST√Å DISE√ëADO]** para ser una base de datos, y muchos menos pensado para generar un entorno flexible para el an√°lisis estad√≠stico:

* **.bg-red_light[Software de pago]**

* **.bg-red_light[Software cerrado]**: solo podemos hacer lo que Excel ha cre√≠do que interesante que podamos hacer.

* **.bg-red_light[Alto consumo de memoria]**.

* **.bg-red_light[No es universal]**: no solo es de pago sino que adem√°s, dependiendo de la versi√≥n que tengas de Excel, tendr√° un formato distinto para datos como fechas, teniendo incluso extensiones distintas.

---



# .red[EPIC FAILS] en Excel

Problemas de **.red[versiones]**


&lt;img src="./img/excel_genes.jpg" width="37%" style="display: block; margin: auto auto auto 0;" /&gt;


üìö Ver **.bg-green_light[bibliograf√≠a]** en &lt;https://github.com/dadosdelaplace/teaching/tree/main/data_mining/biblio&gt;


---

# .red[EPIC FAILS] en Excel

Problemas de **.red[memoria]**

&lt;img src="./img/excel_uk.jpg" width="50%" style="display: block; margin: auto auto auto 0;" /&gt;


üìö Ver **.bg-green_light[bibliograf√≠a]** en &lt;https://github.com/dadosdelaplace/teaching/tree/main/data_mining/biblio&gt;


---

# .red[EPIC FAILS] en Excel

Problemas de **.red[codificaci√≥n]**

&lt;img src="./img/excel_edades.jpg" width="50%" style="display: block; margin: auto auto auto 0;" /&gt;

üìö Ver **.bg-green_light[bibliograf√≠a]** en &lt;https://github.com/dadosdelaplace/teaching/tree/main/data_mining/biblio&gt;

---

name: primeros-pasos

# Primeros pasos en R: .orange[CALCULADORA]

Empecemos por lo sencillo: **.bg-purple-light[¬øc√≥mo usar R como una calculadora?]** Si escribimos `2 + 1` en la consola y pulsamos ENTER, la consola nos mostrar√° el resultado de la suma.


```r
2 + 1
```

```
&gt; [1] 3
```

--

Si dicha suma la quisi√©ramos utilizar para un segundo c√°lculo: ¬øy si la **.bg-purple-light[almacenamos en alguna variable]**? Por ejemplo, vamos a guardar la suma en una variable `x`


```r
*x &lt;- 2 + 1
```

--

Si te fijas ahora `x` aparece definida en nuestro **.bg-yellow[environment]**, y puede ser usada de nuevo


```r
x + 3
```

```
&gt; [1] 6
```

---

# Primeros pasos en R: .orange[CALCULADORA]

### Multiplicaci√≥n


```r
*x * y
```

### Elevar al cuadrado


```r
*x^2
```

### Valor absoluto


```r
*abs(x)
```

---

# .red[Errores]

Durante tu aprendizaje va a ser **muy habitual** que las cosas no salgan a la primera, apareciendo en consola **.bg-purple_light[mensajes de error]** en un **.bg-red_light[color rojo]**. No te asustes: lo peor que puede pasar es que tengas que reiniciar `R`).

&amp;nbsp;

* Mensajes de **.bg-red_light[ERROR]**: ir√°n precedidos de la frase **.bg-yellow[¬´Error in‚Ä¶¬ª]**, y ser√°n aquellos fallos que **impidan la ejecuci√≥n del c√≥digo** 


```r
"a" + 1 # intentando sumar 1 a un texto
```

```
&gt; Error in "a" + 1: argumento no-num√©rico para operador binario
```

&amp;nbsp;

**.bg-green_light[CONSEJO]**: lee siempre los mensajes de error para aprender de ellos (ya que suelen dar pistas de c√≥mo resolverlos).

---

# .red[Errores]

Durante tu aprendizaje va a ser **muy habitual** que las cosas no salgan a la primera, apareciendo en consola **.bg-purple_light[mensajes de error]** en un **.bg-red_light[color rojo]**. No te asustes: lo peor que puede pasar es que tengas que reiniciar `R`).

&amp;nbsp;
 
* Mensajes de **.bg-orange[WARNING]**: ir√°n precedidos de la frase **.bg-yellow[¬´Warning in‚Ä¶¬ª]**, y son los fallos m√°s delicados ya que son posibles incoherencias pero sin que tu c√≥digo deje de ejecutarse.


```r
sqrt(-1) # raiz cuadrada de n√∫mero negativo
```

```
&gt; Warning in sqrt(-1): Se han producido NaNs
```

```
&gt; [1] NaN
```

&amp;nbsp;

**¬øHa ejecutado la orden?** S√≠, pero te advierte de que el resultado de la operaci√≥n es un `NaN`, **Not A Number**, un valor que no existe (al menos dentro de los n√∫meros reales).


---

# ¬øD√≥nde programamos? .orange[SCRIPTS]

Un **.bg-purple_light[script]** ser√° el documento en el que programamos, nuestro equivalente a un archivo .doc, pero aqu√≠ ser√° un archivo con extensi√≥n `.R`, donde **escribiremos las √≥rdenes**. Para **.bg-purple_light[abrir nuestro primero script]**, haz click en el men√∫ superior en `File &lt;&lt; New File &lt;&lt; R Script`.

&amp;nbsp;


.pull-left[


&lt;img src="./img/inicio_rstudio_5.jpg" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

**.bg-green_light[CONSEJO]**: intenta no abusar de la consola, ya que todo lo que no escribas en un script, cuando cierres `RStudio`, lo **habr√°s perdido** (c√≥mo si en lugar de escribir en un Word y guardarlo, nunca guardases el documento).

]

---

# ¬øD√≥nde programamos? .orange[SCRIPTS]

Ahora tenemos una **cuarta ventana**: la ventana donde **escribiremos nuestros c√≥digos**


### **¬øC√≥mo ejecutar nuestro script?**

.pull-left[

&lt;img src="./img/inicio_rstudio_6.jpg" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

1. **.bg-purple_light[Escribimos el c√≥digo]** a ejecutar.

2. **.bg-purple_light[Guardamos]** el archivo `.R` haciendo click en `Save current document`.

3. El c√≥digo **no se ejecuta salvo que se lo indiquemos**. Tenemos tres opciones:
  - **.orange[Copiar y pegar]** en consola.
  - **.orange[Seleccionar l√≠neas]** y clickar en `Run`.
  - Activar `Source on save` a la **derecha de guardar**: no solo guarda sino que ejecuta el c√≥digo completo.

]

---

name: ejercicios1

# Primeros ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: a√±ade debajo otra l√≠nea para definir una variable `b` con el valor `5`. Tras asignarles valores, multiplica los n√∫meros en consola.


```r
a &lt;- 2
```

* üìù **Ejercicio 2**: modifica el c√≥digo inferior para definir dos variables `c` y `d`, con valores 3 y -1.


```r
c &lt;- # deber√≠as asignarle el valor 3
d &lt;- # deber√≠as asignarle el valor -1
```

* üìù **Ejercicio 3**: con las variables `a` y `b` del ej. 1, crea una nueva variable `e` guardando el resultado de su multiplicaci√≥n `a * b`. Escribe `e` en consola para ver su resultado

]

.panel[.panel-name[Soluci√≥n ej. 1]


```r
# Para poner comentarios en el c√≥digo se usa #

# Definici√≥n de variables
a &lt;- 2
b &lt;- 5

# Multiplicaci√≥n
a * b
```

```
&gt; [1] 10
```
]

.panel[.panel-name[Soluci√≥n ej. 2]


```r
# Definici√≥n de variables
c &lt;- 3
d &lt;- -1
```
]

.panel[.panel-name[Soluci√≥n ej. 3]


```r
# Variables
a &lt;- 2
b &lt;- 5

# Resultado
e &lt;- a * b

# Muestro en consola
e
```

```
&gt; [1] 10
```

]
]

---

# Primeros ejercicios


.panelset[
.panel[.panel-name[Ejercicios extra]


* üìù **Ejercicio 4**: asigna un valor positivo a `x` y calcula su ra√≠z cuadrada; asigna otro negativo y calcula su valor absoluto con la funci√≥n `abs()`.


* üìù **Ejercicio 5**: usando la variable `x` ya definida, completa/modifica el c√≥digo inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.


```r
z &lt;- ? - ? # completa el c√≥digo
z
```

* üìù **Ejercicio 6**: usando las variables `x` e `y` ya definidas, calcula el m√°ximo de ambas (funci√≥n `max()`), y gu√°rdalo en una nueva variable `t`.

]

.panel[.panel-name[Soluci√≥n ej. 4]


```r
# Ra√≠z cuadrada
x &lt;- 73 # por ejemplo
sqrt(x)
```

```
&gt; [1] 8.544004
```

```r
# Valor absoluto
y &lt;- -19 # por ejemplo
abs(y)
```

```
&gt; [1] 19
```
]

.panel[.panel-name[Soluci√≥n ej. 5]


```r
z &lt;- x - 5
z
```

```
&gt; [1] 68
```
]

.panel[.panel-name[Soluci√≥n ej. 6]


```r
t &lt;- max(x, y)
t
```

```
&gt; [1] 73
```

]
]


---


name: variables

# De la .orange[celda] a la .green[tabla]
 

¬øDe qu√© tipo pueden ser los datos que tenemos contenidos en cada celda de una ¬´tabla¬ª?


&lt;img src="./img/celdas.jpg" width="55%" style="display: block; margin: auto;" /&gt;

* **.bg-purple_light[Celda]**: un dato **.bg-orange[individual]** de un tipo concreto.
* **.bg-purple_light[Variable]**: una **.bg-orange[concatenaci√≥n de valores]** del mismo tipo (**vectores**).
* **.bg-purple_light[Matriz]**: **.bg-orange[concatenaci√≥n de variables]** del **.bg-yellow[mismo tipo]** y longitud.
* **.bg-purple_light[Tabla]**: **.bg-orange[concatenaci√≥n de variables]** de **.bg-yellow[distinto tipo]** pero igual longitud.

---

# .orange[Celdas]: tipos de datos individuales

¬øExisten **variables m√°s all√° de los n√∫meros**?

&amp;nbsp;

Piensa por ejemplo en los **datos guardados de una persona**:

* La edad o el peso ser√° un **.bg-purple_light[n√∫mero]**.
* Su nombre ser√° una cadena de **.bg-purple_light[texto]**.
* Su fecha de nacimiento ser√° precisamente eso, una **.bg-purple_light[fecha]**.
* A la pregunta ¬´¬øest√° usted soltero/a?¬ª la respuesta ser√° lo que llamamos una **.bg-purple_light[variable l√≥gica]** (`TRUE` si est√° soltero/a o `FALSE` en otro caso).

&lt;img src="./img/celdas.jpg" width="40%" style="display: block; margin: auto;" /&gt;

---

# Variables .orange[NUM√âRICAS]

El **dato m√°s sencillo**, dato que ya hemos usado en nuestros primeros pasos como calculadora, ser√°n las variables que guardan simplemente n√∫meros


```r
a &lt;- 1
b &lt;- 2
a + b
```

```
&gt; [1] 3
```

--

En el c√≥digo anterior, tanto `a` como `b` como la suma `a + b` son de **.bg-purple_light[tipo num√©rico]**


```r
*class(a)
```

```
&gt; [1] "numeric"
```

```r
*typeof(a)
```

```
&gt; [1] "double"
```


---

# Variables .orange[NUM√âRICAS]

Como ya hemos visto, con los datos num√©ricos podemos realizar todas las **.bg-purple_light[operaciones aritm√©ticas]** que se nos ocurrir√≠a hacer en una **calculadora** como sumar (`+`), restar (`-`), multiplicar (`+`), dividir (`/`), ra√≠z cuadrada (`sqrt()`), valor absoluto (`abs()`), elevar al cuadrado (`^2`), elevar al cubo (`^3`), etc.




```r
a &lt;- 5
a^3 # Elevar al cubo
```

```
&gt; [1] 125
```


```r
b &lt;- -43
abs(b) # valor absoluto
```

```
&gt; [1] 43
```

---

# Variables de .orange[TEXTO]

No solo de n√∫meros viven los datos: imagina que adem√°s de la edad de una persona queremos **guardar su nombre** (**.bg-purple_light[tipo caracter]**: una **cadena de texto**)


```r
*nombre &lt;- "Javier"
class(nombre)
```

```
&gt; [1] "character"
```

--

Las cadenas de texto son un **tipo especial de dato** con los que obviamente no podremos hacer operaciones aritm√©ticas (pero s√≠ **.bg-purple_light[otras operaciones]** como pegar o localizar patrones).


```r
nombre + 1 # error al sumar n√∫mero a texto
```

```
&gt; Error in nombre + 1: argumento no-num√©rico para operador binario
```

&amp;nbsp;

--

**.bg-green_light[IMPORTANTE]**: las variables de tipo texto van **.bg-red_light[SIEMPRE ENTRE comillas]**.


---

name: primer-paquete

# .orange[PRIMERA FUNCI√ìN]: paste

Una **.bg-purple_light[funci√≥n]** es un **trozo de c√≥digo encapsulado** bajo un nombre, que depende de unos **.bg-purple_light[argumentos de entrada]**.

--

Nuestra primera funci√≥n ser√° `paste()`: dadas dos cadenas de texto como argumento de entrada nos permite pegarlas, indic√°ndole en el argumento `sep = ` el caracter que queremos entre medias.


```r
# todo junto, sin espacios, igual a paste0("Javier", "√Ålvarez")
paste("Javier", "√Ålvarez", sep = "") 
```

```
&gt; [1] "Javier√Ålvarez"
```




```r
paste("Javier", "√Ålvarez", sep = "?*?") # separados por un ?*?
```

```
&gt; [1] "Javier?*?√Ålvarez"
```


---

# .orange[PRIMERA FUNCI√ìN]: paste



```r
*paste("Javier", "√Ålvarez")
```

```
&gt; [1] "Javier √Ålvarez"
```

Por defecto, `paste()` a√±ade un espacio, es decir, `sep = " "`. Muchas funciones en `R` tendr√°n lo que llamamos **.bg-purple_light[argumentos por defecto]**, el valor que tomar√° sino se le asigna otro. Puedes mirar la **.bg-green_light[ayuda de la funci√≥n]** escribiendo en consola `? paste`

Existe una funci√≥n similar llamada `paste0()` que pega por defecto con `sep = ""` (sin nada).


```r
paste0("Javier", "√Ålvarez") 
```

```
&gt; [1] "Javier√Ålvarez"
```

```r
paste("Javier", "√Ålvarez", sep = "") 
```

```
&gt; [1] "Javier√Ålvarez"
```

---

# .orange[PRIMER PAQUETE]: glue

Otra forma **m√°s intuitiva de trabajar con textos** es usar el **paquete** `{glue}`.


```r
library(glue) # solo la 1¬™ vez install.packages("glue")
```

--

Con dicho paquete podemos **.bg-purple_light[usar variables dentro de cadenas]** de texto. Por ejemplo, la frase ¬´la edad es de ... a√±os¬ª, donde la edad concreta la tenemos guardada en una variable.


```r
edad &lt;- 33
*glue("La edad es de {edad} a√±os")
```

```
&gt; La edad es de 33 a√±os
```

Dentro de las llaves tambi√©n podemos ejecutar operaciones


```r
unidades &lt;- "d√≠as"
*glue("La edad es de {edad * 365} {unidades}")
```

```
&gt; La edad es de 12045 d√≠as
```

---


# .orange[VECTORES]: concatenaci√≥n

¬øY si en lugar de querer almacenar un solo elemento, por ejemplo , tenemos una **colecci√≥n de elementos**?

Hasta ahora solo hemos operado con el contenido de las **celdas**, pero cuando trabajamos con datos normalmente tendremos columnas que representan variables o caracter√≠sticas: llamaremos **.bg-purple_light[vectores]** a una **.bg-orange[concatenaci√≥n]** de variables del **.bg-orange[mismo tipo]**
 
--

La forma m√°s sencilla es con el comando `c()` (c de concatenar), y basta con introducir sus **elementos entre par√©ntesis y separados por comas** (por ejemplo, la edad de 4 personas).


```r
*edades &lt;- c(33, 27, 60, 61)
edades
```

```
&gt; [1] 33 27 60 61
```


&amp;nbsp;

--

**.bg-green_light[IMPORTANTE]**: un n√∫mero individual (`x &lt;- 1`) es en realidad un vector de longitud uno. 

---

# .orange[VECTORES]: concatenaci√≥n


Como ves ahora en el `environment` tenemos una **.bg-purple_light[colecci√≥n de elementos]** guardada

.pull-left[


```r
edades
```

```
&gt; [1] 33 27 60 61
```

]


.pull-right[
&lt;img src="./img/vectores_enviroment.jpg" width="80%" style="display: block; margin: auto auto auto 0;" /&gt;
]

--

.pull-left[

La **.bg-purple_light[longitud de un vector]** se puede calcular con `length()`


```r
*length(edades)
```

```
&gt; [1] 4
```

]


.pull-right[

Tambi√©n podemos **.bg-purple_light[concatenar vectores]**


```r
c(edades, edades, 8)
```

```
&gt; [1] 33 27 60 61 33 27 60 61  8
```

]

---

# Vectores: .orange[SECUENCIAS NUM√âRICAS]

En muchas ocasiones querremos **.bg-purple_light[crear secuencias num√©ricas]** mucho m√°s r√°pido (por ejemplo, un vector con los d√≠as del mes). El comando `seq()` nos permite crear una **secuencia** desde un elemento inicial hasta un elemento final, avanzando de uno en uno.


```r
seq(1, 31)
```

```
&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
&gt; [26] 26 27 28 29 30 31
```

--

El comando `1:n` nos devuelve lo mismo que la orden `seq(1, n)`. Adem√°s, si el elemento inicial es mayor que el final, `R` entender√° solo que la secuencia es **decreciente**.


```r
n &lt;- 5
n:1
```

```
&gt; [1] 5 4 3 2 1
```

---

# Vectores: .orange[SECUENCIAS NUM√âRICAS]

Tambi√©n podemos definir **.bg-purple_light[otro tipo de distancia]** (**.bg-orange[paso de discretizaci√≥n]**) entre dos elementos consecutivos


```r
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
```

```
&gt;  [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0
```

--

Otras veces nos interesar√° definir una **.bg-purple_light[secuencia con un n√∫mero concreto]** de elementos.


```r
seq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7
```

```
&gt; [1]  1.000000  9.166667 17.333333 25.500000 33.666667 41.833333 50.000000
```

--

Tambi√©n podemos crear **.bg-purple_light[vectores de elementos repetidos]** con la funci√≥n `rep()`


```r
rep(0, 7) # vector de 7 ceros
```

```
&gt; [1] 0 0 0 0 0 0 0
```


---

# .green[OPERACIONES] .orange[ARITM√âTICAS]
 
Dado que un **.bg-purple_light[n√∫mero es un vector]** de longitud 1, toda **.bg-orange[operaci√≥n aritm√©tica]** (suma, resta, multiplicaci√≥n, etc) que podamos hacer con un n√∫mero la vamos a poder a hacer con un vector de n√∫meros.

--

Si hacemos por ejemplo la operaci√≥n `2 * x`, siendo `x` un vector, lo que suceder√° es que la operaci√≥n se realizar√° en **.bg-purple_light[CADA ELEMENTO]** del vector (una sola l√≠nea de c√≥digo paro realizar operaciones en 10, 20, 1000 o 100000 elementos).


```r
# Multiplicamos por 2 a CADA ELEMENTO del vector
x &lt;- c(2, 4, 6)
*2 * x
```

```
&gt; [1]  4  8 12
```

--

&amp;nbsp;

**.bg-green_light[IMPORTANTE]**: el **.bg-purple_light[resultado]** de una operaci√≥n aritm√©tica sobre un vector ser√° **.bg-orange[otro vector]**.

---

# .green[OPERACIONES] .orange[ARITM√âTICAS]
 
 
De la misma manera podemos **.bg-purple_light[sumar o restar una constante]** al vector


```r
# Sumamos 3 a CADA ELEMENTO DEL VECTOR
x + 3
```

```
&gt; [1] 5 7 9
```

--

Los vectores tambi√©n pueden **.bg-purple_light[interactuar entre ellos]**, as√≠ que podemos definir sumas de vectores, como `x + y`


```r
y &lt;- c(1, 3, 5)

# suma de vectores 
*x + y
```

```
&gt; [1]  3  7 11
```

--

**.bg-green_light[IMPORTANTE]**: salvo que especifiquemos lo contrario, toda operaci√≥n aritm√©tica que hagas a un vector ser√° **.bg-purple_light[elemento a elemento]**.

 
---


# .green[OPERACIONES] con .orange[AUSENTES]

Imagina que tenemos un vector de temperaturas pero varios de los d√≠as el aparato de medici√≥n no funcionaba, por lo que tenemos un **.bg-purple_light[dato ausente]** marcado como `NA`.


```r
x &lt;- c(21, NA, 13, NA, NA, 25, 36, 17, 19, 5)
sum(x)
```

```
&gt; [1] NA
```

--

Dado que hay d√≠as que no tenemos disponibles, la suma tampoco la podemos conocer.  Para evitar que nos impida hacer ciertas operaciones, en muchas funciones de `R` podemos a√±adir el **argumento** `na.rm = TRUE`: primero elimina ausentes, y luego ejecuta la funci√≥n.


```r
# eliminando datos ausentes antes de aplicar la funci√≥n
*sum(x, na.rm = TRUE)
```

```
&gt; [1] 136
```

```r
mean(x, na.rm = TRUE)
```

```
&gt; [1] 19.42857
```


---

# .green[OPERACIONES] con .orange[AUSENTES]

Para **comprobar** si tenemos un **dato ausente**  podemos hacer uso de la funci√≥n `is.na()`


```r
is.na(x)
```

```
&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE
```

--

Tambi√©n puede aparecernos un **.bg-purple_light[resultado no permitido]**, marcado como `NaN` (not a number): no es un dato ausente, es un dato resultado de una **operaci√≥n no permitida**.


```r
x &lt;- c(1, NA, 3, 4, 6, 7, sqrt(-1), NA)
x
```

```
&gt; [1]   1  NA   3   4   6   7 NaN  NA
```

```r
is.nan(x)
```

```
&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE
```


---

# .orange[SELECCIONAR] elementos

Otra operaci√≥n muy habitual es la **.bg-purple_light[extraer un subconjunto del mismo]**. La forma m√°s sencilla es **usar el operador de selecci√≥n** `[i]` para **acceder al elemento i-√©simo**


```r
edades &lt;- c(20, 30, 33, NA, 61)

# accedemos a la edad de la tercera persona en la lista
*edades[3]
```

```
&gt; [1] 33
```

```r
# accedemos a la edad de la cuarta persona
edades[4]
```

```
&gt; [1] NA
```

---

# .orange[SELECCIONAR] elementos

Un n√∫mero no es m√°s que un vector de longitud uno, as√≠ que esta operaci√≥n tambi√©n la podemos aplicar usando un **.bg-purple_light[vector de √≠ndices a seleccionar]**


```r
# Tercer y cuarto elemento
*edades[c(3, 4)]
```

```
&gt; [1] 33 NA
```

--

Esta l√≥gica para acceder a elementos tambi√©n sirve para **vectores de caracteres**.


```r
y &lt;- c("hola", "qu√©", "tal", "todo", "ok", "?")
y[1:2]
```

```
&gt; [1] "hola" "qu√©"
```

--

**.bg-green_light[TIP]**: para **.bg-purple_light[acceder al √∫ltimo elemento]** podemos pasarle como √≠ndice la longitud del vector 


```r
y[length(y)] 
```

```
&gt; [1] "?"
```

---

# .green[OPERACIONES] .orange[ARITM√âTICAS]
 

Dado que la operaci√≥n (por ejemplo, una suma) se realiza elemento a elemento, ¬øqu√© suceder√° si **.bg-purple_light[sumamos dos vectores de distinta longitud]**?

--

Por ejemplo, definamos `z` con los 4 primeros impares, e intentemos hacer la suma `x + z`.


```r
z &lt;- c(1, 3, 5, 7)
x + z
```

```
&gt; [1]   2  NA   8  11   7  10 NaN  NA
```

--

.pull-left[


&lt;img src="./img/recycle.jpg" width="99%" style="display: block; margin: auto auto auto 0;" /&gt;


]

.pull-right[

`R` intenta molestarte lo menos posible, as√≠ que lo que hace es **.bg-purple_light[reciclar elementos]**: si tiene un vector de 4 elementos y le intentas sumar uno de 3 elementos, lo que har√° ser√° reciclar elementos del vector con menor longitud: har√° `1 + 2`, `3 + 4`, `5 + 6` pero‚Ä¶ `7 + 2` (vuelve al primero).

]

---

# Vectores: .orange[CARACTERES]

Un vector es una **.bg-purple_light[concatenaci√≥n de elementos del mismo tipo]**, pero no tienen porque ser necesariamente n√∫meros. Vamos a crear una frase de ejemplo, con 4 elementos.

.pull-left[


```r
*vector &lt;- c("Me", "llamo", "Javi")
vector
```

```
&gt; [1] "Me"    "llamo" "Javi"
```

```r
length(vector)
```

```
&gt; [1] 3
```

]

.pull-right[


```r
frase &lt;- "Mi llamo Javi"
frase
```

```
&gt; [1] "Mi llamo Javi"
```

```r
length(frase)
```

```
&gt; [1] 1
```

]

F√≠jate la **diferencia** entre tenerlo guardado en un vector o tenerlo como una sola cadena de texto (unida).

---

# Vectores: .orange[CARACTERES]

Cuando usamos la funci√≥n `paste()` con variables diferentes, us√°bamos `sep = ...`. Cuando la funci√≥n `paste()` la aplicamos a un vector de caracteres, decidiremos que caracter queremos que vaya entre palabra con el argumento `collapse = ...`.


```r
paste(vector, collapse = ".") # separados por un punto
```

```
&gt; [1] "Me.llamo.Javi"
```

Podemos **combinar las secuencias de n√∫meros y un vector de caracteres** con `glue()`


```r
edad &lt;- 10:12 # edades
glue("La edad es de {edad} a√±os")
```

```
&gt; La edad es de 10 a√±os
&gt; La edad es de 11 a√±os
&gt; La edad es de 12 a√±os
```


---

name: logicas

# Datos de tipo .orange[L√ìGICO]

Un tipo de datos muy importante en todo lenguaje de programaci√≥n: los **.bg-purple_light[valores l√≥gicos]**. Un valor l√≥gico puede tomar **tres valores**:

* `TRUE` (guardado internamente como un `1`).
* `FALSE` (guardado internamente como un `0`).
* `NA` (**.bg-purple_light[dato ausente]**, son las siglas de **.bg-orange[not available]**).

--

Los valores l√≥gicos suelen ser resultado de evaluar **.bg-purple_light[condiciones l√≥gicas]** (preguntar a los datos). Por ejemplo, imaginemos que definimos un vector de temperaturas. ¬øQu√© d√≠as hizo menos de 22 grados?


```r
x &lt;- c(15, 20, 31, 27, 15, 29)
*x &lt; 22
```

```
&gt; [1]  TRUE  TRUE FALSE FALSE  TRUE FALSE
```

Nos devolver√° un **vector l√≥gico** con `TRUE` o `FALSE` en cada hueco, en funci√≥n de si cumple o no la condici√≥n pedida.

---

# Datos de tipo .orange[L√ìGICO]


Dicha condici√≥n l√≥gica puede hacerse con `&lt;=` (menor o igual), `&gt;` (mayor) o `&gt;=` (mayor igual).


```r
x &lt;= 22
```

```
&gt; [1]  TRUE  TRUE FALSE FALSE  TRUE FALSE
```

--


```r
x &gt; 30
```

```
&gt; [1] FALSE FALSE  TRUE FALSE FALSE FALSE
```

--


```r
x &gt;= 15
```

```
&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE
```

---

# Datos de tipo .orange[L√ìGICO]

Tambi√©n podemos comparar **.bg-purple_light[si es igual a otro elemento]**, para lo que usaremos el operador `==`, pudiendo usar tambi√©n su opuesto `!=` (¬´distinto de¬ª).


```r
x == 15
```

```
&gt; [1]  TRUE FALSE FALSE FALSE  TRUE FALSE
```

```r
x != 15
```

```
&gt; [1] FALSE  TRUE  TRUE  TRUE FALSE  TRUE
```

--

Si tuvi√©ramos un **.bg-purple_light[dato ausente]** (por error del aparato ese d√≠a, marcado como `NA`), la condici√≥n evaluada tambi√©n ser√≠a `NA`


```r
y &lt;- c(15, 20, NA, 31, 27, 7, 29, 10)
y &lt; 22
```

```
&gt; [1]  TRUE  TRUE    NA FALSE FALSE  TRUE FALSE  TRUE
```

---

# Datos de tipo .orange[L√ìGICO]

Las **.bg-purple_light[condiciones pueden ser combinadas]**, principalmente de dos maneras:

.pull-left[

* **.bg-purple_light[Intersecci√≥n]**: **.bg-orange[TODAS]** las condiciones concatenadas se deben cumplir (conjunci√≥n y) para devolver un `TRUE`.


```r
x
```

```
&gt; [1] 15 20 31 27 15 29
```

```r
x &lt; 30 &amp; x &gt; 15
```

```
&gt; [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE
```

]

.pull-right[

* **.bg-purple_light[Uni√≥n]**: basta con que **.bg-orange[AL MENOS UNA]** de las condiciones se cumpla (conjunci√≥n o) para devolver un `TRUE`.


```r
x
```

```
&gt; [1] 15 20 31 27 15 29
```

```r
x &lt; 30 | x &gt; 15
```

```
&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE
```

]

---

name: fecha

# Datos de tipo .orange[FECHA]


Un tipo de datos muy especial: los **.bg-purple_light[datos de tipo fecha]**. 


```r
# Cadena de texto
fecha_char &lt;- "2021-04-21"
class(fecha_char)
```

```
&gt; [1] "character"
```

Podr√≠amos pensar que no tiene nada de especial ya que parece una simple cadena de texto pero representa un **.bg-purple_light[instante en el tiempo]**, que deber√≠amos poder operar como tal.

--

¬øQu√© suceder√≠a si **sumamos un 1 (un d√≠a)** a una fecha definida como una cadena de texto?


```r
fecha_char + 1
```

```
&gt; Error in fecha_char + 1: argumento no-num√©rico para operador binario
```

--

Si guardamos las fechas como un cadena de texto **.bg-red_light[no podemos operar con ellas]**

---

# Datos de tipo .orange[FECHA]

Para trabajar con fechas tenemos el paquete `{lubridate}`, y su funci√≥n `as_date()`: nos **.bg-purple_light[convierte texto a fecha]**.


```r
library(lubridate)
*fecha &lt;- as_date(fecha_char)
class(fecha)
```

```
&gt; [1] "Date"
```

--


```r
fecha + 1 # d√≠a siguiente
```

```
&gt; [1] "2021-04-22"
```

--


```r
fecha - 3 # 3 d√≠as antes
```

```
&gt; [1] "2021-04-18"
```

--

Al convertir texto a fecha, aunque se visualice como un texto, **.bg-purple_light[internamente es un n√∫mero]**. 

---

# Datos de tipo .orange[FECHA]

La funci√≥n `as_date()` tiene un argumento opcional, el **.bg-purple_light[formato]**, que por defecto ser√° `format = "yyyy-mm-dd"` (que podemos cambiar)



```r
*as_date("10-03-2020", format = "%d-%m-%Y")
```

```
&gt; [1] "2020-03-10"
```

--


```r
as_date("10-03-20", format = "%d-%m-%y")
```

```
&gt; [1] "2020-03-10"
```

--


```r
as_date("03-10-2020", format = "%m-%d-%Y")
```

```
&gt; [1] "2020-03-10"
```

--


```r
as_date("Octubre 21, 1995 21:24", format = "%B %d, %Y %H:%M")
```

```
&gt; [1] "1995-10-21"
```

---

# Datos de tipo .orange[FECHA]

Para facilitar conversiones de formatos habituales, el paquete tambi√©n tiene a nuestra disposici√≥n diferentes funciones preparadas para directamente **.bg-purple_light[convertir fechas en distintos formatos]**, como la funci√≥n `ymd_hms()` o `ydm_hms()`


```r
ymd_hms("2017-11-28 14:02:00") # convertir a fecha una cadena a√±o-mes-d√≠a + hora
```

```
&gt; [1] "2017-11-28 14:02:00 UTC"
```

```r
ydm_hms("2017-22-12 10:00:00") # convertir a fecha una cadena a√±o-d√≠a-mes + hora
```

```
&gt; [1] "2017-12-22 10:00:00 UTC"
```

--

De la misma manera tenemos la funci√≥n `dmy_hms()`


```r
dmy_hms("1 Jan 2017 23:59:59") # convertir a fecha una cadena textual de fecha + hora
```

```
&gt; [1] "2017-01-01 23:59:59 UTC"
```

 
---

# Datos de tipo .orange[FECHA]


Tambi√©n podemos hacerlo de forma muy simplificada con `ymd()`


```r
ymd(20170131)
```

```
&gt; [1] "2017-01-31"
```

--

Otra de las funcionalidades que nos proporciona dicho paquete es obtener autom√°ticamente la **.bg-purple_light[fecha de hoy]**, haciendo uso de la funci√≥n `today()`


```r
*hoy &lt;- today()
hoy
```

```
&gt; [1] "2022-11-17"
```

--

Tambi√©n podemos obtener el **.bg-purple_light[¬´hoy y ahora¬ª]** con la funci√≥n `now()`


```r
*now()
```

```
&gt; [1] "2022-11-17 17:43:17 CET"
```
 
---

# Datos de tipo .orange[FECHA]

Tambi√©n tenemos disponibles funciones para **.bg-purple_light[extraer facilmente algunas variables]**.

.pull-left[


```r
year(fecha)
```

```
&gt; [1] 2021
```

```r
month(fecha)
```

```
&gt; [1] 4
```

```r
hour(fecha)
```

```
&gt; [1] 0
```

```r
second(fecha)
```

```
&gt; [1] 0
```

]

.pull-right[

```r
week(fecha)
```

```
&gt; [1] 16
```

```r
wday(fecha)
```

```
&gt; [1] 4
```

```r
wday(fecha, week_start = 1) # D√≠a de la semana 
```

```
&gt; [1] 3
```

]


---

# Datos de tipo .orange[FECHA]


Tambi√©n podemos **.bg-purple_light[realizar comparaciones]**


```r
fecha_actual &lt;- today()
fecha_actual &gt; ymd(20170131) # Actual vs 2017-01-31
```

```
&gt; [1] TRUE
```

```r
fecha_actual &gt; ymd(21000131) # Actual vs 2100-01-31
```

```
&gt; [1] FALSE
```
 
--

Con la funci√≥n `leap_year()` podremos saber si la fecha **.bg-purple_light[corresponde a un a√±o bisiesto]**


```r
leap_year(as_date(ymd(20190131)))
```

```
&gt; [1] FALSE
```

---

# Datos de tipo .orange[FECHA]

.pull-left[

&lt;div class="figure" style="text-align: right"&gt;
&lt;img src="./img/lubridate.png" alt="Chuleta de https://lubridate.tidyverse.org/" width="101%" /&gt;
&lt;p class="caption"&gt;Chuleta de https://lubridate.tidyverse.org/&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

Tambi√©n podemos hacer uso de diferentes funciones para **.bg-purple_light[a√±adir intervalos]** de tiempo.


```r
fecha + weeks(0:2)
```

```
&gt; [1] "2021-04-21" "2021-04-28" "2021-05-05"
```

```r
fecha + seconds(2)
```

```
&gt; [1] "2021-04-21 00:00:02 UTC"
```

]

---


name: ejercicios2

# Ejercicios


.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: define una variable `edad` que guarde tu edad y otra `nombre` con tu nombre.

* üìù **Ejercicio 2**: define otra variable con tus apellidos y junta las variables `nombre` y `apellidos` en una sola cadena de texto que guardes en `nombre_completo`.
 
* üìù **Ejercicio 3**: define un vector que contenga los n√∫meros `1`, `10`, `-1` y `2`, y gu√°rdalo en una variable llamada `vector_num`. Obt√©n la longitud del vector anterior.
 
* üìù **Ejercicio 4**: crea una secuencia de -2 a 17 de forma que salte de uno en uno (y tambi√©n de forma decreciente). Repite el proceso pero saltando de 3 en 3.


]

.panel[.panel-name[Soluci√≥n ej. 1]


```r
# variable num√©rica
edad &lt;- 33
edad
```

```
&gt; [1] 33
```

```r
# variable de tipo texto
nombre &lt;- "Javi"
nombre
```

```
&gt; [1] "Javi"
```
]

.panel[.panel-name[Soluci√≥n ej. 2]


```r
apellidos &lt;- "√Ålvarez Li√©bana"

# Opci√≥n 1
nombre_completo &lt;- glue("{nombre} {apellidos}")
nombre_completo
```

```
&gt; Javi √Ålvarez Li√©bana
```

```r
# Opci√≥n 2
nombre_completo &lt;- paste(nombre, apellidos)
nombre_completo
```

```
&gt; [1] "Javi √Ålvarez Li√©bana"
```
]

.panel[.panel-name[Soluci√≥n ej. 3]


```r
vector_num &lt;- c(1, 10, -1, 2)
vector_num
```

```
&gt; [1]  1 10 -1  2
```

```r
# longitud
length(vector_num)
```

```
&gt; [1] 4
```

]

.panel[.panel-name[Soluci√≥n ej. 4]


```r
secuencia &lt;- -2:17
secuencia
```

```
&gt;  [1] -2 -1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
```

```r
# otra forma
secuencia &lt;- seq(-2, 17, by = 1)

# decreciente
17:-2
```

```
&gt;  [1] 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 -1 -2
```

```r
# de 3 en 3
seq(-2, 17, by = 3)
```

```
&gt; [1] -2  1  4  7 10 13 16
```

]

]

---

# Ejercicios


.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 5**: crea una secuencia que repita 7 veces el patr√≥n -1, 2, 4. Despu√©s crea otra que repita dicho patr√≥n pero de forma intercalada.
 
* üìù **Ejercicio 6**: crea una secuencia de 7 valores l√≥gicos en los que haya 2 valores ciertos, 3 valores falsos y 2 valores ausentes.


* üìù **Ejercicio 7**: toma el vector `vector_num` del ejercicio 3 y obt√©n un vector l√≥gico que nos diga que valores son mayores de 0. Obt√©n otro vector l√≥gico que nos diga que valores est√°n entre 0 y 7. Obt√©n otro vector l√≥gico que nos diga que valores son distintos de 1 en valor absoluto.

* üìù **Ejercicio 8**: obt√©n la fecha de hoy, define la fecha de tu cumplea√±os, y calcula la diferencia de d√≠as.
 
* üìù **Ejercicio 9**: suma un mes y una semana a la fecha de tu cumplea√±os

 

]

.panel[.panel-name[Sol ej. 5]


```r
secuencia &lt;- rep(c(-1, 2, 4), 7)
secuencia
```

```
&gt;  [1] -1  2  4 -1  2  4 -1  2  4 -1  2  4 -1  2  4 -1  2  4 -1  2  4
```

```r
# intercalada
rep(c(-1, 2, 4), each = 7)
```

```
&gt;  [1] -1 -1 -1 -1 -1 -1 -1  2  2  2  2  2  2  2  4  4  4  4  4  4  4
```

]

.panel[.panel-name[Sol ej. 6]


```r
secuencia &lt;- c(FALSE, TRUE, NA, FALSE, NA, TRUE, FALSE)
secuencia
```

```
&gt; [1] FALSE  TRUE    NA FALSE    NA  TRUE FALSE
```

]

.panel[.panel-name[Sol ej. 7]


```r
vector_num &gt; 0
```

```
&gt; [1]  TRUE  TRUE FALSE  TRUE
```

```r
vector_num &gt; 0 &amp; vector_num &lt; 7
```

```
&gt; [1]  TRUE FALSE FALSE  TRUE
```

```r
abs(vector_num) != 1
```

```
&gt; [1] FALSE  TRUE FALSE  TRUE
```

]


.panel[.panel-name[Sol ej. 8]


```r
library(lubridate)
hoy &lt;- today()
cumple &lt;- as_date("1989-09-10")
hoy - cumple
```

```
&gt; Time difference of 12121 days
```

]

.panel[.panel-name[Sol ej. 9]


```r
cumple + months(1) + weeks(1)
```

```
&gt; [1] "1989-10-17"
```

]

]

---

# Ejercicios extras

.panelset[
.panel[.panel-name[Ejercicios extra]


* üìù **Ejercicio 10**: construye con `glue()` una frase que diga ¬´Hola, me llamo ‚Ä¶ y tengo ‚Ä¶ a√±os¬ª.

* üìù **Ejercicio 11**: modifica el c√≥digo inferior para crear un vector de nombre `vector_num` que contenga los n√∫meros 1, 5 y -7.


```r
# Vector de n√∫meros
vector_num &lt;- c(1)
vector_num
```

* üìù **Ejercicio 12**:  extrae el mes, a√±o y d√≠a de la semana de tu cumplea√±os

]

.panel[.panel-name[Soluci√≥n ej. 10]


```r
nombre &lt;- "Javi"
edad &lt;- 33
glue("Hola, me llamo {nombre} y tengo {edad} a√±os")
```

```
&gt; Hola, me llamo Javi y tengo 33 a√±os
```
]

.panel[.panel-name[Soluci√≥n ej. 11]


```r
# Vector de n√∫meros
vector_num &lt;- c(1, 5, -7)
vector_num
```

```
&gt; [1]  1  5 -7
```

```r
# longitud
length(vector_num)
```

```
&gt; [1] 3
```

]

.panel[.panel-name[Soluci√≥n ej. 12]


```r
library(lubridate)
cumple &lt;- as_date("1989-09-10")
month(cumple)
```

```
&gt; [1] 9
```

```r
day(cumple)
```

```
&gt; [1] 10
```

```r
year(cumple)
```

```
&gt; [1] 1989
```

```r
wday(cumple, week_start = 1, label = TRUE)
```

```
&gt; [1] dom
&gt; Levels: lun &lt; mar &lt; mi√© &lt; jue &lt; vie &lt; s√°b &lt; dom
```

]


]


---

class: inverse center middle
name: clase-2

# CLASE 2: primeros datos. Primeros conceptos.

&amp;nbsp;

### [Operaciones con vectores](#operaciones-vectores)

### [Matrices](#matrices)

### [data.frame y tibble](#data.frame)

### [Ejercicios datasets](#ejercicios-tibble)

### [Intro estad√≠stica](#intro-estadistica)



---

name: operaciones-vectores


# .green[OPERACIONES] .orange[ARITM√âTICAS]


Los **.bg-purple_light[valores l√≥gicos]** `TRUE` y `FALSE` son **.bg-orange[guardados internamente]** como `0` y `1`, por lo que podemos usar operaciones aritm√©ticas con ellos.

--

Por ejemplo, si queremos **.bg-purple_light[averiguar el n√∫mero de elementos que cumplen una condici√≥n]** (por ejemplo, `&lt; 3`), los que lo hagan tendr√°n asignado un 1 y los que no un 0, por lo que basta con sumar dicho vector l√≥gico para obtener el n√∫mero de elementos que cumplen dicha condici√≥n (elementos que son `TRUE`).


```r
# sumamos el vector de TRUE/FALSE
x
```

```
&gt; [1] 15 20 31 27 15 29
```

```r
sum(x &lt; 3) 
```

```
&gt; [1] 0
```

---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

Tambi√©n podemos realizar **.bg-purple_light[operaciones estad√≠sticas]** con los vectores, como calcular su **suma**, su **media**, su **mediana**, entre otros.

--

Hagamos antes un **.bg-purple_light[breve repaso]** de algunos t√©rminos estad√≠sticos:

* **.bg-purple_light[Media]**: medida de **.bg-orange[centralizaci√≥n]** que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados (funci√≥n `mean()`). La m√°s conocida pero la menos robusta: dado un conjunto, si se introducen valores at√≠picos o outliers (valores muy grandes o muy peque√±os), la media se perturba con mucha facilidad.

`$$\overline{x} = \frac{1}{n} \sum_{i=1}^{n} x_i$$`


```r
x &lt;- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
mean(x)
```

```
&gt; [1] 169.8889
```

---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

Tambi√©n podemos realizar **.bg-purple_light[operaciones estad√≠sticas]** con los vectores, como calcular su **suma**, su **media**, su **mediana**, entre otros.


Hagamos antes un **.bg-purple_light[breve repaso]** de algunos t√©rminos estad√≠sticos:

* **.bg-purple_light[Mediana]**: medida de **.bg-orange[centralizaci√≥n]** (funci√≥n `median()`) que consiste en, tras **.bg-orange[ordenar]** los datos de menor a mayor, quedarnos con el valor que ocupa el medio (deja tantos n√∫meros por debajo como por encima). 


`$$Me_{x} = \displaystyle \arg \min_{x_i} \left\lbrace F_i &gt; 0.5 \right\rbrace, \quad F_i = \frac{\# \left\lbrace x_j \leq x_i \right\rbrace}{n}$$`


```r
x &lt;- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

```
&gt; [1] 170
```

---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

Tambi√©n podemos realizar **.bg-purple_light[operaciones estad√≠sticas]** con los vectores, como calcular su **suma**, su **media**, su **mediana**, entre otros.


Hagamos antes un **.bg-purple_light[breve repaso]** de algunos t√©rminos estad√≠sticos:

* **.bg-purple_light[Moda]**: medida de **.bg-orange[centralizaci√≥n]** que consiste en encontrar el **.bg-orange[valor o valores m√°s repetidos]**. Es la medida de centralizaci√≥n m√°s robusta. 

`$$Mo_{x} = \displaystyle \arg \max_{x_i}  f_i , \quad f_i = \frac{\# \left\lbrace x_j = x_i \right\rbrace}{n}$$`

&amp;nbsp;

**.bg-red_light[PROBLEMA]**: la moda no siempre es f√°cil de calcular (aunque existen paquetes para calcularla como `{modeest}`)


---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

Otra de las funciones m√°s √∫til es la **.bg-purple_light[suma de elementos]** de un vector con `sum()`


```r
# suma
*sum(x)
```

```
&gt; [1] 1529
```

```r
sum(x) / length(x) # media artesanal
```

```
&gt; [1] 169.8889
```

--

Otra funci√≥n √∫til es la **.bg-purple_light[suma acumulada]** de un vector haciendo uso de `cumsum()`


```r
# suma acumulada
*cumsum(c(1, 2, 4, 7, 7, 10))
```

```
&gt; [1]  1  3  7 14 21 31
```

---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

No solo de medidas de centralizaci√≥n vive la estad√≠stica: **.bg-purple_light[¬øc√≥mo calcular las medidas de dispersi√≥n?]**

* **.bg-purple_light[Varianza]**: definida como la media de desviaciones (respecto a la media) al cuadrado, tal que `\(s_{x}^{2} = \frac{1}{n} \sum_{i = 1}^{n} \left(x_i - \overline{x} \right)^2 = \overline{x^2} - \overline{x}^2\)`


```r
var(x)
```

```
&gt; [1] 159.8611
```

--

**.bg-green_light[IMPORTANTE]**: las funciones de `R` (y de cualquier calculadora) nos devuelve la **.bg-red_light[cuasivarianza]** (dividido entre `\(n-1\)`)
 

```r
# Varianza real
mean((x - mean(x))^2)
```

```
&gt; [1] 142.0988
```

---


# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

No solo de medidas de centralizaci√≥n vive la estad√≠stica: **.bg-purple_light[¬øc√≥mo calcular las medidas de dispersi√≥n?]**

* **.bg-purple_light[Desv. t√≠pica (standard deviation)]**: definida como la ra√≠z cuadrada de la varianza, tal que `\(s_{x} = \sqrt{s_{x}^{2} }\)`


```r
sd(x)
```

```
&gt; [1] 12.64362
```

--

**.bg-green_light[IMPORTANTE]**: las funciones de `R` (y de cualquier calculadora) nos devuelve la **.bg-red_light[cuasidesviaci√≥n t√≠pica]** (ra√≠z de la cuasivarianza, dividida entre `\(n-1\)`)
 

```r
# Desv. t√≠pica real
sqrt(mean((x - mean(x))^2))
```

```
&gt; [1] 11.92052
```


---

# .green[OPERACIONES] .orange[ESTAD√çSTICAS]

Tambi√©n pueden sernos √∫tiles las **.bg-purple_light[medidas de posici√≥n/localizaci√≥n]**, como los **.bg-orange[percentiles]** (valores que nos dividen en partes iguales los datos).


```r
y &lt;- c(1, 2, 5, 5, 10, 10, 10, 13, 15, 20, 25)

# Percentiles por defecto: cuartiles
*quantile(y)
```

```
&gt;   0%  25%  50%  75% 100% 
&gt;    1    5   10   14   25
```

--

En `quantile()` hay un argumento por defecto `probs = c(0, 0.25, 0.5, 0.75, 1)` (**percentiles** a calcular) que puede ser cambiado, por ejemplo, para percentiles 20%-30%-70%-90%.


```r
quantile(y, probs = c(0.2, 0.3, 0.7, 0.9))
```

```
&gt; 20% 30% 70% 90% 
&gt;   5   5  13  20
```

---


# Valores .orange[√öNICOS]

Con la funci√≥n `unique()` podemos tambi√©n extraer los **.bg-purple_light[valores √∫nicos de una variable]**


```r
colores &lt;- c("azul", "azul", "verde", "amarillo",
             "azul", "rojo", "rojo", "azul", "rojo",
             "verde", "morado")
*unique(colores)
```

```
&gt; [1] "azul"     "verde"    "amarillo" "rojo"     "morado"
```

---



# .orange[FILTRAR] elementos


Otras veces no querremos seleccionar un elemento en concreto sino **.bg-purple_light[filtrar algunos elementos en concreto]** y no extraerlos, **.bg-orange[eliminarlos]**.

Deberemos repetir la misma operaci√≥n pero con el signo `-` delante: el operador `[-i]` **no selecciona** el elemento i-√©simo del vector sino que lo **elimina**


```r
y
```

```
&gt;  [1]  1  2  5  5 10 10 10 13 15 20 25
```

```r
y[-2] 
```

```
&gt;  [1]  1  5  5 10 10 10 13 15 20 25
```

---

# .orange[FILTRAR] elementos

Lo habitual es que dicho filtro lo hagamos **.bg-purple_light[en base a una condici√≥n l√≥gica]**. Supongamos que tenemos las edades de dos grupos de personas y que queremos quedarnos **solo con los mayores edad**: vamos a seleccionar los **elementos que cumplen una condici√≥n dada**.


```r
edades_1 &lt;- c(7, 20, 18, 3, 19, 9, 13, 3, 45)
edades_2 &lt;- c(17, 21, 58, 33, 15, 59, 13, 1, 45)
```

--


```r
*edades_1[edades_1 &gt;= 18]
```

```
&gt; [1] 20 18 19 45
```

```r
edades_2[edades_2 &gt;= 18]
```

```
&gt; [1] 21 58 33 59 45
```

Lo que hemos hecho ha sido pasar como **√≠ndices a seleccionar un vector l√≥gico** `TRUE/FALSE`: solo filtrar√° los lugares donde se guarde un `TRUE`.

---

# .orange[FILTRAR] elementos

Esto tambi√©n nos puede servir para **.bg-purple_light[limpiar de datos ausentes]**, combinando la funci√≥n `is.na()`: nos localiza el lugar que ocupan los ausentes, con el operador `!` (**negar el valor l√≥gico** que venga detr√°s).


```r
x &lt;- c(7, NA, 20, 3, 19, 21, 25, 80, NA)
x[is.na(x)] # solo valores ausentes
```

```
&gt; [1] NA NA
```

```r
x[!is.na(x)] # sin valores ausentes: ! es el s√≠mbolo de 
```

```
&gt; [1]  7 20  3 19 21 25 80
```

--

Tambi√©n podemos probar a **combinar condiciones l√≥gicas** para nuestra selecci√≥n.


```r
x[x &gt;= 18 &amp; x &lt;= 25] # los valores que cumplen ambas (&amp;): entre 18 y 25 a√±os
```

```
&gt; [1] NA 20 19 21 25 NA
```

---
 

# .green[SELECCIONAR] elementos: .orange[WHICH]

A veces no querremos el elemento en s√≠, sino el **.bg-purple_light[lugar que ocupa]**: ¬øqu√© valores de un vector cumplen una condici√≥n l√≥gica? Para obtener dicho √≠ndice usaremos la funci√≥n `which()`.


```r
x &lt;- c(7, NA, 20, 3, 19, 21, 25, 80, NA)
which(x &gt;= 18) # Obtenemos los lugares 
```

```
&gt; [1] 3 5 6 7 8
```

--

Esta funci√≥n es muy √∫til especialmente cuando queremos el valor que ocupa el **.bg-purple_light[m√°ximo/m√≠nimo]** de un vector, con las funciones `which.max()` y `which.min()`.


```r
max(x, na.rm = TRUE)
```

```
&gt; [1] 80
```

```r
which.max(x) # Lugar que ocupa el m√°ximo
```

```
&gt; [1] 8
```


---

# .green[SELECCIONAR] elementos: .orange[any/all]
 

Existen dos funciones muy √∫tiles para saber si **.bg-purple_light[todos o alguno de los elementos]** de un vector cumple una condici√≥n: `all()` y `any()` nos devolver√° un √∫nico valor l√≥gico.


```r
x &lt;- c(1, 2, 3, 4, 5, NA, 7)
*all(x &lt; 3)
```

```
&gt; [1] FALSE
```

```r
any(x &lt; 3)
```

```
&gt; [1] TRUE
```

```r
all(x &gt; 0)
```

```
&gt; [1] NA
```


---

# .orange[NOMBRAR] elementos

`R` nos permite dar **.bg-purple_light[significado l√©xico a nuestros valores]** (significan algo, no solo n√∫meros), pudiendo poner **nombres a los elementos** de un vector.


```r
x &lt;- c("edad" = 31, "tlf" = 613910687, "cp" = 33007)
x
```

```
&gt;      edad       tlf        cp 
&gt;        31 613910687     33007
```

--

Esto es una ventaja ya que nos permite su **.bg-purple_light[selecci√≥n usando dichos nombres]**


```r
x[c("edad", "cp")] # seleccionamos los elementos que tienen ese nombre asignado
```

```
&gt;  edad    cp 
&gt;    31 33007
```

--

Con la funci√≥n `names()` podemos, no solo **.bg-purple_light[consultar los nombres]** sino **cambiarlos**.

---

# .orange[ORDENAR] vectores


Una acci√≥n tambi√©n habitual al trabajar con datos es saber **.bg-purple_light[ordenarlos]**: de menor a mayor edad, datos m√°s recientes vs antiguos, etc. Para ello tenemos la funci√≥n `sort()`, que podemos usar directamente para ordenar de **menor a mayor**.


```r
edades &lt;- c(81, 7, 25, 41, 65, 20, 33, 23, 77)

# orden de joven a mayor
*sort(edades)
```

```
&gt; [1]  7 20 23 25 33 41 65 77 81
```

--

Por defecto, `sort()` ordena de menor a mayor. Con el argumento opcional `decreasing = TRUE` podemos **ordenar de mayor a menor**.


```r
# orden de mayor a joven
*sort(edades, decreasing = FALSE)
```

```
&gt; [1]  7 20 23 25 33 41 65 77 81
```

---

# .orange[ORDENAR] vectores

Otra forma de ordenar es obtener los **√≠ndices de los elementos ordenados**, y luego usar dichos √≠ndices para **reorganizar los elementos**, con la funci√≥n `order()`.


```r
*order(x)
```

```
&gt; [1] 1 3 2
```

```r
x[order(x)]
```

```
&gt;      edad        cp       tlf 
&gt;        31     33007 613910687
```

---


# .orange[MEDIR] tiempos de ejecuci√≥n

Hay un paquete muy √∫til para **.bg-purple_light[medir tiempos de distintas √≥rdenes]** que hacen lo mismo (el paquete `{microbenchmark}`). Vamos a comparar `order()` y `sort()`.


```r
library(microbenchmark) # instalar primera vez
x &lt;- rnorm(1e3) # 1000 elementos aleatorias
*microbenchmark(sort(x), x[order(x)], times = 1e3)
```

```
&gt; Unit: microseconds
&gt;         expr    min     lq     mean  median      uq     max neval cld
&gt;      sort(x) 41.223 44.988 52.08416 49.5360 55.6725 148.318  1000   b
&gt;  x[order(x)] 28.239 31.108 36.34062 34.7615 38.2705 144.282  1000  a
```


---

name: ejercicios-vectores

# Ejercicios de vectores


.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: define el vector `x` como la concatenaci√≥n de los 5 primeros n√∫meros impares, y calcula su suma.
 
* üìù **Ejercicio 2**: obt√©n los elementos de `x` mayores que 4. Determina los lugares que ocupan. Calcula el n√∫mero de elementos de `x` mayores que 4.

* üìù **Ejercicio 3**: calcula el vector `1/x` y obt√©n la versi√≥n ordenada (de menor a mayor).

* üìù **Ejercicio 4**: define un vector con tu estatura y peso, y nombra cada elemento.

 
]

.panel[.panel-name[Soluci√≥n ej. 1]


```r
x &lt;- c(1, 3, 5, 7, 9)

# otra forma
x &lt;- seq(1, 9, by = 2)

# Suma
sum(x)
```

```
&gt; [1] 25
```
]

.panel[.panel-name[Soluci√≥n ej. 2]


```r
# Elementos mayores que 4
x[x &gt; 4]
```

```
&gt; [1] 5 7 9
```

```r
# Lugares que ocupan
which(x &gt; 4)
```

```
&gt; [1] 3 4 5
```

```r
# Cantidad de elementos mayores que 4
sum(x &gt; 4)
```

```
&gt; [1] 3
```
]

.panel[.panel-name[Soluci√≥n ej. 3]


```r
y &lt;- 1/x

# una forma
sort(y)
```

```
&gt; [1] 0.1111111 0.1428571 0.2000000 0.3333333 1.0000000
```

```r
# otra forma
y[order(y)]
```

```
&gt; [1] 0.1111111 0.1428571 0.2000000 0.3333333 1.0000000
```

]


.panel[.panel-name[Soluci√≥n ej. 4]


```r
x &lt;- c("estatura" = 180, "peso" = 80)
x
```

```
&gt; estatura     peso 
&gt;      180       80
```

]

]

---

# Ejercicios de vectores

.panelset[
.panel[.panel-name[Ejercicios]

 
* üìù **Ejercicio 5**:  encuentra del vector `x` del ejercicio 1 los elementos mayores (estrictos) que 1 y menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.
 
 
* üìù **Ejercicio 6**: define el vector `x &lt;- c(-1, 0, -2, 5, 3, 7)` y obt√©n los elementos que ocupan una posici√≥n impar.
 
 
* üìù **Ejercicio 7**: define el vector de los primeros n√∫meros impares (hasta el 21) y extrae los elementos que ocupan los lugares `1, 4, 5, 8`. Elimina del vector el segundo elemento

 
* üìù **Ejercicio 8**: define un vector de 8 valores y determina la media, la mediana y los cuartiles.

]

.panel[.panel-name[Soluci√≥n ej. 5]


```r
x &lt;- c(1, 3, 5, 7, 9)
# valores &gt;1 y &lt;7
x[x &gt; 1 &amp; x &lt; 7]
```

```
&gt; [1] 3 5
```

```r
# ¬øTodos positivos?
all(x &gt; 0)
```

```
&gt; [1] TRUE
```

```r
sum(all(x &lt;= 0)) # debe dar 0
```

```
&gt; [1] 0
```

]

 
 
.panel[.panel-name[Soluci√≥n ej. 6]


```r
x &lt;- c(-1, 0, -2, 5, 3, 7)
x[seq(1, length(x), by = 2)]
```

```
&gt; [1] -1 -2  3
```

]

.panel[.panel-name[Soluci√≥n ej. 7]


```r
x &lt;- seq(1, 21, by = 2)

# posiciones pedidas
x[c(1, 4, 5, 8)]
```

```
&gt; [1]  1  7  9 15
```

```r
# sin las posiciones pedidas
x[-c(1, 4, 5, 8)]
```

```
&gt; [1]  3  5 11 13 17 19 21
```

```r
# eliminamos del vector el segundo elemento
x[-2]
```

```
&gt;  [1]  1  5  7  9 11 13 15 17 19 21
```
]

.panel[.panel-name[Soluci√≥n ej. 8]


```r
x &lt;- c(0, -2, 3, 7, -5, 9, 3, 1)
mean(x)
```

```
&gt; [1] 2
```

```r
median(x)
```

```
&gt; [1] 2
```

```r
quantile(x)
```

```
&gt;   0%  25%  50%  75% 100% 
&gt; -5.0 -0.5  2.0  4.0  9.0
```
]


]

---

name: matrices

# De la .orange[celda] a la .green[tabla]
 

&lt;img src="./img/celdas.jpg" width="55%" style="display: block; margin: auto;" /&gt;

* **.bg-purple_light[Celda]**: un dato **.bg-orange[individual]** de un tipo concreto.

* **.bg-purple_light[Variable]**: una **.bg-orange[concatenaci√≥n de valores]** del mismo tipo (**vectores**).


&amp;nbsp;

--

**.bg-purple_light[Matriz]**: **.bg-orange[concatenaci√≥n de variables]** del **.bg-yellow[mismo tipo]** y longitud.

---

# .orange[MATRICES]: concatenando variables


Cuando analizamos datos solemos tener varias **variables distintas** de cada individuo: necesitamos una ¬´tabla¬ª con **.bg-purple_light[distintas variables]** (de **.bg-orange[IGUAL longitud]**).

Las **.bg-purple_light[matrices]** son una concatenaci√≥n de variables, del **.bg-orange[mismo tipo e igual longitud]**, dispuestas en **p columnas** (datos p-dimensionales) 

--

&amp;nbsp;

Vamos a empezar definiendo una **matriz sencilla**: imagina que tenemos las estaturas y pesos de 5 personas. ¬øC√≥mo juntar las dos variables creando nuestro primer conjunto de datos? F√≠jate que son del mismo tipo e igual longitud.


```r
estaturas &lt;- c(150, 160, 170, 180, 190)
pesos &lt;- c(60, 70, 80, 90, 100)
```

---

# .orange[MATRICES]: concatenando variables


```r
estaturas &lt;- c(150, 160, 170, 180, 190)
pesos &lt;- c(60, 70, 80, 90, 100)
```

¬øC√≥mo juntar las dos variables creando nuestro primer conjunto de datos? Vamos a **.bg-purple_light[crear una matriz]**, un conjunto de n√∫meros organizado en 2 columnas (una por variable) y 5 filas o registros (una por persona). Para ello usaremos la funci√≥n `cbind()`, que nos **concatena vectores de igual longitud en columnas**.

 

```r
# Construimos la matriz por columnas
*datos_matriz &lt;- cbind(estaturas, pesos)
datos_matriz
```

```
&gt;      estaturas pesos
&gt; [1,]       150    60
&gt; [2,]       160    70
&gt; [3,]       170    80
&gt; [4,]       180    90
&gt; [5,]       190   100
```

---

# .orange[MATRICES]: concatenando variables


.pull-left[

&lt;img src="./img/datos_matriz_1.jpg" width="99%" style="display: block; margin: auto auto auto 0;" /&gt;


]


.pull-right[


```r
View(datos_matriz)
```

Podemos **.bg-purple_light[visualizar la matriz]** en un formato ¬´excelizado¬ª con la funci√≥n `View()`.


Tambi√©n podemos **.bg-purple_light[construir la matriz por filas]** con la funci√≥n `rbind()` (aunque lo recomendable es tener cada variable en  columna y cada individuo en fila).


```r
# Construimos la matriz por filas
rbind(estaturas, pesos) 
```

```
&gt;           [,1] [,2] [,3] [,4] [,5]
&gt; estaturas  150  160  170  180  190
&gt; pesos       60   70   80   90  100
```

]

---
 
 
# .orange[MATRICES]: concatenando variables

Podemos comprobar las **.bg-purple_light[dimensiones de una matriz]** con `dim()`, `nrow()` y `ncol()`: nuestros datos est√°n **.bg-orange[tabulados]**:


```r
dim(datos_matriz) # vector
```

```
&gt; [1] 5 2
```

```r
nrow(datos_matriz)
```

```
&gt; [1] 5
```

```r
ncol(datos_matriz)
```

```
&gt; [1] 2
```

---

# .orange[MATRICES]: concatenando variables


Veamos un ejemplo con **tres variables/columnas**: edades, tel√©fonos y c√≥digos postales.


```r
edades &lt;- c(14, 24, 56, 31, 20, 87, 73) 
tlf &lt;- c(NA, 683839390, 621539732, 618211286, NA, 914727164, NA)
cp &lt;- c(33007, 28019, 37005, 18003, 33091, 25073, 17140)

# Construimos la matriz por columnas
*datos_matriz &lt;- cbind(edades, tlf, cp)
datos_matriz
```

```
&gt;      edades       tlf    cp
&gt; [1,]     14        NA 33007
&gt; [2,]     24 683839390 28019
&gt; [3,]     56 621539732 37005
&gt; [4,]     31 618211286 18003
&gt; [5,]     20        NA 33091
&gt; [6,]     87 914727164 25073
&gt; [7,]     73        NA 17140
```


---

# .orange[MATRICES]: a√±adir registros/variables

Las funciones `cbind()` y `rbind()` no solo nos permiten crear matrices desde cero sino tambi√©n **.bg-purple_light[a√±adir filas o columnas]** a matrices existentes.


```r
# A√±adimos una fila
rbind(datos_matriz, c(27, 620125780, 28051))
```

```
&gt;      edades       tlf    cp
&gt; [1,]     14        NA 33007
&gt; [2,]     24 683839390 28019
&gt; [3,]     56 621539732 37005
&gt; [4,]     31 618211286 18003
&gt; [5,]     20        NA 33091
&gt; [6,]     87 914727164 25073
&gt; [7,]     73        NA 17140
&gt; [8,]     27 620125780 28051
```

---

# .orange[MATRICES]: valores repetidos

Podemos definir una **.bg-purple_light[matriz de n¬∫ repetidos]** con `matrix(..., nrow = ..., ncol = ...)`


```r
# matriz de ceros de 3 filas, 2 columnas,
*matrix(0, nrow = 3, ncol = 2)
```

```
&gt;      [,1] [,2]
&gt; [1,]    0    0
&gt; [2,]    0    0
&gt; [3,]    0    0
```

--

Tambi√©n podemos definir una **.bg-purple_light[matriz a partir de un vector num√©rico]**, reorganizando los valores en forma de matriz (sabiendo que los elementos se van colocando por columnas).


```r
matrix(1:15, ncol = 5) # Matriz con el vector 1:15
```

```
&gt;      [,1] [,2] [,3] [,4] [,5]
&gt; [1,]    1    4    7   10   13
&gt; [2,]    2    5    8   11   14
&gt; [3,]    3    6    9   12   15
```

---

# .green[OPERACIONES] con .orange[MATRICES]

Con las matrices sucede como con los vectores: cuando aplicamos una **.bg-purple_light[operaci√≥n aritm√©tica]** lo hacemos **.bg-orange[elemento a elemento]**


```r
z &lt;- matrix(1:15, ncol = 5) 
z / 5
```

```
&gt;      [,1] [,2] [,3] [,4] [,5]
&gt; [1,]  0.2  0.8  1.4  2.0  2.6
&gt; [2,]  0.4  1.0  1.6  2.2  2.8
&gt; [3,]  0.6  1.2  1.8  2.4  3.0
```

```r
z + 3
```

```
&gt;      [,1] [,2] [,3] [,4] [,5]
&gt; [1,]    4    7   10   13   16
&gt; [2,]    5    8   11   14   17
&gt; [3,]    6    9   12   15   18
```

---

# .orange[MATRICES] de .green[CARACTERES]

Tambi√©n podemos crear matrices de otros tipos de datos, siempre y cuando las **.bg-purple_light[columnas sean del mismo tipo e igual longitud]**, por ejemplo una **.bg-orange[matriz de caracteres]**.


```r
# matriz de caracteres
nombres &lt;- c("Javier", "Carlos", "Mar√≠a")
apellidos &lt;- c("√Ålvarez", "Garc√≠a", "P√©rez")
cbind(nombres, apellidos)
```

```
&gt;      nombres  apellidos
&gt; [1,] "Javier" "√Ålvarez"
&gt; [2,] "Carlos" "Garc√≠a" 
&gt; [3,] "Mar√≠a"  "P√©rez"
```

--


```r
# matriz de valores l√≥gicos
cbind(c(TRUE, FALSE), c(FALSE, TRUE))
```

```
&gt;       [,1]  [,2]
&gt; [1,]  TRUE FALSE
&gt; [2,] FALSE  TRUE
```

---

# .orange[SELECCIONAR] elementos

Si recuerdas para los vectores, us√°bamos el operador `[i]` para **acceder al elemento i-√©simo**. En el caso de las matrices la l√≥gica ser√° la misma:

* para **.bg-purple_light[acceder a la fila i-√©sima]** se usa el operador `[i, ]` (dejando libre la columna).


```r
datos_matriz[1, ] # fila 1
```

```
&gt; edades    tlf     cp 
&gt;     14     NA  33007
```

---

# .orange[SELECCIONAR] elementos

Si recuerdas para los vectores, us√°bamos el operador `[i]` para **acceder al elemento i-√©simo**. En el caso de las matrices la l√≥gica ser√° la misma:

* para **.bg-purple_light[acceder a la columna j-√©sima]** se usa el operador `[, j]` (dejando libre la fila).


```r
datos_matriz[, 3] # columna 3
```

```
&gt; [1] 33007 28019 37005 18003 33091 25073 17140
```


---

# .orange[SELECCIONAR] elementos

Si recuerdas para los vectores, us√°bamos el operador `[i]` para **acceder al elemento i-√©simo**. En el caso de las matrices la l√≥gica ser√° la misma:

* para **.bg-purple_light[acceder conjuntamente al elemento (i, j)]** se usa el operador `[i, j]`.


```r
datos_matriz[1, 3] # elemento (1, 3)
```

```
&gt;    cp 
&gt; 33007
```

```r
datos_matriz[2, 2] # elemento (1, 3)
```

```
&gt;       tlf 
&gt; 683839390
```


---

# .orange[NOMBRAR] variables

Una matriz por defecto adopta los nombres de los vectores como los nombres de columnas, pero podemos 
**.bg-purple_light[personalizar los nombres de las variables]**


```r
estaturas &lt;- c(150, 160, 170)
pesos &lt;- c(60, 70, 80)
cbind("altura" = estaturas, "pesaje" = pesos)
```

```
&gt;      altura pesaje
&gt; [1,]    150     60
&gt; [2,]    160     70
&gt; [3,]    170     80
```


--

Si las columnas tienen nombres podemos hacer uso de ellos para **acceder a las columnas**


```r
datos_matriz[, c("edades", "tlf")]
```

```
&gt;      edades       tlf
&gt; [1,]     14        NA
&gt; [2,]     24 683839390
&gt; [3,]     56 621539732
&gt; [4,]     31 618211286
&gt; [5,]     20        NA
&gt; [6,]     87 914727164
&gt; [7,]     73        NA
```

---

# .orange[NOMBRAR] variables

Tambi√©n podemos **.bg-purple_light[asignar nombres]** a las filas de una matriz con `row.names()` y acceder a filas y columnas por nombres.


```r
row.names(datos_matriz) &lt;- c("Javi", "Laura", "Patricia", "Carlos", "Juan", "Luis", "Carla")
datos_matriz
```

```
&gt;          edades       tlf    cp
&gt; Javi         14        NA 33007
&gt; Laura        24 683839390 28019
&gt; Patricia     56 621539732 37005
&gt; Carlos       31 618211286 18003
&gt; Juan         20        NA 33091
&gt; Luis         87 914727164 25073
&gt; Carla        73        NA 17140
```

```r
datos_matriz["Javi", "edades"]
```

```
&gt; [1] 14
```

---

# .orange[OPERACIONES] por filas/columnas

Normalmente, para explicar las **operaciones con matrices** en un lenguaje de programaci√≥n al uso, necesitar√≠amos hablar de una **herramienta llamada bucles**. Lo mencionaremos m√°s adelante pero no los vamos a necesitar de momento (cu√°ntos menos los usemos en `R`, mejor)

--

Imagina que tuvi√©semos nuestra matriz de estaturas y pesos.


```r
datos_matriz &lt;- cbind(estaturas, pesos)
datos_matriz
```

```
&gt;      estaturas pesos
&gt; [1,]       150    60
&gt; [2,]       160    70
&gt; [3,]       170    80
```

--

¬øC√≥mo podemos **.bg-purple_light[aplicar una operaci√≥n para cada una de las filas o columnas]** de una matriz?

---

# .orange[OPERACIONES] por filas/columnas

Imagina que queremos obtener la **.bg-purple_light[media de cada columna]**. Lo haremos con la funci√≥n `apply()`, y le indicaremos como argumentos la matriz, el **.bg-orange[sentido de la operaci√≥n]** (`MARGIN = 1` por filas, `MARGIN = 2` por columnas) y la **funci√≥n a aplicar**


```r
# Media (mean) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "mean")
```

```
&gt; estaturas     pesos 
&gt;       160        70
```

--

Si la funci√≥n **requiere de argumentos extras** se lo podemos indicar al final.


```r
estaturas_bis &lt;- c(150, NA, 170, 180, 190)
datos_matriz_bis &lt;- cbind(estaturas_bis, pesos) 
apply(datos_matriz_bis, MARGIN = 2, FUN = "mean")
```

```
&gt; estaturas_bis         pesos 
&gt;            NA            68
```

---

name: ejercicios-matrices

# Ejercicios de matrices

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: modifica el c√≥digo para definir una matriz `x` de ceros de 3 filas y 7 columnas.
 

```r
# Matriz
x &lt;- matrix(0, nrow = 2, ncol = 3)
x
```

* üìù **Ejercicio 2**: a la matriz anterior, suma un 1 a cada n√∫mero de la matriz y divide el resultado entre 5.
 

* üìù **Ejercicio 3**: tras definir la matriz `x` calcula su transpuesta y obt√©n sus dimensiones
 

]

.panel[.panel-name[Soluci√≥n ej. 1]


```r
x &lt;- matrix(0, nrow = 3, ncol = 7)
x
```

```
&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
&gt; [1,]    0    0    0    0    0    0    0
&gt; [2,]    0    0    0    0    0    0    0
&gt; [3,]    0    0    0    0    0    0    0
```

]

.panel[.panel-name[Soluci√≥n ej. 2]


```r
# sumamos 1
x + 1
```

```
&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
&gt; [1,]    1    1    1    1    1    1    1
&gt; [2,]    1    1    1    1    1    1    1
&gt; [3,]    1    1    1    1    1    1    1
```

```r
# dividimos entre 5
(x + 1) / 5
```

```
&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
&gt; [1,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2
&gt; [2,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2
&gt; [3,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2
```

]

.panel[.panel-name[Soluci√≥n ej. 3]


```r
# dimensiones originales
dim(x)
```

```
&gt; [1] 3 7
```

```r
# transpuesta
y &lt;- t(x)
y
```

```
&gt;      [,1] [,2] [,3]
&gt; [1,]    0    0    0
&gt; [2,]    0    0    0
&gt; [3,]    0    0    0
&gt; [4,]    0    0    0
&gt; [5,]    0    0    0
&gt; [6,]    0    0    0
&gt; [7,]    0    0    0
```

```r
dim(y)
```

```
&gt; [1] 7 3
```

]


]

---

# Ejercicios de matrices

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 4**: define la matriz `x &lt;- matrix(1:12, nrow = 4)`. Obt√©n la primera fila, la tercera columna, y el elemento (4, 1).

* üìù **Ejercicio 5**: en la matriz anterior, pon a cada fila `i` el nombre `fila_i` (fila_1, fila_2, fila_3, fila_4).

* üìù **Ejercicio 6**: con la matriz anterior definida como `matrix(1:12, nrow = 4)`, calcula la media de todos los elementos, la media de cada fila y la media de cada columna. Calcula la suma de de cada fila y de cada columna

]

.panel[.panel-name[Soluci√≥n ej. 4]


```r
x &lt;- matrix(1:12, nrow = 4)

# primera fila
x[1, ]
```

```
&gt; [1] 1 5 9
```

```r
# tercera columna
x[, 3]
```

```
&gt; [1]  9 10 11 12
```

```r
# (4, 1)
x[4, 1]
```

```
&gt; [1] 4
```

]

.panel[.panel-name[Soluci√≥n ej. 5]


```r
x
```

```
&gt;      [,1] [,2] [,3]
&gt; [1,]    1    5    9
&gt; [2,]    2    6   10
&gt; [3,]    3    7   11
&gt; [4,]    4    8   12
```

```r
row.names(x) &lt;- glue("fila_{1:4}")
x
```

```
&gt;        [,1] [,2] [,3]
&gt; fila_1    1    5    9
&gt; fila_2    2    6   10
&gt; fila_3    3    7   11
&gt; fila_4    4    8   12
```

]

.panel[.panel-name[Soluci√≥n ej. 6]


```r
# media por filas
apply(x, MARGIN = 1, FUN = mean)
```

```
&gt; fila_1 fila_2 fila_3 fila_4 
&gt;      5      6      7      8
```

```r
# media por columnas
apply(x, MARGIN = 2, FUN = mean)
```

```
&gt; [1]  2.5  6.5 10.5
```

```r
# suma por filas
apply(x, MARGIN = 1, FUN = sum)
```

```
&gt; fila_1 fila_2 fila_3 fila_4 
&gt;     15     18     21     24
```

```r
# suma por columnas
apply(x, MARGIN = 2, FUN = sum)
```

```
&gt; [1] 10 26 42
```

]

]



---

# Ejercicios extras (matrices y vectores)

.panelset[
.panel[.panel-name[Ejercicios extra]

* üìù **Ejercicio 1**: define un vector `y` que contenga los 5 primeros pares, y otro `x` con los 5 primeros impares. Haz la suma de `x` (ejercicio 1 anterior) e `y`.
 
* üìù **Ejercicio 2**: encuentra del vector `x &lt;- c(-1, 0, -2, 5, 3, 7)` el lugar (el √≠ndice) que ocupa su m√≠nimo y su m√°ximo.
 

* üìù **Ejercicio 3**: define el vector `c(-1, 0, 4, 5, -2)`, calcula la ra√≠z cuadrada del vector y determina que lugares son de tipo `NaN`.

* üìù **Ejercicio 4**:  el siguiente c√≥digo define una matriz de dimensiones `4 x 3` y calcula la suma por columnas. Modifica el c√≥digo para que realice la suma por filas.
 

```r
matriz &lt;- matrix(1:12, nrow = 4)
apply(matriz, MARGIN = 2, FUN = "sum")
```

]

.panel[.panel-name[Soluci√≥n ej. 1]


```r
y &lt;- c(0, 2, 4, 6, 8)
x &lt;- y + 1 # forma m√°s r√°pida de (1, 3, 5, 7, 9)
x + y
```

```
&gt; [1]  1  5  9 13 17
```

]

.panel[.panel-name[Soluci√≥n ej. 2]


```r
x &lt;- c(-1, 0, -2, 5, 3, 7)
which.max(x)
```

```
&gt; [1] 6
```

```r
which.min(y)
```

```
&gt; [1] 1
```

]

.panel[.panel-name[Soluci√≥n ej. 3]


```r
x &lt;- c(-1, 0, 4, 5, -2)
sqrt(x)
```

```
&gt; [1]      NaN 0.000000 2.000000 2.236068      NaN
```

```r
is.nan(sqrt(x))
```

```
&gt; [1]  TRUE FALSE FALSE FALSE  TRUE
```

]

.panel[.panel-name[Soluci√≥n ej. 4]


```r
matriz &lt;- matrix(1:12, nrow = 4)
apply(matriz, MARGIN = 1, FUN = "sum")
```

```
&gt; [1] 15 18 21 24
```

]

]

---

name: data.frame

# .orange[TABLAS]: variables .green[data.frame]
 


&lt;img src="./img/celdas.jpg" width="45%" style="display: block; margin: auto;" /&gt;

* **.bg-purple_light[Celda]**: un dato **.bg-orange[individual]** de un tipo concreto.

* **.bg-purple_light[Variable]**: una **.bg-orange[concatenaci√≥n de valores]** del mismo tipo (**vectores**).

* **.bg-purple_light[Matriz]**: **.bg-orange[concatenaci√≥n de variables]** del **.bg-yellow[mismo tipo]** y longitud.

&amp;nbsp;

--

* **.bg-purple_light[data.frame (tabla)]**: **.bg-orange[concatenaci√≥n de variables]** de **.bg-yellow[DISTINTO tipo]** e igual longitud.


---

# .red[PROBLEMAS] de las .green[MATRICES]


Retomemos nuestra matriz de edades, tel√©fonos y c√≥digos postales.


```r
edades &lt;- c(14, 24, 56, 31, 20, 87) 
tlf &lt;- c(NA, 683839390, 621539732, 618211286, NA, 914727164)
cp &lt;- c(33007, 28019, 37005, 18003, 33091, 25073)

# Construimos la matriz por columnas
*datos_matriz &lt;- cbind(edades, tlf, cp)
datos_matriz
```

```
&gt;      edades       tlf    cp
&gt; [1,]     14        NA 33007
&gt; [2,]     24 683839390 28019
&gt; [3,]     56 621539732 37005
&gt; [4,]     31 618211286 18003
&gt; [5,]     20        NA 33091
&gt; [6,]     87 914727164 25073
```

--

¬øQu√© suceder√° si ahora **.bg-purple_light[a√±adimos una columna con los nombres]** (tipo caracter) de cada persona?

---


# .red[PROBLEMAS] de las .green[MATRICES]


```r
nombres &lt;- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")
datos_matriz_nueva &lt;- cbind(nombres, datos_matriz)
```


```
&gt;      nombres  edades tlf         cp     
&gt; [1,] "Sonia"  "14"   NA          "33007"
&gt; [2,] "Carla"  "24"   "683839390" "28019"
&gt; [3,] "Pepito" "56"   "621539732" "37005"
&gt; [4,] "Carlos" "31"   "618211286" "18003"
&gt; [5,] "Lara"   "20"   NA          "33091"
&gt; [6,] "Sandra" "87"   "914727164" "25073"
```

**.bg-red_light[¬øHas visto lo que ha sucedido?]**

--

Como una **.bg-purple_light[matriz solo puedes tener un tipo de dato]**, al a√±adir una variable de tipo texto, `R` se ha visto obligado a **convertir los n√∫meros en texto** (poni√©ndole **comillas**). 


```r
datos_matriz_nueva[, "edades"] + 1
```

```
&gt; Error in datos_matriz_nueva[, "edades"] + 1: argumento no-num√©rico para operador binario
```

---

# .red[PROBLEMAS] de las .green[MATRICES]

Las **.bg-purple_light[matrices]** nos permiten almacenar distintas variables SIEMPRE Y CUANDO tengan

* **.bg-orange[Misma longitud]**.
* **.bg-orange[Mismo tipo]** de dato (sin mezclar).

Esto es bastante limitante en la vida real nuestros datos tendr√°n variables de todo tipo: supongamos que queremos **guardar de 7 personas las siguientes variables**.



```r
# Nombres
nombres &lt;- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")

# Apellidos
apellidos &lt;- c(NA, "Gonz√°lez", "Fern√°ndez", "Mart√≠nez", "Li√©bana", "Garc√≠a", "Ortiz")

# C√≥digo postal
cp &lt;- c(28019, 28001, 34005, 18410, 33007, 34500, 28017)

# Edades
edades &lt;- c(45, 67, NA, 31, 27, 19, 50)
```

---


# .red[PROBLEMAS] de las .green[MATRICES]

Las **.bg-purple_light[matrices]** nos permiten almacenar distintas variables SIEMPRE Y CUANDO tengan

* **.bg-orange[Misma longitud]**.
* **.bg-orange[Mismo tipo]** de dato (sin mezclar).

Esto es bastante limitante en la vida real nuestros datos tendr√°n variables de todo tipo: supongamos que queremos **guardar de 7 personas las siguientes variables**.



```r
# Tel√©fono
tlf &lt;- c(618910564, 914718475, 934567891, 620176565, NA, NA, 688921344)

# Estado civil (no lo sabemos de una persona)
casado &lt;- c(TRUE, FALSE, FALSE, NA, TRUE, FALSE, FALSE)

# Fecha de creaci√≥n (fecha en el que esa persona entra en el sistema)
# lo convertimos a tipo fecha
fecha_creacion &lt;-
  as_date(c("2021-03-04", "2020-10-12", "1990-04-05",
            "2019-09-10", "2017-03-21", "2020-07-07",
            "2000-01-28"))
```


---

# .red[PROBLEMAS] de las .green[MATRICES]

Aahora tenemos un **popurr√≠ de variables**, de la misma longitud pero de tipos distintos:

* `(edades, tlf, cp)` son variables **num√©ricas**.
* `(nombres, apellidos)` son variables de **texto**.
* `casado` es una variable **l√≥gica**.
* `fecha_creacion` de tipo **fecha**.

¬øQu√© suceder√≠a si **.bg-purple_light[intentamos mezclar todo en una matriz]**?

--


```r
# Juntamos por columnas
datos_matriz &lt;-
  cbind(nombres, apellidos, edades, tlf, cp, casado, fecha_creacion)
datos_matriz
```

```
&gt;      nombres  apellidos   edades tlf         cp      casado  fecha_creacion
&gt; [1,] "Sonia"  NA          "45"   "618910564" "28019" "TRUE"  "18690"       
&gt; [2,] "Carla"  "Gonz√°lez"  "67"   "914718475" "28001" "FALSE" "18547"       
&gt; [3,] "Pepito" "Fern√°ndez" NA     "934567891" "34005" "FALSE" "7399"        
&gt; [4,] "Carlos" "Mart√≠nez"  "31"   "620176565" "18410" NA      "18149"       
&gt; [5,] "Lara"   "Li√©bana"   "27"   NA          "33007" "TRUE"  "17246"       
&gt; [6,] "Sandra" "Garc√≠a"    "19"   NA          "34500" "FALSE" "18450"       
&gt; [7,] "Javi"   "Ortiz"     "50"   "688921344" "28017" "FALSE" "10984"
```

---

# .red[PROBLEMAS] de las .green[MATRICES]


```r
datos_matriz
```

```
&gt;      nombres  apellidos   edades tlf         cp      casado  fecha_creacion
&gt; [1,] "Sonia"  NA          "45"   "618910564" "28019" "TRUE"  "18690"       
&gt; [2,] "Carla"  "Gonz√°lez"  "67"   "914718475" "28001" "FALSE" "18547"       
&gt; [3,] "Pepito" "Fern√°ndez" NA     "934567891" "34005" "FALSE" "7399"        
&gt; [4,] "Carlos" "Mart√≠nez"  "31"   "620176565" "18410" NA      "18149"       
&gt; [5,] "Lara"   "Li√©bana"   "27"   NA          "33007" "TRUE"  "17246"       
&gt; [6,] "Sandra" "Garc√≠a"    "19"   NA          "34500" "FALSE" "18450"       
&gt; [7,] "Javi"   "Ortiz"     "50"   "688921344" "28017" "FALSE" "10984"
```

Dado que en una **.bg-purple_light[matriz solo podemos almacenar datos del mismo tipo]**, los n√∫meros los convierte a texto, las variables l√≥gicas las convierte a texto (`TRUE` era un valor l√≥gico, `"TRUE"` es un texto, sin significado de verdadero/falso) y las fechas las ha convertido a texto.


```r
datos_matriz[1, "fecha_creacion"] - datos_matriz[2, "fecha_creacion"]
```

```
&gt; Error in datos_matriz[1, "fecha_creacion"] - datos_matriz[2, "fecha_creacion"]: argumento no-num√©rico para operador binario
```

---

# .orange[TABLAS]: variables .green[data.frame]

Vamos a aprender c√≥mo juntar variables de distinto tipo, sin **modificar la integridad** del dato. El formato de **.bg-purple_light[tabla de datos]** que vamos a empezar a usar se llama `data.frame`: una **.bg-purple_light[colecci√≥n de variables de igual longitud]** pero cada una puede ser de un **.bg-orange[tipo distinto]**.

--

Para crearlo basta con usar la funci√≥n `data.frame()`, pas√°ndole como argumentos (separados por comas) las variables que queremos reunir.


```r
# Creamos nuestro primer data.frame
tabla &lt;- data.frame(nombres, apellidos, edades, tlf,
*                   cp, casado, fecha_creacion)
tabla
```

```
&gt;   nombres apellidos edades       tlf    cp casado fecha_creacion
&gt; 1   Sonia      &lt;NA&gt;     45 618910564 28019   TRUE     2021-03-04
&gt; 2   Carla  Gonz√°lez     67 914718475 28001  FALSE     2020-10-12
&gt; 3  Pepito Fern√°ndez     NA 934567891 34005  FALSE     1990-04-05
&gt; 4  Carlos  Mart√≠nez     31 620176565 18410     NA     2019-09-10
&gt; 5    Lara   Li√©bana     27        NA 33007   TRUE     2017-03-21
&gt; 6  Sandra    Garc√≠a     19        NA 34500  FALSE     2020-07-07
&gt; 7    Javi     Ortiz     50 688921344 28017  FALSE     2000-01-28
```

---

# .orange[TABLAS]: variables .green[data.frame]


```r
tabla
```

```
&gt;   nombres apellidos edades       tlf    cp casado fecha_creacion
&gt; 1   Sonia      &lt;NA&gt;     45 618910564 28019   TRUE     2021-03-04
&gt; 2   Carla  Gonz√°lez     67 914718475 28001  FALSE     2020-10-12
&gt; 3  Pepito Fern√°ndez     NA 934567891 34005  FALSE     1990-04-05
&gt; 4  Carlos  Mart√≠nez     31 620176565 18410     NA     2019-09-10
&gt; 5    Lara   Li√©bana     27        NA 33007   TRUE     2017-03-21
&gt; 6  Sandra    Garc√≠a     19        NA 34500  FALSE     2020-07-07
&gt; 7    Javi     Ortiz     50 688921344 28017  FALSE     2000-01-28
```

```r
class(tabla)
```

```
&gt; [1] "data.frame"
```

```r
dim(tabla)
```

```
&gt; [1] 7 7
```

---

# .orange[TABLAS]: variables .green[data.frame]

Al igual que con matrices, podemos **.bg-purple_light[crear un data.frame]** indicando **nombre de columnas**


```r
tabla &lt;- data.frame("nombre" = nombres, "apellido" = apellidos, "edad" = edades, "tel√©fono" = tlf, 
                    "cp" = cp, "casado" = casado, "fecha_registro" = fecha_creacion)
tabla
```

```
&gt;   nombre  apellido edad  tel√©fono    cp casado fecha_registro
&gt; 1  Sonia      &lt;NA&gt;   45 618910564 28019   TRUE     2021-03-04
&gt; 2  Carla  Gonz√°lez   67 914718475 28001  FALSE     2020-10-12
&gt; 3 Pepito Fern√°ndez   NA 934567891 34005  FALSE     1990-04-05
&gt; 4 Carlos  Mart√≠nez   31 620176565 18410     NA     2019-09-10
&gt; 5   Lara   Li√©bana   27        NA 33007   TRUE     2017-03-21
&gt; 6 Sandra    Garc√≠a   19        NA 34500  FALSE     2020-07-07
&gt; 7   Javi     Ortiz   50 688921344 28017  FALSE     2000-01-28
```

&amp;nbsp;

**.bg-green_light[¬°TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!]** Puedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`

---

# .orange[TABLAS]: variables .green[data.frame]

Si tenemos uno ya creado y queremos **.bg-purple_light[a√±adir una columna]** es tan simple como usar la `funci√≥n data.frame()` que ya hemos visto para concatenar la columna. Vamos a√±adir por ejemplo una nueva variable, el **n√∫mero de hermanos** de cada individuo.


```r
# A√±adimos una nueva columna con n¬∫ de hermanos/as
hermanos &lt;- c(0, 0, 1, 5, 2, 3, 0)
tabla &lt;- data.frame(tabla, "n_hermanos" = hermanos)
tabla
```

```
&gt;   nombre  apellido edad  tel√©fono    cp casado fecha_registro n_hermanos
&gt; 1  Sonia      &lt;NA&gt;   45 618910564 28019   TRUE     2021-03-04          0
&gt; 2  Carla  Gonz√°lez   67 914718475 28001  FALSE     2020-10-12          0
&gt; 3 Pepito Fern√°ndez   NA 934567891 34005  FALSE     1990-04-05          1
&gt; 4 Carlos  Mart√≠nez   31 620176565 18410     NA     2019-09-10          5
&gt; 5   Lara   Li√©bana   27        NA 33007   TRUE     2017-03-21          2
&gt; 6 Sandra    Garc√≠a   19        NA 34500  FALSE     2020-07-07          3
&gt; 7   Javi     Ortiz   50 688921344 28017  FALSE     2000-01-28          0
```

---

# .orange[TABLAS]: variables .green[data.frame]

Si queremos **.bg-purple_light[acceder a una columna, fila o elemento]** en concreto, los `data.frame` tienen las mismas ventajas que una matriz, as√≠ que bastar√≠a con usar los mismos operadores.


```r
tabla[5, ] # Accedemos a la quinta fila
```

```
&gt;   nombre apellido edad tel√©fono    cp casado fecha_registro n_hermanos
&gt; 5   Lara  Li√©bana   27       NA 33007   TRUE     2017-03-21          2
```

--

.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/tabla_dolar.jpg" alt="Men√∫ desplegable de variables (columnas)" width="99%" /&gt;
&lt;p class="caption"&gt;Men√∫ desplegable de variables (columnas)&lt;/p&gt;
&lt;/div&gt;
]

.pull-right[

No solo tiene las ventajas de una matriz sino que tambi√©n tiene las **.bg-purple_light[ventajas de una ¬´base¬ª de datos]**: podemos aceder a las variables por el √≠ndice de columna que ocupan pero tambi√©n **.bg-purple_light[acceder por su nombre]**, poniendo el nombre de la tabla, el s√≠mbolo `$` y, con el tabulador, nos aparecer√° un men√∫ de columnas a elegir.

]

---

# Primer .orange[AN√ÅLISIS DE DATOS]

.panelset[
.panel[.panel-name[USArrests]

Nuestro primer conjunto ser√° `USArrests`, un dataset de **.bg-purple_light[arrestos en EE.UU.]** del paquete `{datasets}` (si escribimos `datasets::` y pulsamos tabulador, se nos abre un desplegable con distintos conjuntos de datos para ser usado)


```r
# install.packages("datasets") # Descomentar si nunca se ha instalado
library(datasets)
datasets::USArrests
```

```
&gt;                Murder Assault UrbanPop Rape
&gt; Alabama          13.2     236       58 21.2
&gt; Alaska           10.0     263       48 44.5
&gt; Arizona           8.1     294       80 31.0
&gt; Arkansas          8.8     190       50 19.5
&gt; California        9.0     276       91 40.6
&gt; Colorado          7.9     204       78 38.7
&gt; Connecticut       3.3     110       77 11.1
&gt; Delaware          5.9     238       72 15.8
&gt; Florida          15.4     335       80 31.9
&gt; Georgia          17.4     211       60 25.8
&gt; Hawaii            5.3      46       83 20.2
&gt; Idaho             2.6     120       54 14.2
&gt; Illinois         10.4     249       83 24.0
&gt; Indiana           7.2     113       65 21.0
&gt; Iowa              2.2      56       57 11.3
&gt; Kansas            6.0     115       66 18.0
&gt; Kentucky          9.7     109       52 16.3
&gt; Louisiana        15.4     249       66 22.2
&gt; Maine             2.1      83       51  7.8
&gt; Maryland         11.3     300       67 27.8
&gt; Massachusetts     4.4     149       85 16.3
&gt; Michigan         12.1     255       74 35.1
&gt; Minnesota         2.7      72       66 14.9
&gt; Mississippi      16.1     259       44 17.1
&gt; Missouri          9.0     178       70 28.2
&gt; Montana           6.0     109       53 16.4
&gt; Nebraska          4.3     102       62 16.5
&gt; Nevada           12.2     252       81 46.0
&gt; New Hampshire     2.1      57       56  9.5
&gt; New Jersey        7.4     159       89 18.8
&gt; New Mexico       11.4     285       70 32.1
&gt; New York         11.1     254       86 26.1
&gt; North Carolina   13.0     337       45 16.1
&gt; North Dakota      0.8      45       44  7.3
&gt; Ohio              7.3     120       75 21.4
&gt; Oklahoma          6.6     151       68 20.0
&gt; Oregon            4.9     159       67 29.3
&gt; Pennsylvania      6.3     106       72 14.9
&gt; Rhode Island      3.4     174       87  8.3
&gt; South Carolina   14.4     279       48 22.5
&gt; South Dakota      3.8      86       45 12.8
&gt; Tennessee        13.2     188       59 26.9
&gt; Texas            12.7     201       80 25.5
&gt; Utah              3.2     120       80 22.9
&gt; Vermont           2.2      48       32 11.2
&gt; Virginia          8.5     156       63 20.7
&gt; Washington        4.0     145       73 26.2
&gt; West Virginia     5.7      81       39  9.3
&gt; Wisconsin         2.6      53       66 10.8
&gt; Wyoming           6.8     161       60 15.6
```

Contiene **.bg-purple_light[estad√≠sticas de arrestos en 1973 (por cada 100 000 habitantes)]** por agresi√≥n, asesinato y violaci√≥n, en cada uno de los 50 estados de Estados Unidos.
]

.panel[.panel-name[Visualizar]

Con `View()` se nos abrir√° el conjunto en un formato ¬´excelizado¬ª. Adem√°s con `head()` podemos **.bg-purple_light[visualizar la cabecera]** (primeras) del conjunto de datos.


```r
head(USArrests)
```

```
&gt;            Murder Assault UrbanPop Rape
&gt; Alabama      13.2     236       58 21.2
&gt; Alaska       10.0     263       48 44.5
&gt; Arizona       8.1     294       80 31.0
&gt; Arkansas      8.8     190       50 19.5
&gt; California    9.0     276       91 40.6
&gt; Colorado      7.9     204       78 38.7
```

]

.panel[.panel-name[Variables]

Con la funci√≥n `names()` podemos obtener directamente el **.bg-purple_light[nombre de las variables]** (tambi√©n podemos usarlo para renombrarlas)


```r
names(USArrests)
```

```
&gt; [1] "Murder"   "Assault"  "UrbanPop" "Rape"
```

El conjunto contiene los **3 tipos de delito** mencionados (para cada estado), y adem√°s el **porcentaje de poblaci√≥n que vive en √°reas urbanas**. Esto lo podemos saber ejecutando la ayuda con `? datasets::USArrests`.

]

.panel[.panel-name[Individuos]

Con la funci√≥n `row.names()` podemos obtener el **.bg-purple_light[nombre de las filas]** (de los estados) para cada uno de ellos.


```r
row.names(USArrests)
```

```
&gt;  [1] "Alabama"        "Alaska"         "Arizona"        "Arkansas"      
&gt;  [5] "California"     "Colorado"       "Connecticut"    "Delaware"      
&gt;  [9] "Florida"        "Georgia"        "Hawaii"         "Idaho"         
&gt; [13] "Illinois"       "Indiana"        "Iowa"           "Kansas"        
&gt; [17] "Kentucky"       "Louisiana"      "Maine"          "Maryland"      
&gt; [21] "Massachusetts"  "Michigan"       "Minnesota"      "Mississippi"   
&gt; [25] "Missouri"       "Montana"        "Nebraska"       "Nevada"        
&gt; [29] "New Hampshire"  "New Jersey"     "New Mexico"     "New York"      
&gt; [33] "North Carolina" "North Dakota"   "Ohio"           "Oklahoma"      
&gt; [37] "Oregon"         "Pennsylvania"   "Rhode Island"   "South Carolina"
&gt; [41] "South Dakota"   "Tennessee"      "Texas"          "Utah"          
&gt; [45] "Vermont"        "Virginia"       "Washington"     "West Virginia" 
&gt; [49] "Wisconsin"      "Wyoming"
```

]


.panel[.panel-name[Dimensiones]

¬øC√≥mo averiguar el **.bg-purple_light[n√∫mero de registros y el n√∫mero de variables]**?


```r
dim(USArrests)
```

```
&gt; [1] 50  4
```

```r
nrow(USArrests)
```

```
&gt; [1] 50
```

```r
ncol(USArrests)
```

```
&gt; [1] 4
```

]

.panel[.panel-name[Selecci√≥n]

Al igual que antes, podemos **.bg-purple_light[seleccionar filas por √≠ndices]** y **.bg-purple_light[variables nombre]**.



```r
USArrests[c(2, 10), c("Murder", "Assault")]
```

```
&gt;         Murder Assault
&gt; Alaska    10.0     263
&gt; Georgia   17.4     211
```

Tambi√©n podemos usar las ventajas de los `data.frame` para acceder a las variables.


```r
USArrests$Murder
```

```
&gt;  [1] 13.2 10.0  8.1  8.8  9.0  7.9  3.3  5.9 15.4 17.4  5.3  2.6 10.4  7.2  2.2
&gt; [16]  6.0  9.7 15.4  2.1 11.3  4.4 12.1  2.7 16.1  9.0  6.0  4.3 12.2  2.1  7.4
&gt; [31] 11.4 11.1 13.0  0.8  7.3  6.6  4.9  6.3  3.4 14.4  3.8 13.2 12.7  3.2  2.2
&gt; [46]  8.5  4.0  5.7  2.6  6.8
```

]

.panel[.panel-name[subset]

En el caso de los `data.frame` tenemos adem√°s a nuestro disposici√≥n una **herramienta muy potente**: la funci√≥n `subset()`. Dicha funci√≥n nos va a permitir **.bg-purple_light[seleccionar filas y columnas a la vez]**, tomando de entrada la tabla, `subset = ...` igual a la **condici√≥n l√≥gica** para filtrar registros (filas) y `select = ...` igual al  nombre de las columnas que queremos seleccionar.


```r
subset(USArrests, subset = UrbanPop &gt; 70, select = c("Murder"))
```

```
&gt;               Murder
&gt; Arizona          8.1
&gt; California       9.0
&gt; Colorado         7.9
&gt; Connecticut      3.3
&gt; Delaware         5.9
&gt; Florida         15.4
&gt; Hawaii           5.3
&gt; Illinois        10.4
&gt; Massachusetts    4.4
&gt; Michigan        12.1
&gt; Nevada          12.2
&gt; New Jersey       7.4
&gt; New York        11.1
&gt; Ohio             7.3
&gt; Pennsylvania     6.3
&gt; Rhode Island     3.4
&gt; Texas           12.7
&gt; Utah             3.2
&gt; Washington       4.0
```

]

.panel[.panel-name[Caso pr√°ctico]

* üìù **Ejercicio**: filtra aquellos estados cuyo porcentaje de poblaci√≥n urbana sea inferior al 70% y donde las agresiones sean superiores a 250 por cada 100 000 habitantes, seleccionando solo las variables `Murder` y `Rape`

]

.panel[.panel-name[Caso pr√°ctico]

* üìù **Ejercicio**: filtra aquellos estados cuyo porcentaje de poblaci√≥n urbana sea inferior al 70% y donde las agresiones sean superiores a 250 por cada 100 000 habitantes, seleccionando solo las variables.


```r
subset(USArrests, subset = UrbanPop &lt; 70 &amp; Assault &gt; 250,
       select = c("Murder", "Rape"))
```

```
&gt;                Murder Rape
&gt; Alaska           10.0 44.5
&gt; Maryland         11.3 27.8
&gt; Mississippi      16.1 17.1
&gt; North Carolina   13.0 16.1
&gt; South Carolina   14.4 22.5
```

]

]

---

name: tibble

# Mejorando los data.frame: .orange[TIBBLE]
 
Las tablas en formato `tibble` (con `tibble()` del paquete `{tibble}`, su clase ser√° `tbl_df`) son un tipo de `data.frame` mejorado, para una gesti√≥n **.bg-purple_light[m√°s √°gil, eficiente y coherente]**. Las tablas en formato `tibble` tienen **.bg-purple_light[4 ventajas principales]**

&lt;img src="./img/tibble.svg" width="30%" style="display: block; margin: auto;" /&gt;

---

# Mejorando los data.frame: .orange[TIBBLE]


*  Muestran **.bg-purple_light[metainformaci√≥n de las variables]**, y solo imprime por defecto las primeras filas.


```r
library(tibble)
tabla_tb &lt;- tibble("x" = 1:50, "y" = rep(c("a", "b", "c", "d", "e"), 10),
                   "logica" = rep(c(TRUE, FALSE), 25))
tabla_tb
```

```
&gt; # A tibble: 50 √ó 3
&gt;        x y     logica
&gt;    &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; 
&gt;  1     1 a     TRUE  
&gt;  2     2 b     FALSE 
&gt;  3     3 c     TRUE  
&gt;  4     4 d     FALSE 
&gt;  5     5 e     TRUE  
&gt;  6     6 a     FALSE 
&gt;  7     7 b     TRUE  
&gt;  8     8 c     FALSE 
&gt;  9     9 d     TRUE  
&gt; 10    10 e     FALSE 
&gt; # ‚Ä¶ with 40 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```



---

# Mejorando los data.frame: .orange[TIBBLE]
 
Puedes **imprimir las filas y columnas** que quieras con `print()`


```r
*print(tabla_tb, n = 12, width = Inf)
```

```
&gt; # A tibble: 50 √ó 3
&gt;        x y     logica
&gt;    &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; 
&gt;  1     1 a     TRUE  
&gt;  2     2 b     FALSE 
&gt;  3     3 c     TRUE  
&gt;  4     4 d     FALSE 
&gt;  5     5 e     TRUE  
&gt;  6     6 a     FALSE 
&gt;  7     7 b     TRUE  
&gt;  8     8 c     FALSE 
&gt;  9     9 d     TRUE  
&gt; 10    10 e     FALSE 
&gt; 11    11 a     TRUE  
&gt; 12    12 b     FALSE 
&gt; # ‚Ä¶ with 38 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---

# Mejorando los data.frame: .orange[TIBBLE]
 

* La funci√≥n `tibble()` **.bg-purple_light[construye las variables secuencialmente]**, pudiendo hacer uso en la propia definici√≥n de variables reci√©n definidas en dicha definici√≥n.


```r
# data.frame
data.frame("x1" = 1:3, "x2" = 4:6, "y" = x1 * x2)
```

```
&gt; Error in data.frame(x1 = 1:3, x2 = 4:6, y = x1 * x2): objeto 'x1' no encontrado
```


```r
# tibble
tibble("x1" = 1:3, "x2" = 4:6, "y" = x1 * x2)
```

```
&gt; # A tibble: 3 √ó 3
&gt;      x1    x2     y
&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;
&gt; 1     1     4     4
&gt; 2     2     5    10
&gt; 3     3     6    18
```


---

# Mejorando los data.frame: .orange[TIBBLE]
 
* Si accedes a una **.bg-purple_light[columna que no existe]** avisa con un **.bg-red[warning]**.


```r
tabla_df &lt;- data.frame("x" = 1:50, "y" = rep(c("a", "b", "c", "d", "e"), 10),
                   "logica" = rep(c(TRUE, FALSE), 25))
```

.pull-left[


```r
# data.frame
tabla_df$variable_inexistente
```

```
&gt; NULL
```

]

.pull-right[


```r
# tibble
tabla_tb$variable_inexistente
```

```
&gt; Warning: Unknown or uninitialised column: `variable_inexistente`.
```

```
&gt; NULL
```

]

---


# Mejorando los data.frame: .orange[TIBBLE]

* No solo no te cambiar√° el tipo de datos sino que **.bg-purple_light[no te cambiar√° el nombre de las variables]**.

.pull-left[


```r
data.frame(":)" = "emoticono",
           " " = "en blanco",
           "2000" = "n√∫mero")
```

```
&gt;         X..        X.  X2000
&gt; 1 emoticono en blanco n√∫mero
```

]

.pull-right[


```r
tibble(":)" = "emoticono",
       " " = "en blanco",
       "2000" = "n√∫mero")
```

```
&gt; # A tibble: 1 √ó 3
&gt;   `:)`      ` `       `2000`
&gt;   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt; 
&gt; 1 emoticono en blanco n√∫mero
```

]

---


# Mejorando los data.frame: .orange[TIBBLE]

Si ya tienes un `data.frame` es altamente recomendable **.bg-purple_light[convertirlo a tibble]** con `as_tibble()` (del paquete `{dplyr}`)


```r
library(dplyr)
as_tibble(USArrests)
```

```
&gt; # A tibble: 50 √ó 4
&gt;    Murder Assault UrbanPop  Rape
&gt;     &lt;dbl&gt;   &lt;int&gt;    &lt;int&gt; &lt;dbl&gt;
&gt;  1   13.2     236       58  21.2
&gt;  2   10       263       48  44.5
&gt;  3    8.1     294       80  31  
&gt;  4    8.8     190       50  19.5
&gt;  5    9       276       91  40.6
&gt;  6    7.9     204       78  38.7
&gt;  7    3.3     110       77  11.1
&gt;  8    5.9     238       72  15.8
&gt;  9   15.4     335       80  31.9
&gt; 10   17.4     211       60  25.8
&gt; # ‚Ä¶ with 40 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

Puedes consultar **m√°s funcionalidades** de dichos datos en &lt;https://tibble.tidyverse.org/&gt;

---

# Mejorando los data.frame: .orange[TIBBLE]

Una de las ventajas es la funci√≥n `glimpse()`, que nos permite obtener el **.bg-purple_light[resumen de columnas]** (no es para tener un resumen de los datos sino para ver las variables que tenemos y su tipo).


```r
glimpse(tabla_tb)
```

```
&gt; Rows: 50
&gt; Columns: 3
&gt; $ x      &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, ‚Ä¶
&gt; $ y      &lt;chr&gt; "a", "b", "c", "d", "e", "a", "b", "c", "d", "e", "a", "b", "c"‚Ä¶
&gt; $ logica &lt;lgl&gt; TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE‚Ä¶
```

---

# Mejorando los data.frame: .orange[TIBBLE]

Am√©n de poder convetir con `as_tibble()` podemos **.bg-purple_light[crearlos por filas]** (como copiar y pegar de una tabla en documento) en lugar de por columnas con `tribble()`


```r
datos &lt;- tribble(
  ~colA, ~colB,
  "a",   1,
  "b",   2)
datos
```

```
&gt; # A tibble: 2 √ó 2
&gt;   colA   colB
&gt;   &lt;chr&gt; &lt;dbl&gt;
&gt; 1 a         1
&gt; 2 b         2
```

&amp;nbsp;

--

**.bg-green_light[CONSEJO]**: prueba adem√°s el paquete `{datapasta}`, que nos permite **.bg-purple_light[copiar y pegar tablas de p√°ginas web]**


---

name: ejercicios-tibble

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: carga del paquete `{datasets}` el conjunto de datos `airquality` (contiene variables de la calidad del aire de la ciudad de Nueva York desde mayo hasta septiembre de 1973). ¬øEs el conjunto de datos airquality de tipo tibble? En caso negativo, convi√©rtelo a `tibble`.

* üìù **Ejercicio 2**: obt√©n el nombre de las variables y las dimensiones del conjunto de datos. ¬øCu√°ntas variables hay? ¬øCu√°ntos d√≠as se han medido?
 
* üìù **Ejercicio 3**:  modifica el c√≥digo inferior para que nos filtre solo los datos del mes de agosto.
 

```r
# Filtramos filas
filtro_fila &lt;- subset(., subset = Month &lt; 6)
filtro_fila
```

]

.panel[.panel-name[Soluci√≥n ej. 1]


```r
library(datasets)
class(airquality) # no es data.frame
```

```
&gt; [1] "data.frame"
```

```r
# Convertimos a tibble
airquality &lt;- as_tibble(airquality)
class(airquality)
```

```
&gt; [1] "tbl_df"     "tbl"        "data.frame"
```

]

.panel[.panel-name[Soluci√≥n ej. 2]


```r
names(airquality)
```

```
&gt; [1] "Ozone"   "Solar.R" "Wind"    "Temp"    "Month"   "Day"
```

```r
dim(airquality)
```

```
&gt; [1] 153   6
```

```r
# N√∫mero variables
ncol(airquality)
```

```
&gt; [1] 6
```

```r
# N√∫mero d√≠as
nrow(airquality)
```

```
&gt; [1] 153
```

]


.panel[.panel-name[Soluci√≥n ej. 3]


```r
# Filtramos filas
filtro_fila &lt;- subset(airquality, subset = Month == 8)
filtro_fila
```

```
&gt; # A tibble: 31 √ó 6
&gt;    Ozone Solar.R  Wind  Temp Month   Day
&gt;    &lt;int&gt;   &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
&gt;  1    39      83   6.9    81     8     1
&gt;  2     9      24  13.8    81     8     2
&gt;  3    16      77   7.4    82     8     3
&gt;  4    78      NA   6.9    86     8     4
&gt;  5    35      NA   7.4    85     8     5
&gt;  6    66      NA   4.6    87     8     6
&gt;  7   122     255   4      89     8     7
&gt;  8    89     229  10.3    90     8     8
&gt;  9   110     207   8      90     8     9
&gt; 10    NA     222   8.6    92     8    10
&gt; # ‚Ä¶ with 21 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```
]

]

---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 4**: del conjunto selecciona aquellos datos que no sean ni de julio ni de agosto.

* üìù **Ejercicio 5**: modifica el siguiente c√≥digo para quedarte solo con las variable de ozono y temperatura.
 

```r
filtro_col &lt;- subset(.,  select = c("Ozone"))
filtro_col
```

* üìù **Ejercicio 6**:  selecciona los datos de temperatura y viento de agosto. Traduce a castellano el nombre de las columnas del conjunto filtrado.


* üìù **Ejercicio 7**: a√±ade a los datos originales una columna con la fecha completa (recuerda que es del a√±o 1973 todas las observaciones).

]

.panel[.panel-name[Soluci√≥n ej. 4]


```r
subset(airquality, subset = !(Month %in% c(7, 8)))
```

```
&gt; # A tibble: 91 √ó 6
&gt;    Ozone Solar.R  Wind  Temp Month   Day
&gt;    &lt;int&gt;   &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
&gt;  1    41     190   7.4    67     5     1
&gt;  2    36     118   8      72     5     2
&gt;  3    12     149  12.6    74     5     3
&gt;  4    18     313  11.5    62     5     4
&gt;  5    NA      NA  14.3    56     5     5
&gt;  6    28      NA  14.9    66     5     6
&gt;  7    23     299   8.6    65     5     7
&gt;  8    19      99  13.8    59     5     8
&gt;  9     8      19  20.1    61     5     9
&gt; 10    NA     194   8.6    69     5    10
&gt; # ‚Ä¶ with 81 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

]

.panel[.panel-name[Soluci√≥n ej. 5]


```r
# Filtramos columnas
filtro_col &lt;- subset(airquality,  select = c("Ozone", "Temp"))
filtro_col
```

```
&gt; # A tibble: 153 √ó 2
&gt;    Ozone  Temp
&gt;    &lt;int&gt; &lt;int&gt;
&gt;  1    41    67
&gt;  2    36    72
&gt;  3    12    74
&gt;  4    18    62
&gt;  5    NA    56
&gt;  6    28    66
&gt;  7    23    65
&gt;  8    19    59
&gt;  9     8    61
&gt; 10    NA    69
&gt; # ‚Ä¶ with 143 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

]

.panel[.panel-name[Soluci√≥n ej. 6]


```r
datos &lt;- subset(airquality, subset = Month == 8, select = c("Temp", "Wind"))
datos 
```

```
&gt; # A tibble: 31 √ó 2
&gt;     Temp  Wind
&gt;    &lt;int&gt; &lt;dbl&gt;
&gt;  1    81   6.9
&gt;  2    81  13.8
&gt;  3    82   7.4
&gt;  4    86   6.9
&gt;  5    85   7.4
&gt;  6    87   4.6
&gt;  7    89   4  
&gt;  8    90  10.3
&gt;  9    90   8  
&gt; 10    92   8.6
&gt; # ‚Ä¶ with 21 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

```r
# Traducimos a castellano el nombre
names(datos) &lt;- c("temperatura", "viento")
glimpse(datos)
```

```
&gt; Rows: 31
&gt; Columns: 2
&gt; $ temperatura &lt;int&gt; 81, 81, 82, 86, 85, 87, 89, 90, 90, 92, 86, 86, 82, 80, 79‚Ä¶
&gt; $ viento      &lt;dbl&gt; 6.9, 13.8, 7.4, 6.9, 7.4, 4.6, 4.0, 10.3, 8.0, 8.6, 11.5, ‚Ä¶
```

]

.panel[.panel-name[Soluci√≥n ej. 7]


```r
nuevos_datos &lt;- 
  tibble(airquality, "fecha" = as_date(glue("1973-{Month}-{Day}")))
nuevos_datos
```

```
&gt; # A tibble: 153 √ó 7
&gt;    Ozone Solar.R  Wind  Temp Month   Day fecha     
&gt;    &lt;int&gt;   &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;date&gt;    
&gt;  1    41     190   7.4    67     5     1 1973-05-01
&gt;  2    36     118   8      72     5     2 1973-05-02
&gt;  3    12     149  12.6    74     5     3 1973-05-03
&gt;  4    18     313  11.5    62     5     4 1973-05-04
&gt;  5    NA      NA  14.3    56     5     5 1973-05-05
&gt;  6    28      NA  14.9    66     5     6 1973-05-06
&gt;  7    23     299   8.6    65     5     7 1973-05-07
&gt;  8    19      99  13.8    59     5     8 1973-05-08
&gt;  9     8      19  20.1    61     5     9 1973-05-09
&gt; 10    NA     194   8.6    69     5    10 1973-05-10
&gt; # ‚Ä¶ with 143 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

]


]

---

# Ejercicios extras

.panelset[
.panel[.panel-name[Ejercicios extras]


* üìù **Ejercicio 8**: define un `tibble` con tres variables num√©ricas `a, b, c`, tal que la tercera sea el producto de las dos primeras `c = a * b`.

* üìù **Ejercicio 9**:  define un tibble con tres variables de nombres `variable`, `2`, `tercera` y `:)`, e intenta acceder a ellas.
 
* üìù **Ejercicio 10**:  obten de los paquetes `{dplyr}` y `{gapminder}` los conjuntos de datos `starwars` y `gapminder`. Comprueba el n√∫mero de variables, de registros e imprime los datos

]

.panel[.panel-name[Soluci√≥n ej. 8]


```r
tibble("a" = 1:4, "b" = 11:14, "c" = a * b)
```

```
&gt; # A tibble: 4 √ó 3
&gt;       a     b     c
&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;
&gt; 1     1    11    11
&gt; 2     2    12    24
&gt; 3     3    13    39
&gt; 4     4    14    56
```

]

.panel[.panel-name[Soluci√≥n ej. 9]


```r
datos &lt;- tibble("variable" = 1, "2" = "a", "tercera" = 3, ":)" = "b")

# Accedemos
datos$variable
```

```
&gt; [1] 1
```

```r
datos$`2`
```

```
&gt; [1] "a"
```

```r
datos$tercera
```

```
&gt; [1] 3
```

```r
datos$`:)`
```

```
&gt; [1] "b"
```

]

.panel[.panel-name[Soluci√≥n ej. 10]


```r
library(dplyr)
dim(starwars)
```

```
&gt; [1] 87 14
```

```r
library(gapminder)
dim(gapminder)
```

```
&gt; [1] 1704    6
```

]

]

---

class: inverse center middle
name: intro-estadistica

# Introducci√≥n a la ESTAD√çSTICA

---



# Introducci√≥n a la .orange[ESTAD√çSTICA]

&lt;img src="./img/tellme.jpg" width="50%" style="display: block; margin: auto;" /&gt;


---

# Introducci√≥n a la .orange[ESTAD√çSTICA]

.pull-left[

**.bg-purple_light[¬øQu√© es la estad√≠stica?]** Seg√∫n la RAE...

* **.bg-purple_light[Estudio de los datos]** cuantitativos de la poblaci√≥n, de los recursos naturales e industriales, del tr√°fico o de cualquier otra manifestaci√≥n de las sociedades

* **.bg-purple_light[Rama de la matem√°tica]** que utiliza grandes conjuntos de datos num√©ricos para obtener inferencias basadas en el c√°lculo de probabilidades.

]

.pull-right[

&lt;img src="./img/perez_reverte.jpg" width="90%" style="display: block; margin: auto;" /&gt;

]

---

# Introducci√≥n a la .orange[ESTAD√çSTICA]

.pull-left[

**.bg-purple_light[¬øQu√© es la estad√≠stica?]** Seg√∫n la RAE...

* **.bg-purple_light[Estudio de los datos]** cuantitativos de la poblaci√≥n, de los recursos naturales e industriales, del tr√°fico o de cualquier otra manifestaci√≥n de las sociedades

* **.bg-purple_light[Rama de la matem√°tica]** que utiliza grandes conjuntos de datos num√©ricos para obtener inferencias basadas en el c√°lculo de probabilidades.

]

.pull-right[

&lt;img src="./img/perez_reverte.jpg" width="51%" style="display: block; margin: auto;" /&gt;

]


&gt; ¬´La estad√≠stica est√° caracterizada por una informaci√≥n acerca de un colectivo o universo, lo que constituye su objeto material; un modo propio de razonamiento, el m√©todo estad√≠stico, lo que constituye su objeto formal y unas previsiones de cara al futuro, lo que implica un ambiente de incertidumbre¬ª (Cabri√°, 1994). 

---

# Introducci√≥n a la .orange[ESTAD√çSTICA]

.pull-left[

La **.bg-purple_light[estad√≠stica]** como ciencia naci√≥ como una **.bg-purple_light[ciencia del Estado]**, de hecho nuestra palabra actual viene de dos palabras previas

* del t√©rmino (neo)latino ¬´statisticum collegium¬ª: consejo de Estado.
* del alem√°n **.bg-purple_light[¬´statistik¬ª]** (ciencia del Estado), t√©rmino introducido por G. Achenwall.

&amp;nbsp;

En su origen fue una desarrollada como una mera **.bg-purple_light[herramienta para la administraci√≥n eficiente]** de la sociedad.

]

.pull-right[

&lt;img src="./img/biblia.jpg" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]

---

# Introducci√≥n a la .orange[ESTAD√çSTICA]

.pull-left[

Los **.bg-purple_light[primeros usos]** documentados son de hecho para elaborar **.bg-purple_light[censos y de uso militar]** en Mesopotamia, China y Egipto, con el objetivo de tener un **.bg-purple_light[recuento y organizaci√≥n de recursos]**

* Cobrar **impuestos**
* Repartir **tierras**
* Reclutar **soldados**

&amp;nbsp;

Seg√∫n Tuc√≠dides, conceptos como la **.bg-purple_light[moda]** ya exist√≠an en el siglo V a.C.: para asaltar la muralla de Platea, se usaba la estad√≠stica para el recuento de ladrillos de la muralla y aproximar su altura.

]


.pull-right[

&lt;img src="./img/census.jpg" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]


---

# Introducci√≥n a la .orange[ESTAD√çSTICA]

El **.bg-purple_light[objetivo principal]** de la estad√≠stica, ayudada por la probabilidad, es **.bg-purple_light[analizar datos y fen√≥menos]** cuyo mecanismo subyacente suele ser un experimento aleatorio.

--

### Experimento .green[ALEATORIO]

Un experimento se puede clasificar principalmente en

* **.bg-purple_light[Determinista]**: con las mismas condiciones iniciales, se obtiene el mismo resultado. Por ejemplo, el movimiento parab√≥lico de un proyectil sin rozamiento.

* **.bg-purple_light[Aleatorio]**: con las mismas condiciones iniciales, se pueden obtener resultados diferentes. Por ejemplo, el tiempo entre clientes que entran en un establecimiento.

---

# Introducci√≥n a la .orange[ESTAD√çSTICA]


Un error muy habitual es interpretar lo ¬´aleatorio¬ª como **.bg-purple_light[equiprobable]**: un suceso aleatorio **.bg-red_light[NO IMPLICA]** que todas sus opciones tengan la misma probabilidad de suceder.

* **.bg-purple_light[Aleatorio]**: el resultado individual inmediato no se puede asegurar con total certeza (tenemos **.bg-orange[incertidumbre]**)

* **.bg-purple_light[Sucesos equiprobables]**: colecci√≥n de sucesos de una variable aleatoria cuya probabilidad de suceder es la misma para todos ellos.

--

**.bg-green_light[RECUERDA]**: un **dado trucado** sigue siendo aleatorio, igual de aleatorio que un dado sin trucar. No hay algo m√°s o menos aleatorio, solo **.bg-purple_light[diferentes distribuciones de probabilidad]** que modelizan los sucesos.

---

# .green[POBLACI√ìN] vs .orange[MUESTRA]

.pull-left[

**.bg-green_light[POBLACI√ìN]**

Una poblaci√≥n ser√° el conjunto total o **.bg-purple_light[colectivo de individuos factibles de estudiar]**, o de posibles elementos/eventos de los podr√≠amos tener observaciones (por ejemplo, 47 millones de espa√±oles). 

Es nuestro **.bg-purple_light[universo te√≥rico]**, y nuestro objetivo ser√° conocer algunas de las propiedades de esa poblaci√≥n.

&amp;nbsp;

**.bg-green_light[INDIVIDUO]**

Cada uno de los elementos o eventos de la poblaci√≥n.

]

.pull-right[

**.bg-orange[MUESTRA (SAMPLE)]**

Dado que la **.bg-red_light[poblaci√≥n suele ser inaccesible]** en su totalidad (no podemos medir a TODA la poblaci√≥n), debemos realizar una **.bg-purple_light[selecci√≥n]** de un conjunto de individuos

Dicho subconjunto ser√° siempre de **.bg-purple_light[tama√±o finito n]**, de forma que la muestra sea de alguna manera **.bg-purple_light[¬´representativa¬ª]** de la poblaci√≥n (bien a lo largo de los individuos, bien a lo largo del tiempo). Un estudio estad√≠stico realizado sobre la totalidad de una poblaci√≥n se denomina censo. 


]

---

# .green[POBLACI√ìN] vs .orange[MUESTRA]


&lt;img src="./img/poblacion_muestra.jpg" width="55%" style="display: block; margin: auto;" /&gt;

---

# .green[CARACTERES] y .orange[MODALIDADES]


.pull-left[

* **.bg-purple_light[Caracteres (variables)]**: cada una de las **caracter√≠sticas o cualidades** que se podr√≠an medir o analizar para cada individuo de la poblaci√≥n (y de los que disponemos el valor para cada individuo de la muestra).

* **.bg-purple_light[Modalidades]**: conjunto de los **diferentes valores** que puede adoptar una caracter√≠stica o variable.


]

.pull-right[

Un **.bg-purple_light[ejemplo]** (poblaci√≥n de alumnos de UCM)

* **.bg-orange[Caracteres o variables]**:
  - sexo
  - edad
  - carrera
  - estatura

* **.bg-orange[Modalidades]**:
  - sexo: hombre/mujer.
  - edad: 18, 19, 20, 21, 22, ..., 98, 99, 100
  - carrera: mates, filolog√≠a, historia, etc.
  - estatura: intervalo [130cm, 200cm].
  
* **.bg-orange[Muestra]**: conjunto de 300 estudiantes seleccionados al azar.
]

---

# .orange[TIPOS] de variables

Imagina las siguientes variables:

* ¬øTienes hermanos?
* Resultado de la tirada de un dado
* Color de zapatillas
* Nivel de estudios
* N√∫mero de hermanos
* N√∫mero de pelos en la cabeza
* Resultado de un dado dividido entre 10
* Temperatura ¬∫C
* G√©nero
* Estatura o peso
* Religi√≥n


**.bg-purple_light[¬øCU√ÅL ES LA DIFERENCIA ENTRE ELLAS?]**

---


# .orange[TIPOS] de variables

.pull-left[

Imagina las siguientes variables:

* ¬øTienes hermanos?
* Resultado de la tirada de un dado
* Color de zapatillas
* Nivel de estudios
* N√∫mero de hermanos
* N√∫mero de pelos en la cabeza
* Resultado de un dado dividido entre 10
* Temperatura ¬∫C
* G√©nero
* Estatura o peso
* Religi√≥n


**.bg-purple_light[¬øCU√ÅL ES LA DIFERENCIA ENTRE ELLAS?]**

]

.pull-right[

* **.bg-purple_light[Cualitativas]**: representan **.bg-orange[cualidades o categor√≠as]** no cuantificables num√©ricamente (sexo, estado civil, etc).

  - **.bg-purple_light[Ordinales]**: admiten **jerarqu√≠a** (suspenso-aprobado-notable).
  - **.bg-purple_light[Nominales]**: no tienen asociada una jerarqu√≠a (sexo, religi√≥n, color, etc).


* **.bg-purple_light[Cuantitativas]**: caracter√≠stica **.bg-orange[cuantificable num√©ricamente]**.

  - **.bg-purple_light[Discretas]**: se pueden contar y enumerar (aunque sean infinitos) (n¬∫ granos de arena, n¬∫ hermanos, etc).
  - **.bg-purple_light[Continuas]**: adem√°s de tomar infinitos valores, entre dos valores cualesquiera hay a su vez infinitas opciones (estatura, peso, etc).


]

---

# .orange[DISCRETA] vs .green[CONTINUAS]

&lt;img src="./img/discreta_continua.jpg" width="76%" style="display: block; margin: auto;" /&gt;

---

# Resumiendo informaci√≥n: .orange[MOMENTOS]

En estad√≠stica los **.bg-purple_light[momentos]** ser√°n par√°metros calculados a partir de los datos que, mediante una f√≥rmula, **.bg-purple_light[resumen num√©ricamente]** algunas caracter√≠sticas de nuestros datos:

--

* Medidas de **.bg-purple_light[centralizaci√≥n]**: en torno a qu√© valores se **concentran** los datos.

--

* Medidas de **.bg-purple_light[dispersi√≥n]**: cuantifican la **dispersi√≥n respecto al centro**.

--

* Medidas de **.bg-purple_light[posici√≥n/localizaci√≥n]**: c√≥mo se **localizan** los datos, valores que nos permiten segmentar nuestros datos en conjuntos de partes iguales (mismo % de datos, los famosos percentiles).

--

* Medidas de **.bg-purple_light[forma]**: nos complementan la caracterizaci√≥n de la distribuci√≥n, por ejemplo, indic√°ndonos la **direcci√≥n** en la que se desv√≠an los datos.


---

# Medidas de .orange[CENTRALIZACI√ìN]

Las **.bg-purple_light[medidas de centralizaci√≥n]** nos informan de los valores en torno a los que se **concentra** nuestra variable, un **.bg-purple_light[¬´representante¬ª]** de nuestra variable.

--

* **.bg-purple_light[Media]** (aritm√©tica, sin ponderar): definida como la suma de valores, dividida entre el tama√±o muestral. **.bg-red_light[Solo para cuantitativas]**

--

* **.bg-purple_light[Mediana]**: si ordenamos los datos de menor a mayor, el valor central (por debajo el 50%, por encima el 50%). **.bg-red_light[Solo si existe jerarqu√≠a de orden]**.

--

* **.bg-purple_light[Moda]**: el **valor o valores m√°s repetidos** de nuestra variable, lo m√°s frecuente. **.bg-red_light[Amodal]**: todos se repiten por igual -&gt; no hay moda.


---

# .orange[MEDIA] aritm√©tica

.pull-left[

Dada una muestra, la **.bg-purple_light[media (aritm√©tica) muestral]** `\(\overline{x}\)` se define como la suma de todos los valores dividida por el tama√±o muestral.

`$$\overline{x} = \frac{1}{N} \sum_{i=1}^{N} x_i$$`

Tambi√©n se puede definir como el **.bg-purple_light[valor ¬´m√°s cercano¬ª a todos los datos]** a la vez, minimizando las distancias (al cuadrado) de los datos a dicho valor.

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/media.jpg" alt="Extra√≠da de instagram.com/javieralvarezliebana" width="89%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de instagram.com/javieralvarezliebana&lt;/p&gt;
&lt;/div&gt;


]


---

# .orange[ROBUSTEZ] de la media

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/robustez.jpg" alt="Extra√≠da de instagram.com/javieralvarezliebana" width="43%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de instagram.com/javieralvarezliebana&lt;/p&gt;
&lt;/div&gt;

---


# .orange[MEDIANA]


.pull-left[

Dada una muestra, la **.bg-purple_light[mediana muestral]** se define como el valor que es mayor o igual que al menos el 50%, y menor igual que al menos el 50% de los datos

`$$Me_{x} = \displaystyle \arg \min_{x_i} \left\lbrace F_i &gt; 0.5 \right\rbrace$$`

En caso de `\(F_i = 0.5\)` en variables discretas, realizaremos la media de `\(x_i\)` y `\(x_{i+1}\)`.

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/mediana.jpg" alt="Extra√≠da de instagram.com/javieralvarezliebana" width="89%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de instagram.com/javieralvarezliebana&lt;/p&gt;
&lt;/div&gt;


]


---

# .orange[MODA]


.pull-left[

Dada una muestra, la **.bg-purple_light[moda muestral]** se define como el valor o valores m√°s repetidos (en caso de que existan)

`$$Mo_{x} = \displaystyle \arg \max_{x_i} f_i$$`

Podr√≠amos tener distribuciones **unimodales**, **bimodales**, **trimodales**...incluso **amodales**

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/moda.jpg" alt="Extra√≠da de instagram.com/javieralvarezliebana" width="89%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de instagram.com/javieralvarezliebana&lt;/p&gt;
&lt;/div&gt;


]

---

# .orange[ROBUSTEZ]

**.bg-green_light[¬øCu√°l es cu√°l?]**

&lt;img src="./img/ine_salarios.jpg" width="70%" style="display: block; margin: auto;" /&gt;


---

# Medidas de .orange[DISPERSI√ìN]

&lt;img src="./img/iker.jpg" width="45%" style="display: block; margin: auto;" /&gt;

--

El cambio clim√°tico, un problema de dispersi√≥n

---

# Medidas de .orange[DISPERSI√ìN]

&lt;img src="./img/fenom_extremos.jpg" width="70%" style="display: block; margin: auto;" /&gt;

El cambio clim√°tico, un **.bg-purple_light[problema de dispersi√≥n]**

---

# Medidas de .orange[DISPERSI√ìN]

.pull-left[

Una primera idea podr√≠a ser **.bg-purple_light[medir la distancia de cada dato al centro]**, es decir, restar cada dato de la media, y despu√©s realizar su promedio.

`$$\frac{1}{N} \sum_{i=1}^{N} \left(x_i - \overline{x} \right)$$`

**.bg-red_light[¬øProblema?]**

]

.pull-right[

&lt;img src="./img/distancia_var.jpg" width="99%" style="display: block; margin: auto;" /&gt;

]

--

&amp;nbsp;

Imagina que tenemos `\(X = \left\lbrace -5, -3, -1, 0, 1, 3, 5 \right\rbrace\)`: la media es 0, y el promedio de las distancias a la media tambi√©n ya que se **.bg-red_light[cancelan los signos]**.

**.bg-green_light[¬øSoluci√≥n?]**

---

# Medidas de .orange[DISPERSI√ìN]

En matem√°ticas suele ser **desaconsejable usar el valor absoluto** (dado que es una funci√≥n no derivable), as√≠ que lo que haremos ser√° calcula el **.bg-purple_light[promedio de las distancias al cuadrado]**


`$$s_{x}^{2} = \frac{1}{N} \sum_{i=1}^{N} \left(x_i - \overline{x} \right)^2 = \overline{x^2} - \overline{x}^2$$`

--

Esta medida de dispersi√≥n es lo que conocemos como **.bg-purple_light[VARIANZA muestral]**.

--

**.bg-red_light[CUIDADO]**: tanto `R` como el resto de software nos devolver√°n la cuasivarianza `\(S_{x}^{2}\)` (promedio entre `\(N-1\)`, no entre `\(N\)`), ya que es el **estimador insesgado** de la varianza poblacional `\(\sigma_{x}^2\)`: asumimos que los estimadores casi nunca coincidir√°n con su valor te√≥rico pero si repetimos el experimento un n√∫mero suficiente de veces, su promedio si tender√° a √©l.

`$${\rm E} [\overline{x}] = \mu, \quad {\rm E} [S_{x}^{}] = \sigma_{x}^{2}$$`



---

# Medidas de .orange[DISPERSI√ìN]


**.bg-red_light[¬øProblema?]**

--

&lt;img src="./img/albert_rivera.jpg" width="70%" style="display: block; margin: auto;" /&gt;

Necesitamos una medida de dispersi√≥n en las **unidades de los datos**.

---

# Medidas de .orange[DISPERSI√ìN]


Para tener una **.bg-purple_light[medida de dispersi√≥n en las unidades]** de los datos calcularemos la **.bg-purple_light[desviaci√≥n t√≠pica]**, como la ra√≠z cuadrada de la varianza


`$$s_{x} = \sqrt{s_{x}^{2}} = \sqrt{\frac{1}{N} \sum_{i=1}^{N} \left(x_i - \overline{x} \right)^2} = \sqrt{\overline{x^2} - \overline{x}^2}$$`
--

Imaginemos entonces que tenemos dos conjuntos de datos: estaturas (de 165 a 175 cm) y di√°metros de n√∫cleos de c√©lulas (de 3 a 7 micr√≥metros). Si obtenemos una  desviaci√≥n t√≠pica de 1 cm y 1.5 micr√≥metros, **.bg-purple_light[¬øcu√°l es m√°s dispersa?]**

--

&amp;nbsp;

¬ø**.bg-red_light[NO podemos comparar]** varianzas y desviaciones t√≠picas? 

---

# Medidas de .orange[DISPERSI√ìN]


&lt;img src="./img/sorry.jpg" width="80%" style="display: block; margin: auto;" /&gt;


**.bg-red_light[NO podemos comparar]** ni varianzas ni desviaciones t√≠picas: dependen de la magnitud y unidades de los datos.

---

# Medidas de .orange[DISPERSI√ìN]

Para tener una **.bg-purple_light[medida de dispersi√≥n adimensional]** que podamos comparar en distintos conjuntos de datos calcularemos el **.bg-purple_light[coeficiente de variaci√≥n]**, como la desv. t√≠pica entre el valor absoluto de la media


`$$CV_{x} = \frac{s_{x}}{\left| \overline{x} \right|}$$`

---

# Medidas de .orange[LOCALIZACI√ìN/POSICI√ìN]


Las **.bg-purple_light[medidas de posici√≥n]** nos **localizan** los datos: son **.bg-purple_light[valores que nos dividen]** un conjunto ordenado en un n√∫mero de tramos con el mismo tama√±o muestral. Ejemplo: la mediana es el percentil `\(P_{50}\)`, el decil `\(D_{5}\)` y el cuartil `\(C_{2}\)` o `\(q_2\)`.

* **.bg-purple_light[Percentil]**: valores `\(P_{\alpha}\)` del conjunto ordenado que dejan por debajo, al menos, el `\(\alpha  \%\)` de datos y el `\((100-\alpha) \%\)` por encima.   


* **.bg-purple_light[Decil]**: valores `\(D_{\alpha}\)` del conjunto ordenado que dividen los datos en 10 partes iguales, que dejan por debajo, al menos, el `\(10*\alpha  \%\)` de datos y el `\((100-10*\alpha) \%\)` por encima.   


* **.bg-purple_light[Cuartil]**: valores `\(C_{\alpha}\)` o `\(q_{\alpha}\)` del conjunto ordenado que dividen los datos en 4 partes iguales, que dejan por debajo, al menos, el `\(25*\alpha  \%\)` de datos y el `\((100-25*\alpha) \%\)` por encima.   

---

class: inverse center middle
name: clase-3

# CLASE 3: Tidydata

&amp;nbsp;


### [Estructuras de control](#estructuras-condicionales)

### [Tidydata](#tidydata)

### [Comunicando resultados](#rmd)

### [Caso pr√°ctico: datos de la OMS](#oms)


---

name: estructuras-condicionales

# Estructuras de control: .orange[IF-ELSE]


Una **.bg-purple_light[expresi√≥n de control]** ser√° un conjunto de √≥rdenes que nos permiten **.bg-purple_light[decidir el camino]** por el que queremos que avance nuestro c√≥digo:

* ¬øQu√© hacemos si sucede A?

* ¬øY si sucede B?

* ¬øTengo que programar X veces lo mismo si quiere que se repita?

&amp;nbsp;

Si has programado en alg√∫n otro lenguaje, estar√°s familiarizado/a con **.bg-purple_light[estructuras condicionales]** como un `if (blabla) {...} else {...}` (que los usaremos a veces) o **.bg-purple_light[bucles]** `for/while` (que intentaremos evitarlos lo m√°ximo posible).

---

# Estructuras de control: .orange[IF]

Una de las estructuras de control m√°s famosas de cualquier lenguaje de programaci√≥n es la **.bg-purple_light[estructura condicional]** `if`

&gt; SI las condiciones impuestas se cumplen (TRUE), ejecuta las √≥rdenes que tengamos dentro de la misma.

Por ejemplo, la estructura `if (x == 1) { c√≥digo A }` lo que har√° ser√° **.bg-purple_light[ejecutar el c√≥digo entre llaves]** pero **.bg-orange[SI Y SOLO SI]** la **.bg-purple_light[condici√≥n es cierta]** (en este caso, solo si `x` es igual 1). En **caso contrario, no hace nada**.

--

Definamos por ejemplo una variable sencilla, las edades de 8 personas y comprobemos cuales son menores de edad.


```r
edades &lt;- c(14, 17, 24, 56, 31, 20, 87, 73)
edades &lt; 18
```

```
&gt; [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
```

---

# Estructuras de control: .orange[IF]


Recuerda que con las funciones `any()` y `all()` podemos saber si **.bg-purple_light[todos o alguno de los elementos]** de un vector cumplen una condici√≥n.


```r
any(edades &lt; 18) # existe algun menor de edad
```

```
&gt; [1] TRUE
```

--

Con dichos elementos vamos a construir nuestra primera estructura condicional: queremos que, **.bg-purple_light[SI existe alg√∫n menor de edad, nos imprima un mensaje]**.


```r
if (any(edades &lt; 18)) { 
  
  print("existe alguna persona mayor de edad")
  
}
```

```
&gt; [1] "existe alguna persona mayor de edad"
```

---

# Estructuras de control: .orange[IF]


```r
if (any(edades &lt; 18)) { 
  
  print("existe alguna persona mayor de edad")
  
}
```


En caso de que **.bg-purple_light[no se cumplan las condiciones]** dentro del `if()` (FALSE), no suceder√° nada. 



```r
if (all(edades &gt;= 18)) { 
  
  print("todas las personas son mayores de edad")
  
}
```

F√≠jate que en este caso **no hemos obtenido ning√∫n mensaje** porque la condici√≥n `all(edades &gt;= 18)` no es cierta (no son todos mayores de 18 a√±os), as√≠ que **no ha ejecutado el c√≥digo**.

---

# Estructuras de control: .orange[IF-ELSE]

La estructura `if (condicion) { }` puede ser combinada con un `else { }`: cuando la **.bg-purple_light[condici√≥n no se cumpla]** (como en el √∫ltimo ejemplo), se **.bg-purple_light[ejecutar√° el c√≥digo alternativo]** que haya dentro del `else { }`, permiti√©ndonos decidir que sucede cuando S√ç se cumple y cuando NO se cumple.

--

Por ejemplo, la estructura `if (x == 1) { c√≥digo A } else { c√≥digo B }` ejecutar√° A si `x` es 1 y B en cualquier otro caso.


```r
if (all(edades &gt;= 18)) { 
  
  print("todas las personas son mayores de edad")
  
*} else {
  
  print("existe alguna persona menor de edad")
}
```

```
&gt; [1] "existe alguna persona menor de edad"
```

---

# Estructuras de control: .orange[IF-ELSE]

Dicha estructura `if - else` puede **.bg-purple_light[anidarse]**: imagina que queremos realizar una acci√≥n si todos fuesen mayores de edad; en caso contrario, pero si todos los menores tienen 16 a√±os o m√°s, realizar otra acci√≥n; en caso contrario, otra acci√≥n


```r
if (all(edades &gt;= 18)) { 
  
  print("todas las personas son mayores de edad")
  
} else if (all(edades &gt;= 16)) {
  
  print("Existe alguna persona menor de edad pero todos con 16 a√±os o m√°s")
  
} else { print("Existe alguna persona menor de 16 a√±os") }
```

```
&gt; [1] "Existe alguna persona menor de 16 a√±os"
```

**.bg-green_light[CONSEJO]**: puedes **colapsar las estructuras de control** pulsando en la flecha que aparece a la izquierda de ellas en tu script.


---

# Estructuras de control: .orange[IFELSE()]


Esta estructura condicional puede ser **.bg-purple_light[vectorizada]**: reunir en una sola fila un n√∫mero elevado de estructuras de comparaci√≥n con la funci√≥n `ifelse()`, cuyos argumentos de entrada ser√°n

* la condici√≥n a evaluar
* lo que sucede cuando se cumple
* lo que sucede cuando no se cumple

Con el ejemplo de las edades, vamos a dejar el dato ausente si son menores de edad, y si son mayores de edad se queda como est√°.


```r
# NA si no cumple la condici√≥n, la edad si se cumple.
*ifelse(edades &gt;= 18, edades, NA)
```

```
&gt; [1] NA NA 24 56 31 20 87 73
```

---

# Estructuras de control: .orange[IFELSE()]


Todas estas estructuras **.bg-purple_light[no solo sirven para datos num√©ricos]**. Vamos a definir un vector de nombres con algunos ausentes, y vamos a sustituir los ausentes por el texto `"nombre_desconocido"` (los que no sean ausentes, es decir los que `is.na()` devuelva FALSE, se quedan como est√°n).


```r
nombres &lt;- c("Juan", "Mar√≠a", NA, NA, "Luc√≠a",
             "Carmen", "Javier", NA, "Carlos", 
             NA, "Gregorio", "Paloma")

# Si tiene ausente --&gt; "nombre_desconocido"
# Si no tiene ausente --&gt; nombres originales
nombres &lt;-
  ifelse(is.na(nombres), "nombre_desconocido", nombres)
nombres
```

```
&gt;  [1] "Juan"               "Mar√≠a"              "nombre_desconocido"
&gt;  [4] "nombre_desconocido" "Luc√≠a"              "Carmen"            
&gt;  [7] "Javier"             "nombre_desconocido" "Carlos"            
&gt; [10] "nombre_desconocido" "Gregorio"           "Paloma"
```

---

name: bucles

# Estructuras de control: .orange[BUCLES]

Aunque la mayor√≠a de veces son sustituibles por otras expresiones m√°s legibles y eficientes, es importante que conozcamos otra archiconocida expresion de control: **.bg-purple_light[los bucles]**.

* `for { }`: permite **.bg-purple_light[repetir el mismo c√≥digo]** un **.bg-orange[n√∫mero fijo y conocido]** de veces (normalmente en funci√≥n de un √≠ndice).

* `while { }`: permite **.bg-purple_light[repetir el mismo c√≥digo]** un **.bg-orange[n√∫mero indeterminado de veces]**, hasta que una **condici√≥n** dada se deje de cumplir.

---

# Estructuras de control: .orange[BUCLES FOR]

Un **.bg-purple_light[bucle for]** es una estructura que nos permite **.bg-purple_light[repetir]** un conjunto de √≥rdenes un **.bg-orange[n√∫mero finito y conocido]** de veces: dado un **conjunto de √≠ndices**, el bucle ir√° recorriendo cada uno de ellos.

Vamos a definir un vector `x`. Si quisi√©ramos el primer elemento al cuadrado escribir√≠amos `x[1]^2`; si quisi√©ramos el segundo elemento al cuadrado `x[2]^2`; si lo quisi√©ramos hacer en general, para el elemento i-√©simo, `x[i]^2`. Lo que haremos dentro del `for (indices) { √≥rdenes }` es indicarle que valores ir√° tomando `i` (**.bg-purple_light[vector de √≠ndices]**).


```r
x &lt;- c(0, -7, 1, 4)
*for (i in 1:4) {
  
  print(x[i]^2) # √≥rdenes
  
}
```

```
&gt; [1] 0
&gt; [1] 49
&gt; [1] 1
&gt; [1] 16
```

---

# Estructuras de control: .orange[BUCLES FOR]


```r
*for (i in 1:4) {
  print(x[i]^2) # √≥rdenes
}
```

Lo que tenemos dentro de los par√©ntesis `for ()` no es m√°s que la **.bg-purple_light[secuencia de n√∫meros]** que hemos aprendido a construir. Si quisi√©ramos que haga lo mismo pero excluyendo por ejemplo el segundo elemento bastar√≠a con definir los √≠ndices a recorrer como `c(1, 3, 4)`.


```r
for (i in c(1, 3, 4)) {
  
  print(x[i]^2) # que lo imprima
  
}
```

```
&gt; [1] 0
&gt; [1] 1
&gt; [1] 16
```

---

# Estructuras de control: .orange[BUCLES FOR]

Podemos definir tambi√©n una variable `y &lt;- rep(0, 4)` (un **vector ¬´vac√≠o¬ª** lleno de ceros), y hacer que el **.bg-purple_light[elemento i-√©simo del vector]** se defina como `x[i]^2`


```r
y &lt;- rep(0, 4)
for (i in 1:4) {
  
  y[i] &lt;- x[i]^2
  
}
y
```

```
&gt; [1]  0 49  1 16
```

--

Lo anterior es equivalente a esto


```r
y &lt;- x^2
y
```

```
&gt; [1]  0 49  1 16
```

---

# .orange[BUCLES] suelen ser .red[INEFICIENTES]


Haciendo uso del paquete `microbenchmark` podemos comprobar como los **.bg-purple_light[bucles son menos eficientes]** (de ah√≠ que la mayor√≠a de veces los intentemos evitar si existe otra alternativa)


```r
library(microbenchmark)
x &lt;- 1:100
microbenchmark(x^2, 
               for (i in 1:100) { y[i] &lt;- x[i]^2 },
               times = 1000)
```

```
&gt; Unit: nanoseconds
&gt;                                     expr     min      lq        mean  median
&gt;                                      x^2     354     452    1249.407    1034
&gt;  for (i in 1:100) {     y[i] &lt;- x[i]^2 } 1696873 1870944 2206409.806 1998632
&gt;         uq     max neval cld
&gt;     1927.5   19893  1000  a 
&gt;  2322279.0 8763610  1000   b
```

---
 
# Estructuras de control: .orange[BUCLES FOR]


Veamos otro ejemplo **.bg-purple_light[combinando vectores num√©ricos y de caracteres]**: vamos a definir de nuevo un vector de edades y nombres, y vamos a recorrer cada uno imprimiento un mensaje por pantalla.


```r
nombres &lt;- c("Javi", "Laura", "Carlos", "Luc√≠a", "Mar")
edades &lt;- c(33, 51, 18, 43, 29)

# Recorremos cada uno de los 5 elementos e imprimimos un
# mensaje que depende de ese √≠ndice i
for (i in 1:5) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} a√±os")) 
  
}
```

```
&gt; Javi tiene 33 a√±os
&gt; Laura tiene 51 a√±os
&gt; Carlos tiene 18 a√±os
&gt; Luc√≠a tiene 43 a√±os
&gt; Mar tiene 29 a√±os
```

---

# Estructuras de control: .orange[BUCLES FOR]

F√≠jate que **.bg-purple_light[si no nos queremos preocupar de si a√±adimos otra persona]**, podemos hacer que el bucle empiece en 1 y termine en el **.bg-purple_light[√∫ltimo lugar]** (sea el que sea), usando `length()`.


```r
for (i in 1:length(nombres)) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} a√±os")) 
  
}
```

```
&gt; Javi tiene 33 a√±os
&gt; Laura tiene 51 a√±os
&gt; Carlos tiene 18 a√±os
&gt; Luc√≠a tiene 43 a√±os
&gt; Mar tiene 29 a√±os
```

---

# Estructuras de control: .orange[BUCLES FOR]

Aunque normalmente el conjunto que recorre el bucle suelen ser √≠ndices num√©ricos, podemos **.bg-purple_light[recorrer cualquier tipo de objeto]**, por ejemplo d√≠as e la semana


```r
library(stringr)
dias_semana &lt;- c("lunes", "martes", "mi√©rcoles", "jueves",
                 "viernes", "s√°bado", "domingo")

for (dias in dias_semana) { # dias recorre los d√≠as de la semana
  
  print(str_to_upper(dias)) # Imprimimos en may√∫sculas el d√≠a
}
```

```
&gt; [1] "LUNES"
&gt; [1] "MARTES"
&gt; [1] "MI√âRCOLES"
&gt; [1] "JUEVES"
&gt; [1] "VIERNES"
&gt; [1] "S√ÅBADO"
&gt; [1] "DOMINGO"
```

---

# Estructuras de control: .orange[BUCLES FOR]

Un √∫ltimo ejemplo: vamos a recorrer nuestro conjunto de datos `swiss` del paquete `{datasets}` y vamos a **pasar a dato ausente** todos los valores de fertilidad superiores a 80. Para ello recorreremos cada fila para despu√©s ejecutar un `if`.


```r
for (i in 1:nrow(swiss)) {
  
  # si cumple la condici√≥n dicha fila, ponemos ausente.
  if (swiss$Fertility[i] &gt; 80) { 
    
    swiss$Fertility[i] &lt;- NA
    
  }
}
```

--

Esto ser√≠a exactamente equivalente al `ifelse()` vectorizado que vimos en el tema anterior


```r
data("swiss") # lo cargamos de 0
swiss$Fertility &lt;- ifelse(swiss$Fertility &gt; 80, NA, swiss$Fertility)
```


---

# Estructuras de control: .orange[BUCLES WHILE]

Otra manera de dise√±ar un bucle es con la estructura `while { }`, que ejecutar√° el bucle un **.bg-purple_light[n√∫mero de veces a priori  desconocido]**, lo har√° hasta que la **.bg-purple_light[condici√≥n impuesta deje de ser cierta]**. Por ejemplo, vamos a inicializar una variable `ciclos &lt;- 1`, y en cada paso aumentaremos una unidad, y no saldremos del bucle hasta que `ciclos &gt; 4`


```r
ciclos &lt;- 1

# Mientras el n√∫mero de ciclos sea inferior 4, imprime
while(ciclos &lt;= 4) {
  
  print(paste("Todav√≠a no, vamos por el ciclo ", ciclos)) # Pegamos la frase al n√∫mero de ciclo por el que vayamos con paste
  ciclos &lt;- ciclos + 1
  
}
```

```
&gt; [1] "Todav√≠a no, vamos por el ciclo  1"
&gt; [1] "Todav√≠a no, vamos por el ciclo  2"
&gt; [1] "Todav√≠a no, vamos por el ciclo  3"
&gt; [1] "Todav√≠a no, vamos por el ciclo  4"
```


---
  
# Estructuras de control: .orange[BUCLES WHILE]


¬øY qu√© sucede cuando la **.bg-purple_light[condici√≥n nunca llega a ser FALSE]**? Compru√©balo t√∫ mismo/a.


```r
while (1 &gt; 0) { # Nunca va a dejar de ser cierto
  
  print("Presiona ESC para salir del bucle")
  
}
```

&amp;nbsp;

**.bg-red_light[CUIDADO]**: un bucle `while { }` puede ser muy peligroso sino se controla bien que el bucle acaba en alg√∫n momento.

---

# Estructuras de control: .orange[BUCLES WHILE]

Tenemos dos comandos reservados para poder **.bg-purple_light[abortar un bucle o avanzar forzosamente]**:

* `break`: os habilita para **.bg-purple_light[parar un bucle]** aunque no haya llegado al final de su conjunto de √≠ndices a recorrer (o se siga cumpliendo la condici√≥n).


```r
for(i in 1:10) {
  if (i == 3) {
    
    break # si i es 3, el bucle frena aqu√≠
    
  }
  print(i)
}
```

```
&gt; [1] 1
&gt; [1] 2
```

---

# Estructuras de control: .orange[BUCLES WHILE]

Tenemos dos comandos reservados para poder **.bg-purple_light[abortar un bucle o avanzar forzosamente]**:

* `next`: **.bg-purple_light[obliga al bucle a avanzar]** a la siguiente iteracci√≥n, abortando la iteraci√≥n actual en la que se encuentra. 


```r
for(i in 1:5) {
  if (i == 3) {
    
    next # si i es 3, pasar√° a la siguiente
    
  }
  print(i)
}
```

```
&gt; [1] 1
&gt; [1] 2
&gt; [1] 4
&gt; [1] 5
```

---



# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: modifica el c√≥digo inferior para imprimir un mensaje por pantalla si todos los datos del conjunto `airquality` son de meses que no sean enero.


```r
# install.packages("dataset") # solo la primera vez
library(datasets) # paquete con los datos
mes &lt;- airquality$Month

if (mes == 2) {
  
  print("Ning√∫n dato es del mes de enero")
  
}
```

]

.panel[.panel-name[Soluci√≥n ej. 1]

* üìù **Ejercicio 1**: modifica el c√≥digo inferior para imprimir un mensaje por pantalla si todos los datos del conjunto `airquality` son de meses que no sean enero.


```r
# install.packages("dataset") # solo la primera vez
library(datasets) # paquete con los datos
mes &lt;- airquality$Month

if (all(mes != 1)) {
  
  print("Ning√∫n dato es del mes de enero")
  
}
```

```
&gt; [1] "Ning√∫n dato es del mes de enero"
```

]

]


---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]

* üìù **Ejercicio 2**: modifica el c√≥digo inferior para guardar en una variable llamada `temperatura_alta` un valor `TRUE` si alguno de los registros tiene una temperatura mayor a 90 (est√°n en Farenheit) y un `FALSE` en caso contrario.
 

```r
temperatura &lt;- airquality$Temp

if (temperatura == 100) {
  
  print("Alguno de los registros tiene temperatura superior a 90 Farenheit")
  
}
```

]

.panel[.panel-name[Soluci√≥n ej. 2]

* üìù **Ejercicio 2**: modifica el c√≥digo inferior para guardar en una variable llamada `temperatura_alta` un valor `TRUE` si alguno de los registros tiene una temperatura mayor a 90 (est√°n en Farenheit) y un `FALSE` en caso contrario.
 

```r
# Opci√≥n 1
temperatura &lt;- airquality$Temp
temperatura_alta &lt;- FALSE
if (any(temperatura &gt; 90)) {
  
   temperatura_alta &lt;- TRUE
  
}

# Opci√≥n 2
temperatura_alta &lt;- any(airquality$Temp &gt; 90)
```


]

]

---


# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]

* üìù **Ejercicio 3**: modifica el c√≥digo inferior para dise√±ar un bucle `for` de 5 iteraciones que recorra los 5 primeros impares y les sume uno.


```r
for (i in 1:5) {
  
  print(i)
}
```

* üìù **Ejercicio 4**: modifica el c√≥digo inferior para dise√±ar un bucle `while` que parta con una variable `conteo &lt;- 1` y pare cuando llegue a 6.


```r
conteo &lt;- 1
while (conteo == 2) {
  
  print(conteo)
}
```

]

.panel[.panel-name[Soluci√≥n ej. 3]

* üìù **Ejercicio 3**: modifica el c√≥digo inferior para dise√±ar un bucle `for` de 5 iteraciones que recorra los 5 primeros impares y les sume uno.


```r
for (i in c(1, 3, 5, 7, 9)) {
  
  print(i + 1)
}
```

```
&gt; [1] 2
&gt; [1] 4
&gt; [1] 6
&gt; [1] 8
&gt; [1] 10
```

]

.panel[.panel-name[Soluci√≥n ej. 4]

* üìù **Ejercicio 4**: modifica el c√≥digo inferior para dise√±ar un bucle `while` que parta con una variable `conteo &lt;- 1` y pare cuando llegue a 6.


```r
conteo &lt;- 1
while (conteo &lt; 6) {
  
  print(conteo)
  conteo &lt;- conteo + 1
  
}
```

```
&gt; [1] 1
&gt; [1] 2
&gt; [1] 3
&gt; [1] 4
&gt; [1] 5
```

]

]

---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]

* üìù **Ejercicio 5**: dise√±a un bucle `for` de 200 iteraciones que, empezando en un valor inicial de 100 (euros), te sume 3‚Ç¨ (actualizando el valor) si el n√∫mero actual de la iteraci√≥n es par, y te reste 5‚Ç¨ si es impar (investiga la funci√≥n `%%`).

* üìù **Ejercicio 6**: dise√±a el anterior bucle pero guardando el dinero de cada iteraci√≥n en alguna variable
 

* üìù **Ejercicio 7**: dise√±a el bucle del ejercicio 5 pero parando cuando no nos quede dinero.

]

.panel[.panel-name[Sol. ej. 5]

Un n√∫mero par ser√° todo aquel n√∫mero que al dividir entre 2, la divisi√≥n es exacta, es decir, que su resto es nulo. Para calcular ese resto usaremos la funci√≥n `%%`.



```r
# dinero inicial
dinero &lt;- 100

for (i in 1:200) {
  
  dinero &lt;- ifelse(i %% 2 == 0, dinero + 3, dinero  - 5)
  
}
dinero
```

```
&gt; [1] -100
```

]

.panel[.panel-name[Sol. ej. 6]


```r
# vector inicial de importes
dinero &lt;- rep(0, 201)
dinero[1] &lt;- 100 # dinero inicial

# Bucle for
for (i in 2:201) {
  
  # si i es par o  impar
  dinero[i] &lt;- ifelse(i %% 2 == 0, dinero[i - 1] + 3,
                      dinero[i - 1]  - 5)
  
}
dinero
```

```
&gt;   [1]  100  103   98  101   96   99   94   97   92   95   90   93   88   91   86
&gt;  [16]   89   84   87   82   85   80   83   78   81   76   79   74   77   72   75
&gt;  [31]   70   73   68   71   66   69   64   67   62   65   60   63   58   61   56
&gt;  [46]   59   54   57   52   55   50   53   48   51   46   49   44   47   42   45
&gt;  [61]   40   43   38   41   36   39   34   37   32   35   30   33   28   31   26
&gt;  [76]   29   24   27   22   25   20   23   18   21   16   19   14   17   12   15
&gt;  [91]   10   13    8   11    6    9    4    7    2    5    0    3   -2    1   -4
&gt; [106]   -1   -6   -3   -8   -5  -10   -7  -12   -9  -14  -11  -16  -13  -18  -15
&gt; [121]  -20  -17  -22  -19  -24  -21  -26  -23  -28  -25  -30  -27  -32  -29  -34
&gt; [136]  -31  -36  -33  -38  -35  -40  -37  -42  -39  -44  -41  -46  -43  -48  -45
&gt; [151]  -50  -47  -52  -49  -54  -51  -56  -53  -58  -55  -60  -57  -62  -59  -64
&gt; [166]  -61  -66  -63  -68  -65  -70  -67  -72  -69  -74  -71  -76  -73  -78  -75
&gt; [181]  -80  -77  -82  -79  -84  -81  -86  -83  -88  -85  -90  -87  -92  -89  -94
&gt; [196]  -91  -96  -93  -98  -95 -100
```

]

.panel[.panel-name[Sol. ej. 7]


```r
dinero &lt;- 100 # dinero inicial

# Bucle while
while (dinero &gt; 0) {
  
  dinero &lt;- ifelse(i %% 2 == 0, dinero + 3, dinero - 5)
  
}
dinero
```

```
&gt; [1] 0
```

]


]


---

name: tidydata

# Datos limpios: .orange[TIDY DATA]

.pull-left[

&lt;img src="./img/tidyverrse_universe.jpg" width="99%" style="display: block; margin: auto;" /&gt;

]

.pull-right[
&lt;img src="./img/flow_tidyverse.jpg" width="99%" style="display: block; margin: auto;" /&gt;
]

Universo de **.bg-purple_light[paquetes tidyverse]**: un conjunto de paquetes para un flujo de **trabajo eficiente, coherente y lexicogr√°ficamente** sencillo de entender.

---

# Datos limpios: .orange[TIDY DATA]

&gt; Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

Hasta ahora solo le hemos dado importancia al ¬´qu√©¬ª pero no al **.bg-purple_light[¬´c√≥mo¬ª manejamos los datos]**. La organizaci√≥n de nuestros datos es fundamental para que su **.bg-purple_light[preparaci√≥n y explotaci√≥n]** sea lo m√°s eficiente posible.

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/tidy_flow.jpg" alt="Flujo deseable de datos seg√∫n Hadley Wickham, extra√≠da de https://r4ds.had.co.nz/wrangle-intro.html" width="60%" /&gt;
&lt;p class="caption"&gt;Flujo deseable de datos seg√∫n Hadley Wickham, extra√≠da de https://r4ds.had.co.nz/wrangle-intro.html&lt;/p&gt;
&lt;/div&gt;


---

# Datos limpios: .orange[TIDY DATA]

El concepto **.bg-purple_light[tidy data]** fue introducido por **Hadley Wickham** (Wickham, 2014) como el primer paso de un flujo de trabajo eficiente. Para ello haremos uso del paquete `{tidyr}` (dentro de `{tidyverse}`) que nos proporciona herramientas eficientes y sencillaspara su manejo.

&amp;nbsp;

Los **.bg-purple_light[conjuntos tidy u ordenados]** tienen tres objetivos

* **.bg-orange[Estandarizaci√≥n]** en su estructura para una depuraci√≥n y an√°lisis eficiente.
* **.bg-orange[Sencillez]** en su manipulaci√≥n.
* Listos para ser **.bg-orange[modelizados y visualizados]**.

&amp;nbsp;

üìö Ver Wickham (2014) en **.bg-green_light[bibliograf√≠a]** en &lt;https://github.com/dadosdelaplace/teaching/tree/main/data_mining/biblio&gt;

---

# Datos limpios: .orange[TIDY Dblob/main/data_mining/biblio/tidy_data_wickham_2014.pdfbg-purple_light[datos ordenados o tidy data]** deben cumplir:

1. Cada **.bg-green_light[variable en una columna]**.

2. Cada **.bg-orange[observaci√≥n/individuo en una fila]** diferente.

3. Cada **.bg-green_light[celda con un √∫nico valor]**.

4. Cada **.bg-orange[conjunto en un tibble]** (tabla).

5. Si usamos m√∫ltiples tablas a la vez debemos tener una **.bg-green_light[columna com√∫n para poder cruzarlas]**.

]

.pull-right[

&lt;img src="./img/tidy_def.jpg" width="85%" style="display: block; margin: auto;" /&gt;

&amp;nbsp;

&lt;img src="./img/tidyr_1.jpg" width="53%" style="display: block; margin: auto;" /&gt;


]


---

# Tuber√≠a .orange[PIPE]

En este entorno de trabajo tendremos un **.bg-purple_light[operador clave]**: el **.bg-purple_light[operador pipeline]** `%&gt;%` (podemos usar el atajo con `ctrl+shift+M` o `command+shift+M`). Dicho operador lo debemos interpretar como una **.bg-purple_light[tuber√≠a]** que va pasando por los datos y los va transformando.


Por ejemplo, si tuvi√©semos tres funciones `first()`, `second()` y `third()`, la opci√≥n m√°s inmediata ser√≠a anidar las tres funciones tal que `third(second(first(x)))`, algo que dificulta la lectura posterior del c√≥digo

--

Con `%&gt;%` podremos escribir (y leer) la concetanci√≥n de acciones como una **.bg-purple_light[tuber√≠a de izquierda a derecha]**:


```r
first(x) %&gt;% second(x) %&gt;% third(x)
```

--

Dicho operador viene del paquete `{magrittr}`. Para **evitar esta dependencia** (cuantos menos paquetes tengamos que cargar, mejor), desde la versi√≥n 4.1.0 de R, disponemos de un pipeline nativo de R, el **operador** `|&gt;` (disponible adem√°s fuera del entorno tidyverse).

---

# Tuber√≠a .orange[PIPE]

.pull-left[


```r
datos %&gt;%
  limpio(...) %&gt;%
  selecciono(...) %&gt;%
  filtro(...) %&gt;%
  ordeno(...) %&gt;%
  agrupo(...) %&gt;%
  cuento(...) %&gt;%
  resumo(...) %&gt;% 
  pinto(...)
```


```r
datos |&gt;
  limpio(...) |&gt;
  selecciono(...) |&gt;
  filtro(...) |&gt;
  ordeno(...) |&gt;
  agrupo(...) |&gt;
  cuento(...) |&gt;
  resumo(...) |&gt;
  pinto(...)
```

]

.pull-right[

&lt;img src="./img/tuberia.jpg" width="90%" style="display: block; margin: auto;" /&gt;

]

---

# Datos .orange[SUCIOS]: messy data

Por ejemplo, vamos a cargar la tabla `table4a` del paquete `{tidyr}` (que ya lo tenemos cargado del entorno `{tidyverse}`).




```r
table4a
```

```
&gt; # A tibble: 3 √ó 3
&gt;   country     `1999` `2000`
&gt; * &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;
&gt; 1 Afghanistan    745   2666
&gt; 2 Brazil       37737  80488
&gt; 3 China       212258 213766
```

**.bg-purple_light[¬øQu√© falla?]**

---


# Datos .orange[SUCIOS]: messy data

.pull-left[




```r
table4a
```

```
&gt; # A tibble: 3 √ó 3
&gt;   country     `1999` `2000`
&gt; * &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;
&gt; 1 Afghanistan    745   2666
&gt; 2 Brazil       37737  80488
&gt; 3 China       212258 213766
```

**.bg-purple_light[¬øQu√© falla?]**

]

.pull-right[


‚ùé Cada **.bg-green_light[variable en una columna]**.

‚ùé Cada **.bg-orange[observaci√≥n/individuo en una fila]** diferente.

‚ùé Cada **.bg-green_light[celda con un √∫nico valor]**.

]

Aunque la columna `$country` representa una variable, las otras columnas no: **.bg-purple_light[ambas son la misma variable]**, solo que medida en a√±os distintos (que deber√≠a ser a su vez otra variable), de forma que **.bg-purple_light[cada fila est√° representando dos observaciones]** (1999, 2000). Tenemos datos en los nombres de las columnas.


---

# Datos .orange[SUCIOS]: messy data


.pull-left[

Lo que haremos ser√° incluir una nueva columna llamada (por ejemplo) `year` que nos marque el a√±o y otra llamada `cases` que nos diga el valor de la variable de inter√©s en cada uno de esos a√±os.

]

.pull-right[

&lt;img src="./img/table4a.jpg" width="65%" style="display: block; margin: auto;" /&gt;


]

--

Con la funci√≥n `pivot_longer()` pivotaremos la tabla para pasarla a **formato long**:


```r
table4a %&gt;%
* pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```

```
&gt; # A tibble: 6 √ó 3
&gt;   country     year   cases
&gt;   &lt;chr&gt;       &lt;chr&gt;  &lt;int&gt;
&gt; 1 Afghanistan 1999     745
&gt; 2 Afghanistan 2000    2666
&gt; 3 Brazil      1999   37737
&gt; 4 Brazil      2000   80488
&gt; 5 China       1999  212258
&gt; 6 China       2000  213766
```

---

# Datos .orange[SUCIOS]: messy data

.pull-left[


```r
table4a %&gt;%
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year", 
*              values_to = "cases")
```

]

.pull-right[

&lt;img src="./img/table4a_2.png" width="110%" style="display: block; margin: auto;" /&gt;


]


* `cols`: el **.bg-purple_light[nombre de las columnas a pivotar]** (con comillas por ser n√∫meros y no caracteres).
* `names_to`: el **.bg-purple_light[nombre de la nueva columna]** a la mandamos los **.bg-purple_light[nombres]** de las columnas.
* `values_to`: el **.bg-purple_light[nombre de la nueva columna]** a la que vamos a mandar los **.bg-purple_light[datos]**.


---

# Datos .orange[SUCIOS]: messy data

Echa un vistazo a la tabla `{table4b}`


```r
table4b
```

```
&gt; # A tibble: 3 √ó 3
&gt;   country         `1999`     `2000`
&gt; * &lt;chr&gt;            &lt;int&gt;      &lt;int&gt;
&gt; 1 Afghanistan   19987071   20595360
&gt; 2 Brazil       172006362  174504898
&gt; 3 China       1272915272 1280428583
```

**.bg-purple_light[TODO TUYO]**: ¬øes tidy o messy? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?


---

# Datos .orange[SUCIOS]: messy data

Echa un vistazo a la tabla `{relig_income}`


```r
relig_income
```

```
&gt; # A tibble: 18 √ó 11
&gt;    religion      `&lt;$10k` $10-2‚Ä¶¬π $20-3‚Ä¶¬≤ $30-4‚Ä¶¬≥ $40-5‚Ä¶‚Å¥ $50-7‚Ä¶‚Åµ $75-1‚Ä¶‚Å∂ $100-‚Ä¶‚Å∑
&gt;    &lt;chr&gt;           &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
&gt;  1 Agnostic           27      34      60      81      76     137     122     109
&gt;  2 Atheist            12      27      37      52      35      70      73      59
&gt;  3 Buddhist           27      21      30      34      33      58      62      39
&gt;  4 Catholic          418     617     732     670     638    1116     949     792
&gt;  5 Don‚Äôt know/r‚Ä¶      15      14      15      11      10      35      21      17
&gt;  6 Evangelical ‚Ä¶     575     869    1064     982     881    1486     949     723
&gt;  7 Hindu               1       9       7       9      11      34      47      48
&gt;  8 Historically‚Ä¶     228     244     236     238     197     223     131      81
&gt;  9 Jehovah's Wi‚Ä¶      20      27      24      24      21      30      15      11
&gt; 10 Jewish             19      19      25      25      30      95      69      87
&gt; 11 Mainline Prot     289     495     619     655     651    1107     939     753
&gt; 12 Mormon             29      40      48      51      56     112      85      49
&gt; 13 Muslim              6       7       9      10       9      23      16       8
&gt; 14 Orthodox           13      17      23      32      32      47      38      42
&gt; 15 Other Christ‚Ä¶       9       7      11      13      13      14      18      14
&gt; 16 Other Faiths       20      33      40      46      49      63      46      40
&gt; 17 Other World ‚Ä¶       5       2       3       4       2       7       3       4
&gt; 18 Unaffiliated      217     299     374     365     341     528     407     321
&gt; # ‚Ä¶ with 2 more variables: `&gt;150k` &lt;dbl&gt;, `Don't know/refused` &lt;dbl&gt;, and
&gt; #   abbreviated variable names ¬π‚Äã`$10-20k`, ¬≤‚Äã`$20-30k`, ¬≥‚Äã`$30-40k`, ‚Å¥‚Äã`$40-50k`,
&gt; #   ‚Åµ‚Äã`$50-75k`, ‚Å∂‚Äã`$75-100k`, ‚Å∑‚Äã`$100-150k`
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```

**.bg-purple_light[TODO TUYO]**: ¬øes tidy o messy? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?

---

# Datos .orange[SUCIOS]: messy data

Veamos un segundo tipo de dato sucio: vamos a cargar la tabla `table2` del paquete `{tidyr}` (que ya lo tenemos cargado del entorno `{tidyverse}`). **.bg-purple_light[¬øQu√© falla?]**



```r
table2
```

```
&gt; # A tibble: 12 √ó 4
&gt;    country      year type            count
&gt;    &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;           &lt;int&gt;
&gt;  1 Afghanistan  1999 cases             745
&gt;  2 Afghanistan  1999 population   19987071
&gt;  3 Afghanistan  2000 cases            2666
&gt;  4 Afghanistan  2000 population   20595360
&gt;  5 Brazil       1999 cases           37737
&gt;  6 Brazil       1999 population  172006362
&gt;  7 Brazil       2000 cases           80488
&gt;  8 Brazil       2000 population  174504898
&gt;  9 China        1999 cases          212258
&gt; 10 China        1999 population 1272915272
&gt; 11 China        2000 cases          213766
&gt; 12 China        2000 population 1280428583
```


---

# Datos .orange[SUCIOS]: messy data

.pull-left[



```r
head(table2)
```

```
&gt; # A tibble: 6 √ó 4
&gt;   country      year type           count
&gt;   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;          &lt;int&gt;
&gt; 1 Afghanistan  1999 cases            745
&gt; 2 Afghanistan  1999 population  19987071
&gt; 3 Afghanistan  2000 cases           2666
&gt; 4 Afghanistan  2000 population  20595360
&gt; 5 Brazil       1999 cases          37737
&gt; 6 Brazil       1999 population 172006362
```

]

.pull-right[


&lt;img src="./img/table2.jpg" width="69%" style="display: block; margin: auto;" /&gt;
]


‚ùé Cada **.bg-orange[observaci√≥n/individuo en una fila]** diferente.


F√≠jate en las cuatro primeras filas: los registros con el mismo a√±o deber√≠an ser el mismo, es la misma informaci√≥n, **.bg-purple_light[deber√≠a estar en la misma fila]**, pero est√° dividada en dos. 

---


# Datos .orange[SUCIOS]: messy data

Lo que haremos ser√° lo opuesto a antes: con `pivot_wider()` ¬´ampliaremos¬ª la **.bg-purple_light[tabla a lo ancho]**, con menos filas pero con m√°s columnas.


```r
table2 %&gt;%
* pivot_wider(names_from = type, values_from = count)
```

```
&gt; # A tibble: 6 √ó 4
&gt;   country      year  cases population
&gt;   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
&gt; 1 Afghanistan  1999    745   19987071
&gt; 2 Afghanistan  2000   2666   20595360
&gt; 3 Brazil       1999  37737  172006362
&gt; 4 Brazil       2000  80488  174504898
&gt; 5 China        1999 212258 1272915272
&gt; 6 China        2000 213766 1280428583
```

* `names_from`: el **.bg-purple_light[nombre de la columna original]** de la que vamos a sacar las **.bg-purple_light[nuevas columnas]** que vamos a crear (`cases` y `population`).
* `values_from`: el **.bg-purple_light[nombre de la columna orignal]** de la que vamos a sacar los **.bg-purple_light[datos]**.


---

# Datos .orange[SUCIOS]: messy data


Por √∫ltimo veamos un tercer tipo de dato sucio: vamos a cargar la tabla `table3` del paquete `{tidyr}` (que ya lo tenemos cargado del entorno `{tidyverse}`). **.bg-purple_light[¬øQu√© falla?]**



```r
table3
```

```
&gt; # A tibble: 6 √ó 3
&gt;   country      year rate             
&gt; * &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;            
&gt; 1 Afghanistan  1999 745/19987071     
&gt; 2 Afghanistan  2000 2666/20595360    
&gt; 3 Brazil       1999 37737/172006362  
&gt; 4 Brazil       2000 80488/174504898  
&gt; 5 China        1999 212258/1272915272
&gt; 6 China        2000 213766/1280428583
```

--

‚ùé Cada **.bg-green_light[celda con un √∫nico valor]**.


---

# Datos .orange[SUCIOS]: messy data

Lo que haremos ser√° usar `separate()` para mandar **.bg-purple_light[cada valor a una columna diferente]**.


```r
*table3 %&gt;% separate(rate, into = c("cases", "pop"))
```

```
&gt; # A tibble: 6 √ó 4
&gt;   country      year cases  pop       
&gt;   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     
&gt; 1 Afghanistan  1999 745    19987071  
&gt; 2 Afghanistan  2000 2666   20595360  
&gt; 3 Brazil       1999 37737  172006362 
&gt; 4 Brazil       2000 80488  174504898 
&gt; 5 China        1999 212258 1272915272
&gt; 6 China        2000 213766 1280428583
```

* `into`: **.bg-purple_light[nombre de nuevas columnas]** donde separaremos valores.


&lt;img src="./img/seperate.jpg" width="40%" style="display: block; margin: auto;" /&gt;


---

# Datos .orange[SUCIOS]: messy data


Por defecto lo que hace es **.bg-purple_light[localizar como separador cualquier caracter que no sea alfa-num√©rico]**. Si queremos un caracter concreto para dividir podemos indic√°rselo expl√≠citamente. Si usas un separador que no est√° en los datos te devolver√° dichas columnas vac√≠as ya que no ha podido dividirlas.



```r
table3 %&gt;% separate(rate, into = c("cases", "population"), sep = ".")
```

```
&gt; Warning: Expected 2 pieces. Additional pieces discarded in 6 rows [1, 2, 3, 4,
&gt; 5, 6].
```

```
&gt; # A tibble: 6 √ó 4
&gt;   country      year cases population
&gt;   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt; &lt;chr&gt;     
&gt; 1 Afghanistan  1999 ""    ""        
&gt; 2 Afghanistan  2000 ""    ""        
&gt; 3 Brazil       1999 ""    ""        
&gt; 4 Brazil       2000 ""    ""        
&gt; 5 China        1999 ""    ""        
&gt; 6 China        2000 ""    ""
```

---

# Datos .orange[SUCIOS]: messy data

De la misma manera que podemos separar columnas tambi√©n podemos **.bg-purple_light[unir columnas]**. Para ello vamos a usar la tabla `table5` del ya mencionado paquete.


```r
table5
```

```
&gt; # A tibble: 6 √ó 4
&gt;   country     century year  rate             
&gt; * &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;            
&gt; 1 Afghanistan 19      99    745/19987071     
&gt; 2 Afghanistan 20      00    2666/20595360    
&gt; 3 Brazil      19      99    37737/172006362  
&gt; 4 Brazil      20      00    80488/174504898  
&gt; 5 China       19      99    212258/1272915272
&gt; 6 China       20      00    213766/1280428583
```

---

# Datos .orange[SUCIOS]: messy data

.pull-left[

Con la funci√≥n `unite()` vamos a **.bg-purple_light[unir]** el siglo (en `century`) y el a√±o (en `year`), y al inicio le indicaremos como se llamar√° la nueva variable `year_ok`


```r
table5 %&gt;%
  unite(col = year_ok,
        century, year, sep = "")
```

```
&gt; # A tibble: 6 √ó 3
&gt;   country     year_ok rate             
&gt;   &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt;            
&gt; 1 Afghanistan 1999    745/19987071     
&gt; 2 Afghanistan 2000    2666/20595360    
&gt; 3 Brazil      1999    37737/172006362  
&gt; 4 Brazil      2000    80488/174504898  
&gt; 5 China       1999    212258/1272915272
&gt; 6 China       2000    213766/1280428583
```

]

.pull-right[

&lt;img src="./img/unite.jpg" width="99%" style="display: block; margin: auto;" /&gt;

]


---

# Eliminando .orange[AUSENTES]

El paquete `{tidyr}` tambi√©n dispone de algunas herramientas √∫tiles para **.bg-purple_light[quitar ausentes]**


```r
datos &lt;- tibble(x = c(1, 2, NA), y = c("a", NA, "b"))
datos
```

```
&gt; # A tibble: 3 √ó 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 &lt;NA&gt; 
&gt; 3    NA b
```

---

# Eliminando .orange[AUSENTES]


Con `drop_na()` podemos indicarle que nos **.bg-purple_light[elimine las filas con alg√∫n ausente]** en alguna de las variables (o especificarle la variable concreta).


.pull-left[


```r
datos %&gt;% drop_na()
```

```
&gt; # A tibble: 1 √ó 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a
```

]


.pull-right[


```r
datos %&gt;% drop_na(x)
```

```
&gt; # A tibble: 2 √ó 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 &lt;NA&gt;
```

]

---

# Eliminando .orange[AUSENTES]

A veces no querremos eliminarlos sino **.bg-purple_light[imputar por el valor previo/siguiente]**  con `fill()`

.pull-left[


```r
datos %&gt;% fill(x)
```

```
&gt; # A tibble: 3 √ó 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 &lt;NA&gt; 
&gt; 3     2 b
```

```r
datos %&gt;% fill(x, .direction = c("up"))
```

```
&gt; # A tibble: 3 √ó 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 &lt;NA&gt; 
&gt; 3    NA b
```

]

.pull-right[


```r
datos %&gt;% fill(y)
```

```
&gt; # A tibble: 3 √ó 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 a    
&gt; 3    NA b
```

```r
datos %&gt;% fill(y, .direction = c("up"))
```

```
&gt; # A tibble: 3 √ó 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 b    
&gt; 3    NA b
```

]


---

# Eliminando .orange[AUSENTES]

Los **.bg-purple_light[ausentes]** tambi√©n pueden ser **.bg-purple_light[eliminados al pivotar]** con `values_drop_na`.



```r
stocks &lt;-
  tibble(qtr = 1:4,
         "2015" = c(1.88, 0.59, 0.35, NA),
         "2016" = c(NA, 0.92, 0.17, 2.66))
stocks
```

```
&gt; # A tibble: 4 √ó 3
&gt;     qtr `2015` `2016`
&gt;   &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;
&gt; 1     1   1.88  NA   
&gt; 2     2   0.59   0.92
&gt; 3     3   0.35   0.17
&gt; 4     4  NA      2.66
```

---

# Eliminando .orange[AUSENTES]

Los **.bg-purple_light[ausentes]** tambi√©n pueden ser **.bg-purple_light[eliminados al pivotar]** con `values_drop_na`.


```r
stocks %&gt;%
  pivot_longer(cols = c("2015", "2016"), names_to = "year",
               values_to = "return", values_drop_na = TRUE)
```

```
&gt; # A tibble: 6 √ó 3
&gt;     qtr year  return
&gt;   &lt;int&gt; &lt;chr&gt;  &lt;dbl&gt;
&gt; 1     1 2015    1.88
&gt; 2     2 2015    0.59
&gt; 3     2 2016    0.92
&gt; 4     3 2015    0.35
&gt; 5     3 2016    0.17
&gt; 6     4 2016    2.66
```

---

# Reemplazando .orange[AUSENTES]

Otras veces querremos **.bg-purple_light[imputar los ausentes por un valor fijo]**, algo que podemos hacer con `replace_na()`

.pull-left[


```r
datos
```

```
&gt; # A tibble: 3 √ó 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 &lt;NA&gt; 
&gt; 3    NA b
```

]

.pull-right[


```r
datos %&gt;%
  replace_na(list(x = -1,
                  y = "unknown"))
```

```
&gt; # A tibble: 3 √ó 2
&gt;       x y      
&gt;   &lt;dbl&gt; &lt;chr&gt;  
&gt; 1     1 a      
&gt; 2     2 unknown
&gt; 3    -1 b
```

]

---


# Completando .orange[AUSENTES]

Por √∫ltimo, tambi√©n podemos **.bg-purple_light[crear todas las combinaciones posibles de variables]** (para completar datos ausentes que se hayan podido eliminar).



```r
stocks &lt;- tibble(year = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),
                 qtr = c(1, 2, 3, 4, 2, 3, 4),
                 return = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66))
```

.pull-left[


```r
stocks
```

```
&gt; # A tibble: 7 √ó 3
&gt;    year   qtr return
&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
&gt; 1  2015     1   1.88
&gt; 2  2015     2   0.59
&gt; 3  2015     3   0.35
&gt; 4  2015     4  NA   
&gt; 5  2016     2   0.92
&gt; 6  2016     3   0.17
&gt; 7  2016     4   2.66
```

]

.pull-right[


```r
stocks %&gt;% complete(year, qtr)
```

```
&gt; # A tibble: 8 √ó 3
&gt;    year   qtr return
&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
&gt; 1  2015     1   1.88
&gt; 2  2015     2   0.59
&gt; 3  2015     3   0.35
&gt; 4  2015     4  NA   
&gt; 5  2016     1  NA   
&gt; 6  2016     2   0.92
&gt; 7  2016     3   0.17
&gt; 8  2016     4   2.66
```

]

---

name: rmd

# .orange[COMUNICANDO] resultados: archivos .green[.Rmd] 


Una de las principales **.bg-purple_light[fortalezas]** de `R` es la facilidad para generar informes, libros, webs, **.bg-purple_light[apuntes y hasta diapositivas]** (este material por ejemplo).

&amp;nbsp;

Para ello instalaremos antes el paquete `{rmarkdown}` que nos permitir√° generar documentos `.Rmd`


```r
install.packages("rmarkdown")
```

---

# .orange[COMUNICANDO] resultados: archivos .green[.Rmd] 

¬øCu√°l son las **ventajas** de generarlos desde **.bg-purple_light[rmarkdown]**?

--

* Al hacerlo desde `RStudio`, puedes generar un informe o una presentaci√≥n **.bg-purple_light[sin salirte del entorno]** de programaci√≥n en el que est√°s trabajando

--

* Podr√°s analizar los datos, resumirlos y a la vez **.bg-purple_light[comunicarlos]**. 

--

* Permite **.bg-purple_light[integrar f√°cilmente c√≥digo]** `R`, de forma que no solo podremos integrar las salidas de nuestro trabajo sino tambi√©n el c√≥digo con el que lo hemos generado.

---

# ¬øQu√© es .orange[RMARKDOWN]? 


Una herramienta que nos permite crear de forma sencilla **documentos combinando**:

--

* **.bg-purple_light[Markdown]**: creado en 2004 por John Gruber, y de uso libre, es un ¬´lenguaje¬ª que nos permite crear contenido de una manera sencilla de escribir, y que en todo momento mantenga un dise√±o legible, con algunas de las ventajas de un HTML (si acostumbras a escribir en wordpress o blogs, seguramente hayas escrito de esta forma).

--

* **.bg-green_light[Matem√°ticas (latex)]**: herramienta (lenguaje en realidad) para escribir notaci√≥n matem√°tica como `\(x^2\)` o `\(\sqrt{2}\)` (si escribes notaci√≥n similar en editores de texto, seguramente sin saberlo est√©s usando ya latex).

--

* **.bg-purple_light[C√≥digo]** y salidas de `R`: podremos no solo mostrar el paso final sino el c√≥digo que has ido realizando, con **cajitas de c√≥digo** como las del manual.

--

* **.bg-green_light[Im√°genes y tablas]**.

--

* **.bg-purple_light[Estilos]** (css, js, etc).

---

# Creando nuestro .orange[PRIMER INFORME] 

.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/file_rmarkdown.jpg" alt="Creando el primer fichero .rmd" width="80%" /&gt;
&lt;p class="caption"&gt;Creando el primer fichero .rmd&lt;/p&gt;
&lt;/div&gt;


]

.pull-right[

Vamos a crear el **.bg-purple_light[primer fichero]** con extensi√≥n `.Rmd` (la extensi√≥n de los archivos R Markdown).

&amp;nbsp;

Haz click en el bot√≥n `File &lt;&lt; New File &lt;&lt; R Markdown`.

]

---

# Creando nuestro .orange[PRIMER INFORME] 

.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/new_rmd.jpg" alt="Creando el primer fichero .rmd" width="80%" /&gt;
&lt;p class="caption"&gt;Creando el primer fichero .rmd&lt;/p&gt;
&lt;/div&gt;


]

.pull-right[

Tras hacerlo, nos aparecer√°n **.bg-purple_light[varias opciones]**de formatos de salida:

* archivo `.pdf`

* archivo `.html` (**.bg-purple_light[recomendable]**): documento din√°mico, permite la interacci√≥n con el usuario, como una ¬´p√°gina web¬ª)

* archivo `.doc` (nada recomendable)

De momento dejaremos marcado el **.bg-purple_light[formato HTML que viene por defecto]**, y escribiremos el t√≠tulo de nuestro documento. Tras ello tendremos nuestro archivo `.Rmd` (ya no es un script `.R` como los que hemos abierto hasta ahora)

]

---


# Creando nuestro .orange[PRIMER INFORME] 

Un fichero `.Rmd` se divide b√°sicamente en **.bg-purple_light[tres partes]**

1. **.bg-purple_light[Cabecera]**: la parte que tienes al inicio entre `---`.

2.  **.bg-purple_light[Texto]**: que podremos formatear y mejorar con **negritas** (escrito como `**negritas**`, con doble ast√©risco al inicio y final), _cursivas_ (`_cursivas_`, con barra baja al inicio y final) o destacar nombres de funciones o variables de `R` (con ``R`). Recuerda que puedes a√±adir adem√°s ecuaciones como `\(x^2\)` (he escrito `$x^2$`, la ecuaci√≥n entre d√≥lares).

3. **.bg-purple_light[C√≥digo R]**.

---

# .orange[PRIMER INFORME]: .green[CABECERA]


La cabecera est√°n en formato `YAML`, y contiene los **.bg-purple_light[metadatos del documento]**: t√≠tulo, autor, fecha, estilos (si los tuvi√©semos), etc. Para probar, vamos a cambiar la cabecera que nos ha generado por defecto de la siguiente forma:


```r
---
title: "Probando Probando"
author: "Se√±or/a X"
date: "11/7/2014"
output: html_document
---
```

Tras tunear nuestra cabecera borraremos todo lo que viene despu√©s para **.bg-purple_light[empezar desde cero]**.

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/rmd_vacio.jpg" alt="Fichero .Rmd vac√≠o, solo con la cabecera" width="27%" /&gt;
&lt;p class="caption"&gt;Fichero .Rmd vac√≠o, solo con la cabecera&lt;/p&gt;
&lt;/div&gt;

---

# .orange[PRIMER INFORME]: .green[TEXTO]

Solo hay una cosa **.bg-purple_light[importante]** a tener en cuenta en este entorno: salvo que indiquemos lo contrario, **.bg-purple_light[TODO lo que vamos a escribir en el documento es texto]**. No c√≥digo R. Texto plano que podremos mejorar un poco con algun detalle, pero texto.

Vamos a empezar nuestro documento escribiendo por ejemplo la siguiente frase



```r
Este material ha sido dise√±ado por el profesor Javier √Ålvarez Li√©bana,
docente en la Universidad Complutense de Madrid
```

---

# .orange[PRIMER INFORME]: .green[TEXTO]


.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/html_con_texto.jpg" alt="Primer informe html" width="99%" /&gt;
&lt;p class="caption"&gt;Primer informe html&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

Una vez que hemos escrito el texto vamos a **.bg-purple_light[guardar el archivo .Rmd]** haciendo click en el bot√≥n `Guardar` (yo he llamado al archivo `primer_rmarkdown.Rmd`). Tras guardar el documento, **.bg-purple_light[¬´tejeremos¬ª nuestro documento]** haciendo click en el bot√≥n `Knit`.

Al ¬´tejer¬ª se nos habr√° generado (seguramente en una ventana al margen) un archivo .html, que podemos incluso **.bg-purple_light[abrir en nuestro navegador]**. Hemos creado nuestro primer informe, obviamente vac√≠o de momento. 


]



---

# .orange[PRIMER INFORME]: .green[TEXTO]


.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/rmd_con_formato.jpg" alt="Tuneando nuestro primer informe html" width="99%" /&gt;
&lt;p class="caption"&gt;Tuneando nuestro primer informe html&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

Vamos a **.bg-purple_light[mejorar]** un poco el texto haciendo lo siguiente:

* Vamos a a√±adir **.bg-purple_light[negrita]** al nombre (poniendo `**` al inicio y al final).

* Vamos a√±adir _cursiva_ a la palabra `material` (poniendo `_` al inicio y al final).

*  Vamos a√±adir un enlace `https://www.ucm.es`, asoci√°ndolo al nombre de la Universidad. Para ello el t√≠tulo lo ponemos entre corchetes y justo detr√°s el enlace entre par√©ntesis `[¬´Universidad Complutense de Madrid¬ª](https://www.ucm.es)`

]

---


# .orange[PRIMER INFORME]: .green[CHUNKS] de R

Para a√±adir **.bg-purple_light[c√≥digo R]** debemos crear nuestras **.bg-purple_light[cajas de c√≥digo]** llamadas **.bg-orange[chunks]**: altos en el camino en nuestro texto markdown donde podremos incluir **c√≥digo**. Para incluir uno deber√° de ir encabezado de la siguiente forma.

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/chunk_1.jpg" alt="Encabezado/final del chunk" width="90%" /&gt;
&lt;p class="caption"&gt;Encabezado/final del chunk&lt;/p&gt;
&lt;/div&gt;

---

# .orange[PRIMER INFORME]: .green[CHUNKS] de R


Dentro de dicha **.bg-purple_light[cajita]** (que tiene ahora **otro color** en el documento) escribiremos **.bg-purple_light[c√≥digo R]**, como lo ven√≠amos haciendo hasta ahora. Vamos por ejemplo a **.bg-purple_light[definir dos variables]** y su suma de la siguiente manera, escribiendo dicho c√≥digo en nuestro `.Rmd` (dentro de ese chunk)

.pull-left[


```r
# C√≥digo R
x &lt;- 1
y &lt;- 2
x + y
```

```
&gt; [1] 3
```

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/rmd_3.jpg" alt="Primer chunk con c√≥digo" width="99%" /&gt;
&lt;p class="caption"&gt;Primer chunk con c√≥digo&lt;/p&gt;
&lt;/div&gt;

]

---

# .orange[PRIMER INFORME]: .green[CHUNKS] de R

.pull-left[


```r
# C√≥digo R
x &lt;- 1
y &lt;- 2
x + y
```

```
&gt; [1] 3
```

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/rmd_3.jpg" alt="Primer chunk con c√≥digo" width="70%" /&gt;
&lt;p class="caption"&gt;Primer chunk con c√≥digo&lt;/p&gt;
&lt;/div&gt;

]

Como ves dentro de esos _chunks_ puedes **.bg-purple_light[comentar c√≥digo]** con `#` (ahora veremos que hace `#` fuera de esas cajas de c√≥digo). Tras hacerlo tejemos de nuevo y obtenemos ahora un documento que tiene una caja de c√≥digo y su salida.

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/html_rmd_3.jpg" alt="Salida del html con el primer chunk" width="40%" /&gt;
&lt;p class="caption"&gt;Salida del html con el primer chunk&lt;/p&gt;
&lt;/div&gt;



---

# .orange[PRIMER INFORME]: .green[CHUNKS] de R


Somos capaces de **.bg-purple_light[escribir en un mismo documento texto]** con cierto formato, **.bg-purple_light[c√≥digo R y la salida]** del resultado, permiti√©ndonos generar informes (ya veremos como incluir gr√°ficas). De hecho, lo m√°s pr√°ctico para **.bg-purple_light[tomar apuntes de R]** es ir anotando en un archivo `.Rmd`.

Los chunks pueden tener un **.bg-purple_light[nombre o etiqueta]**, de forma que podamos referenciarlos de nuevo para no repetir c√≥digo.

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/chunk_repe_tag.jpg" alt="Etiquetando un chunk y recicl√°ndolo" width="40%" /&gt;
&lt;p class="caption"&gt;Etiquetando un chunk y recicl√°ndolo&lt;/p&gt;
&lt;/div&gt;



---

# .orange[PRIMER INFORME]: .green[ORGANIZANDO]

Con todo incluido en el documento podemos **.bg-purple_light[dividirlo en secciones y subsecciones]**. Para ello usaremos la sintaxis de markdown, poniendo **.bg-purple_light[almohadillas]**: una `#` para secciones, `##` para subsecciones, `###` para subsubsecciones, etc. Por ejemplo, vamos a

* Hacer una secci√≥n principal que sea `# Primer informe`
* Tras ello a√±adiremos la parte de texto.
* Creamos una subsecci√≥n que se titule `## Chunks de c√≥digo` donde incluiremos los dos chunks que tenemos hasta ahora.


.pull-left[

&lt;div class="figure" style="text-align: right"&gt;
&lt;img src="./img/secciones_rmd.jpg" alt="Secciones en el rmd" width="80%" /&gt;
&lt;p class="caption"&gt;Secciones en el rmd&lt;/p&gt;
&lt;/div&gt;


]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/secciones_html.jpg" alt="Secciones en el html" width="80%" /&gt;
&lt;p class="caption"&gt;Secciones en el html&lt;/p&gt;
&lt;/div&gt;


]

---


# .orange[PRIMER INFORME]: .green[ORGANIZANDO]

Adem√°s podemos incluir tras el t√≠tulo (y entre llaves `{}`) **.bg-purple_light[etiquetas]** (con `{#etiqueta}`) para luego **.bg-purple_light[referenciar dichas secciones]** en el documento.

.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/ref_rmd.jpg" alt="Referencias a secciones y subsecciones" width="75%" /&gt;
&lt;p class="caption"&gt;Referencias a secciones y subsecciones&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

Tambi√©n podemos organizar nuestro c√≥digo **.bg-purple_light[creando listas]**, usando `*` como √≠tems.

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/items_rmd.jpg" alt="Creando listas con √≠tems" width="85%" /&gt;
&lt;p class="caption"&gt;Creando listas con √≠tems&lt;/p&gt;
&lt;/div&gt;

]

---

# .orange[PRIMER INFORME]: .green[PERSONALIZAR]

En cada chunk aparece una **.bg-purple_light[bot√≥n de play]**: puls√°ndolo podemos tener la **ejecuci√≥n y salida** de cada chunk en nuestro `.Rmd`, sin tener que esperar a ¬´tejer¬ª (con Knit) todo el documento para ver lo que vamos ejecutando.


.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/play_chunk.jpg" alt="Pulsando al bot√≥n play" width="99%" /&gt;
&lt;p class="caption"&gt;Pulsando al bot√≥n play&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/chunk_ejecutado.jpg" alt="Chunk ejecutado in-line" width="99%" /&gt;
&lt;p class="caption"&gt;Chunk ejecutado in-line&lt;/p&gt;
&lt;/div&gt;

]

---

# .orange[PRIMER INFORME]: .green[PERSONALIZAR]


Adem√°s podemos **.bg-purple_light[incluir c√≥digo R dentro de la l√≠nea de texto]** (en lugar de mostrar el texto x ejecuta el c√≥digo R mostrando la variable).



.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/codigo_inline_rmd.jpg" alt="C√≥digo R inline" width="99%" /&gt;
&lt;p class="caption"&gt;C√≥digo R inline&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/codigo_inline_html.jpg" alt="Salida del c√≥digo in-line" width="99%" /&gt;
&lt;p class="caption"&gt;Salida del c√≥digo in-line&lt;/p&gt;
&lt;/div&gt;

]

---

# .orange[PRIMER INFORME]: .green[PERSONALIZAR]


Los chunk podemos **.bg-purple_light[personalizar su salida]** con algunas opciones, pas√°ndolos como argumentos dentro de las llaves ({r etiqueta, ...}).

* `include = FALSE`: **.bg-green_light[ejecuta c√≥digo]** pero **.bg-red_light[no se muestra (ni resultados)]** en la salida.

* `echo = FALSE`: **.bg-green_light[ejecuta c√≥digo]** y se **.bg-green_light[muestra resultado]** pero **.bg-red_light[no el c√≥digo]** en la salida.

* `eval = FALSE`: se **.bg-green_light[muestra el c√≥digo]** pero **.bg-red_light[no se ejecuta]** en la salida final.

* `message = FALSE`: se **.bg-green_light[ejecuta el c√≥digo]** pero **.bg-red_light[no se muestran mensajes]** de salida que tendr√≠amos en consola.

* `warning = FALSE`: **.bg-green_light[ejecuta c√≥digo]** pero **.bg-red_light[no se muestran warning]**.

* `error = TRUE`: se **.bg-green_light[ejecuta el c√≥digo]** pero permite ejecutar el c√≥digo **.bg-green_light[con errores]** mostrando los mensajes de error.
 
--

Estas opciones podemos aplicarlas chunk a chunk o fijar los par√°metros de forma global con `knitr::opts_chunk$set()` (dentro de un chunk), pas√°ndole como argumentos dichas opciones (por ejemplo, `knitr::opts_chunk$set(echo = FALSE)`).

---

# .orange[PRIMER INFORME]: .green[VARIABLES/ECUACIONES]

Por √∫ltimo en este primer documento vamos a a√±adir una subsecci√≥n `## Variables y ecuaciones` donde a√±adiremos un chunk asignando la suma `x + y` a una variable `z`, escribiendo antes en texto el nombre de la variable y la **.bg-purple_light[f√≥rmula]** ($z = x + y$ entre d√≥lares).


.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/variables_rmd.jpg" alt="A√±adiendo variables en el .rmd" width="90%" /&gt;
&lt;p class="caption"&gt;A√±adiendo variables en el .rmd&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/variables_html.jpg" alt="A√±adiendo variables en el .rmd" width="110%" /&gt;
&lt;p class="caption"&gt;A√±adiendo variables en el .rmd&lt;/p&gt;
&lt;/div&gt;

]


---

name: oms

# .orange[CASO PR√ÅCTICO]: datos de la OMS

Instala el paquete `{tidyr}` y usa el conjunto `who` contenido en √©l mismo (sobre casos de tuberculosis). Lee la ayuda `? who` para detalles de los datos.  


```r
# install.packages("tidyr")
library(tidyr)
who
```

```
&gt; # A tibble: 7,240 √ó 60
&gt;    country     iso2  iso3   year new_s‚Ä¶¬π new_s‚Ä¶¬≤ new_s‚Ä¶¬≥ new_s‚Ä¶‚Å¥ new_s‚Ä¶‚Åµ new_s‚Ä¶‚Å∂
&gt;    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;
&gt;  1 Afghanistan AF    AFG    1980      NA      NA      NA      NA      NA      NA
&gt;  2 Afghanistan AF    AFG    1981      NA      NA      NA      NA      NA      NA
&gt;  3 Afghanistan AF    AFG    1982      NA      NA      NA      NA      NA      NA
&gt;  4 Afghanistan AF    AFG    1983      NA      NA      NA      NA      NA      NA
&gt;  5 Afghanistan AF    AFG    1984      NA      NA      NA      NA      NA      NA
&gt;  6 Afghanistan AF    AFG    1985      NA      NA      NA      NA      NA      NA
&gt;  7 Afghanistan AF    AFG    1986      NA      NA      NA      NA      NA      NA
&gt;  8 Afghanistan AF    AFG    1987      NA      NA      NA      NA      NA      NA
&gt;  9 Afghanistan AF    AFG    1988      NA      NA      NA      NA      NA      NA
&gt; 10 Afghanistan AF    AFG    1989      NA      NA      NA      NA      NA      NA
&gt; # ‚Ä¶ with 7,230 more rows, 50 more variables: new_sp_m65 &lt;int&gt;,
&gt; #   new_sp_f014 &lt;int&gt;, new_sp_f1524 &lt;int&gt;, new_sp_f2534 &lt;int&gt;,
&gt; #   new_sp_f3544 &lt;int&gt;, new_sp_f4554 &lt;int&gt;, new_sp_f5564 &lt;int&gt;,
&gt; #   new_sp_f65 &lt;int&gt;, new_sn_m014 &lt;int&gt;, new_sn_m1524 &lt;int&gt;,
&gt; #   new_sn_m2534 &lt;int&gt;, new_sn_m3544 &lt;int&gt;, new_sn_m4554 &lt;int&gt;,
&gt; #   new_sn_m5564 &lt;int&gt;, new_sn_m65 &lt;int&gt;, new_sn_f014 &lt;int&gt;,
&gt; #   new_sn_f1524 &lt;int&gt;, new_sn_f2534 &lt;int&gt;, new_sn_f3544 &lt;int&gt;, ‚Ä¶
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

class: inverse center middle
name: clase-4

# CLASE 4: introducci√≥n a la miner√≠a (SEMMA)

&amp;nbsp;

### [Introducci√≥n al aprendizaje estad√≠stico](#learning)

### [Sesgo vs varianza](#sesgo-varianza)

### [Introducci√≥n a la miner√≠a de datos (SEMMA)](#data-mining)

### [Muestreo (sample)](#sample)


---

name: learning

&lt;img src="./img/ml_maths.jpg" width="80%" style="display: block; margin: auto;" /&gt;


---

# .orange[CIENCIA DE DATOS]


**.bg-purple_light[¬øQu√© es la ciencia de datos]** ¬øQu√© incluye? La conocida como **.bg-purple_light[Data Science (Ciencia de Datos)]** es un campo muy extenso en el que, seg√∫n algunos autores, se podr√≠a incluir (o intersecar con) campos como la **Miner√≠a de Datos**, el **Machine Learning** o el **Big Data**


&lt;img src="./img/stats_IA.jpg" width="40%" style="display: block; margin: auto;" /&gt;

üìö Ver definiciones en **.bg-green_light[Fern√°ndez-Casal et al. (2021)]** en &lt;https://rubenfcasal.github.io/aprendizaje_estadistico&gt;

---

# .orange[APRENDIZAJE] estad√≠stico

Uno de los conceptos clave es la idea de **.bg-purple_light[aprendizaje estad√≠stico]**: formularemos modelos que buscan **.bg-purple_light[aprender]** de los datos (teniendo en cuenta la incertidumbre subyacente), mejorando los resultados si **.bg-purple_light[aumentamos la calidad de la informaci√≥n]** (!= aumentar su tama√±o).

&amp;nbsp;

--

En ese aprendizaje normalmente realizaremos una **.bg-purple_light[partici√≥n preliminar de los datos]**:

- **.bg-purple_light[Entrenamiento]**: conjunto del que modelo **.bg-orange[aprender√° para su construcci√≥n]** (por ej., 70%).

--

- **.bg-purple_light[Validaci√≥n]**: conjunto que usaremos para **.bg-orange[evaluar nuestras decisiones]** (el modelo no ha podido aprender de √©l) y poder afinar los hiperpar√°metros (por ej., 20%).

--

- **.bg-purple_light[Test]**: conjunto final que nos proporcionar√° una **.bg-orange[evaluaci√≥n insesgada]** (por ej., 10%).

üìö Ver explicaci√≥n detallada en &lt;https://mlu-explain.github.io/train-test-validation/&gt;

---


# .orange[APRENDIZAJE] estad√≠stico

.pull-left[

Veamos un ejemplo: imagina que queremos construir un m√©todo que nos permita **.bg-purple_light[clasificar]** si un animal es un **.bg-purple_light[gato o perro]** en funci√≥n de dos variables: **suavidad** y **peso**.

En concreto el aprendizaje ser√° **.bg-purple_light[supervisado]** (s√© a priori en mi dataset cu√°l es gato o perro, veremos m√°s adelante qu√© es el aprendizaje supervisado y el no supervisado).

]

.pull-right[

&lt;img src="./img/dogs_cats.jpg" width="85%" style="display: block; margin: auto auto auto 0;" /&gt;

]

üìö Ver explicaci√≥n en &lt;https://mlu-explain.github.io/train-test-validation/&gt;


---

# .orange[APRENDIZAJE] estad√≠stico


&lt;img src="./img/train_valid_test.jpg" width="45%" style="display: block; margin: auto;" /&gt;

.pull-left[


- **.bg-orange[Conjunto train]**: datos que el **modelo conocer√°** para **.bg-purple_light[aprender patrones]**, siendo lo m√°s representativo de mi conjunto global (para evitar la propagaci√≥n de sesgos)

]

.pull-right[

&lt;img src="./img/train_dataset.jpg" width="55%" style="display: block; margin: auto;" /&gt;

]

---

# .orange[APRENDIZAJE] estad√≠stico

.pull-left[

El aprendizaje no solo depender√° de los datos, tambi√©n de **.bg-purple_light[nuestras decisiones]**: cada decisi√≥n es un sesgo que acumulamos.

* un clasificador tonto (**.bg-green_light[dummy]**) que diga que todos son la moda (gatos)
* usar solo la variable suavidad
* usar solo la variable peso
* un clasificador que use ambas variables

**.bg-purple_light[¬øCu√°l elegir?]** Y si tuvi√©ramos m√°s variables, ¬øcon cu√°ntas?

&amp;nbsp;

**.bg-green_light[Clasificador dummy]**: asigna la moda (cuali)/media (cuanti) o bien un valor al azar, sin asumir patr√≥n alguno en los datos.

]

.pull-right[


.pull-left[

&lt;img src="./img/model_1.jpg" width="140%" style="display: block; margin: auto;" /&gt;

&lt;img src="./img/model_3.jpg" width="140%" style="display: block; margin: auto;" /&gt;

]

.pull-right[

&lt;img src="./img/model_2.jpg" width="150%" style="display: block; margin: auto;" /&gt;

&lt;img src="./img/model_4.jpg" width="150%" style="display: block; margin: auto;" /&gt;

]

]

---

# .orange[APRENDIZAJE] estad√≠stico


&lt;img src="./img/train_valid_test.jpg" width="45%" style="display: block; margin: auto;" /&gt;


.pull-left[


- **.bg-orange[Conjunto validation]**: datos que el modelo **no ha conocido** para aprender pero que usaremos para **.bg-purple_light[afinar y calibrar nuestras decisiones]**, de forma que sea **.bg-purple_light[independiente del entrenamiento]**

]

.pull-right[

&lt;img src="./img/validation_dataset.jpg" width="99%" style="display: block; margin: auto;" /&gt;

]

---

# .orange[APRENDIZAJE] estad√≠stico


&lt;img src="./img/train_valid_test.jpg" width="45%" style="display: block; margin: auto;" /&gt;


.pull-left[


- **.bg-orange[Conjunto test]**: datos que el **modelo no ha conocido**

‚ùé ni para aprender

‚ùé ni para afinar hiperpar√°metros/decisiones

Es un modelo que SOLO ser√° usado para una **.bg-purple_light[evaluaci√≥n final]** (insesgada): **.bg-red_light[NUNCA se usar√° en el proceso]**, solo cuando ya se ha terminado (simulando un cliente final).

]

.pull-right[

&lt;img src="./img/test_dataset.jpg" width="99%" style="display: block; margin: auto;" /&gt;

]


---

# .orange[APRENDIZAJE] estad√≠stico


.pull-left[


Si te fijas en este ejemplo, la **.bg-purple_light[m√©trica (tasa de bien clasificados)]** es superior en el conjunto de test que en el conjunto de validaci√≥n. **.bg-red_light[¬øEs malo? ¬øExtra√±o?]**

]

.pull-right[

&lt;img src="./img/test_vs_validation.jpg" width="97%" style="display: block; margin: auto;" /&gt;

]

--

No, no es ni malo ni extra√±o. Es m√°s, es un s√≠ntoma de que el conjunto de test no est√° sesgado a ninguna otra de las particiones

**.bg-green_light[RECUERDA]**: el √©xito del conjunto test **.bg-purple_light[NO es algo a optimizar]**, es simplemente una **.bg-purple_light[estimaci√≥n de c√≥mo funcionar√°]** nuestro modelo en datos reales.


---

name: sesgo-varianza

# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]

En el campo del aprendizaje estad√≠stico (y por tanto en la miner√≠a de datos) ser√° recurrente un t√©rmino a evitar: **.bg-purple_light[sobrejauste]**.


&amp;nbsp;

üìö Ver bibliograf√≠a en 

* ¬´The bias-variance tradeoff¬ª: &lt;https://mlu-explain.github.io/bias-variance/&gt;

* ¬´Understanding the bias-variance tradeoff¬ª:  &lt;https://towardsdatascience.com/understanding-the-bias-variance-tradeoff-165e6942b229&gt;

* ¬´Bias‚Äìvariance tradeoff¬ª: &lt;https://daviddalpiaz.github.io/r4sl/biasvariance-tradeoff.html&gt;

* ¬´Understanding the Bias-Variance Tradeoff¬ª: &lt;https://scott.fortmann-roe.com/docs/BiasVariance.html&gt;

---


# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]


En el campo del aprendizaje estad√≠stico (y por tanto en la miner√≠a de datos) ser√° recurrente un t√©rmino a evitar: **.bg-purple_light[sobrejauste]**.

&lt;img src="./img/bustamante.jpg" width="80%" style="display: block; margin: auto;" /&gt;

---

# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]

Imagina que tenemos los siguientes ingredientes

* **.bg-purple_light[Modelo real]** `\(f(X)\)` donde `\(X\)` ser√°n los datos, con `\(\hat{f}(X)\)` las estimaciones.

--

* **.bg-purple_light[Output real]** que llamaremos `\(Y = f(X) + \varepsilon\)` ($\varepsilon$ ser√° el **.bg-orange[ruido existente]**)

--

* **.bg-purple_light[Output estimada]** que llamaremos `\(\hat{Y}\)`, definido como `\(\hat{Y} = \hat{f}(X)\)`

--

* **.bg-purple_light[Error]** tras aplicar el modelo que llamaremos `\(E(x, f)\)`, y que podr√≠amos definir como la **.bg-purple_light[media de las equivocaciones al cuadrado]**

--

`$$Error := E(x, f) := {\rm E} \left[ \left(realidad - estimado\right)^2 \right] = {\rm E} \left[ \left(Y - \hat{Y}\right)^2 \right] = {\rm E}\left[\left(Y - \hat{f}(X)\right)^2  \right]$$`

&amp;nbsp;

--

¬øC√≥mo podemos **.bg-purple_light[descomponer el error]**?

---


# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]


* **Paso 1**: a√±adir y restar `\({\rm E} \left[ \hat{Y} \right]\)` dentro del par√©ntesis.

$$E(x, f) := {\rm E}\left[\left(Y - \hat{f}(X)\right)^2  \right] = {\rm E}\left[\left(\left(Y - {\rm E} \left[ \hat{Y} \right] \right) + \left( {\rm E} \left[ \hat{Y} \right] - \hat{f}(X)\right)^2 \right)  \right] $$

--

* **Paso 2**: resolver `\((a-c+c-b)^2 = ((a-c)+(c-b))^2 = (a-c)^2 + (c-b)^2 - 2*(a-c)(c-b)\)` 

$$E(x, f) := \left(Y - {\rm E} \left[ \hat{Y} \right] \right)^2  + {\rm E}\left[ \left( {\rm E} \left[ \hat{Y} \right] - \hat{f}(X)\right)^2 \right] + 2 {\rm E} \left[\left(Y - {\rm E} \left[ \hat{Y} \right] \right) \left( {\rm E} \left[ \hat{Y} \right] - \hat{f}(X)\right) \right] $$
--

* **Paso 3**: identificar t√©rminos

`$$E(x, f) := {\rm E}\left[\left(Y - \hat{f}(X)\right)^2  \right] = sesgo^2 + varianza + ruido$$`

---


# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]


* **.bg-red_light[Sesgo (bias)]** ser√° igual a `\(\left(Y - {\rm E} \left[ \hat{Y} \right] \right)^2\)` (diferencia media entre la predicci√≥n media del modelo y el valor correcto a predecir).

--

* **.bg-green_light[Varianza (variance)]** ser√° igual a `\({\rm E}\left[ \left( {\rm E} \left[ \hat{Y} \right] - \hat{f}(X)\right)^2 \right]\)` (la  dispersi√≥n/variaci√≥n entre las predicci√≥n individuales y la predicci√≥n media).

--

* **.bg-orange[Ruido]**: error aleatorio **irreducible** `\(\varepsilon\)` (la componente aleatoria del modelo no determin√≠stico) de media nula.

--

&amp;nbsp;

El **.bg-red_light[sesgo]** ser√° por tanto lo que nos **.bg-red_light[equivocamos/desviamos de forma sistem√°tica]** y la **.bg-green_light[varianza]** del modelo ser√° la **.bg-green_light[dispersi√≥n entre las predicciones]** de un mismo valor, como si repitieramos el modelo con distintas muestras aleatorias obtenidas de la misma poblaci√≥n. 

---

# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/bias_variance.jpg" alt="Extra√≠da de https://scott.fortmann-roe.com/docs/BiasVariance.html" width="40%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://scott.fortmann-roe.com/docs/BiasVariance.html&lt;/p&gt;
&lt;/div&gt;

---

# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]



.pull-left[

* **.bg-red_light[Bajoajuste (underfitting)]**: modelos **muy simples** proporcionan un **.bg-red_light[sesgo muy grande]**, y poca varianza ya que la predicci√≥n siempre ser√° muy parecida (errores altos en train).

* **.bg-green_light[Sobreajuste (overfitting)]**: modelos **muy complicados**  proporcionan un **.bg-green_light[sesgo bajo]** pero al ser tan complejas proporcionar√°n una **.bg-green_light[mayor varianza]** para cada intento (errores altos en test).

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/bias_varianc_tradeoff.jpg" alt="Extra√≠da de https://mlu-explain.github.io/bias-variance/" width="99%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://mlu-explain.github.io/bias-variance/&lt;/p&gt;
&lt;/div&gt;

Lo deseable ser√° encontrar ese **.bg-purple_light[punto √≥ptimo de equilibrio]** en el que el error ser√° m√≠nimo.

]

---

# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/train_test_underfitting.jpg" alt="Extra√≠da de https://mlu-explain.github.io/bias-variance/" width="99%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://mlu-explain.github.io/bias-variance/&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/simple_model.jpg" alt="Extra√≠da de https://mlu-explain.github.io/bias-variance/" width="99%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://mlu-explain.github.io/bias-variance/&lt;/p&gt;
&lt;/div&gt;

]

---

# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/train_test_overfitting.jpg" alt="Extra√≠da de https://mlu-explain.github.io/bias-variance/" width="99%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://mlu-explain.github.io/bias-variance/&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/complex_model.jpg" alt="Extra√≠da de https://mlu-explain.github.io/bias-variance/" width="99%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://mlu-explain.github.io/bias-variance/&lt;/p&gt;
&lt;/div&gt;

]


---

# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/overfitting.jpg" alt="Extra√≠da de https://365datascience.com/tutorials/machine-learning-tutorials/overfitting-underfitting/" width="60%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://365datascience.com/tutorials/machine-learning-tutorials/overfitting-underfitting/&lt;/p&gt;
&lt;/div&gt;

Un **.bg-purple_light[modelo muy simple no captura los patrones]** subyancetes en los datos mientras que un **.bg-purple_light[modelo muy complejo solo memoriza]**, no aprende.


---

# Sobreajuste. .green[SESGO] vs .orange[VARIANZA]

&lt;img src="./img/meme_overfitting.jpg" width="45%" style="display: block; margin: auto;" /&gt;

---

# .green[SUPERVISADO] vs .orange[NO SUPERVISADO]

&lt;img src="./img/non_supervised.jpg" width="47%" style="display: block; margin: auto;" /&gt;


---

# .green[SUPERVISADO] vs .orange[NO SUPERVISADO]


.pull-left[

* **.bg-purple_light[Aprendizaje supervisado]**: tendremos dos tipos de variables, la **.bg-orange[variable dependiente (output/target)]** que se quiere predecir/clasificar (con su valor conocido en el conjunto de entrenamiento) y las **.bg-orange[variables independientes (inputs)]** o variables explicativas, que contienen la informaci√≥n disponible.

&amp;nbsp;

Todo lo que veremos en esta asignatura entra dentro de la idea de **aprendizaje supervisado**

]


.pull-right[


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/esquema_supervised.jpg" alt="Extra√≠da de https://realpython.com/knn-python/basics-of-machine-learning" width="110%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://realpython.com/knn-python/basics-of-machine-learning&lt;/p&gt;
&lt;/div&gt;


]

---

# .green[SUPERVISADO] vs .orange[NO SUPERVISADO]


.pull-left[


* **.bg-purple_light[Aprendizaje no supervisado]**: no existe la distinci√≥n entre target y variables explicativas ya que **.bg-orange[no tenemos etiquetados los datos]**, no sabemos a priori la respuesta correcta. El aprendizaje no supervisado buscar√° **.bg-orange[similitudes/diferencias]**.

]


.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/esquema_nonsupervised.jpg" alt="Extra√≠da de https://realpython.com/knn-python/basics-of-machine-learning" width="110%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://realpython.com/knn-python/basics-of-machine-learning&lt;/p&gt;
&lt;/div&gt;


]


---

# .green[CLASIFICACI√ìN] vs .orange[PREDICCI√ìN]

Dos opciones dependiendo de la **.bg-purple_light[naturaleza de la variable objetivo]** (output/target):

* **.bg-purple_light[Predicci√≥n]**: la variable objetivo es una variable **.bg-purple_light[cuantitativa continua]** (por ejemplo, precio, glucosa, etc), y la etiqueta del conjunto de entrenamiento tomar√° un **valor continuo**, a partir de una (unidimensional) o varias variables (multidimensional).

* **.bg-purple_light[Clasificaci√≥n]**: la variable objetivo es una variable **.bg-purple_light[cualitativa]** (por ejemplo, especie de flor, ausencia/presencia de enfermedad, si/no, etc) o **.bg-purple_light[cuantitativa discreta]** (por ejemplo, n√∫mero de accidentes). La etiqueta tomar√° un valor dentro del conjunto de **modalidades permitidas**, pudiendo ser binaria (si/no) o multiclase (A, B, C, D).

&amp;nbsp;

De aqu√≠ en adelante `\(Y\)` ser√° nuestra variable objetivo (cdentro de un rango o de un grupo de modalidades `\(G = \left\lbrace 1, 2, \ldots,k \right\rbrace\)`), y el conjunto `\(\left(X_1, \ldots, X_p \right)\)` ser√°n las variables predictoras.


üìö Ver ¬´The elements of Statistical Learning¬ª (Hastie et al., 2008): &lt;https://github.com/dadosdelaplace/teaching/blob/main/data_mining/biblio/datamining_hastieetal_2008.pdf&gt;


---

name: data-mining

# .orange[DATA MINING]: ¬øqu√© es?

No hay una definici√≥n √∫nica o formal pero podemos ayudarnos de las definiciones dadas por algunos de los m√°ximos gigantes tecnol√≥gicos.

--

Seg√∫n **.bg-purple_light[IBM]**...

&gt; La miner√≠a de datos es una forma innovadora de obtener informaci√≥n comercial valiosa mediante el an√°lisis de los datos contenidos en la base de datos de la empresa (IBM)

--

&amp;nbsp;

Seg√∫n **.bg-purple_light[Microsoft]**...

&gt; La miner√≠a de datos es el proceso de detectar informaci√≥n procesable de grandes conjuntos de datos para deducir los patrones y tendencias que existen. Normalmente,
estos patrones no se pueden detectar mediante la exploraci√≥n tradicional de los datos
porque las relaciones son demasiado complejas o hay demasiados datos (Microsoft)

---

# .orange[DATA MINING]: ¬øqu√© es?

.pull-left[

La miner√≠a de datos tiene como objetivo  **.bg-purple_light[descubrir patrones]** de forma autom√°tica o semiautom√°tica, patrones que a simple vista (o con estad√≠stica b√°sica) no podemos aflorar, bien por contar con **.bg-orange[grandes conjuntos de datos]**, bien por existir **.bg-green_light[relaciones muy complejas]**.

&amp;nbsp;

No solo comprende la exploraci√≥n y el modelado, sino tambi√©n la **.bg-purple_light[evaluaci√≥n]** y la **.bg-purple_light[transformaci√≥n de la informaci√≥n]** para su uso posterior.

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/proceso-mineria-de-datos.png.webp" alt="Extra√≠da de https://www.masterdatascienceucm.com" width="90%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://www.masterdatascienceucm.com&lt;/p&gt;
&lt;/div&gt;


El **gran tama√±o muestral** suele hacer inviable la aplicaci√≥n de t√©cnicas de inferencia cl√°sica (problemas de potencia).

]

---

# .orange[DATA MINING]: ejemplos de uso


* **.bg-purple_light[Clasificaci√≥n de vuelos]**: usando, entre otras, variables de tr√°fico de aereo, tipolog√≠a de vuelo, variables meteorol√≥gicas, las aerol√≠neas pueden calcular la probabilidad de retraso en un vuelo.

* **.bg-purple_light[Marketing y ventas]**: conocer el perfil de p√∫blico objetivo para enfocar campa√±as personalizadas, en funci√≥n de patrones en su comportamiento, y predecir futuras bajas.

* **.bg-purple_light[Miner√≠a de textos]**: extracci√≥n de patrones en textos para clasificar, por ejemplo, noticias (detecci√≥n de Fake News).

* **.bg-purple_light[Supermercados]**: pueden analizar el conjunto de compras masivas que hacen sus clientes, para identificar asociaciones de productos o las ofertas que mejor han funcionado.

* **.bg-purple_light[Predicci√≥n de enfermedades]**: haciendo uso de diferente variables m√©dicas y de h√°bitos de salud se puede predecir la probabilidad de aparici√≥n de ciertas enfermedades, as√≠ como encontrar factores explicativos que nos puedan ayudar a su prevenci√≥n.


---

# Metodolog√≠a .orange[SEMMA]

Existen distintas metodolog√≠as/esquemas dentro de la miner√≠a de datos como la CRISP-DM (desarrollada por IBM) la
**.bg-purple_light[metodolog√≠a SEMMA]** (desarrollada por SAS), que usaremos parcialmente en esta asignatura. En esta metodolog√≠a SEMMA no siempre intervienen todas las fases del proceso y, adem√°s, las fases pueden repetirse y el
orden de las mismas modificarse.

.pull-left[


* **.bg-purple_light[SAMPLE (muestreo)]**: am√©n de las particiones train-validate-train, si la base de datos es demasiado grande, ser√° necesario tomar una **.bg-purple_light[submuestra representativa]** para poder ser procesada computacionalmente.

]

.pull-right[

&lt;img src="./img/SEMMA.JPG" width="82%" style="display: block; margin: auto auto auto 0;" /&gt;

]

---

# Metodolog√≠a .orange[SEMMA]

En esta metodolog√≠a SEMMA no siempre intervienen todas las fases del proceso y, adem√°s, las fases pueden repetirse y el
orden de las mismas modificarse.

.pull-left[


* **.bg-purple_light[EXPLORE (explorar)]**: antes de tomar decisiones deberemos **.bg-purple_light[explorar, visualizar y entender]** los datos que tenemos, para poder detectar posibles tendencias, inconsistencias, datos ausentes o anomal√≠as.

]

.pull-right[

&lt;img src="./img/SEMMA.JPG" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]

---

# Metodolog√≠a .orange[SEMMA]

En esta metodolog√≠a SEMMA no siempre intervienen todas las fases del proceso y, adem√°s, las fases pueden repetirse y el
orden de las mismas modificarse.

.pull-left[

* **.bg-purple_light[MODIFY (modificar)]**: para preparar los datos de forma adecuada a los modelos, a veces es necesario realizar una **.bg-purple_light[transformaci√≥n]** previa de los mismos.

]

.pull-right[

&lt;img src="./img/SEMMA.JPG" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]

---

# Metodolog√≠a .orange[SEMMA]


En esta metodolog√≠a SEMMA no siempre intervienen todas las fases del proceso y, adem√°s, las fases pueden repetirse y el
orden de las mismas modificarse.

.pull-left[

* **.bg-purple_light[MODEL (modelizar)]**: aplicaci√≥n de los **.bg-purple_light[modelos y t√©cnicas estad√≠sticas]** en el conjunto del entrenamiento para predecir la variable objetivo (regresi√≥n, knn, √°rboles de decisi√≥n, redes neuronales, etc).

]

.pull-right[

&lt;img src="./img/SEMMA.JPG" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]

---

# Metodolog√≠a .orange[SEMMA]


En esta metodolog√≠a SEMMA no siempre intervienen todas las fases del proceso y, adem√°s, las fases pueden repetirse y el
orden de las mismas modificarse.

.pull-left[

* **.bg-purple_light[ASSESS (evaluar)]**: comprobar y **.bg-purple_light[evaluar nuestras decisiones]** para decidir los mejores par√°metros haciendo uso del conjunto de validaci√≥n. Es habitual tener que volver a la fase de modelizaci√≥n, para plantear correcciones en el modelado. Finalmente, al final del camino, se proveer√° de la calidad del modelo en el conjunto test.

]

.pull-right[

&lt;img src="./img/SEMMA.JPG" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]


---

name: sample

# Primera fase SEMMA: .orange[MUESTREO]

Como hemos comentado, **.bg-purple_light[ANTES]** de las posibles particiones train-validaci√≥n-test que necesitemos, si la base de datos es **.bg-purple_light[demasiado grande]**, ser√° necesario tomar una **.bg-purple_light[submuestra]** (representativa) para poder ser procesada de forma eficiente.

--

.pull-left[

* **.bg-purple_light[No aleatorio]** (por cuotas) en base a **.bg-orange[condiciones]** sobre los registros (`filter()`)

* **.bg-purple_light[No aleatorio]** (intencional/discreccional) en base a **.bg-orange[posici√≥n]** (`slice`)

* **.bg-purple_light[Aleatorio]** **.bg-orange[simple]**  (`slice_sample()`)

* **.bg-purple_light[Aleatorio]** **.bg-orange[estratificado]** (`group_by()` + `slice_sample()`)

]

.pull-right[

&lt;img src="./img/sample.jpg" width="99%" style="display: block; margin: auto auto auto 0;" /&gt;


]

üìö Ver otros tipos de muestreo &lt;https://www.unir.net/ingenieria/revista/tipos-de-muestreo/&gt;

---

# Introducci√≥n a .orange[TIDYVERSE]


.pull-left[

&lt;img src="./img/tidyverrse_universe.jpg" width="89%" style="display: block; margin: auto;" /&gt;

Tambi√©n tenemos los paquetes `{purrr}` y `{lubridate}` para el manejo de **listas** y **fechas**, `{readxl}` para importar archivos **.xls y .xlsx**, `{haven}` para importar archivos **SPSS, Stata y SAS**, `{httr}` para importar **desde web** y `{rvest}` para **web scraping**.


]

.pull-right[

* `{tibble}`: **.bg-purple_light[optimizando data.frame]**.

* `{tidyr}`: **.bg-purple_light[limpiar datos]**.

* `{readr}`: **.bg-purple_light[carga r√°pida]** de datos rectangulares (formatos .csv, .tsv, etc). 

* `{dplyr}`: gram√°tica para **.bg-purple_light[depuraci√≥n de datos]** para facilitar su procesamiento.

* `{stringr}`: manejo de **.bg-purple_light[textos]**. 

* `{forcast}` manejo de **.bg-purple_light[cualitativas]**.

* `{ggplot2}`: una gram√°tica para la **.bg-purple_light[visualizaci√≥n de datos]**.

* `{tidymodels}`: una gram√°tica para la **.bg-purple_light[modelizaci√≥n y predicci√≥n]**.


]


Puedes ver su **documentaci√≥n completa** en &lt;https://www.tidyverse.org/&gt;.



---

# Introducci√≥n a .orange[TIDYVERSE]


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/dplyr.png" alt="Cheet sheet de las opciones del paquete dplyr" width="60%" /&gt;
&lt;p class="caption"&gt;Cheet sheet de las opciones del paquete dplyr&lt;/p&gt;
&lt;/div&gt;

El paquete vamos a usar para **.bg-purple_light[depurar y muestrear los datos]** ser√° el paquete `{dplyr}`, una gram√°tica para la manipulaci√≥n de datos.

---

# No aleatorio por condiciones: .orange[FILTER]

El conocido como **.bg-purple_light[muestreo no aleatorio por cuotas]** se basa en seleccionar (filtrar) individuos (registros) concretos que cumplan condiciones concretas.

.pull-left[


```r
datos %&gt;%
  filtro(condicion)
```

]

.pull-right[


```r
starwars %&gt;%
  filter(condicion)
```

]


--

Comparadores habituales:

* `==, !=` igual/distinto que
* `&gt;, &lt;` mayor/menor que
* `&gt;=, &lt;=` mayor/menor o igual que
* `%in%` los valores pertenecen a un listado
* `!is.na()` los valores no son ausentes (mejor usar `drop_na()`)
* `between(variable, val1, val2)`: si los valores (normalmente continuos) est√°n dentro de un rango.

---

# No aleatorio por condiciones: .orange[FILTER]

.pull-left[


```r
datos %&gt;%
  filtro(condicion)
```

]

.pull-right[


```r
starwars %&gt;%
  filter(condicion)
```

]

&amp;nbsp;

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/tablas_verdad.jpg" alt="Tablas de verdad de operadores l√≥gicos" width="80%" /&gt;
&lt;p class="caption"&gt;Tablas de verdad de operadores l√≥gicos&lt;/p&gt;
&lt;/div&gt;

---

# No aleatorio por condiciones: .orange[FILTER]

Dicha funci√≥n `filter()` tambi√©n la usaremos cuando queramos **.bg-purple_light[depurar los datos]** en nuestra fase exploratoria.

.pull-left[


```r
datos %&gt;%
  filtro(condicion)
```

]

.pull-right[


```r
starwars %&gt;%
  filter(condicion)
```

]

--

Por ejemplo, vamos a **filtrar** aquellos personajes con **.bg-purple_light[ojos marrones]**.


```r
starwars %&gt;%
* filter(eye_color == "brown")
```

```
&gt; # A tibble: 21 √ó 14
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Leia Organa    150  49   brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  2 Biggs Dark‚Ä¶    183  84   black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  3 Han Solo       180  80   brown   fair    brown      29   male  mascu‚Ä¶ Corell‚Ä¶
&gt;  4 Yoda            66  17   white   green   brown     896   male  mascu‚Ä¶ &lt;NA&gt;   
&gt;  5 Boba Fett      183  78.2 black   fair    brown      31.5 male  mascu‚Ä¶ Kamino 
&gt;  6 Lando Calr‚Ä¶    177  79   black   dark    brown      31   male  mascu‚Ä¶ Socorro
&gt;  7 Arvel Cryn‚Ä¶     NA  NA   brown   fair    brown      NA   male  mascu‚Ä¶ &lt;NA&gt;   
&gt;  8 Wicket Sys‚Ä¶     88  20   brown   brown   brown       8   male  mascu‚Ä¶ Endor  
&gt;  9 Quarsh Pan‚Ä¶    183  NA   black   dark    brown      62   &lt;NA&gt;  &lt;NA&gt;   Naboo  
&gt; 10 Shmi Skywa‚Ä¶    163  NA   black   fair    brown      72   fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt; # ‚Ä¶ with 11 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[VISUALIZAR] operaciones con datos


En la web &lt;https://tidydatatutor.com/&gt; podemos visualizar el flujo de datos d las transformaciones que podemos hacer con `dplyr`

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/filter1.jpg" alt="Flujo de https://tidydatatutor.com/" width="90%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

]

---

# No aleatorio por condiciones: .orange[FILTER]


De la misma manera podemos **filtrar** los personajes que **.bg-purple_light[no tienen ojos marrones]** (en realidad estamos eliminando filas de alguna manera).



```r
starwars %&gt;% filter(eye_color != "brown")
```

```
&gt; # A tibble: 66 √ó 14
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa‚Ä¶    172    77 blond   fair    blue       19   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  3 R2-D2           96    32 &lt;NA&gt;    white,‚Ä¶ red        33   none  mascu‚Ä¶ Naboo  
&gt;  4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  5 Owen Lars      178   120 brown,‚Ä¶ light   blue       52   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  6 Beru White‚Ä¶    165    75 brown   light   blue       47   fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt;  7 R5-D4           97    32 &lt;NA&gt;    white,‚Ä¶ red        NA   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  8 Obi-Wan Ke‚Ä¶    182    77 auburn‚Ä¶ fair    blue-g‚Ä¶    57   male  mascu‚Ä¶ Stewjon
&gt;  9 Anakin Sky‚Ä¶    188    84 blond   fair    blue       41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 10 Wilhuff Ta‚Ä¶    180    NA auburn‚Ä¶ fair    blue       64   male  mascu‚Ä¶ Eriadu 
&gt; # ‚Ä¶ with 56 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# No aleatorio por condiciones: .orange[FILTER]

Al ser una variable discreta, ser√≠a bastante l√≥gico comprobar si toma alg√∫n valor **.bg-purple_light[dentro de una lista permitida]**  (por ejemplo, personjes con ojos marrones o azules).



```r
starwars %&gt;% filter(eye_color %in% c("brown", "blue"))
```

```
&gt; # A tibble: 40 √ó 14
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa‚Ä¶    172    77 blond   fair    blue       19   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  2 Leia Organa    150    49 brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  3 Owen Lars      178   120 brown,‚Ä¶ light   blue       52   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  4 Beru White‚Ä¶    165    75 brown   light   blue       47   fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt;  5 Biggs Dark‚Ä¶    183    84 black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  6 Anakin Sky‚Ä¶    188    84 blond   fair    blue       41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  7 Wilhuff Ta‚Ä¶    180    NA auburn‚Ä¶ fair    blue       64   male  mascu‚Ä¶ Eriadu 
&gt;  8 Chewbacca      228   112 brown   unknown blue      200   male  mascu‚Ä¶ Kashyy‚Ä¶
&gt;  9 Han Solo       180    80 brown   fair    brown      29   male  mascu‚Ä¶ Corell‚Ä¶
&gt; 10 Jek Tono P‚Ä¶    180   110 brown   fair    blue       NA   male  mascu‚Ä¶ Bestin‚Ä¶
&gt; # ‚Ä¶ with 30 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# No aleatorio por condiciones: .orange[FILTER]

Cuando es una variable continua el inter√©s podr√≠a estar en comprobar si la variable toma valores **.bg-purple_light[dentro de un intervalo continuo]**.


.pull-left[


```r
starwars %&gt;%
  filter(between(height, 120, 160))
```


```
&gt; # A tibble: 5 √ó 4
&gt;   name        height  mass eye_color
&gt;   &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;    
&gt; 1 Leia Organa    150    49 brown    
&gt; 2 Mon Mothma     150    NA blue     
&gt; 3 Nien Nunb      160    68 black    
&gt; 4 Watto          137    NA yellow   
&gt; 5 Gasgano        122    NA black
```

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/filter3.jpg" alt="Flujo de https://tidydatatutor.com/" width="160%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

]


---


# No aleatorio por condiciones: .orange[FILTER]


Las condiciones tambi√©n se pueden **.bg-purple_light[concatenar]**, pudiendo en pocas l√≠neas realizar un filtro complejo. Por ejemplo, podemos filtrar los personajes con **.bg-purple_light[ojos marrones Y ADEM√ÅS NO humanos]**, o **.bg-purple_light[con m√°s de 60 a√±os]**.

.pull-left[


```r
starwars %&gt;%
  filter((eye_color == "brown" &amp;
            species != "Human") |
           birth_year &gt; 60)
```

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/filter5.jpg" alt="Flujo de https://tidydatatutor.com/" width="100%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;


]

---

# Ejercicios (filter)

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: selecciona del conjunto de `starwars` solo los personajes que sean humanos (`species == "Human"`)

* üìù **Ejercicio 2**: selecciona del conjunto de `starwars` solo los personajes cuyo peso est√© entre 65 y 90 kg.

* üìù **Ejercicio 3**: selecciona del conjunto de `starwars` los personajes con ojos marrones o rojos.

* üìù **Ejercicio 4**: selecciona del conjunto de `starwars` los personajes no humanos, hombres y que midan m√°s de 170 cm, o los personajes con ojos marrones o rojos.

* üìù **Ejercicio 5**: selecciona aquellos personajes de `starwars` que hayan pilotado m√°s de 2 naves.

]

.panel[.panel-name[Sol. Ej. 1]


```r
starwars %&gt;%
  filter(species == "Human")
```

```
&gt; # A tibble: 35 √ó 14
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa‚Ä¶    172    77 blond   fair    blue       19   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  2 Darth Vader    202   136 none    white   yellow     41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  3 Leia Organa    150    49 brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  4 Owen Lars      178   120 brown,‚Ä¶ light   blue       52   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  5 Beru White‚Ä¶    165    75 brown   light   blue       47   fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt;  6 Biggs Dark‚Ä¶    183    84 black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  7 Obi-Wan Ke‚Ä¶    182    77 auburn‚Ä¶ fair    blue-g‚Ä¶    57   male  mascu‚Ä¶ Stewjon
&gt;  8 Anakin Sky‚Ä¶    188    84 blond   fair    blue       41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  9 Wilhuff Ta‚Ä¶    180    NA auburn‚Ä¶ fair    blue       64   male  mascu‚Ä¶ Eriadu 
&gt; 10 Han Solo       180    80 brown   fair    brown      29   male  mascu‚Ä¶ Corell‚Ä¶
&gt; # ‚Ä¶ with 25 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 2]


```r
starwars %&gt;%
  filter(between(mass, 65, 90))
```

```
&gt; # A tibble: 32 √ó 14
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa‚Ä¶    172    77 blond   fair    blue       19   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  3 Beru White‚Ä¶    165    75 brown   light   blue       47   fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt;  4 Biggs Dark‚Ä¶    183    84 black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  5 Obi-Wan Ke‚Ä¶    182    77 auburn‚Ä¶ fair    blue-g‚Ä¶    57   male  mascu‚Ä¶ Stewjon
&gt;  6 Anakin Sky‚Ä¶    188    84 blond   fair    blue       41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  7 Han Solo       180    80 brown   fair    brown      29   male  mascu‚Ä¶ Corell‚Ä¶
&gt;  8 Greedo         173    74 &lt;NA&gt;    green   black      44   male  mascu‚Ä¶ Rodia  
&gt;  9 Wedge Anti‚Ä¶    170    77 brown   fair    hazel      21   male  mascu‚Ä¶ Corell‚Ä¶
&gt; 10 Palpatine      170    75 grey    pale    yellow     82   male  mascu‚Ä¶ Naboo  
&gt; # ‚Ä¶ with 22 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 3]


```r
starwars %&gt;%
  filter(eye_color %in% c("brown", "red"))
```

```
&gt; # A tibble: 26 √ó 14
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 R2-D2           96  32   &lt;NA&gt;    white,‚Ä¶ red        33   none  mascu‚Ä¶ Naboo  
&gt;  2 Leia Organa    150  49   brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  3 R5-D4           97  32   &lt;NA&gt;    white,‚Ä¶ red        NA   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  4 Biggs Dark‚Ä¶    183  84   black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  5 Han Solo       180  80   brown   fair    brown      29   male  mascu‚Ä¶ Corell‚Ä¶
&gt;  6 Yoda            66  17   white   green   brown     896   male  mascu‚Ä¶ &lt;NA&gt;   
&gt;  7 Boba Fett      183  78.2 black   fair    brown      31.5 male  mascu‚Ä¶ Kamino 
&gt;  8 IG-88          200 140   none    metal   red        15   none  mascu‚Ä¶ &lt;NA&gt;   
&gt;  9 Bossk          190 113   none    green   red        53   male  mascu‚Ä¶ Trando‚Ä¶
&gt; 10 Lando Calr‚Ä¶    177  79   black   dark    brown      31   male  mascu‚Ä¶ Socorro
&gt; # ‚Ä¶ with 16 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 4]


```r
starwars %&gt;%
  filter((species != "Human" &amp; sex == "Male" &amp; height &gt; 170) |
           eye_color %in% c("brown", "red"))
```

```
&gt; # A tibble: 26 √ó 14
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 R2-D2           96  32   &lt;NA&gt;    white,‚Ä¶ red        33   none  mascu‚Ä¶ Naboo  
&gt;  2 Leia Organa    150  49   brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  3 R5-D4           97  32   &lt;NA&gt;    white,‚Ä¶ red        NA   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  4 Biggs Dark‚Ä¶    183  84   black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  5 Han Solo       180  80   brown   fair    brown      29   male  mascu‚Ä¶ Corell‚Ä¶
&gt;  6 Yoda            66  17   white   green   brown     896   male  mascu‚Ä¶ &lt;NA&gt;   
&gt;  7 Boba Fett      183  78.2 black   fair    brown      31.5 male  mascu‚Ä¶ Kamino 
&gt;  8 IG-88          200 140   none    metal   red        15   none  mascu‚Ä¶ &lt;NA&gt;   
&gt;  9 Bossk          190 113   none    green   red        53   male  mascu‚Ä¶ Trando‚Ä¶
&gt; 10 Lando Calr‚Ä¶    177  79   black   dark    brown      31   male  mascu‚Ä¶ Socorro
&gt; # ‚Ä¶ with 16 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 5]


```r
library(purrr) # ya est√° en tidyverse per por si
starwars$n_starships &lt;- starwars$starships %&gt;% map_int(length)
starwars %&gt;% filter(n_starships &gt; 2)
```

```
&gt; # A tibble: 3 √ó 15
&gt;   name         height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Obi-Wan Ken‚Ä¶    182    77 auburn‚Ä¶ fair    blue-g‚Ä¶    57   male  mascu‚Ä¶ Stewjon
&gt; 2 Anakin Skyw‚Ä¶    188    84 blond   fair    blue       41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 3 Padm√© Amida‚Ä¶    165    45 brown   light   brown      46   fema‚Ä¶ femin‚Ä¶ Naboo  
&gt; # ‚Ä¶ with 5 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, n_starships &lt;int&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```



]

]

---

# Ejercicio extra


Veamos un ejercicio extra para comprobar la **potencia y flexibilidad** de `{tidyverse}`, pudiendo hacer muchas cosas en dos l√≠neas de c√≥digo.

&amp;nbsp;

* üìù **Ejercicio extra**: selecciona aquellos personajes de `starwars` que hayan salido en la pel√≠cula de la saga "El ataque de los clones" (en ingl√©s, "Attack of the Clones"). Busca informaci√≥n de la funci√≥n `str_detect()` del paquete `stringr`. Consejo: prueba antes las funciones que vayas a usar con alg√∫n vector de prueba para poder comprobar su funcionamiento.

---


# No aleatorio por posici√≥n: .orange[SLICE]

El conocido como **.bg-purple_light[muestreo no aleatorio intencional o discreccional]** se basa en seleccionar (filtrar) individuos (registros) concretos por su posici√≥n, elementos ¬´a dedo¬ª.

.pull-left[


```r
datos %&gt;%
  rebanada(posicion)
```

]

.pull-right[


```r
starwars %&gt;%
  slice(posicion)
```

]

--

Normalmente filtraremos registros por alguna condici√≥n pero a veces nos puede interesar, por ejemplo, sacar las primeras n filas. Para podemos crear **.bg-purple_light[rebanadas de los datos]**, seleccionando filas por su posici√≥n con `slice()`.


```r
*starwars %&gt;% slice(1)
```

```
&gt; # A tibble: 1 √ó 14
&gt;   name         height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Luke Skywal‚Ä¶    172    77 blond   fair    blue         19 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt; # ‚Ä¶ with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¬π‚Äãhair_color, ¬≤‚Äãskin_color,
&gt; #   ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```

---

# No aleatorio por posici√≥n: .orange[SLICE]

.pull-left[


```r
datos %&gt;%
  rebanada(posicion)
```

]

.pull-right[


```r
starwars %&gt;%
  slice(posicion)
```

]


Recuerda que todo lo que podemos hacer con un n√∫mero (vector de longitud 1) podemos hacerlo con un vector de √≠ndices, as√≠ que podemos **.bg-purple_light[extraer varias rebanadas]**, a la vez.


```r
# filas de la 1 a la 5
starwars %&gt;% slice(1:5)
```

```
&gt; # A tibble: 5 √ó 14
&gt;   name         height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Luke Skywal‚Ä¶    172    77 blond   fair    blue       19   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 2 C-3PO           167    75 &lt;NA&gt;    gold    yellow    112   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 3 R2-D2            96    32 &lt;NA&gt;    white,‚Ä¶ red        33   none  mascu‚Ä¶ Naboo  
&gt; 4 Darth Vader     202   136 none    white   yellow     41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 5 Leia Organa     150    49 brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt; # ‚Ä¶ with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¬π‚Äãhair_color, ¬≤‚Äãskin_color,
&gt; #   ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```

---

# No aleatorio por posici√≥n: .orange[SLICE]

Tambi√©n podr√≠amos usar una **.bg-purple_light[secuencia de √≠ndices]** a extraer.


```r
# filas 1, 2, 10, 13, 27
starwars %&gt;% slice(c(1, 2, 10, 13, 27))
```

```
&gt; # A tibble: 5 √ó 14
&gt;   name         height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Luke Skywal‚Ä¶    172    77 blond   fair    blue         19 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 2 C-3PO           167    75 &lt;NA&gt;    gold    yellow      112 none  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 3 Obi-Wan Ken‚Ä¶    182    77 auburn‚Ä¶ fair    blue-g‚Ä¶      57 male  mascu‚Ä¶ Stewjon
&gt; 4 Chewbacca       228   112 brown   unknown blue        200 male  mascu‚Ä¶ Kashyy‚Ä¶
&gt; 5 Mon Mothma      150    NA auburn  fair    blue         48 fema‚Ä¶ femin‚Ä¶ Chandr‚Ä¶
&gt; # ‚Ä¶ with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¬π‚Äãhair_color, ¬≤‚Äãskin_color,
&gt; #   ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```


---

# No aleatorio por posici√≥n: .orange[SLICE]


Disponemos adem√°s de opciones por defecto de operaciones habituales

* `slice_head(n = ...)`: extraer las n **.bg-purple_light[primeras filas]**.



```r
# las 2 primeras filas
starwars %&gt;% slice_head(n = 2)
```

```
&gt; # A tibble: 2 √ó 14
&gt;   name         height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Luke Skywal‚Ä¶    172    77 blond   fair    blue         19 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 2 C-3PO           167    75 &lt;NA&gt;    gold    yellow      112 none  mascu‚Ä¶ Tatooi‚Ä¶
&gt; # ‚Ä¶ with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¬π‚Äãhair_color, ¬≤‚Äãskin_color,
&gt; #   ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```

---


# No aleatorio por posici√≥n: .orange[SLICE]

* `slice_tail(n = ...)`: extraer las n **.bg-purple_light[√∫ltimas filas]**.


```r
# los 3 √∫ltimas filas
starwars %&gt;% slice_tail(n = 3) 
```

```
&gt; # A tibble: 3 √ó 14
&gt;   name         height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 BB8              NA    NA none    none    black        NA none  mascu‚Ä¶ &lt;NA&gt;   
&gt; 2 Captain Pha‚Ä¶     NA    NA unknown unknown unknown      NA &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;   
&gt; 3 Padm√© Amida‚Ä¶    165    45 brown   light   brown        46 fema‚Ä¶ femin‚Ä¶ Naboo  
&gt; # ‚Ä¶ with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¬π‚Äãhair_color, ¬≤‚Äãskin_color,
&gt; #   ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```

---

# No aleatorio por posici√≥n: .orange[SLICE]


* `slice_min(var, n = ...)` y `slice_max(var, n = ...)`: extrae las n filas con **.bg-purple_light[menor/mayor de una variable]** (si hay empate, mostrar√° todas salvo que `with_ties = FALSE`). 

.pull-left[


```r
# los 3 m√°s bajitos
starwars %&gt;% slice_min(height, n = 3) 
```


```
&gt; # A tibble: 3 √ó 4
&gt;   name                  height  mass hair_color
&gt;   &lt;chr&gt;                  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;     
&gt; 1 Yoda                      66    17 white     
&gt; 2 Ratts Tyerell             79    15 none      
&gt; 3 Wicket Systri Warrick     88    20 brown
```

]

.pull-right[


```r
# los 3 m√°s pesados
starwars %&gt;% slice_max(mass, n = 3) 
```


```
&gt; # A tibble: 3 √ó 4
&gt;   name                  height  mass hair_color
&gt;   &lt;chr&gt;                  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;     
&gt; 1 Jabba Desilijic Tiure    175  1358 &lt;NA&gt;      
&gt; 2 Grievous                 216   159 none      
&gt; 3 IG-88                    200   140 none
```

]

---

# Ejercicios (slice)

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: selecciona solo los personajes que sean humanos y de ojos marrones.

* üìù **Ejercicio 2**: selecciona los 3 personajes m√°s mayores.

* üìù **Ejercicio 3**: selecciona los 5 personajes m√°s bajitos.



]

.panel[.panel-name[Sol. Ej. 1]


```r
# Podemos combinar varias acciones en pocas l√≠neas
starwars %&gt;%
  filter(eye_color == "brown",
         species == "Human")
```

```
&gt; # A tibble: 17 √ó 14
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Leia Organa    150  49   brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  2 Biggs Dark‚Ä¶    183  84   black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  3 Han Solo       180  80   brown   fair    brown      29   male  mascu‚Ä¶ Corell‚Ä¶
&gt;  4 Boba Fett      183  78.2 black   fair    brown      31.5 male  mascu‚Ä¶ Kamino 
&gt;  5 Lando Calr‚Ä¶    177  79   black   dark    brown      31   male  mascu‚Ä¶ Socorro
&gt;  6 Arvel Cryn‚Ä¶     NA  NA   brown   fair    brown      NA   male  mascu‚Ä¶ &lt;NA&gt;   
&gt;  7 Shmi Skywa‚Ä¶    163  NA   black   fair    brown      72   fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt;  8 Mace Windu     188  84   none    dark    brown      72   male  mascu‚Ä¶ Haruun‚Ä¶
&gt;  9 Gregar Typ‚Ä¶    185  85   black   dark    brown      NA   male  mascu‚Ä¶ Naboo  
&gt; 10 Cord√©          157  NA   brown   light   brown      NA   fema‚Ä¶ femin‚Ä¶ Naboo  
&gt; 11 Dorm√©          165  NA   brown   light   brown      NA   fema‚Ä¶ femin‚Ä¶ Naboo  
&gt; 12 Dooku          193  80   white   fair    brown     102   male  mascu‚Ä¶ Serenno
&gt; 13 Bail Prest‚Ä¶    191  NA   black   tan     brown      67   male  mascu‚Ä¶ Aldera‚Ä¶
&gt; 14 Jango Fett     183  79   black   tan     brown      66   male  mascu‚Ä¶ Concor‚Ä¶
&gt; 15 Raymus Ant‚Ä¶    188  79   brown   light   brown      NA   male  mascu‚Ä¶ Aldera‚Ä¶
&gt; 16 Poe Dameron     NA  NA   brown   light   brown      NA   male  mascu‚Ä¶ &lt;NA&gt;   
&gt; 17 Padm√© Amid‚Ä¶    165  45   brown   light   brown      46   fema‚Ä¶ femin‚Ä¶ Naboo  
&gt; # ‚Ä¶ with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¬π‚Äãhair_color, ¬≤‚Äãskin_color,
&gt; #   ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 2]



```r
starwars %&gt;%
  slice_max(birth_year, n = 3)
```

```
&gt; # A tibble: 3 √ó 14
&gt;   name         height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Yoda             66    17 white   green   brown       896 male  mascu‚Ä¶ &lt;NA&gt;   
&gt; 2 Jabba Desil‚Ä¶    175  1358 &lt;NA&gt;    green-‚Ä¶ orange      600 herm‚Ä¶ mascu‚Ä¶ Nal Hu‚Ä¶
&gt; 3 Chewbacca       228   112 brown   unknown blue        200 male  mascu‚Ä¶ Kashyy‚Ä¶
&gt; # ‚Ä¶ with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¬π‚Äãhair_color, ¬≤‚Äãskin_color,
&gt; #   ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 3]




```r
starwars %&gt;%
  slice_min(height, n = 5)
```

```
&gt; # A tibble: 6 √ó 14
&gt;   name         height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Yoda             66    17 white   green   brown       896 male  mascu‚Ä¶ &lt;NA&gt;   
&gt; 2 Ratts Tyere‚Ä¶     79    15 none    grey, ‚Ä¶ unknown      NA male  mascu‚Ä¶ Aleen ‚Ä¶
&gt; 3 Wicket Syst‚Ä¶     88    20 brown   brown   brown         8 male  mascu‚Ä¶ Endor  
&gt; 4 Dud Bolt         94    45 none    blue, ‚Ä¶ yellow       NA male  mascu‚Ä¶ Vulpter
&gt; 5 R2-D2            96    32 &lt;NA&gt;    white,‚Ä¶ red          33 none  mascu‚Ä¶ Naboo  
&gt; 6 R4-P17           96    NA none    silver‚Ä¶ red, b‚Ä¶      NA none  femin‚Ä¶ &lt;NA&gt;   
&gt; # ‚Ä¶ with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¬π‚Äãhair_color, ¬≤‚Äãskin_color,
&gt; #   ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```
]

]

---

# Ejercicio extra


Veamos un ejercicio extra para comprobar la **potencia y flexibilidad** de `{tidyverse}`, pudiendo hacer muchas cosas en dos l√≠neas de c√≥digo.

&amp;nbsp;

* üìù **Ejercicio extra**: de los personajes que son humanos y miden m√°s de 160 cm, selecciona los 5 m√°s altos, y orden de mayor a menor peso. Devuelve la tabla.


---


# Aleatorio simple: .orange[SLICE_SAMPLE]

El conocido como **.bg-purple_light[muestreo aleatorio simple]** se basa en seleccionar individuos aleatoriamente, de forma que cada uno tenga las mismas probabilidades de ser seleccionado.

.pull-left[


```r
datos %&gt;%
  rebanada_aleatoria(n, probabilidades)
```

]

.pull-right[


```r
starwars %&gt;%
  slice_sample(n = ..., weight_by = ..., replace = ...)
```

]

--

Con`slice_sample(n = ...)` podemos extraer n **.bg-purple_light[registros aleatoriamente]** (a priori equiprobables).




```r
# 3 registros aleatorios
starwars %&gt;% slice_sample(n = 3)
```

```
&gt; # A tibble: 3 √ó 14
&gt;   name         height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Jek Tono Po‚Ä¶    180   110 brown   fair    blue         NA male  mascu‚Ä¶ Bestin‚Ä¶
&gt; 2 Ratts Tyere‚Ä¶     79    15 none    grey, ‚Ä¶ unknown      NA male  mascu‚Ä¶ Aleen ‚Ä¶
&gt; 3 Arvel Crynyd     NA    NA brown   fair    brown        NA male  mascu‚Ä¶ &lt;NA&gt;   
&gt; # ‚Ä¶ with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¬π‚Äãhair_color, ¬≤‚Äãskin_color,
&gt; #   ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```

---

# Aleatorio simple: .orange[SLICE_SAMPLE]

Tambi√©n podremos indicarle la **.bg-purple_light[proporci√≥n]** de datos a samplear (en lugar del n√∫mero) y si queremos que sea con **.bg-purple_light[reemplazamiento]** (que se puedan repetir).


```r
# 5% de registros aleatorios
starwars %&gt;% slice_sample(prop = 0.05, replace = TRUE)
```

```
&gt; # A tibble: 4 √ó 14
&gt;   name        height  mass hair_c‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;   &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 IG-88          200   140 none     metal   red          15 none  mascu‚Ä¶ &lt;NA&gt;   
&gt; 2 Tion Medon     206    80 none     grey    black        NA male  mascu‚Ä¶ Utapau 
&gt; 3 Poe Dameron     NA    NA brown    light   brown        NA male  mascu‚Ä¶ &lt;NA&gt;   
&gt; 4 Nien Nunb      160    68 none     grey    black        NA male  mascu‚Ä¶ Sullust
&gt; # ‚Ä¶ with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¬π‚Äãhair_color, ¬≤‚Äãskin_color,
&gt; #   ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```

---

# Aleatorio simple: .orange[SLICE_SAMPLE]

En `slice_sample()` podemos pasar un **.bg-purple_light[vector de probabilidades]** (no equiprobable). Vamos a forzar que sea muy improbable sacar una fila que no sean las dos primeras


```r
starwars %&gt;% slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```


```
&gt; # A tibble: 2 √ó 9
&gt;   name           height  mass hair_color skin_color eye_c‚Ä¶¬π birth‚Ä¶¬≤ sex   gender
&gt;   &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt; 1 Luke Skywalker    172    77 blond      fair       blue         19 male  mascu‚Ä¶
&gt; 2 C-3PO             167    75 &lt;NA&gt;       gold       yellow      112 none  mascu‚Ä¶
&gt; # ‚Ä¶ with abbreviated variable names ¬π‚Äãeye_color, ¬≤‚Äãbirth_year
```


```r
starwars %&gt;% slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```


```
&gt; # A tibble: 2 √ó 9
&gt;   name           height  mass hair_color skin_color eye_c‚Ä¶¬π birth‚Ä¶¬≤ sex   gender
&gt;   &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt; 1 Luke Skywalker    172    77 blond      fair       blue         19 male  mascu‚Ä¶
&gt; 2 C-3PO             167    75 &lt;NA&gt;       gold       yellow      112 none  mascu‚Ä¶
&gt; # ‚Ä¶ with abbreviated variable names ¬π‚Äãeye_color, ¬≤‚Äãbirth_year
```

---

# Aleatorio .orange[ESTRATIFICADO]

El conocido como **.bg-purple_light[muestreo aleatorio estratificado]** se basa en seleccionar (filtrar) individuos (registros) de forma que la selecci√≥na sea **.bg-purple_light[aleatoria PERO en diferentes estratos]**: crearemos grupos, de forma que **.bg-purple_light[muestreemos un porcentaje similar]** en cada estrato.

--

Para ello, antes del muestreo, usaremos una opci√≥n muy potente de tidyverse: con `group_by()` no modificaremos los datos sino **.bg-purple_light[modificaremos la acci√≥n posterior]**, realiz√°ndose en paralelo en cada grupo o estrato.

.pull-left[


```r
datos %&gt;%
  agrupar(var_grupo1, var_grupo2, ...) %&gt;% 
  rebanada_aleatoria(n, probabilidades) %&gt;% 
  desagrupar()
```

]

.pull-right[


```r
starwars %&gt;%
  group_by(var_grupo1, var_grupo2, ...) %&gt;% 
  slice_sample(n = ..., weight_by = ...) %&gt;% 
  ungroup()
```

]

---

# Aleatorio .orange[ESTRATIFICADO]

Cuando apliquemos `group_by()` es importante entender que **.bg-purple_light[NO MODIFICA los datos]**: nos crea una variable de grupo que **.bg-purple_light[modificar√° las acciones futuras]** que apliquemos, generando una especie de generar **m√∫ltiples subtablas**, y las operaciones aplicadas despu√©s se **.bg-purple_light[aplicar√°n a cada una por separado]**.

---

# Aleatorio .orange[ESTRATIFICADO]

.pull-left[

Por ejemplo, imagina que queremos saber el **.bg-purple_light[n√∫mero de registros por sexo]**: primero **.bg-purple_light[agruparemos]** por la variable `sex`, y despu√©s aplicaremos el **.bg-purple_light[conteo]** con `count()` (realiza la acci√≥n pedida en cada subtabla).


```r
starwars %&gt;%
* group_by(sex) %&gt;%
  count() %&gt;%
* ungroup()
```

```
&gt; # A tibble: 5 √ó 2
&gt;   sex                n
&gt;   &lt;chr&gt;          &lt;int&gt;
&gt; 1 female            16
&gt; 2 hermaphroditic     1
&gt; 3 male              60
&gt; 4 none               6
&gt; 5 &lt;NA&gt;               4
```

**IMPORTANTE**: siempre que agrupes, acu√©rdate de desagrupar con `ungroup()`.

]


.pull-right[

&lt;img src="./img/count_group_1.jpg" width="45%" style="display: block; margin: auto;" /&gt;

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/count_group_2.jpg" alt="Flujo de https://tidydatatutor.com/" width="95%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;


]

---

# Aleatorio .orange[ESTRATIFICADO]


.pull-left[

Podemos **.bg-purple_light[agrupar por variables]**, por ejemplo vamos a agrupar por `sex` y `gender`, y despu√©s aplicaremos `count()` (realiza la acci√≥n en cada subtabla).


```r
starwars %&gt;%
* group_by(sex, gender) %&gt;%
  count() %&gt;%
* ungroup()
```

```
&gt; # A tibble: 6 √ó 3
&gt;   sex            gender        n
&gt;   &lt;chr&gt;          &lt;chr&gt;     &lt;int&gt;
&gt; 1 female         feminine     16
&gt; 2 hermaphroditic masculine     1
&gt; 3 male           masculine    60
&gt; 4 none           feminine      1
&gt; 5 none           masculine     5
&gt; 6 &lt;NA&gt;           &lt;NA&gt;          4
```

**IMPORTANTE**: siempre que agrupes, acu√©rdate de desagrupar con `ungroup()`.

]

.pull-right[

&lt;img src="./img/group_1.jpg" width="150%" style="display: block; margin: auto;" /&gt;

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/group_count.jpg" alt="Flujo de https://tidydatatutor.com/" width="150%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

]

---

# Aleatorio .orange[ESTRATIFICADO]

El **.bg-purple_light[muestreo aleatorio estratificado]** lo podremos realizar con un `slice_sample()` pero antes aplicando un `group_by()` para **.bg-purple_light[seleccionar por estratos]**. 

¬øC√≥mo **.bg-purple_light[muestrear el 50%]** pero tener la **.bg-purple_light[misma proporci√≥n de hombres que de mujeres]** que en los datos originales?

--

Para el ejemplo, filtraremos solo los hombres y mujeres (76 registros)


```r
starwars %&gt;% filter(sex %in% c("female", "male"))
```

---


# Aleatorio .orange[ESTRATIFICADO]

¬øC√≥mo **.bg-purple_light[muestrear el 50%]** pero tener la **.bg-purple_light[misma proporci√≥n de hombres que de mujeres]** que en los datos originales?

F√≠jate que tenemos 38 filas (el 50% de los 76 registros, redondeando hacia abajo) pero...


```r
starwars %&gt;%
  filter(sex %in% c("female", "male")) %&gt;% 
* group_by(sex) %&gt;%
  slice_sample(prop = 0.5) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 38 √ó 14
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Padm√© Amid‚Ä¶    165  45   brown   light   brown        46 fema‚Ä¶ femin‚Ä¶ Naboo  
&gt;  2 Barriss Of‚Ä¶    166  50   black   yellow  blue         40 fema‚Ä¶ femin‚Ä¶ Mirial 
&gt;  3 Zam Wesell     168  55   blonde  fair, ‚Ä¶ yellow       NA fema‚Ä¶ femin‚Ä¶ Zolan  
&gt;  4 Cord√©          157  NA   brown   light   brown        NA fema‚Ä¶ femin‚Ä¶ Naboo  
&gt;  5 Leia Organa    150  49   brown   light   brown        19 fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  6 Taun We        213  NA   none    grey    black        NA fema‚Ä¶ femin‚Ä¶ Kamino 
&gt;  7 Luminara U‚Ä¶    170  56.2 black   yellow  blue         58 fema‚Ä¶ femin‚Ä¶ Mirial 
&gt;  8 Mon Mothma     150  NA   auburn  fair    blue         48 fema‚Ä¶ femin‚Ä¶ Chandr‚Ä¶
&gt;  9 Wat Tambor     193  48   none    green,‚Ä¶ unknown      NA male  mascu‚Ä¶ Skako  
&gt; 10 Ben Quadin‚Ä¶    163  65   none    grey, ‚Ä¶ orange       NA male  mascu‚Ä¶ Tund   
&gt; # ‚Ä¶ with 28 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```


---

# Aleatorio .orange[ESTRATIFICADO]

F√≠jate que seguimos teniendo 38 filas (el 50% de los 76 registros, redondeando hacia abajo) pero...

.pull-left[


```r
starwars %&gt;%
  filter(sex %in% c("female", "male")) %&gt;% 
* group_by(sex) %&gt;%
  slice_sample(prop = 0.5) %&gt;% 
  ungroup() %&gt;% 
  count(sex)
```

```
&gt; # A tibble: 2 √ó 2
&gt;   sex        n
&gt;   &lt;chr&gt;  &lt;int&gt;
&gt; 1 female     8
&gt; 2 male      30
```

]

.pull-right[


```r
starwars %&gt;%
  filter(sex %in% c("female", "male")) %&gt;% 
  count(sex)
```

```
&gt; # A tibble: 2 √ó 2
&gt;   sex        n
&gt;   &lt;chr&gt;  &lt;int&gt;
&gt; 1 female    16
&gt; 2 male      60
```

]

...**.bg-purple_light[asegurando una proporci√≥n similar]** de hombres que de mujeres que en la muestra original

---

# .orange[CONTAR]: group_by() + count()

Aunque lo veremos de nuevo en exploraci√≥n y depuraci√≥n, hemos visto ya como **.bg-purple_light[generar el resumen estad√≠stico]** m√°s sencillo: **.bg-purple_light[contar (frecuencias)]**

.pull-left[


```r
datos %&gt;%
  contar(var1, var2)
```

]

.pull-right[


```r
starwars %&gt;%
  count(var1, var2)
```

]

--

Cuando lo usamos en solitario, `count()` nos devolver√° simplemente el **.bg-purple_light[n√∫mero de registros]**


```r
starwars %&gt;% count()
```

```
&gt; # A tibble: 1 √ó 1
&gt;       n
&gt;   &lt;int&gt;
&gt; 1    87
```

---

# .orange[CONTAR]: group_by() + count()

Sin embargo, cuando lo usamos pas√°ndole como **.bg-purple_light[argumento una o varias variables]**, `count()` nos cuenta lo que se conoce en estad√≠stica como **.bg-purple_light[frecuencias absolutas]**: el n√∫mero de elementos pertenecientes a cada una de las **modalidades**. En nuestro caso, la variable `sex` tiene 4 modalidades: `female, hermaphroditic, male, none`.


```r
*starwars %&gt;% count(sex)
```

```
&gt; # A tibble: 5 √ó 2
&gt;   sex                n
&gt;   &lt;chr&gt;          &lt;int&gt;
&gt; 1 female            16
&gt; 2 hermaphroditic     1
&gt; 3 male              60
&gt; 4 none               6
&gt; 5 &lt;NA&gt;               4
```

---

# .orange[CONTAR]: group_by() + count()


Adem√°s si pasamos **.bg-purple_light[varias variables]** nos calcula una **.bg-purple_light[tabla de contigencia]** con las frecuencias absolutas n-dimensionales


```r
starwars %&gt;% count(sex, gender)
```

```
&gt; # A tibble: 6 √ó 3
&gt;   sex            gender        n
&gt;   &lt;chr&gt;          &lt;chr&gt;     &lt;int&gt;
&gt; 1 female         feminine     16
&gt; 2 hermaphroditic masculine     1
&gt; 3 male           masculine    60
&gt; 4 none           feminine      1
&gt; 5 none           masculine     5
&gt; 6 &lt;NA&gt;           &lt;NA&gt;          4
```

---


# .orange[CONTAR]: group_by() + count()

Adem√°s dentro del `count()` podemos a√±adir `sort = TRUE`, que nos devolver√° el conteo de frecuencias con los **.bg-purple_light[elementos m√°s frecuentes primero]** (sin necesidad de a√±adir un `arrange()` a la tabla de conteo generada).


```r
starwars %&gt;%
  count(sex, sort = TRUE)
```

```
&gt; # A tibble: 5 √ó 2
&gt;   sex                n
&gt;   &lt;chr&gt;          &lt;int&gt;
&gt; 1 male              60
&gt; 2 female            16
&gt; 3 none               6
&gt; 4 &lt;NA&gt;               4
&gt; 5 hermaphroditic     1
```

---

# Ejercicios (group_by() + count())

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: calcula cu√°ntos personajes hay de cada especie de `starwars` haciendo uso de `group_by()` y `count()`. Determina el n√∫mero de especies distintas.

* üìù **Ejercicio 2**: calcula cu√°ntos personajes hay de cada sexo y g√©nero.

* üìù **Ejercicio 3**: tras eliminar ausentes en  `birth_year`, obt√©n la edad m√≠nima y m√°xima por sexo.

* üìù **Ejercicio 4**: obt√©n el personaje m√°s viejo por cada sexo.

* üìù **Ejercicio 5**: selecciona aleatoriamente el 60% de los registros de `starwars` pero manteniendo el reparto original entre humanos y no humanos (recuerda limpiar antes de ausentes, con `filter()` o `drop_na()`)

* üìù **Ejercicio 6**: selecciona aleatoriamente un personaje de cada sexo.

]

.panel[.panel-name[Sol. Ej. 1]


```r
starwars %&gt;% 
  group_by(species) %&gt;% 
  count() %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 38 √ó 2
&gt;    species       n
&gt;    &lt;chr&gt;     &lt;int&gt;
&gt;  1 Aleena        1
&gt;  2 Besalisk      1
&gt;  3 Cerean        1
&gt;  4 Chagrian      1
&gt;  5 Clawdite      1
&gt;  6 Droid         6
&gt;  7 Dug           1
&gt;  8 Ewok          1
&gt;  9 Geonosian     1
&gt; 10 Gungan        3
&gt; # ‚Ä¶ with 28 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```


```r
starwars %&gt;% 
  group_by(species) %&gt;% 
  count() %&gt;% 
  ungroup() %&gt;%
  nrow()
```

```
&gt; [1] 38
```


]

.panel[.panel-name[Sol. Ej. 2]



```r
starwars %&gt;%
  count(sex, gender)
```

```
&gt; # A tibble: 6 √ó 3
&gt;   sex            gender        n
&gt;   &lt;chr&gt;          &lt;chr&gt;     &lt;int&gt;
&gt; 1 female         feminine     16
&gt; 2 hermaphroditic masculine     1
&gt; 3 male           masculine    60
&gt; 4 none           feminine      1
&gt; 5 none           masculine     5
&gt; 6 &lt;NA&gt;           &lt;NA&gt;          4
```


```r
starwars %&gt;%
  group_by(sex, gender) %&gt;% 
  count() %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 6 √ó 3
&gt;   sex            gender        n
&gt;   &lt;chr&gt;          &lt;chr&gt;     &lt;int&gt;
&gt; 1 female         feminine     16
&gt; 2 hermaphroditic masculine     1
&gt; 3 male           masculine    60
&gt; 4 none           feminine      1
&gt; 5 none           masculine     5
&gt; 6 &lt;NA&gt;           &lt;NA&gt;          4
```

]

.panel[.panel-name[Sol. Ej. 3]


```r
starwars %&gt;% 
  drop_na(birth_year) %&gt;% 
  group_by(sex) %&gt;% 
  slice_min(n = 1, birth_year) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 5 √ó 14
&gt;   name         height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Leia Organa     150    49 brown   light   brown        19 fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt; 2 Jabba Desil‚Ä¶    175  1358 &lt;NA&gt;    green-‚Ä¶ orange      600 herm‚Ä¶ mascu‚Ä¶ Nal Hu‚Ä¶
&gt; 3 Wicket Syst‚Ä¶     88    20 brown   brown   brown         8 male  mascu‚Ä¶ Endor  
&gt; 4 IG-88           200   140 none    metal   red          15 none  mascu‚Ä¶ &lt;NA&gt;   
&gt; 5 Quarsh Pana‚Ä¶    183    NA black   dark    brown        62 &lt;NA&gt;  &lt;NA&gt;   Naboo  
&gt; # ‚Ä¶ with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¬π‚Äãhair_color, ¬≤‚Äãskin_color,
&gt; #   ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```

```r
starwars %&gt;% 
  drop_na(birth_year) %&gt;% 
  group_by(sex) %&gt;% 
  slice_max(n = 1, birth_year) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 5 √ó 14
&gt;   name         height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Shmi Skywal‚Ä¶    163    NA black   fair    brown        72 fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt; 2 Jabba Desil‚Ä¶    175  1358 &lt;NA&gt;    green-‚Ä¶ orange      600 herm‚Ä¶ mascu‚Ä¶ Nal Hu‚Ä¶
&gt; 3 Yoda             66    17 white   green   brown       896 male  mascu‚Ä¶ &lt;NA&gt;   
&gt; 4 C-3PO           167    75 &lt;NA&gt;    gold    yellow      112 none  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 5 Quarsh Pana‚Ä¶    183    NA black   dark    brown        62 &lt;NA&gt;  &lt;NA&gt;   Naboo  
&gt; # ‚Ä¶ with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¬π‚Äãhair_color, ¬≤‚Äãskin_color,
&gt; #   ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 4]


```r
starwars %&gt;% 
  group_by(sex) %&gt;% 
  slice_max(n = 1, birth_year) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 5 √ó 14
&gt;   name         height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Shmi Skywal‚Ä¶    163    NA black   fair    brown        72 fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt; 2 Jabba Desil‚Ä¶    175  1358 &lt;NA&gt;    green-‚Ä¶ orange      600 herm‚Ä¶ mascu‚Ä¶ Nal Hu‚Ä¶
&gt; 3 Yoda             66    17 white   green   brown       896 male  mascu‚Ä¶ &lt;NA&gt;   
&gt; 4 C-3PO           167    75 &lt;NA&gt;    gold    yellow      112 none  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 5 Quarsh Pana‚Ä¶    183    NA black   dark    brown        62 &lt;NA&gt;  &lt;NA&gt;   Naboo  
&gt; # ‚Ä¶ with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¬π‚Äãhair_color, ¬≤‚Äãskin_color,
&gt; #   ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 5]


```r
starwars %&gt;% 
  drop_na(species) %&gt;% 
  group_by(species == "Human") %&gt;% 
  slice_sample(prop = 0.6) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 49 √ó 15
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Plo Koon       188    80 none    orange  black        22 male  mascu‚Ä¶ Dorin  
&gt;  2 Gasgano        122    NA none    white,‚Ä¶ black        NA male  mascu‚Ä¶ Troiken
&gt;  3 Greedo         173    74 &lt;NA&gt;    green   black        44 male  mascu‚Ä¶ Rodia  
&gt;  4 Ratts Tyer‚Ä¶     79    15 none    grey, ‚Ä¶ unknown      NA male  mascu‚Ä¶ Aleen ‚Ä¶
&gt;  5 Barriss Of‚Ä¶    166    50 black   yellow  blue         40 fema‚Ä¶ femin‚Ä¶ Mirial 
&gt;  6 Rugor Nass     206    NA none    green   orange       NA male  mascu‚Ä¶ Naboo  
&gt;  7 Watto          137    NA black   blue, ‚Ä¶ yellow       NA male  mascu‚Ä¶ Toydar‚Ä¶
&gt;  8 Shaak Ti       178    57 none    red, b‚Ä¶ black        NA fema‚Ä¶ femin‚Ä¶ Shili  
&gt;  9 Yoda            66    17 white   green   brown       896 male  mascu‚Ä¶ &lt;NA&gt;   
&gt; 10 R5-D4           97    32 &lt;NA&gt;    white,‚Ä¶ red          NA none  mascu‚Ä¶ Tatooi‚Ä¶
&gt; # ‚Ä¶ with 39 more rows, 5 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, `species == "Human"` &lt;lgl&gt;, and
&gt; #   abbreviated variable names ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color,
&gt; #   ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```


]

.panel[.panel-name[Sol. Ej. 6]


```r
starwars %&gt;% 
  group_by(sex) %&gt;% 
  slice_sample(n = 1) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 5 √ó 14
&gt;   name         height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Taun We         213    NA none    grey    black        NA fema‚Ä¶ femin‚Ä¶ Kamino 
&gt; 2 Jabba Desil‚Ä¶    175  1358 &lt;NA&gt;    green-‚Ä¶ orange      600 herm‚Ä¶ mascu‚Ä¶ Nal Hu‚Ä¶
&gt; 3 Lando Calri‚Ä¶    177    79 black   dark    brown        31 male  mascu‚Ä¶ Socorro
&gt; 4 BB8              NA    NA none    none    black        NA none  mascu‚Ä¶ &lt;NA&gt;   
&gt; 5 Sly Moore       178    48 none    pale    white        NA &lt;NA&gt;  &lt;NA&gt;   Umbara 
&gt; # ‚Ä¶ with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¬π‚Äãhair_color, ¬≤‚Äãskin_color,
&gt; #   ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```

]

]

---

# Ejercicio extra

* üìù **Ejercicio extra**

  - Carga la tabla `billboard` del paquete `{tidyr}`.
  - Convierte el dataset a tidydata, ausentes incluidos (deber√≠as obtener 5307 filas y 5 columnas).
  - Extrae la lista de artistas distintos que aparecen en la tabla.
  - Determina el artista que aparece m√°s veces en la lista.
  - Determina el arista y canci√≥n que ha estado m√°s semanas en la lista.
  - Realiza un muestreo extrayendo solo los registros de Enrique Iglesias y The Backstreet Boys.
  - Realiza un muestreo extrayendo los 5 artistas cuya canci√≥n haya estado m√°s veces en el top5.
  - Realiza un muestreo aleatorio estratificado, extrayendo el 60% de los datos manteniendo la proporci√≥n de datos entre las distintas semanas.
  
  

---

class: inverse center middle
name: clase-5

# CLASE 5: primer algoritmo de clasificaci√≥n (knn)

&amp;nbsp;

### [Depuraci√≥n tidyverse](#preproc)

### [Introducci√≥n a la clasificaci√≥n supervisada](#sup-class)

### [Clasificador Bayesiano](#bayes)

### [knn: algoritmo de los k-vecinos m√°s cercanos](#knn)



---

name: preproc

# .orange[ELIMINAR] duplicados: distinct()

Otra opci√≥n es **.bg-purple_light[eliminar filas duplicadas]** con `distinct()`, pas√°ndole como argumentos las variables. Por defecto, solo extrae las columnas en base a las cuales hemos eliminado duplicados. Si queremos que nos **mantenga todas** deberemos explicitarlo con `.keep_all = TRUE`.

.pull-left[


```r
# Elimina filas con igual (color_pelo, color_ojos)
starwars %&gt;% distinct(hair_color, eye_color)
```

```
&gt; # A tibble: 35 √ó 2
&gt;    hair_color    eye_color
&gt;    &lt;chr&gt;         &lt;chr&gt;    
&gt;  1 blond         blue     
&gt;  2 &lt;NA&gt;          yellow   
&gt;  3 &lt;NA&gt;          red      
&gt;  4 none          yellow   
&gt;  5 brown         brown    
&gt;  6 brown, grey   blue     
&gt;  7 brown         blue     
&gt;  8 black         brown    
&gt;  9 auburn, white blue-gray
&gt; 10 auburn, grey  blue     
&gt; # ‚Ä¶ with 25 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

]

.pull-left[


```r
# Elimina filas con igual (color_pelo, color_ojos)
starwars %&gt;% distinct(hair_color, eye_color, .keep_all = TRUE)
```

```
&gt; # A tibble: 35 √ó 14
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa‚Ä¶    172    77 blond   fair    blue       19   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  3 R2-D2           96    32 &lt;NA&gt;    white,‚Ä¶ red        33   none  mascu‚Ä¶ Naboo  
&gt;  4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  5 Leia Organa    150    49 brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  6 Owen Lars      178   120 brown,‚Ä¶ light   blue       52   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  7 Beru White‚Ä¶    165    75 brown   light   blue       47   fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt;  8 Biggs Dark‚Ä¶    183    84 black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  9 Obi-Wan Ke‚Ä¶    182    77 auburn‚Ä¶ fair    blue-g‚Ä¶    57   male  mascu‚Ä¶ Stewjon
&gt; 10 Wilhuff Ta‚Ä¶    180    NA auburn‚Ä¶ fair    blue       64   male  mascu‚Ä¶ Eriadu 
&gt; # ‚Ä¶ with 25 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]
  
---

# .orange[SELECCIONAR] columnas:  select()

.pull-left[


```r
datos %&gt;%
  selecciono(col1, col2, ...)
```

]

.pull-right[


```r
starwars %&gt;%
  select(col1, col2, ...)
```

]

--

La opci√≥n m√°s sencilla para **.bg-purple_light[seleccionar variables]** es `select()`, dando como argumentos los nombres de columnas. Por ejemplo, vamos a seleccionar las variables `names` y `hair_color`


```r
starwars %&gt;%
* select(name, hair_color)
```

```
&gt; # A tibble: 87 √ó 2
&gt;    name               hair_color   
&gt;    &lt;chr&gt;              &lt;chr&gt;        
&gt;  1 Luke Skywalker     blond        
&gt;  2 C-3PO              &lt;NA&gt;         
&gt;  3 R2-D2              &lt;NA&gt;         
&gt;  4 Darth Vader        none         
&gt;  5 Leia Organa        brown        
&gt;  6 Owen Lars          brown, grey  
&gt;  7 Beru Whitesun lars brown        
&gt;  8 R5-D4              &lt;NA&gt;         
&gt;  9 Biggs Darklighter  black        
&gt; 10 Obi-Wan Kenobi     auburn, white
&gt; # ‚Ä¶ with 77 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```


---

# .orange[SELECCIONAR] columnas:  select()

.pull-left[


```r
starwars %&gt;% select(name, hair_color)
```

```
&gt; # A tibble: 87 √ó 2
&gt;    name               hair_color   
&gt;    &lt;chr&gt;              &lt;chr&gt;        
&gt;  1 Luke Skywalker     blond        
&gt;  2 C-3PO              &lt;NA&gt;         
&gt;  3 R2-D2              &lt;NA&gt;         
&gt;  4 Darth Vader        none         
&gt;  5 Leia Organa        brown        
&gt;  6 Owen Lars          brown, grey  
&gt;  7 Beru Whitesun lars brown        
&gt;  8 R5-D4              &lt;NA&gt;         
&gt;  9 Biggs Darklighter  black        
&gt; 10 Obi-Wan Kenobi     auburn, white
&gt; # ‚Ä¶ with 77 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/select1.jpg" alt="Flujo de https://tidydatatutor.com/" width="140%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

]

---

# .orange[SELECCIONAR] columnas:  select()


Como suced√≠a al filtrar, la funci√≥n `select()` es bastante versatil y nos permite:

* Seleccionar **.bg-purple_light[varias variables a la vez]** (concatenando sus nombres).


```r
starwars %&gt;% select(name:skin_color)
```

```
&gt; # A tibble: 87 √ó 5
&gt;    name               height  mass hair_color    skin_color 
&gt;    &lt;chr&gt;               &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;      
&gt;  1 Luke Skywalker        172    77 blond         fair       
&gt;  2 C-3PO                 167    75 &lt;NA&gt;          gold       
&gt;  3 R2-D2                  96    32 &lt;NA&gt;          white, blue
&gt;  4 Darth Vader           202   136 none          white      
&gt;  5 Leia Organa           150    49 brown         light      
&gt;  6 Owen Lars             178   120 brown, grey   light      
&gt;  7 Beru Whitesun lars    165    75 brown         light      
&gt;  8 R5-D4                  97    32 &lt;NA&gt;          white, red 
&gt;  9 Biggs Darklighter     183    84 black         light      
&gt; 10 Obi-Wan Kenobi        182    77 auburn, white fair       
&gt; # ‚Ä¶ with 77 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---

# .orange[SELECCIONAR] columnas:  select()

* **.bg-purple_light[Deseleccionar]** columnas con `-`


```r
starwars %&gt;% select(-c(mass:eye_color), -species, -c(films:starships))
```

```
&gt; # A tibble: 87 √ó 6
&gt;    name               height birth_year sex    gender    homeworld
&gt;    &lt;chr&gt;               &lt;int&gt;      &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;    
&gt;  1 Luke Skywalker        172       19   male   masculine Tatooine 
&gt;  2 C-3PO                 167      112   none   masculine Tatooine 
&gt;  3 R2-D2                  96       33   none   masculine Naboo    
&gt;  4 Darth Vader           202       41.9 male   masculine Tatooine 
&gt;  5 Leia Organa           150       19   female feminine  Alderaan 
&gt;  6 Owen Lars             178       52   male   masculine Tatooine 
&gt;  7 Beru Whitesun lars    165       47   female feminine  Tatooine 
&gt;  8 R5-D4                  97       NA   none   masculine Tatooine 
&gt;  9 Biggs Darklighter     183       24   male   masculine Tatooine 
&gt; 10 Obi-Wan Kenobi        182       57   male   masculine Stewjon  
&gt; # ‚Ä¶ with 77 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---

# .orange[SELECCIONAR] columnas:  select()


* Seleccionar columnas que **.bg-purple_light[comiencen por un prefijo]** (`starts_with()`), **.bg-purple_light[terminen]** con un sufijo (`ends_with()`), **.bg-purple_light[contengan]** un texto (`contains()`) o cumplan una **.bg-purple_light[expresi√≥n regular]** (`matches()`)



```r
# nombre acaba en "color"
starwars %&gt;% select(ends_with("color"))
```

```
&gt; # A tibble: 87 √ó 3
&gt;    hair_color    skin_color  eye_color
&gt;    &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;    
&gt;  1 blond         fair        blue     
&gt;  2 &lt;NA&gt;          gold        yellow   
&gt;  3 &lt;NA&gt;          white, blue red      
&gt;  4 none          white       yellow   
&gt;  5 brown         light       brown    
&gt;  6 brown, grey   light       blue     
&gt;  7 brown         light       blue     
&gt;  8 &lt;NA&gt;          white, red  red      
&gt;  9 black         light       brown    
&gt; 10 auburn, white fair        blue-gray
&gt; # ‚Ä¶ with 77 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---

# .orange[SELECCIONAR] columnas:  select()


* Seleccionar columnas que **.bg-purple_light[comiencen por un prefijo]** (`starts_with()`), **.bg-purple_light[terminen]** con un sufijo (`ends_with()`), **.bg-purple_light[contengan]** un texto (`contains()`) o cumplan una **.bg-purple_light[expresi√≥n regular]** (`matches()`)


```r
# empiezan por new_sp
who %&gt;% select(country, year, starts_with("new_sp"))
```

```
&gt; # A tibble: 7,240 √ó 16
&gt;    country  year new_s‚Ä¶¬π new_s‚Ä¶¬≤ new_s‚Ä¶¬≥ new_s‚Ä¶‚Å¥ new_s‚Ä¶‚Åµ new_s‚Ä¶‚Å∂ new_s‚Ä¶‚Å∑ new_s‚Ä¶‚Å∏
&gt;    &lt;chr&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;
&gt;  1 Afghan‚Ä¶  1980      NA      NA      NA      NA      NA      NA      NA      NA
&gt;  2 Afghan‚Ä¶  1981      NA      NA      NA      NA      NA      NA      NA      NA
&gt;  3 Afghan‚Ä¶  1982      NA      NA      NA      NA      NA      NA      NA      NA
&gt;  4 Afghan‚Ä¶  1983      NA      NA      NA      NA      NA      NA      NA      NA
&gt;  5 Afghan‚Ä¶  1984      NA      NA      NA      NA      NA      NA      NA      NA
&gt;  6 Afghan‚Ä¶  1985      NA      NA      NA      NA      NA      NA      NA      NA
&gt;  7 Afghan‚Ä¶  1986      NA      NA      NA      NA      NA      NA      NA      NA
&gt;  8 Afghan‚Ä¶  1987      NA      NA      NA      NA      NA      NA      NA      NA
&gt;  9 Afghan‚Ä¶  1988      NA      NA      NA      NA      NA      NA      NA      NA
&gt; 10 Afghan‚Ä¶  1989      NA      NA      NA      NA      NA      NA      NA      NA
&gt; # ‚Ä¶ with 7,230 more rows, 6 more variables: new_sp_f1524 &lt;int&gt;,
&gt; #   new_sp_f2534 &lt;int&gt;, new_sp_f3544 &lt;int&gt;, new_sp_f4554 &lt;int&gt;,
&gt; #   new_sp_f5564 &lt;int&gt;, new_sp_f65 &lt;int&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãnew_sp_m014, ¬≤‚Äãnew_sp_m1524, ¬≥‚Äãnew_sp_m2534, ‚Å¥‚Äãnew_sp_m3544, ‚Åµ‚Äãnew_sp_m4554,
&gt; #   ‚Å∂‚Äãnew_sp_m5564, ‚Å∑‚Äãnew_sp_m65, ‚Å∏‚Äãnew_sp_f014
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[SELECCIONAR] columnas:  select()


* Seleccionar columnas que **.bg-purple_light[comiencen por un prefijo]** (`starts_with()`), **.bg-purple_light[terminen]** con un sufijo (`ends_with()`), **.bg-purple_light[contengan]** un texto (`contains()`) o cumplan una **.bg-purple_light[expresi√≥n regular]** (`matches()`)


```r
tb &lt;- tibble("edad" = c(30, 35, 40),
             "color_ojos" = c("azul", "amarillo", "negro"),
             "pelo_color" = c("negro", "marr√≥n", "rubio"))
tb %&gt;% select(contains("color"))
```

```
&gt; # A tibble: 3 √ó 2
&gt;   color_ojos pelo_color
&gt;   &lt;chr&gt;      &lt;chr&gt;     
&gt; 1 azul       negro     
&gt; 2 amarillo   marr√≥n    
&gt; 3 negro      rubio
```


---

# .orange[SELECCIONAR] columnas:  select()

Incluso podemos seleccionar por rango num√©rico si tenemos variables conun prefijo y n√∫meros.


```r
billboard %&gt;% select(num_range("wk", 10:15))
```

```
&gt; # A tibble: 317 √ó 6
&gt;     wk10  wk11  wk12  wk13  wk14  wk15
&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
&gt;  1    NA    NA    NA    NA    NA    NA
&gt;  2    NA    NA    NA    NA    NA    NA
&gt;  3    51    51    51    47    44    38
&gt;  4    61    61    59    61    66    72
&gt;  5    57    64    70    75    76    78
&gt;  6     6     7    22    29    36    47
&gt;  7    NA    NA    NA    NA    NA    NA
&gt;  8    36    37    37    38    49    61
&gt;  9    10     9     8     6     1     2
&gt; 10    59    66    68    61    67    59
&gt; # ‚Ä¶ with 307 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---

# .orange[SELECCIONAR] columnas:  select()

* Seleccionar columnas de un **.bg-purple_light[tipo]** haciendo uso de `where()`.



```r
# Solo columnas num√©ricas o de trexto
starwars %&gt;% select(where(is.numeric) | where(is.character))
```

```
&gt; # A tibble: 87 √ó 11
&gt;    height  mass birth_year name     hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ sex   gender homew‚Ä¶‚Å¥
&gt;     &lt;int&gt; &lt;dbl&gt;      &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1    172    77       19   Luke Sk‚Ä¶ blond   fair    blue    male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  2    167    75      112   C-3PO    &lt;NA&gt;    gold    yellow  none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  3     96    32       33   R2-D2    &lt;NA&gt;    white,‚Ä¶ red     none  mascu‚Ä¶ Naboo  
&gt;  4    202   136       41.9 Darth V‚Ä¶ none    white   yellow  male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  5    150    49       19   Leia Or‚Ä¶ brown   light   brown   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  6    178   120       52   Owen La‚Ä¶ brown,‚Ä¶ light   blue    male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  7    165    75       47   Beru Wh‚Ä¶ brown   light   blue    fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt;  8     97    32       NA   R5-D4    &lt;NA&gt;    white,‚Ä¶ red     none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  9    183    84       24   Biggs D‚Ä¶ black   light   brown   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 10    182    77       57   Obi-Wan‚Ä¶ auburn‚Ä¶ fair    blue-g‚Ä¶ male  mascu‚Ä¶ Stewjon
&gt; # ‚Ä¶ with 77 more rows, 1 more variable: species &lt;chr&gt;, and abbreviated variable
&gt; #   names ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[RECOLOCAR] columnas: relocate()

F√≠jate que con `select()` podr√≠as adem√°s **.bg-purple_light[recolocar columnas]**, ind√≠candole el orden, ayud√°ndote tambi√©n de `everything()`


```r
starwars %&gt;%  select(c(species, name, birth_year, everything()))
```

```
&gt; # A tibble: 87 √ó 14
&gt;    species name        birth‚Ä¶¬π height  mass hair_‚Ä¶¬≤ skin_‚Ä¶¬≥ eye_c‚Ä¶‚Å¥ sex   gender
&gt;    &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Human   Luke Skywa‚Ä¶    19      172    77 blond   fair    blue    male  mascu‚Ä¶
&gt;  2 Droid   C-3PO         112      167    75 &lt;NA&gt;    gold    yellow  none  mascu‚Ä¶
&gt;  3 Droid   R2-D2          33       96    32 &lt;NA&gt;    white,‚Ä¶ red     none  mascu‚Ä¶
&gt;  4 Human   Darth Vader    41.9    202   136 none    white   yellow  male  mascu‚Ä¶
&gt;  5 Human   Leia Organa    19      150    49 brown   light   brown   fema‚Ä¶ femin‚Ä¶
&gt;  6 Human   Owen Lars      52      178   120 brown,‚Ä¶ light   blue    male  mascu‚Ä¶
&gt;  7 Human   Beru White‚Ä¶    47      165    75 brown   light   blue    fema‚Ä¶ femin‚Ä¶
&gt;  8 Droid   R5-D4          NA       97    32 &lt;NA&gt;    white,‚Ä¶ red     none  mascu‚Ä¶
&gt;  9 Human   Biggs Dark‚Ä¶    24      183    84 black   light   brown   male  mascu‚Ä¶
&gt; 10 Human   Obi-Wan Ke‚Ä¶    57      182    77 auburn‚Ä¶ fair    blue-g‚Ä¶ male  mascu‚Ä¶
&gt; # ‚Ä¶ with 77 more rows, 4 more variables: homeworld &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãbirth_year, ¬≤‚Äãhair_color, ¬≥‚Äãskin_color, ‚Å¥‚Äãeye_color
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[RECOLOCAR] columnas: relocate()


.pull-left[


```r
datos %&gt;% 
  recolocar(col1, col2, .after = ...)
```

]

.pull-right[


```r
starwars %&gt;% 
  relocate(col1, col2, .after = ...)
```

]

--

Para facilitar la **.bg-purple_light[recolocaci√≥n]** tenemos una funci√≥n para ello, `relocate()`,  indic√°ndole en `.after` o `.before` detr√°s o delante de qu√© columnas queremos moverlas.


```r
starwars %&gt;% relocate(species, .before = name)
```

```
&gt; # A tibble: 87 √ó 14
&gt;    species name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender
&gt;    &lt;chr&gt;   &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Human   Luke Skywa‚Ä¶    172    77 blond   fair    blue       19   male  mascu‚Ä¶
&gt;  2 Droid   C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu‚Ä¶
&gt;  3 Droid   R2-D2           96    32 &lt;NA&gt;    white,‚Ä¶ red        33   none  mascu‚Ä¶
&gt;  4 Human   Darth Vader    202   136 none    white   yellow     41.9 male  mascu‚Ä¶
&gt;  5 Human   Leia Organa    150    49 brown   light   brown      19   fema‚Ä¶ femin‚Ä¶
&gt;  6 Human   Owen Lars      178   120 brown,‚Ä¶ light   blue       52   male  mascu‚Ä¶
&gt;  7 Human   Beru White‚Ä¶    165    75 brown   light   blue       47   fema‚Ä¶ femin‚Ä¶
&gt;  8 Droid   R5-D4           97    32 &lt;NA&gt;    white,‚Ä¶ red        NA   none  mascu‚Ä¶
&gt;  9 Human   Biggs Dark‚Ä¶    183    84 black   light   brown      24   male  mascu‚Ä¶
&gt; 10 Human   Obi-Wan Ke‚Ä¶    182    77 auburn‚Ä¶ fair    blue-g‚Ä¶    57   male  mascu‚Ä¶
&gt; # ‚Ä¶ with 77 more rows, 4 more variables: homeworld &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[EXTRAER] columnas: pull()


.pull-left[


```r
datos %&gt;% 
  retirar(variable)
```

]

.pull-right[


```r
starwars %&gt;% 
  pull(variable)
```

]

--

.pull-left[

Si observas la salida de los `select()`, sigue siendo una tabla `tibble`, nos preserva la naturaleza de nuestros datos.


```r
starwars %&gt;% select(name)
```

```
&gt; # A tibble: 87 √ó 1
&gt;    name              
&gt;    &lt;chr&gt;             
&gt;  1 Luke Skywalker    
&gt;  2 C-3PO             
&gt;  3 R2-D2             
&gt;  4 Darth Vader       
&gt;  5 Leia Organa       
&gt;  6 Owen Lars         
&gt;  7 Beru Whitesun lars
&gt;  8 R5-D4             
&gt;  9 Biggs Darklighter 
&gt; 10 Obi-Wan Kenobi    
&gt; # ‚Ä¶ with 77 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

]

.pull-right[

A veces no querremos dicha estructura sino **.bg-purple_light[extraer literalmente la columna]**, algo que podemos hacer con `pull()`


```r
starwars %&gt;% pull(name)
```

```
&gt;  [1] "Luke Skywalker"        "C-3PO"                 "R2-D2"                
&gt;  [4] "Darth Vader"           "Leia Organa"           "Owen Lars"            
&gt;  [7] "Beru Whitesun lars"    "R5-D4"                 "Biggs Darklighter"    
&gt; [10] "Obi-Wan Kenobi"        "Anakin Skywalker"      "Wilhuff Tarkin"       
&gt; [13] "Chewbacca"             "Han Solo"              "Greedo"               
&gt; [16] "Jabba Desilijic Tiure" "Wedge Antilles"        "Jek Tono Porkins"     
&gt; [19] "Yoda"                  "Palpatine"             "Boba Fett"            
&gt; [22] "IG-88"                 "Bossk"                 "Lando Calrissian"     
&gt; [25] "Lobot"                 "Ackbar"                "Mon Mothma"           
&gt; [28] "Arvel Crynyd"          "Wicket Systri Warrick" "Nien Nunb"            
&gt; [31] "Qui-Gon Jinn"          "Nute Gunray"           "Finis Valorum"        
&gt; [34] "Jar Jar Binks"         "Roos Tarpals"          "Rugor Nass"           
&gt; [37] "Ric Oli√©"              "Watto"                 "Sebulba"              
&gt; [40] "Quarsh Panaka"         "Shmi Skywalker"        "Darth Maul"           
&gt; [43] "Bib Fortuna"           "Ayla Secura"           "Dud Bolt"             
&gt; [46] "Gasgano"               "Ben Quadinaros"        "Mace Windu"           
&gt; [49] "Ki-Adi-Mundi"          "Kit Fisto"             "Eeth Koth"            
&gt; [52] "Adi Gallia"            "Saesee Tiin"           "Yarael Poof"          
&gt; [55] "Plo Koon"              "Mas Amedda"            "Gregar Typho"         
&gt; [58] "Cord√©"                 "Cliegg Lars"           "Poggle the Lesser"    
&gt; [61] "Luminara Unduli"       "Barriss Offee"         "Dorm√©"                
&gt; [64] "Dooku"                 "Bail Prestor Organa"   "Jango Fett"           
&gt; [67] "Zam Wesell"            "Dexter Jettster"       "Lama Su"              
&gt; [70] "Taun We"               "Jocasta Nu"            "Ratts Tyerell"        
&gt; [73] "R4-P17"                "Wat Tambor"            "San Hill"             
&gt; [76] "Shaak Ti"              "Grievous"              "Tarfful"              
&gt; [79] "Raymus Antilles"       "Sly Moore"             "Tion Medon"           
&gt; [82] "Finn"                  "Rey"                   "Poe Dameron"          
&gt; [85] "BB8"                   "Captain Phasma"        "Padm√© Amidala"
```

]

---

# .orange[RENOMBRAR] columnas: rename()


.pull-left[


```r
datos %&gt;% 
  renombrar(col1, col2)
```

]

.pull-right[


```r
starwars %&gt;% 
  rename(col1, col2)
```

]

--

A veces tambi√©n podemos querer **modificar la ¬´metainformaci√≥n¬ª** de los datos, **.bg-purple_light[renombrando columnas]**. Para ello usaremos la funci√≥n `rename()` poniendo primero el nombre nuevo y luego el antiguo.


```r
starwars %&gt;% 
  rename(nombre = name, altura = height,  peso = mass)
```

```
&gt; # A tibble: 87 √ó 14
&gt;    nombre      altura  peso hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa‚Ä¶    172    77 blond   fair    blue       19   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  3 R2-D2           96    32 &lt;NA&gt;    white,‚Ä¶ red        33   none  mascu‚Ä¶ Naboo  
&gt;  4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  5 Leia Organa    150    49 brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  6 Owen Lars      178   120 brown,‚Ä¶ light   blue       52   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  7 Beru White‚Ä¶    165    75 brown   light   blue       47   fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt;  8 R5-D4           97    32 &lt;NA&gt;    white,‚Ä¶ red        NA   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  9 Biggs Dark‚Ä¶    183    84 black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 10 Obi-Wan Ke‚Ä¶    182    77 auburn‚Ä¶ fair    blue-g‚Ä¶    57   male  mascu‚Ä¶ Stewjon
&gt; # ‚Ä¶ with 77 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```


---

# Ejercicios (columnas)

.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: filtra el conjunto de personajes y qu√©date solo con aquellos que en la variable `height` no tengan un dato ausente.

* üìù **Ejercicio 2**: con los datos obtenidos del filtro anterior, selecciona solo las variables `name`, `height`, as√≠ como todas aquellas variables que CONTENGAN la palabra `color` en su nombre.

* üìù **Ejercicio 3**: con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano

* üìù **Ejercicio 4**: con los datos obtenidos del ejercicio anterior, coloca la variable de color de pelo justo detr√°s de la variable de nombres.

* üìù **Ejercicio 5**: con los datos obtenidos del ejercicio, comprueba cu√°ntas modalidades √∫nicas hay en la variable de color de pelo.

]

.panel[.panel-name[Sol. Ej. 1]

**IMPORTANTE**: todo lo que hagas en la tabla original, si el resultado final no se lo asignas `&lt;-` a otra variable, lo ver√°s en consola pero no se guardar√° en ning√∫n sitio. Lo que no guardes, no existe.



```r
starwars_NA &lt;- starwars %&gt;% drop_na(height)
starwars_NA 
```

```
&gt; # A tibble: 81 √ó 14
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa‚Ä¶    172    77 blond   fair    blue       19   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  3 R2-D2           96    32 &lt;NA&gt;    white,‚Ä¶ red        33   none  mascu‚Ä¶ Naboo  
&gt;  4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  5 Leia Organa    150    49 brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  6 Owen Lars      178   120 brown,‚Ä¶ light   blue       52   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  7 Beru White‚Ä¶    165    75 brown   light   blue       47   fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt;  8 R5-D4           97    32 &lt;NA&gt;    white,‚Ä¶ red        NA   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  9 Biggs Dark‚Ä¶    183    84 black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 10 Obi-Wan Ke‚Ä¶    182    77 auburn‚Ä¶ fair    blue-g‚Ä¶    57   male  mascu‚Ä¶ Stewjon
&gt; # ‚Ä¶ with 71 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 2]


```r
starwars %&gt;%
  drop_na(height) %&gt;%
  select(c(name, height, contains("color")))
```

```
&gt; # A tibble: 81 √ó 5
&gt;    name               height hair_color    skin_color  eye_color
&gt;    &lt;chr&gt;               &lt;int&gt; &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;    
&gt;  1 Luke Skywalker        172 blond         fair        blue     
&gt;  2 C-3PO                 167 &lt;NA&gt;          gold        yellow   
&gt;  3 R2-D2                  96 &lt;NA&gt;          white, blue red      
&gt;  4 Darth Vader           202 none          white       yellow   
&gt;  5 Leia Organa           150 brown         light       brown    
&gt;  6 Owen Lars             178 brown, grey   light       blue     
&gt;  7 Beru Whitesun lars    165 brown         light       blue     
&gt;  8 R5-D4                  97 &lt;NA&gt;          white, red  red      
&gt;  9 Biggs Darklighter     183 black         light       brown    
&gt; 10 Obi-Wan Kenobi        182 auburn, white fair        blue-gray
&gt; # ‚Ä¶ with 71 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

]

.panel[.panel-name[Sol. Ej. 3]



```r
starwars %&gt;%
  drop_na(height) %&gt;%
  select(c(name, height, contains("color"))) %&gt;%
  rename(nombre = name, altura = height,
         color_pelo = hair_color,
         color_piel = skin_color,
         color_ojos = eye_color)
```

```
&gt; # A tibble: 81 √ó 5
&gt;    nombre             altura color_pelo    color_piel  color_ojos
&gt;    &lt;chr&gt;               &lt;int&gt; &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;     
&gt;  1 Luke Skywalker        172 blond         fair        blue      
&gt;  2 C-3PO                 167 &lt;NA&gt;          gold        yellow    
&gt;  3 R2-D2                  96 &lt;NA&gt;          white, blue red       
&gt;  4 Darth Vader           202 none          white       yellow    
&gt;  5 Leia Organa           150 brown         light       brown     
&gt;  6 Owen Lars             178 brown, grey   light       blue      
&gt;  7 Beru Whitesun lars    165 brown         light       blue      
&gt;  8 R5-D4                  97 &lt;NA&gt;          white, red  red       
&gt;  9 Biggs Darklighter     183 black         light       brown     
&gt; 10 Obi-Wan Kenobi        182 auburn, white fair        blue-gray 
&gt; # ‚Ä¶ with 71 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

]

.panel[.panel-name[Sol. Ej. 4]



```r
starwars %&gt;%
  drop_na(height) %&gt;%
  select(c(name, height, contains("color"))) %&gt;%
  rename(nombre = name, altura = height,
         color_pelo = hair_color,
         color_piel = skin_color,
         color_ojos = eye_color) %&gt;%
  relocate(color_pelo, .after = nombre)
```

```
&gt; # A tibble: 81 √ó 5
&gt;    nombre             color_pelo    altura color_piel  color_ojos
&gt;    &lt;chr&gt;              &lt;chr&gt;          &lt;int&gt; &lt;chr&gt;       &lt;chr&gt;     
&gt;  1 Luke Skywalker     blond            172 fair        blue      
&gt;  2 C-3PO              &lt;NA&gt;             167 gold        yellow    
&gt;  3 R2-D2              &lt;NA&gt;              96 white, blue red       
&gt;  4 Darth Vader        none             202 white       yellow    
&gt;  5 Leia Organa        brown            150 light       brown     
&gt;  6 Owen Lars          brown, grey      178 light       blue      
&gt;  7 Beru Whitesun lars brown            165 light       blue      
&gt;  8 R5-D4              &lt;NA&gt;              97 white, red  red       
&gt;  9 Biggs Darklighter  black            183 light       brown     
&gt; 10 Obi-Wan Kenobi     auburn, white    182 fair        blue-gray 
&gt; # ‚Ä¶ with 71 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

]

.panel[.panel-name[Sol. Ej. 5]


```r
starwars %&gt;%
  drop_na(height) %&gt;%
  select(c(name, height, contains("color"))) %&gt;%
  rename(nombre = name, altura = height, color_pelo = hair_color,
         color_piel = skin_color, color_ojos = eye_color) %&gt;%
  relocate(color_pelo, .after = nombre) %&gt;%
  distinct(color_pelo)
```

```
&gt; # A tibble: 12 √ó 1
&gt;    color_pelo   
&gt;    &lt;chr&gt;        
&gt;  1 blond        
&gt;  2 &lt;NA&gt;         
&gt;  3 none         
&gt;  4 brown        
&gt;  5 brown, grey  
&gt;  6 black        
&gt;  7 auburn, white
&gt;  8 auburn, grey 
&gt;  9 white        
&gt; 10 grey         
&gt; 11 auburn       
&gt; 12 blonde
```

**IMPORTANTE**: recuerda que `distinct()` de mantener todas las columnas a√±adiendo `.keep_all = TRUE`.

]

]


---

# Ejercicio extra


Veamos un ejercicio extra para comprobar la **potencia y flexibilidad** de `{tidyverse}`, pudiendo hacer muchas cosas en dos l√≠neas de c√≥digo.

&amp;nbsp;

* üìù **Ejercicio extra**: selecciona solo las variables `name` y aquellas que sean de tipo num√©rico y la variable `homeworld`, y selecciona solo los personajes que no sean humanos y que pesen entre 70 y 90 kg.  Tras ello elimina datos ausentes, y elimina duplicados con el mismo valor en `homeworld`. Tras ello, recoloca las variables para que el orden la primera columna sea `name` y la segunda `birth_year`. Para acabar, cambia el nombre  a castellano de las variables.


---

name: mutate


# .orange[MODIFICAR] columnas: mutate()


.pull-left[


```r
datos %&gt;%
  modificar(nueva_var = ...)
```

]

.pull-right[


```r
starwars %&gt;%
  mutate(nueva_var = ...)
```

]

--

En muchas ocasiones querremos **.bg-purple_light[modificar o crear  variables]**. Para ello tenemos la funci√≥n `mutate()`. Vamos a crear una **nueva variable** `height_m` con la altura en cent√≠metros.


```r
# altura en metros
starwars %&gt;%
* mutate(height_m = height / 100)
```

```
&gt; # A tibble: 87 √ó 15
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa‚Ä¶    172    77 blond   fair    blue       19   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  3 R2-D2           96    32 &lt;NA&gt;    white,‚Ä¶ red        33   none  mascu‚Ä¶ Naboo  
&gt;  4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  5 Leia Organa    150    49 brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  6 Owen Lars      178   120 brown,‚Ä¶ light   blue       52   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  7 Beru White‚Ä¶    165    75 brown   light   blue       47   fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt;  8 R5-D4           97    32 &lt;NA&gt;    white,‚Ä¶ red        NA   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  9 Biggs Dark‚Ä¶    183    84 black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 10 Obi-Wan Ke‚Ä¶    182    77 auburn‚Ä¶ fair    blue-g‚Ä¶    57   male  mascu‚Ä¶ Stewjon
&gt; # ‚Ä¶ with 77 more rows, 5 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, height_m &lt;dbl&gt;, and abbreviated variable
&gt; #   names ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[MODIFICAR] columnas: mutate()



```r
starwars %&gt;% mutate(height_m = height / 100)
```

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/mutate1.jpg" alt="Flujo de https://tidydatatutor.com/" width="90%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

---

# .orange[MODIFICAR] columnas: mutate()

Otra opci√≥n es **.bg-purple_light[quedarnos solo con las modificadas]** (por ejemplo, para ver si hace lo que debe) con `transmute()`


```r
starwars %&gt;%
* transmute(height_m = height / 100)
```

```
&gt; # A tibble: 87 √ó 1
&gt;    height_m
&gt;       &lt;dbl&gt;
&gt;  1     1.72
&gt;  2     1.67
&gt;  3     0.96
&gt;  4     2.02
&gt;  5     1.5 
&gt;  6     1.78
&gt;  7     1.65
&gt;  8     0.97
&gt;  9     1.83
&gt; 10     1.82
&gt; # ‚Ä¶ with 77 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---


# .orange[MODIFICAR] columnas: mutate()

Tambi√©n se pueden aplicar **.bg-purple_light[funciones m√°s complejas]** o incluso **.bg-purple_light[funciones propias]** creadas por nosotros mismos (y varias a la vez).


```r
calculo_IMC &lt;- function(peso, estatura, unidades = "metros") {
  
  estatura &lt;- ifelse(unidades == "metros", estatura, estatura / 100)
  IMC &lt;- peso / (estatura^2)
  
  return(IMC)
}
```

---

# .orange[MODIFICAR] columnas: mutate()

Tambi√©n se pueden aplicar **.bg-purple_light[funciones m√°s complejas]** o incluso **.bg-purple_light[funciones propias]** creadas por nosotros mismos (y varias a la vez).


```r
starwars %&gt;%
  mutate(IMC = calculo_IMC(mass, height, unidades = "cent√≠metros"),
         height_m = height / 100) %&gt;%
  relocate(IMC, height_m, .after = mass)
```

```
&gt; # A tibble: 87 √ó 16
&gt;    name  height  mass   IMC heigh‚Ä¶¬π hair_‚Ä¶¬≤ skin_‚Ä¶¬≥ eye_c‚Ä¶‚Å¥ birth‚Ä¶‚Åµ sex   gender
&gt;    &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Luke‚Ä¶    172    77  26.0    1.72 blond   fair    blue       19   male  mascu‚Ä¶
&gt;  2 C-3PO    167    75  25.4    1.67 &lt;NA&gt;    gold    yellow    112   none  mascu‚Ä¶
&gt;  3 R2-D2     96    32  10.8    0.96 &lt;NA&gt;    white,‚Ä¶ red        33   none  mascu‚Ä¶
&gt;  4 Dart‚Ä¶    202   136  46.0    2.02 none    white   yellow     41.9 male  mascu‚Ä¶
&gt;  5 Leia‚Ä¶    150    49  16.6    1.5  brown   light   brown      19   fema‚Ä¶ femin‚Ä¶
&gt;  6 Owen‚Ä¶    178   120  40.6    1.78 brown,‚Ä¶ light   blue       52   male  mascu‚Ä¶
&gt;  7 Beru‚Ä¶    165    75  25.4    1.65 brown   light   blue       47   fema‚Ä¶ femin‚Ä¶
&gt;  8 R5-D4     97    32  10.8    0.97 &lt;NA&gt;    white,‚Ä¶ red        NA   none  mascu‚Ä¶
&gt;  9 Bigg‚Ä¶    183    84  28.4    1.83 black   light   brown      24   male  mascu‚Ä¶
&gt; 10 Obi-‚Ä¶    182    77  26.0    1.82 auburn‚Ä¶ fair    blue-g‚Ä¶    57   male  mascu‚Ä¶
&gt; # ‚Ä¶ with 77 more rows, 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable
&gt; #   names ¬π‚Äãheight_m, ¬≤‚Äãhair_color, ¬≥‚Äãskin_color, ‚Å¥‚Äãeye_color, ‚Åµ‚Äãbirth_year
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[MODIFICAR] columnas: mutate()

Tambi√©n podemos combinarlo con la funci√≥n `if_else()`, una modificaci√≥n dentro de `{tidyverse}` para hacer un `if-else` vectorizado, que nos puede ayudar a **.bg-purple_light[recategorizaciones sencillas]**.


```r
starwars %&gt;%
  mutate(human = if_else(species == "Human", "Human", "Not Human")) %&gt;% 
  relocate(human, .after = name)
```

```
&gt; # A tibble: 87 √ó 15
&gt;    name  human height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt; &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke‚Ä¶ Human    172    77 blond   fair    blue       19   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  2 C-3PO Not ‚Ä¶    167    75 &lt;NA&gt;    gold    yellow    112   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  3 R2-D2 Not ‚Ä¶     96    32 &lt;NA&gt;    white,‚Ä¶ red        33   none  mascu‚Ä¶ Naboo  
&gt;  4 Dart‚Ä¶ Human    202   136 none    white   yellow     41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  5 Leia‚Ä¶ Human    150    49 brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  6 Owen‚Ä¶ Human    178   120 brown,‚Ä¶ light   blue       52   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  7 Beru‚Ä¶ Human    165    75 brown   light   blue       47   fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt;  8 R5-D4 Not ‚Ä¶     97    32 &lt;NA&gt;    white,‚Ä¶ red        NA   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  9 Bigg‚Ä¶ Human    183    84 black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 10 Obi-‚Ä¶ Human    182    77 auburn‚Ä¶ fair    blue-g‚Ä¶    57   male  mascu‚Ä¶ Stewjon
&gt; # ‚Ä¶ with 77 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```


---

# .orange[RECATEGORIZAR]: case_when()

Para **.bg-purple_light[recategorizaciones m√°s complejas]** tenemos a nuestra disposici√≥n `case_when()`. Supongamos por ejemplo que queremos crear una **categor√≠a en funci√≥n de su altura**.

* Si `height &gt; 180` ‚Äì&gt; ser√°n `"alto"`.
* Si `height &lt;= 180` y `height &gt; 120` ‚Äì&gt; ser√°n `"bajo"`
* Si `height &lt;= 120` y `height &gt; 0` ‚Äì&gt; ser√°n `"enano"`
* Si no se cumple lo anterior ‚Äì&gt; ser√°n `"ausente"`

--


```r
starwars %&gt;% mutate(height = case_when(height &gt; 180 ~ "alto",
                                       height &gt; 120 ~ "bajo",
                                       height &gt; 0 ~ "enano",
                                       TRUE ~ "ausente"))
```

```
&gt; # A tibble: 87 √ó 14
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa‚Ä¶ bajo      77 blond   fair    blue       19   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  2 C-3PO       bajo      75 &lt;NA&gt;    gold    yellow    112   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  3 R2-D2       enano     32 &lt;NA&gt;    white,‚Ä¶ red        33   none  mascu‚Ä¶ Naboo  
&gt;  4 Darth Vader alto     136 none    white   yellow     41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  5 Leia Organa bajo      49 brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  6 Owen Lars   bajo     120 brown,‚Ä¶ light   blue       52   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  7 Beru White‚Ä¶ bajo      75 brown   light   blue       47   fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt;  8 R5-D4       enano     32 &lt;NA&gt;    white,‚Ä¶ red        NA   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  9 Biggs Dark‚Ä¶ alto      84 black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 10 Obi-Wan Ke‚Ä¶ alto      77 auburn‚Ä¶ fair    blue-g‚Ä¶    57   male  mascu‚Ä¶ Stewjon
&gt; # ‚Ä¶ with 77 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[RECATEGORIZAR]: case_when()

Las condiciones de `case_when()` pueden combinar varias variables, c√≥mo por ejemplo:

* Si pesan mucho o miden mucho --&gt; `"large"`
* Si `species == "Droid"` --&gt; `"robot"`
* En caso contrario --&gt; `"other"`


```r
starwars %&gt;%
  mutate(type =
           case_when(height &gt; 200 | mass &gt; 200 ~ "large",
                     species == "Droid" ~ "robot",
                     TRUE ~ "other"))
```

```
&gt; # A tibble: 87 √ó 15
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa‚Ä¶    172    77 blond   fair    blue       19   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  3 R2-D2           96    32 &lt;NA&gt;    white,‚Ä¶ red        33   none  mascu‚Ä¶ Naboo  
&gt;  4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  5 Leia Organa    150    49 brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  6 Owen Lars      178   120 brown,‚Ä¶ light   blue       52   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  7 Beru White‚Ä¶    165    75 brown   light   blue       47   fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt;  8 R5-D4           97    32 &lt;NA&gt;    white,‚Ä¶ red        NA   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  9 Biggs Dark‚Ä¶    183    84 black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 10 Obi-Wan Ke‚Ä¶    182    77 auburn‚Ä¶ fair    blue-g‚Ä¶    57   male  mascu‚Ä¶ Stewjon
&gt; # ‚Ä¶ with 77 more rows, 5 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, type &lt;chr&gt;, and abbreviated variable
&gt; #   names ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# Ejercicios (mutate)


.panelset[
.panel[.panel-name[Ejercicios]


* üìù **Ejercicio 1**: crea tres nuevas columnas que nos digan el n√∫mero de pel√≠culas en las que han salido, el n√∫mero de veh√≠culos y el n√∫mero d naves (pero haciendo uso de mutate()). 

* üìù **Ejercicio 2**: con las 3 columnas creadas, crea una nueva columna llamada `frequency` que nos ponga `almost_all` en personajes que salen en 5 o m√°s pel√≠culas, `many` en personajes que salen en m√°s de 2 pel√≠culas pero en menos de 5 y `some` en personajes que salen 1 o 2 pel√≠culas.

* üìù **Ejercicio 3**: elimina registros con datos ausentes en la variable `birth_year` y filtra solo los 20 personajes m√°s j√≥venes.

* üìù **Ejercicio 4**: selecciona solo las variables num√©ricas y de tipo texto. Define una nueva variable llamada `under_18` que nos recategorice la variable `birth_year`: `TRUE` si es menor de edad y `FALSE` en caso contrario

]

.panel[.panel-name[Sol. Ej. 1]


```r
starwars_nueva &lt;- 
  starwars %&gt;%
  mutate(n_films = films %&gt;% map_int(length),
         n_vehicles = vehicles %&gt;% map_int(length),
         n_starships = starships %&gt;% map_int(length))
starwars_nueva
```

```
&gt; # A tibble: 87 √ó 17
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa‚Ä¶    172    77 blond   fair    blue       19   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  3 R2-D2           96    32 &lt;NA&gt;    white,‚Ä¶ red        33   none  mascu‚Ä¶ Naboo  
&gt;  4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  5 Leia Organa    150    49 brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  6 Owen Lars      178   120 brown,‚Ä¶ light   blue       52   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  7 Beru White‚Ä¶    165    75 brown   light   blue       47   fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt;  8 R5-D4           97    32 &lt;NA&gt;    white,‚Ä¶ red        NA   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  9 Biggs Dark‚Ä¶    183    84 black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 10 Obi-Wan Ke‚Ä¶    182    77 auburn‚Ä¶ fair    blue-g‚Ä¶    57   male  mascu‚Ä¶ Stewjon
&gt; # ‚Ä¶ with 77 more rows, 7 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, n_films &lt;int&gt;, n_vehicles &lt;int&gt;,
&gt; #   n_starships &lt;int&gt;, and abbreviated variable names ¬π‚Äãhair_color, ¬≤‚Äãskin_color,
&gt; #   ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 2]


```r
starwars_nueva &lt;-
  starwars_nueva %&gt;%
  mutate(frequency =
           case_when(n_films &gt;= 5 ~ "almost_all",
                     n_films &gt; 2 ~ "many",
                     TRUE ~ "some"))
starwars_nueva
```

```
&gt; # A tibble: 87 √ó 18
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa‚Ä¶    172    77 blond   fair    blue       19   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  3 R2-D2           96    32 &lt;NA&gt;    white,‚Ä¶ red        33   none  mascu‚Ä¶ Naboo  
&gt;  4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  5 Leia Organa    150    49 brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  6 Owen Lars      178   120 brown,‚Ä¶ light   blue       52   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  7 Beru White‚Ä¶    165    75 brown   light   blue       47   fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt;  8 R5-D4           97    32 &lt;NA&gt;    white,‚Ä¶ red        NA   none  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  9 Biggs Dark‚Ä¶    183    84 black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt; 10 Obi-Wan Ke‚Ä¶    182    77 auburn‚Ä¶ fair    blue-g‚Ä¶    57   male  mascu‚Ä¶ Stewjon
&gt; # ‚Ä¶ with 77 more rows, 8 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, n_films &lt;int&gt;, n_vehicles &lt;int&gt;,
&gt; #   n_starships &lt;int&gt;, frequency &lt;chr&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 3]


```r
starwars_nueva &lt;-
  starwars_nueva %&gt;%
  drop_na(birth_year) %&gt;%
  slice_min(n = 20, birth_year)
starwars_nueva
```

```
&gt; # A tibble: 21 √ó 18
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Wicket Sys‚Ä¶     88  20   brown   brown   brown       8   male  mascu‚Ä¶ Endor  
&gt;  2 IG-88          200 140   none    metal   red        15   none  mascu‚Ä¶ &lt;NA&gt;   
&gt;  3 Luke Skywa‚Ä¶    172  77   blond   fair    blue       19   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  4 Leia Organa    150  49   brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  5 Wedge Anti‚Ä¶    170  77   brown   fair    hazel      21   male  mascu‚Ä¶ Corell‚Ä¶
&gt;  6 Plo Koon       188  80   none    orange  black      22   male  mascu‚Ä¶ Dorin  
&gt;  7 Biggs Dark‚Ä¶    183  84   black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  8 Han Solo       180  80   brown   fair    brown      29   male  mascu‚Ä¶ Corell‚Ä¶
&gt;  9 Lando Calr‚Ä¶    177  79   black   dark    brown      31   male  mascu‚Ä¶ Socorro
&gt; 10 Boba Fett      183  78.2 black   fair    brown      31.5 male  mascu‚Ä¶ Kamino 
&gt; # ‚Ä¶ with 11 more rows, 8 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, n_films &lt;int&gt;, n_vehicles &lt;int&gt;,
&gt; #   n_starships &lt;int&gt;, frequency &lt;chr&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 4]


```r
starwars_nueva &lt;-
  starwars_nueva %&gt;%
  select(where(is.numeric) | where(is.character)) %&gt;%
  mutate(under_18 = birth_year &lt; 18)
starwars_nueva
```

```
&gt; # A tibble: 21 √ó 16
&gt;    height  mass birth_year n_films n_veh‚Ä¶¬π n_sta‚Ä¶¬≤ name  hair_‚Ä¶¬≥ skin_‚Ä¶‚Å¥ eye_c‚Ä¶‚Åµ
&gt;     &lt;int&gt; &lt;dbl&gt;      &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  
&gt;  1     88  20          8         1       0       0 Wick‚Ä¶ brown   brown   brown  
&gt;  2    200 140         15         1       0       0 IG-88 none    metal   red    
&gt;  3    172  77         19         5       2       2 Luke‚Ä¶ blond   fair    blue   
&gt;  4    150  49         19         5       1       0 Leia‚Ä¶ brown   light   brown  
&gt;  5    170  77         21         3       1       1 Wedg‚Ä¶ brown   fair    hazel  
&gt;  6    188  80         22         3       0       1 Plo ‚Ä¶ none    orange  black  
&gt;  7    183  84         24         1       0       1 Bigg‚Ä¶ black   light   brown  
&gt;  8    180  80         29         4       0       2 Han ‚Ä¶ brown   fair    brown  
&gt;  9    177  79         31         2       0       1 Land‚Ä¶ black   dark    brown  
&gt; 10    183  78.2       31.5       3       0       1 Boba‚Ä¶ black   fair    brown  
&gt; # ‚Ä¶ with 11 more rows, 6 more variables: sex &lt;chr&gt;, gender &lt;chr&gt;,
&gt; #   homeworld &lt;chr&gt;, species &lt;chr&gt;, frequency &lt;chr&gt;, under_18 &lt;lgl&gt;, and
&gt; #   abbreviated variable names ¬π‚Äãn_vehicles, ¬≤‚Äãn_starships, ¬≥‚Äãhair_color,
&gt; #   ‚Å¥‚Äãskin_color, ‚Åµ‚Äãeye_color
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```


]

]


---


# Ejercicios (mutate)


.panelset[
.panel[.panel-name[Ejercicios]

* üìù **Ejercicio 5**: de la base de datos original, determina el n√∫mero de modalidades que toma la variable `species` (elimina antes registros con ausente en dicha variable). Despu√©s elimina duplicados por dicha variable, dejando el representante m√°s bajito.

* üìù **Ejercicio 6**: sobre la base de datos original, crea una nueva columna llamada `auburn` (cobrizo/caoba) que nos diga `TRUE` si el color de pelo contiene dicha palabra y `FALSE` en caso contrario.

* üìù **Ejercicio 7**: sobre la base de datos original, filtra solo aquellos personajes de la familia `"Skywalker"` o `"Antilles"`, selecciona solo las columnas de `name` y `specie`, y renombra a castellano.


]

.panel[.panel-name[Sol. Ej. 5]


```r
starwars %&gt;%
  drop_na(species) %&gt;%
  distinct(species)
```

```
&gt; # A tibble: 37 √ó 1
&gt;    species       
&gt;    &lt;chr&gt;         
&gt;  1 Human         
&gt;  2 Droid         
&gt;  3 Wookiee       
&gt;  4 Rodian        
&gt;  5 Hutt          
&gt;  6 Yoda's species
&gt;  7 Trandoshan    
&gt;  8 Mon Calamari  
&gt;  9 Ewok          
&gt; 10 Sullustan     
&gt; # ‚Ä¶ with 27 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

```r
starwars %&gt;%
  drop_na(species) %&gt;%
  arrange(height) %&gt;%
  distinct(species, .keep_all = TRUE)
```

```
&gt; # A tibble: 37 √ó 14
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Yoda            66    17 white   green   brown       896 male  mascu‚Ä¶ &lt;NA&gt;   
&gt;  2 Ratts Tyer‚Ä¶     79    15 none    grey, ‚Ä¶ unknown      NA male  mascu‚Ä¶ Aleen ‚Ä¶
&gt;  3 Wicket Sys‚Ä¶     88    20 brown   brown   brown         8 male  mascu‚Ä¶ Endor  
&gt;  4 Dud Bolt        94    45 none    blue, ‚Ä¶ yellow       NA male  mascu‚Ä¶ Vulpter
&gt;  5 R2-D2           96    32 &lt;NA&gt;    white,‚Ä¶ red          33 none  mascu‚Ä¶ Naboo  
&gt;  6 Sebulba        112    40 none    grey, ‚Ä¶ orange       NA male  mascu‚Ä¶ Malast‚Ä¶
&gt;  7 Gasgano        122    NA none    white,‚Ä¶ black        NA male  mascu‚Ä¶ Troiken
&gt;  8 Watto          137    NA black   blue, ‚Ä¶ yellow       NA male  mascu‚Ä¶ Toydar‚Ä¶
&gt;  9 Leia Organa    150    49 brown   light   brown        19 fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt; 10 Nien Nunb      160    68 none    grey    black        NA male  mascu‚Ä¶ Sullust
&gt; # ‚Ä¶ with 27 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 6]


```r
starwars %&gt;%
  drop_na(hair_color) %&gt;%
  mutate(auburn = str_detect(hair_color, "auburn"))
```

```
&gt; # A tibble: 82 √ó 15
&gt;    name        height  mass hair_‚Ä¶¬π skin_‚Ä¶¬≤ eye_c‚Ä¶¬≥ birth‚Ä¶‚Å¥ sex   gender homew‚Ä¶‚Åµ
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa‚Ä¶    172    77 blond   fair    blue       19   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  2 Darth Vader    202   136 none    white   yellow     41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  3 Leia Organa    150    49 brown   light   brown      19   fema‚Ä¶ femin‚Ä¶ Aldera‚Ä¶
&gt;  4 Owen Lars      178   120 brown,‚Ä¶ light   blue       52   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  5 Beru White‚Ä¶    165    75 brown   light   blue       47   fema‚Ä¶ femin‚Ä¶ Tatooi‚Ä¶
&gt;  6 Biggs Dark‚Ä¶    183    84 black   light   brown      24   male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  7 Obi-Wan Ke‚Ä¶    182    77 auburn‚Ä¶ fair    blue-g‚Ä¶    57   male  mascu‚Ä¶ Stewjon
&gt;  8 Anakin Sky‚Ä¶    188    84 blond   fair    blue       41.9 male  mascu‚Ä¶ Tatooi‚Ä¶
&gt;  9 Wilhuff Ta‚Ä¶    180    NA auburn‚Ä¶ fair    blue       64   male  mascu‚Ä¶ Eriadu 
&gt; 10 Chewbacca      228   112 brown   unknown blue      200   male  mascu‚Ä¶ Kashyy‚Ä¶
&gt; # ‚Ä¶ with 72 more rows, 5 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, auburn &lt;lgl&gt;, and abbreviated variable
&gt; #   names ¬π‚Äãhair_color, ¬≤‚Äãskin_color, ¬≥‚Äãeye_color, ‚Å¥‚Äãbirth_year, ‚Åµ‚Äãhomeworld
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 6]


```r
starwars %&gt;%
  filter(str_detect(name, "Skywalker") |
           str_detect(name, "Antilles")) %&gt;%
  select(name, species) %&gt;%
  rename(nombre = name, especie = species)
```

```
&gt; # A tibble: 5 √ó 2
&gt;   nombre           especie
&gt;   &lt;chr&gt;            &lt;chr&gt;  
&gt; 1 Luke Skywalker   Human  
&gt; 2 Anakin Skywalker Human  
&gt; 3 Wedge Antilles   Human  
&gt; 4 Shmi Skywalker   Human  
&gt; 5 Raymus Antilles  Human
```

]
]


---

name: sup-class

# Aprendizaje .green[SUPERVISADO]

.pull-left[

* **.bg-purple_light[Aprendizaje supervisado]**: tendremos dos tipos de variables, la **.bg-orange[variable dependiente (output/target)]** que se quiere predecir/clasificar (con su valor conocido en el conjunto de entrenamiento) y las **.bg-orange[variables independientes (inputs)]** o variables explicativas, que contienen la informaci√≥n disponible.

&amp;nbsp;

Todo lo que veremos en esta asignatura entra dentro de la idea de **aprendizaje supervisado**

]


.pull-right[


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/esquema_supervised.jpg" alt="Extra√≠da de https://realpython.com/knn-python/basics-of-machine-learning" width="110%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://realpython.com/knn-python/basics-of-machine-learning&lt;/p&gt;
&lt;/div&gt;


]

---

# Fundamentos de la .orange[CLASIFICACI√ìN]

Como dec√≠amos en diapositivas pasadas, un problema de **.bg-purple_light[clasificaci√≥n]** constar√° de los siguientes elementos

* Una **.bg-purple_light[variable objetivo]** `\(Y\)` que ser√° **.bg-purple_light[cualitativa]** (o cuantitativa discreta recategorizada).

--

* Dicha variable objetivo podr√° tomar un **.bg-purple_light[n√∫mero finito C de categor√≠as]** denotadas como `\(G = \left\lbrace 1, 2, \ldots, C \right\rbrace\)`).

--

* El **.bg-purple_light[conjunto de variables predictoras]** ser√° denotada como `\(\left(X_1, \ldots, X_p \right)\)` 

--

* Nuestros datos formar√°n una **.bg-purple_light[muestra conjunta]** de tama√±o `\(n\)` denotada como `\(\left\lbrace \left(x_{i, 1},...,x_{i, p}, y_i \right) \right\rbrace_{i=1,\ldots,n}\)`

&amp;nbsp;

--

Si `\(C = 2\)` diremos que es un problema de **.bg-purple_light[clasificaci√≥n binaria]**


üìö Ver ¬´The elements of Statistical Learning¬ª (Hastie et al., 2008): &lt;https://github.com/dadosdelaplace/teaching/blob/main/data_mining/biblio/datamining_hastieetal_2008.pdf&gt;


---

# Objetivo de la .orange[CLASIFICACI√ìN]

Nuestro **.bg-purple_light[objetivo]** primario (no siempre) ser√° conseguir que la mayor parte de etiquetas predichas `\(\hat{y}_i\)` coincidan con su categor√≠a real `\(y_i\)`, siendo la tasa de bien clasificados una de las m√©trias m√°s importantes (no la √∫nica).

&amp;nbsp;

* **.bg-purple_light[Accuracy]** (tasa de bien clasificados): del total de datos de tu partici√≥n, la **.bg-purple_light[proporci√≥n o % de observaciones con una etiqueta correcta]** (al ser supervisado sabemos que est√° bien y que est√° mal).


`$$ACC  = \frac{1}{n} \sum_{i=1}^{n} I(y_i = \hat{y}_i)$$`

A veces nos fijaremos en su complementario, la **.bg-purple_light[tasa de mal clasificados]**, siendo esta la proporci√≥n de individuos mal clasificados.

---

# M√©tricas de .orange[CLASIFICACI√ìN BINARIA]

En la mayor√≠a de ocasiones nuestros problemas ser√°n de **.bg-purple_light[clasificaci√≥n binaria]** (podemos entender las categor√≠as como `\(G = \left\lbrace 0, 1\right\rbrace\)`), ya que todo problema de clasificac√≥n multiclase se puede reducir a un conjunto de problemas binarios. En ese caso tendremos adem√°s un **.bg-purple_light[conjunto de m√©tricas]** basadas en los conceptos de falso negativo/positivo y verdadero negativo/positivo

* **.bg-purple_light[Verdadero positivo (TP)]**: todos aquellos individuos con clasificaci√≥n positiva `\(\hat{y}_i = 1\)` y que efectivamente as√≠ lo eran `\(y_i = 1\)`

* **.bg-purple_light[Falso positivo (FP)]**: todos aquellos individuos con clasificaci√≥n positiva `\(\hat{y}_i = 1\)` pero que no lo eran `\(y_i = 0\)`

--

* **.bg-purple_light[Verdadero negativo (TN)]**: todos aquellos individuos con clasificaci√≥n negativa `\(\hat{y}_i = 0\)` y que efectivamente as√≠ lo eran `\(y_i = 0\)`

* **.bg-purple_light[Falso negativo (FN)]**: todos aquellos individuos con clasificaci√≥n negativa `\(\hat{y}_i = 0\)` pero que no lo eran `\(y_i = 1\)`

---


# M√©tricas de .orange[CLASIFICACI√ìN BINARIA]

.pull-left[

* **.bg-purple_light[Verdadero positivo (TP)]**: individuos con clasificaci√≥n positiva `\(\hat{y}_i = 1\)` y que efectivamente as√≠ lo eran `\(y_i = 1\)`

* **.bg-purple_light[Falso positivo (FP)]**: individuos con clasificaci√≥n positiva `\(\hat{y}_i = 1\)` pero que no lo eran `\(y_i = 0\)`

* **.bg-purple_light[Verdadero negativo (TN)]**: individuos con clasificaci√≥n negativa `\(\hat{y}_i = 0\)` y que efectivamente as√≠ lo eran `\(y_i = 0\)`

* **.bg-purple_light[Falso negativo (FN)]**: individuos con clasificaci√≥n negativa `\(\hat{y}_i = 0\)` pero que no lo eran `\(y_i = 1\)`

]

.pull-right[


&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/contigency_table.jpg" alt="Tabla extra√≠da de wikipedia" width="80%" /&gt;
&lt;p class="caption"&gt;Tabla extra√≠da de wikipedia&lt;/p&gt;
&lt;/div&gt;

]

En el futuro, en la fase de evaluaci√≥n (assess) hablaremos de una herramienta conocida como **.bg-purple_light[curva ROC]**.

---



# M√©tricas de .orange[CLASIFICACI√ìN BINARIA]

En base a dichos conceptos existen otras **.bg-purple_light[m√©tricas habituales]** a tener en cuenta:

* **.bg-purple_light[Accuracy (ACC)]**: definida en el caso binario como `\(ACC = \frac{TP + TN}{TP+TN+FP+FN} = \frac{TP + TN}{n}\)`

--

* **.bg-purple_light[Sensibilidad (TPR)]**: tambi√©n conocida como True Positive Rate o **.bg-purple_light[recall]**, es la proporci√≥n de positivos reales `\(y_i=1\)` que han sido clasificadas como  positivo `\(\hat{y}_i = 1\)`, definida como `\(TPR = \frac{TP}{P}\)` (**.bg-purple_light[probabilidad]** emp√≠rica de **.bg-purple_light[detectar correctamente los positivos]**). Su complementario se conoce como **False Negative Rate (FNR)**.

--

* **.bg-purple_light[Especificidad (TNR)]**: tambi√©n conocida como True Negative Rate, es la proporci√≥n de negativos reales `\(y_i=0\)` que han sido clasificadas como negativos `\(\hat{y}_i = 0\)`, definida como `\(TNR = \frac{TN}{N}\)` (**.bg-purple_light[probabilidad]** emp√≠rica de **.bg-purple_light[detectar correctamente los negativos]**). Su complementario se conoce como **False Positive Rate (FPR)**.

&amp;nbsp;

Desde lo te√≥rico, ambas son maximizables de forma conjunta al 100% (aunque en la pr√°ctica, una mejora en una supondr√° un coste en la otra).

---


# M√©tricas de .orange[CLASIFICACI√ìN BINARIA]

Un ejemplo reciente son las **.bg-purple_light[pruebas de detecci√≥n de covid]**. En el caso de las pruebas PCR comercializadas en Espa√±a

* la **.bg-purple_light[sensibilidad]** era en torno al 80-90%. ¬øQu√© implica el 10-20% restante?

* la **.bg-purple_light[especificidad]** era en torno al 99%. ¬øQu√© implica el 1% restante?


--

&amp;nbsp;

Otras m√©tricas habituales que pueden ayudarnos a tomar decisiones son la **.bg-purple_light[prevalencia]**, definida como  `\(P / (P + N)\)` (la proporci√≥n de positivos en tu poblaci√≥n) y la conocida como **.bg-purple_light[precisi√≥n (PPV)]** o Positive Predictive Value, definida como `\(TP / PP\)` (siendo `\(PP\)` los positivos predichos, del total de clasificados como positivos cuantos son verdaderos positivos)


üìö Ver &lt;https://www.aemps.gob.es/la-aemps/ultima-informacion-de-la-aemps-acerca-del-covid%E2%80%9119/informacion-general-sobre-tests-de-diagnostico-de-covid-19/&gt;

---

name: bayes

# Clasificador .orange[BAYESIANO]

M√°s all√° de la comparaci√≥n que podamos hacer entre distintos m√©todos, ¬øexiste **.bg-purple_light[alg√∫n clasificador de referencia]** contra el que compararnos? La buena noticia es que s√≠ existe, la mala noticia es que en la mayor√≠a de casos no vamos a poder conocerlo.

--

&amp;nbsp;

Dicho clasificador se conoce como **.bg-purple_light[clasificador Bayesiano]**, y es el **.bg-purple_light[clasificador √≥ptimo]** en el sentido de que nos devuelve como clase predicha aquella que sea m√°s probable, haciendo uso de la distribuci√≥n de probabilidad te√≥rica de nuestros datos (algo que normalmente no conoceremos).


`$$\hat{y_i} = j \quad \text{si} \quad  P(Y = j | X = \left(x_{i,1}, \ldots, x_{i,p} \right) =  \max_{g \in G} P(Y = g | X = \left(x_{i,1}, \ldots, x_{i,p} \right)$$`

&amp;nbsp;

En el **.bg-purple_light[caso binario]**, se asignar√° la clase 1 si `\(P(Y = 1|X) &gt; 0.5\)`, y la clase 0 en otro
caso.


---

# Clasificador .orange[BAYESIANO]

.pull-left[

F√≠jate que el criterio √≥ptimo no es seguramente el perfecto, ni el que mejor tasa de bien clasificados proporcione: es aquel que es capaz de entender los patrones de los datos. El **.bg-purple_light[clasificador Bayesiano solo es posible si conocemos la distribuci√≥n conjunta]** de probabilidad (algo que por desgracia, no suele ser).

]

.pull-right[


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/bayes_rule.jpg" alt="Hastie et al. (2008)" width="99%" /&gt;
&lt;p class="caption"&gt;Hastie et al. (2008)&lt;/p&gt;
&lt;/div&gt;

]

---


name: knn

# Algoritmo .orange[KNN]: k-vecinos m√°s cercanos

**.bg-purple_light[Motivaci√≥n]**: imagina que quieres dedicir si vas al cine para ver o no una pel√≠cula. **.bg-purple_light[¬øQu√© proceso seguir√≠as?]**


--

Parece l√≥gico que el proceso sea **.bg-purple_light[considerar opiniones]** de tu entorno y/o de las cr√≠ticas que puedas buscar en internet. **.bg-purple_light[¬øQu√© decisiones tomar√≠as? ¬øC√≥mo ¬´algoritmizar√≠as¬ª el proceso?]**

--

1. **.bg-purple_light[N√∫mero de vecinos]**: decidir el n√∫mero `\(k\)` de opiniones (**.bg-purple_light[k-vecinos]**) que vas a tomar cuenta (no puedes preguntar a todo el mundo ni leer todas las cr√≠ticas, pero tampoco fiarte de una sola persona).

--

2. **.bg-purple_light[¬øQu√© es ¬´entorno cercano¬ª?]** Tendremos que decidir qui√©n entra y qui√©n no en nuestro entorno m√°s cercano. ¬øCu√°l es la definici√≥n de cercano? Deberemos definir el **.bg-purple_light[concepto de cercan√≠a con una distancia]** que nos permita decidir los **.bg-purple_light[k-vecinos m√°s cercanos]**

--

3. **.bg-purple_light[Ponderaci√≥n]**: deberemos por √∫ltimo decidir si **.bg-purple_light[todas las opiniones valen lo mismo o no]**. ¬øVale lo mismo la opini√≥n de alguien muy af√≠n a ti que la de Boyero (cr√≠tico de cine)? ¬øTe f√≠as igual
de todas ellas? Deberemos decidir si estas distancias son **.bg-purple_light[ponderadas]**.

---

# Algoritmo .orange[KNN]

Tu decisi√≥n final ser√° por tanto aquella **.bg-purple_light[opini√≥n mayoritaria (moda)]** de las opiniones de tus **.bg-purple_light[k-vecinos]** **.bg-orange[m√°s cercanos]**, una vez que dichas opiniones han sido o no **.bg-green_light[ponderadas]**: 

* **.bg-purple_light[Sin poderar]**: para cada  individuo, su clasificaci√≥n ser√° asignada como la **.bg-purple_light[moda de sus k-vecinos]** m√°s cercanos.

* **.bg-purple_light[Con ponderaci√≥n]**: para cada  individuo, su clasificaci√≥n ser√° asignada como la **.bg-purple_light[moda ponderada de sus k-vecinos]** m√°s cercanos, por ejemplo tomando como peso el inverso de la distancia (cu√°nto m√°s cerca, m√°s pesa).

--

Matem√°ticamente, dado un registro `\(x_i = (x_{i,1},\ldots,x_{i,p})\)`, un n√∫mero `\(k\)` de vecinos y una m√©trica `\(d()\)`, la **.bg-purple_light[probabilidad de pertenencia]** de `\(y_i\)` a la **.bg-purple_light[clase j]** ser√°

`$$P(y_i = j | X = x_i) = \frac{1}{k} \sum_{l=1}^{k} w_l I(y_l = j)$$`

donde `\(x_l\)`, con `\(l=1,...,k\)`, son los k-vecinos m√°s cercanos en funci√≥n de `\(d()\)` y `\(w_l\)` es el peso de v√©cino l-√©simo (pudiendo ser todos uno si no ponderamos, o `\(w_l = \frac{1}{d(x_i, x_l)}\)`)

---


# Algoritmo .orange[KNN]

En el caso de que tengamos un problema de **.bg-purple_light[clasificaci√≥n binaria]**, el problema ser√° mucho m√°s sencillo. Dado un registro `\(x_i = (x_{i,1},\ldots,x_{i,p})\)`, un n√∫mero `\(k\)` de vecinos y una m√©trica `\(d()\)`, la **.bg-purple_light[probabilidad de ser 1]** de `\(y_i\)` ser√°

`$$P(y_i = 1 | X = x_i) = \frac{1}{k} \sum_{l=1}^{k} w_l I(y_l = 1)$$`

y la **.bg-purple_light[probabilidad de ser 0]** de `\(y_i\)` ser√° 
`\(P(y_i = 0 | X = x_i) = 1- P(y_i = 1 | X = x_i)\)` (su complementario).

&amp;nbsp;

La **.bg-purple_light[clase predicha]** ser√° aquella cuya probabilidad sea mayor.

---

# Decisiones KNN: .orange[K] vecinos

.pull-left[

* **.bg-purple_light[Pocos vecinos]**: regla de decisi√≥n extremadamente flexible, creando incluso ¬´islas¬ª de un solo individuo. **.bg-purple_light[Poco sesgo y enorme varianza]** (con un dato nuevo que tuvi√©ramos, ya cambiar√≠a todo).

* **.bg-purple_light[Muchos vecinos]**: regla de decisi√≥n extremadamente r√≠gida. **.bg-purple_light[Mucho sesgo y poca varianza]** (dado que aunque tengamos inputs nuevos, apenas cambiar√°)

]

.pull-right[

&lt;img src="./img/knn_1.jpg" width="70%" style="display: block; margin: auto auto auto 0;" /&gt;

&lt;img src="./img/knn_todos.jpg" width="70%" style="display: block; margin: auto auto auto 0;" /&gt;

]

Ser√° por tanto crucial **.bg-purple_light[probar un rango de vecinos lo suficientemente amplio]** como para encontrar lo √≥ptimo.

---

# Decisiones KNN: .orange[DISTANCIA]

Lo segundo a elegir ser√° la **.bg-purple_light[distancia]** con la que se decidir√° qu√© est√° **.bg-purple_light[cerca o lejos]**.Cuando tenemos **.bg-purple_light[variables num√©ricas]** tenemos dos opciones:

* **.bg-purple_light[Distancias geom√©tricas]**: miden distancias en un plano/espacio/espacio de dimensi√≥n p.

* **.bg-purple_light[Distancias probabil√≠sticas]**: miden distancias en base par√°metros estad√≠sticos como la media o la desviaci√≥n t√≠pica.

---

# Decisiones KNN: .orange[DISTANCIA]

En el caso de las **.bg-purple_light[distancias geom√©tricas]** la m√°s habitual es la conocida como **.bg-purple_light[distancia eucl√≠dea]**, la que usamos de forma habitual.


.pull-left[

En el plano, se define como

`$$d(x, y) = \sqrt{(x_1 - y_1)^2 + (x_2 - y_2)^2}$$`

En el caso general en el que tengamos `\(p\)` predictoras num√©ricas se calcular√° como

`$$d(x, y) = \sqrt{\displaystyle \sum_{j=1}^{p} (x_j - y_j)^2}$$`

]

.pull-right[

&lt;img src="./img/circulo_distancia_euclidea.jpg" width="80%" style="display: block; margin: auto auto auto 0;" /&gt;

C√≠rculo eucl√≠deo: conjunto de puntos a la misma distancia del centro, haciendo uso de la distancia Eucl√≠dea (el radio).

]

---

# Decisiones KNN: .orange[DISTANCIA]


Existen otro tipo de distancias geom√©tricas como la **.bg-purple_light[distancia Manhattan]**, la distancia que usas cuando caminas por la calle (dado que no puedes atravesar manzanas), definida como

`$$d(x, y) = \sqrt{\displaystyle \sum_{j=1}^{p} |x_j - y_j|}$$`


Otra m√©trica es la **.bg-purple_light[distancia de Chebyshev]**
 `\(d(x, y) = \max_i \left(|x_i - y_i| \right)\)`

&lt;img src="./img/minkowski.jpeg" width="40%" style="display: block; margin: auto;" /&gt;


--

¬øC√≥mo se definir√≠an los c√≠rculos (lugares a la misma distancia de un centro) en dichas m√©tricas?

---

# Decisiones KNN: .orange[DISTANCIA]


Todas estas m√©tricas en realidad son casos particulares de las conocidas como **.bg-purple_light[distancias de Minkowski]**, definidas en funci√≥n de un par√°metro `\(r\)`

`$$d(x, y) = \left(\displaystyle \sum_{j=1}^{p} |x_j - y_j|^r\right)^{1/r}$$`

.pull-left[

&lt;img src="./img/minkowski_1.jpg" width="100%" style="display: block; margin: auto auto auto 0;" /&gt;

]


.pull-right[

&lt;img src="./img/minkowski_2.jpg" width="100%" style="display: block; margin: auto auto auto 0;" /&gt;

]

Cuando `\(p=1\)` estamos ante la distancia Manhattan, cuando `\(p=2\)` es la distancia Eucl√≠dea, cuando `\(p=\infty\)` es la distancia de Chebyshev.

---

# .orange[PREPROCESAMIENTO] en KNN

En el caso en el que tengamos **.bg-purple_light[predictoras num√©ricas]** y que decidamos optar por una **.bg-purple_light[distancia geom√©trica]**, en un ejemplo bidimensional, si `\(x_1\)` toma valores entre 10 000 y 100 000 y `\(x_2\)` toma valores entre 0 y 0.001, a la hora de calcular las distancias en realidad la **.bg-purple_light[segunda variable no est√° participando]** en el aprendizaje (ya que es tan peque√±a que da igual lo que valga).

¬øQu√© **.bg-purple_light[preprocesamiento/depuraci√≥n]** de los datos deber√≠amos hacer para que eso no suceda?

--

Cuando usamos las distancias geom√©tricas debemos **.bg-purple_light[reescalar o estandarizar por rango]**, de forma que **.bg-purple_light[todas las variables est√©n en un rango com√∫n]** (por ejempo, `\([0,1]\)`)

`$$\tilde{x}_{i,j} = \frac{x_{i,j} - min(x_j)}{max(x_j) - min(x_j)}$$`

--

&amp;nbsp;

Adem√°s necesitamos **.bg-purple_light[tratar los datos ausentes]** (lo veremos en futuras clases, si imputarles un valor o si eliminarlos).

---

# Decisiones KNN: .orange[DISTANCIA]

En el caso de las **.bg-purple_light[distancias probabil√≠sticas]** la m√°s habitual es la conocida como **.bg-purple_light[distancia de Mahalanobis]**, que tiene en cuenta las caracter√≠sticas probabil√≠sticas de los datos. En el caso **.bg-purple_light[bidimensional (con variables independientes)]**

`$$d(x, y) = \sqrt{\left(\frac{x_1 - y_1}{\sigma_1} \right)^2 + \left(\frac{x_2 - y_2}{\sigma_2} \right)^2}$$`

--

En el caso **.bg-purple_light[multidimensional (con variables independientes)]**

`$$d(x, y) = \sqrt{\displaystyle \sum_{j=1}^{p} \left(\frac{x_j - y_j}{\sigma_j} \right)^2 }$$`

---

# Decisiones KNN: .orange[DISTANCIA]

En el caso general de tener un problema **.bg-purple_light[multidimensional (con variables dependientes)]**, la idea es promediar las observaciones por la **.bg-purple_light[matriz de varianzas y covarianzas]**

`$$d(x, y) = \sqrt{\displaystyle \sum_{j=1}^{p} \left(x_j - y_j \right)^{T} \Sigma^{-1} \left(x_j - y_j \right) }$$`

Donde `\(\Sigma^{-1}\)` es la **.bg-purple_light[matriz de varianzas y covarianzas]** (matriz sim√©trica)

`$$\Sigma = \begin{pmatrix} \sigma_{1}^2 &amp; cov(x_1, x_2) &amp; \ldots &amp; cov(x_1, x_p) \\ cov(x_2, x_1) &amp; \sigma_{2}^2 &amp; \ldots &amp; cov(x_2, x_p) \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ cov(x_p, x_1) &amp; cov(x_p, x_2) &amp; \ldots &amp; \sigma_{p}^2 \end{pmatrix}$$`

---

# .orange[PREPROCESAMIENTO] en KNN

En el caso en el que tengamos **.bg-purple_light[predictoras num√©ricas]** y que decidamos optar por una **.bg-purple_light[distancia probabil√≠stica]**,  ya no ser√° tan importante los valores en s√≠ literales sino las **.bg-purple_light[caracter√≠sticas probabil√≠sticas de nuestras variables]** 

¬øQu√© **.bg-purple_light[preprocesamiento/depuraci√≥n]** de los datos deber√≠amos hacer para que eso no suceda?

--

Cuando usamos las distancias probabil√≠sticas debemos **.bg-purple_light[normalizar o estandarizar por media/varianza)]**, de forma que **.bg-purple_light[todas las variables tengan media 0 y desv. t√≠pica 1]**

`$$\tilde{x}_{i,j} = \frac{x_{i,j} - \overline{x}_j}{\sigma_j}$$`

---

class: inverse center middle
name: clase-6

# CLASE 6: depuraci√≥n para KNN

&amp;nbsp;


### [Factores](#factores)

### [Fase 1: muestreo](#sample-iris)

### [Fase 2: exploraci√≥n](#exploracion-iris)

### [Fase 3: modificaci√≥n/depuraci√≥n](#depuracion-iris)


---

# Primer conjunto: iris

Para empezar con la implementaci√≥n de nuestro primer **.bg-purple_light[algoritmo de clasificaci√≥n]** vamos a usar un conjunto simple y conocido: el iris.


```r
iris &lt;- as_tibble(iris)
iris
```

```
&gt; # A tibble: 150 √ó 5
&gt;    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
&gt;           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
&gt;  1          5.1         3.5          1.4         0.2 setosa 
&gt;  2          4.9         3            1.4         0.2 setosa 
&gt;  3          4.7         3.2          1.3         0.2 setosa 
&gt;  4          4.6         3.1          1.5         0.2 setosa 
&gt;  5          5           3.6          1.4         0.2 setosa 
&gt;  6          5.4         3.9          1.7         0.4 setosa 
&gt;  7          4.6         3.4          1.4         0.3 setosa 
&gt;  8          5           3.4          1.5         0.2 setosa 
&gt;  9          4.4         2.9          1.4         0.2 setosa 
&gt; 10          4.9         3.1          1.5         0.1 setosa 
&gt; # ‚Ä¶ with 140 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---

# .orange[EXPLORACI√ìN] inicial

Dentro de esa metodolog√≠a SEMMMA hay una fase muy importante: la **.bg-purple_light[fase exploratoria]**. Aunque m√°s adelante podemos volver a realizarla, una vez realizado el muestro, lo conveniente ser√≠a una **.bg-purple_light[an√°lisis exploratorio previo]** a los datos en bruto.


--

* `View()`: el primer paso deber√≠a ser ver nuestra tabla para tener una idea preliminar de nuestros datos.


```r
iris %&gt;% View()
```

---

# .orange[EXPLORACI√ìN] inicial


* `glimpse()`: tambi√©n podemos ejecutar algunos comandos que nos permiten saber r√°pidamente el **.bg-purple_light[n√∫mero de registros y variables]** que tenemos, as√≠ como el **.bg-purple_light[tipo de variables]** que tenemos. En nuestro caso tenemos **.bg-purple_light[5 variables]**: 4 variables num√©ricas (cuantitativas continuas) y una **.bg-purple_light[variable categ√≥rica]** (de tipo factor).


```r
dim(iris)
```

```
&gt; [1] 150   5
```

```r
iris %&gt;% glimpse()
```

```
&gt; Rows: 150
&gt; Columns: 5
&gt; $ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.‚Ä¶
&gt; $ Sepal.Width  &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.‚Ä¶
&gt; $ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.‚Ä¶
&gt; $ Petal.Width  &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.‚Ä¶
&gt; $ Species      &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, setosa, s‚Ä¶
```

---

name: factores


# Variables cuali: .orange[FACTORES]

.pull-left[

Las variables cualitativas se conocen en `R` como **.bg-purple_light[factores]**. Y el paquete fundamental para tratarlos es `{forcats}` (del entorno `{tidyverse}`). 

]

.pull-right[

&lt;img src="./img/factors.jpg" width="100%" style="display: block; margin: auto auto auto 0;" /&gt;

]

---

# Variables cuali: .orange[FACTORES]

Este paquete nos permite fijar los **.bg-purple_light[niveles/modalidades]** (guardados internamente como `levels`) que toma una determinada variable categ√≥rica para que no puedan generarse errores. Adem√°s hace que su an√°lisis sea menos costoso computacionalmente a la hora de hacer b√∫squedas y comparativas, d√°ndoles un **.bg-purple_light[tratamiento diferente que a las cadena de texto normales]**.

--

Veamos un ejempo sencillo definiendo una variable `estado` que tome los valores `"sano"`, `"leve"` y `"grave"` de la siguiente manera.


```r
estado &lt;-
  c("leve", "grave", "sano", "sano", "leve", "sano", "sano", "grave",
    "grave", "leve", "grave", "sano", "sano")
estado
```

```
&gt;  [1] "leve"  "grave" "sano"  "sano"  "leve"  "sano"  "sano"  "grave" "grave"
&gt; [10] "leve"  "grave" "sano"  "sano"
```

La variable `estado` actualmente es de **.bg-purple_light[tipo texto]**, de tipo `chr`, algo que podemos comprobar con `class(estado)`.


```r
class(estado)
```

```
&gt; [1] "character"
```

---

# Variables cuali: .orange[FACTORES]


Desde un punto de vista estad√≠stico y computacional, para `R` esta variable ahora mismo ser√≠a equivalente una variable de nombres. Pero estad√≠sticamente **.bg-purple_light[no es lo mismo una variable con nombres]** (que identifican muchas veces el registro) que una variable categ√≥rica como estado que **.bg-purple_light[solo puede tomar esos 3 niveles]**. ¬øC√≥mo **.bg-purple_light[convertir a factor]**? Haciendo uso de la funci√≥n `as_factor()` del paquete `{forcats}`.

--


```r
library(tidyverse)
estado_fct &lt;- tibble(paciente = 1:length(estado),
                     estado = as_factor(estado))
estado_fct
```

```
&gt; # A tibble: 13 √ó 2
&gt;    paciente estado
&gt;       &lt;int&gt; &lt;fct&gt; 
&gt;  1        1 leve  
&gt;  2        2 grave 
&gt;  3        3 sano  
&gt;  4        4 sano  
&gt;  5        5 leve  
&gt;  6        6 sano  
&gt;  7        7 sano  
&gt;  8        8 grave 
&gt;  9        9 grave 
&gt; 10       10 leve  
&gt; 11       11 grave 
&gt; 12       12 sano  
&gt; 13       13 sano
```

---

# Variables cuali: .orange[FACTORES]


No solo ha cambiado la clase de la variable sino que ahora, debajo del valor guardado, nos aparece la frase `Levels: grave leve sano`: son las **.bg-purple_light[modalidades o niveles]** de nuestra cualitativa. Imagina que ese d√≠a en el hospital no tuvi√©semos a **nadie en estado grave**: aunque ese d√≠a nuestra variable no tome dicho valor, el estado `grave` es un **.bg-purple_light[nivel permitido en la base de datos]**, as√≠ que aunque lo eliminemos, por ser un factor, el nivel permanece (no lo tenemos ahora pero es un nivel permitido).



```r
estado_fct %&gt;% 
  filter(estado %in% c("sano", "leve")) %&gt;% 
  pull(estado)
```

```
&gt; [1] leve sano sano leve sano sano leve sano sano
&gt; Levels: leve grave sano
```

---

# Variables cuali: .orange[FACTORES]


Con `factor()` podemos **.bg-purple_light[especificar expl√≠citamente]** los nombres de las modalidades, incluso si son nominales u **.bg-purple_light[ordinales]**


```r
estado_fct &lt;-
  tibble(paciente = 1:length(estado),
         estado = factor(estado, ordered = TRUE))
estado_fct %&gt;% pull(estado)
```

```
&gt;  [1] leve  grave sano  sano  leve  sano  sano  grave grave leve  grave sano 
&gt; [13] sano 
&gt; Levels: grave &lt; leve &lt; sano
```

---

# Variables cuali: .orange[FACTORES]


Con  `levels = ...` podemos indicarle expl√≠citamente el **.bg-purple_light[orden de las modalidades]**


```r
estado_fct &lt;-
  tibble(paciente = 1:length(estado),
         estado = factor(estado,
                         levels = c("sano", "leve", "grave"),
                         ordered = TRUE))
estado_fct %&gt;% pull(estado)
```

```
&gt;  [1] leve  grave sano  sano  leve  sano  sano  grave grave leve  grave sano 
&gt; [13] sano 
&gt; Levels: sano &lt; leve &lt; grave
```



---

# Variables cuali: .orange[FACTORES]


.pull-left[

Si queremos indicarle que **.bg-purple_light[elimine un nivel no usado]** en ese momento (y que queremos excluir de la definici√≥n) podemos hacerlo con `fct_drop()`

]


.pull-right[

&lt;img src="./img/drop_factor.jpg" width="100%" style="display: block; margin: auto auto auto 0;" /&gt;

]


```r
estado_fct %&gt;% 
  filter(estado %in% c("sano", "leve")) %&gt;% 
  mutate(estado = fct_drop(estado)) %&gt;% 
  pull(estado)
```

```
&gt; [1] leve sano sano leve sano sano leve sano sano
&gt; Levels: sano &lt; leve
```

---

# Variables cuali: .orange[FACTORES]

.pull-left[

Al igual que podemos eliminar niveles podemos **.bg-purple_light[ampliar los niveles existentes]** (aunque no existan datos de ese nivel en ese momento) con `fct_expand()`


]


.pull-right[

&lt;img src="./img/factor_expand.jpg" width="100%" style="display: block; margin: auto auto auto 0;" /&gt;

]


```r
estado_fct %&gt;% 
  mutate(estado = fct_expand(estado, c("UCI", "fallecido"))) %&gt;% 
  pull(estado)
```

```
&gt;  [1] leve  grave sano  sano  leve  sano  sano  grave grave leve  grave sano 
&gt; [13] sano 
&gt; Levels: sano &lt; leve &lt; grave &lt; UCI &lt; fallecido
```

---

# Variables cuali: .orange[FACTORES]

.pull-left[

Adem√°s con `fct_explicit_na()` podemos **.bg-purple_light[asignar un nivel a los valores]** para que sea incluido dicho nivel en los an√°lisis y visualizaciones.


]


.pull-right[

&lt;img src="./img/factor_explicit.jpg" width="100%" style="display: block; margin: auto auto auto 0;" /&gt;

]


```r
fct_explicit_na(factor(c("a", "b", NA)))
```

```
&gt; [1] a         b         (Missing)
&gt; Levels: a b (Missing)
```

---

# Variables cuali: .orange[FACTORES]


Incluso una vez definidos podemos **.bg-purple_light[reordenar los n√≠veles]** con `fct_relevel()`



```r
estado_fct_expand &lt;- 
  estado_fct %&gt;% 
  mutate(estado = fct_expand(estado, c("UCI", "fallecido"))) %&gt;% 
  pull(estado)

estado_fct_expand %&gt;%
  fct_relevel(c("fallecido", "leve", "sano",
                "grave", "UCI"))
```

```
&gt;  [1] leve  grave sano  sano  leve  sano  sano  grave grave leve  grave sano 
&gt; [13] sano 
&gt; Levels: fallecido &lt; leve &lt; sano &lt; grave &lt; UCI
```


---

# Variables cuali: .orange[FACTORES]

.pull-left[

Esta forma de trabajar con variables cualitativas nos permite dar una **.bg-purple_light[definici√≥n te√≥rica]** de nuestra base de datos, pudiendo incluso contar valores que a√∫n no existen (pero que podr√≠an), haciendo uso de `fct_count()`

]


.pull-right[

&lt;img src="./img/fct_count.jpg" width="70%" style="display: block; margin: auto auto auto 0;" /&gt;

]


```r
estado_fct %&gt;% 
  mutate(estado = fct_expand(estado, c("UCI", "fallecido"))) %&gt;% 
  pull(estado) %&gt;% 
  fct_count()
```

```
&gt; # A tibble: 5 √ó 2
&gt;   f             n
&gt;   &lt;fct&gt;     &lt;int&gt;
&gt; 1 sano          6
&gt; 2 leve          3
&gt; 3 grave         4
&gt; 4 UCI           0
&gt; 5 fallecido     0
```


---

# Variables cuali: .orange[FACTORES]


Los n√≠veles tambi√©n podemos **.bg-purple_light[ordenarlos por frecuencia]** con `fct_infreq()`


```r
estado_fct %&gt;% 
  mutate(estado = fct_infreq(estado)) %&gt;% 
  pull(estado) %&gt;% 
  fct_count()
```

```
&gt; # A tibble: 3 √ó 2
&gt;   f         n
&gt;   &lt;fct&gt; &lt;int&gt;
&gt; 1 sano      6
&gt; 2 grave     4
&gt; 3 leve      3
```

---

# Variables cuali: .orange[FACTORES]


A veces querremos **.bg-purple_light[agrupar niveles]**, por ejemplo, no permitiendo niveles que **.bg-purple_light[no sucedan un m√≠nimo de veces]** con `fct_lump_min(.., min = ..)` (las observaciones que no lo cumplan ir√°n a un **nivel gen√©rico** llamado `Other`, aunque se puede cambiar con el argumento `other_level`). 

.pull-left[



```r
estado_fct %&gt;% 
  pull(estado) %&gt;% 
  fct_lump_min(min = 4)
```

```
&gt;  [1] Other grave sano  sano  Other sano  sano  grave grave Other grave sano 
&gt; [13] sano 
&gt; Levels: sano &lt; grave &lt; Other
```

]

.pull-right[


```r
estado_fct %&gt;% 
  pull(estado) %&gt;% 
  fct_lump_min(min = 4,
               other_level = "otros")
```

```
&gt;  [1] otros grave sano  sano  otros sano  sano  grave grave otros grave sano 
&gt; [13] sano 
&gt; Levels: sano &lt; grave &lt; otros
```

]

---

# Variables cuali: .orange[FACTORES]


Podemos hacer algo equivalente pero en funci√≥n de su **.bg-purple_light[frecuencia relativa]** con `fct_lump_prop()`.



```r
estado_fct %&gt;% 
  pull(estado) %&gt;% 
  fct_lump_prop(prop = 0.4,
                other_level = "otros")
```

```
&gt;  [1] otros otros sano  sano  otros sano  sano  otros otros otros otros sano 
&gt; [13] sano 
&gt; Levels: sano &lt; otros
```


---

# Variables cuali: .orange[FACTORES]

Con `fct_reorder()` podemos tambi√©n indicar que queremos **.bg-purple_light[ordenar los factores]** en funci√≥n de una funci√≥n aplicada a otra variable.



```r
starwars_factor &lt;- 
  starwars %&gt;% 
  drop_na(height, species) %&gt;% 
  mutate(species =
           fct_lump_min(species, min = 3,
                        other_level = "Otras"))
```

.pull-left[


```r
starwars_factor %&gt;% pull(species)
```

```
&gt;  [1] Human  Droid  Droid  Human  Human  Human  Human  Droid  Human  Human 
&gt; [11] Human  Human  Otras  Human  Otras  Otras  Human  Human  Otras  Human 
&gt; [21] Human  Droid  Otras  Human  Human  Otras  Human  Otras  Otras  Human 
&gt; [31] Otras  Human  Gungan Gungan Gungan Otras  Otras  Human  Otras  Otras 
&gt; [41] Otras  Otras  Otras  Otras  Human  Otras  Otras  Otras  Otras  Otras 
&gt; [51] Otras  Otras  Otras  Human  Human  Human  Otras  Otras  Otras  Human 
&gt; [61] Human  Human  Human  Otras  Otras  Otras  Otras  Human  Otras  Droid 
&gt; [71] Otras  Otras  Otras  Otras  Otras  Human  Otras  Human 
&gt; Levels: Droid Gungan Human Otras
```

]

.pull-right[


```r
starwars_factor %&gt;%
  mutate(species = fct_reorder(species, height, mean)) %&gt;% 
  pull(species)
```

```
&gt;  [1] Human  Droid  Droid  Human  Human  Human  Human  Droid  Human  Human 
&gt; [11] Human  Human  Otras  Human  Otras  Otras  Human  Human  Otras  Human 
&gt; [21] Human  Droid  Otras  Human  Human  Otras  Human  Otras  Otras  Human 
&gt; [31] Otras  Human  Gungan Gungan Gungan Otras  Otras  Human  Otras  Otras 
&gt; [41] Otras  Otras  Otras  Otras  Human  Otras  Otras  Otras  Otras  Otras 
&gt; [51] Otras  Otras  Otras  Human  Human  Human  Otras  Otras  Otras  Human 
&gt; [61] Human  Human  Human  Otras  Otras  Otras  Otras  Human  Otras  Droid 
&gt; [71] Otras  Otras  Otras  Otras  Otras  Human  Otras  Human 
&gt; Levels: Droid Otras Human Gungan
```

]


---

# Ejercicios (factores)


.panelset[
.panel[.panel-name[Ejercicios]

* üìù **Ejercicio 1**: dada la variable `meses` definida debajo (definida como un vector de caracteres), convierte dicha variable a factor (solo eso)


```r
meses &lt;- c("Ene", "Feb", "Mar", "Abr")
```
  
* üìù **Ejercicio 2**:  dada la variable `meses` definida debajo convierte dicha variable a factor pero indicando los niveles de forma correcta.


```r
meses &lt;- c(NA, "Abr", "Ene", "Oct", "Jul", "Ene", "Sep", NA, "Feb", "Dic",
           "Jul", "Mar", "Ene", "Mar", "Feb", "Abr", "May", "Oct", "Sep",  NA,
           "Dic", "Jul", "Nov", "Feb", "Oct", "Jun", "Sep", "Oct", "Oct", "Sep")
```

  
* üìù **Ejercicio 3**: cuenta cuantos valores hay de cada mes pero teniendo en cuenta que son factores (quiz√°s haya niveles sin ser usados y de los que deber√≠a obtener un 0).

]

.panel[.panel-name[Sol. ej. 1]


```r
meses &lt;- c("Ene", "Feb", "Mar", "Abr")
meses_fct &lt;- as_factor(meses)
meses_fct
```

```
&gt; [1] Ene Feb Mar Abr
&gt; Levels: Ene Feb Mar Abr
```



]

.panel[.panel-name[Sol. ej. 2]


```r
meses &lt;- c(NA, "Abr", "Ene", "Oct", "Jul", "Ene", "Sep", NA, "Feb", "Dic",
           "Jul", "Mar", "Ene", "Mar", "Feb", "Abr", "May", "Oct", "Sep",  NA,
           "Dic", "Jul", "Nov", "Feb", "Oct", "Jun", "Sep", "Oct", "Oct", "Sep")

# Orden de niveles correcto e incluimos agosto aunque no haya
meses_fct &lt;-
  factor(meses,
         levels = c("Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"))
meses_fct
```

```
&gt;  [1] &lt;NA&gt; Abr  Ene  Oct  Jul  Ene  Sep  &lt;NA&gt; Feb  Dic  Jul  Mar  Ene  Mar  Feb 
&gt; [16] Abr  May  Oct  Sep  &lt;NA&gt; Dic  Jul  Nov  Feb  Oct  Jun  Sep  Oct  Oct  Sep 
&gt; Levels: Ene Feb Mar Abr May Jun Jul Ago Sep Oct Nov Dic
```

]

.panel[.panel-name[Sol. ej. 3]


```r
meses_fct %&gt;% fct_count()
```

```
&gt; # A tibble: 13 √ó 2
&gt;    f         n
&gt;    &lt;fct&gt; &lt;int&gt;
&gt;  1 Ene       3
&gt;  2 Feb       3
&gt;  3 Mar       2
&gt;  4 Abr       2
&gt;  5 May       1
&gt;  6 Jun       1
&gt;  7 Jul       3
&gt;  8 Ago       0
&gt;  9 Sep       4
&gt; 10 Oct       5
&gt; 11 Nov       1
&gt; 12 Dic       2
&gt; 13 &lt;NA&gt;      3
```

]

]

---

# Ejercicios (factores)


.panelset[
.panel[.panel-name[Ejercicios]

* üìù **Ejercicio 4**: dado que hay ausentes, indica que los ausentes sea un decimotercer nivel etiquetado como "ausente".

* üìù **Ejercicio 5**: elimina los niveles no usados.

* üìù **Ejercicio 6**: ordena los niveles por frecuencia de aparici√≥n.
  
* üìù **Ejercicio 7**:  agrupa niveles de forma que todo nivel que no aparezca al menos el 7% de las veces se agrupe en un nivel llamado "otros meses"
]

.panel[.panel-name[Sol. ej. 4]


```r
meses_fct &lt;- 
  meses_fct %&gt;%
  fct_explicit_na(na_level = "ausente")
meses_fct
```

```
&gt;  [1] ausente Abr     Ene     Oct     Jul     Ene     Sep     ausente Feb    
&gt; [10] Dic     Jul     Mar     Ene     Mar     Feb     Abr     May     Oct    
&gt; [19] Sep     ausente Dic     Jul     Nov     Feb     Oct     Jun     Sep    
&gt; [28] Oct     Oct     Sep    
&gt; Levels: Ene Feb Mar Abr May Jun Jul Ago Sep Oct Nov Dic ausente
```

]

.panel[.panel-name[Sol. ej. 4]


```r
meses_fct &lt;- 
  meses_fct %&gt;%
  fct_drop()
meses_fct
```

```
&gt;  [1] ausente Abr     Ene     Oct     Jul     Ene     Sep     ausente Feb    
&gt; [10] Dic     Jul     Mar     Ene     Mar     Feb     Abr     May     Oct    
&gt; [19] Sep     ausente Dic     Jul     Nov     Feb     Oct     Jun     Sep    
&gt; [28] Oct     Oct     Sep    
&gt; Levels: Ene Feb Mar Abr May Jun Jul Sep Oct Nov Dic ausente
```

]

.panel[.panel-name[Sol. ej. 6]


```r
meses_fct %&gt;% 
  fct_infreq()
```

```
&gt;  [1] ausente Abr     Ene     Oct     Jul     Ene     Sep     ausente Feb    
&gt; [10] Dic     Jul     Mar     Ene     Mar     Feb     Abr     May     Oct    
&gt; [19] Sep     ausente Dic     Jul     Nov     Feb     Oct     Jun     Sep    
&gt; [28] Oct     Oct     Sep    
&gt; Levels: Oct Sep Ene Feb Jul ausente Mar Abr Dic May Jun Nov
```

]

.panel[.panel-name[Sol. ej. 7]


```r
meses_fct &lt;-
  meses_fct %&gt;% 
  fct_lump_prop(prop = 0.07, other_level = "otros")
meses_fct
```

```
&gt;  [1] ausente otros   Ene     Oct     Jul     Ene     Sep     ausente Feb    
&gt; [10] otros   Jul     otros   Ene     otros   Feb     otros   otros   Oct    
&gt; [19] Sep     ausente otros   Jul     otros   Feb     Oct     otros   Sep    
&gt; [28] Oct     Oct     Sep    
&gt; Levels: Ene Feb Jul Sep Oct ausente otros
```

]
]

---

name: exploracion-inicial

# .orange[EXPLORACI√ìN] inicial

* `skim()`: con el paquete `{skimr}` podemos realizar un **.bg-purple_light[primer an√°lisis num√©rico]** muy sencillo, haciendo uso de la funci√≥n `skim()`


```r
library(skimr)
iris %&gt;% skim()
```

---

# ¬øCu√°l es nuestra variable .orange[OBJETIVO]?

Una vez que hemos echado un vistazo a qu√© tenemos (de forma muy muy preliminar), lo primero a hacer en un **.bg-purple_light[problema de clasificaci√≥n]** es determinar **.bg-purple_light[cu√°l es nuestra variable objetivo]**: nuestra variable `\(Y\)` que vamos a clasificar, y que debe ser categ√≥rica.

--

En este caso nuestra variable objetivo ser√° la **.bg-purple_light[variable Species]**: vamos a intentar clasificar las flores, siendo la variable objetivo una variable que puede tomar 3 categor√≠as (algo que podemos ver y resumir con `count()`).


```r
iris %&gt;% count(Species)
```

```
&gt; # A tibble: 3 √ó 2
&gt;   Species        n
&gt;   &lt;fct&gt;      &lt;int&gt;
&gt; 1 setosa        50
&gt; 2 versicolor    50
&gt; 3 virginica     50
```

En nuestro caso la variable objetivo est√° **.bg-purple_light[balanceada]**: tenemos proporciones similares para cada una de las modalidades.

---

name: sample-iris

# Fase 1: .orange[MUESTREO]

La primera fase de la **.bg-purple_light[metodolog√≠a SEMMA]** ser√° decidir si es necesario realizar un **.bg-purple_light[muestreo]** previo (una submuestra de la muestra). ¬øC√≥mo har√≠amos un **.bg-purple_light[muestro aleatorio estratificado del 50%]**, respetando la proporci√≥n de cada clase de la variable objetivo?

--


```r
iris_sample &lt;-
  iris %&gt;% group_by(Species) %&gt;%
  slice_sample(prop = 0.5) %&gt;% 
  ungroup()
iris_sample %&gt;% count(Species)
```

```
&gt; # A tibble: 3 √ó 2
&gt;   Species        n
&gt;   &lt;fct&gt;      &lt;int&gt;
&gt; 1 setosa        25
&gt; 2 versicolor    25
&gt; 3 virginica     25
```

En nuestro caso: ¬øes necesario? No parece dado que tenemos **.bg-purple_light[muy pocas observaciones]**, as√≠ que trabajaremos con la tabla iris original.

---

name: exploracion-iris

# Fase 2: .orange[EXPLORACI√ìN]

Como ya hemos comentado, una **.bg-purple_light[primera fase exploratoria]** la podemos realizar con `skim()` (del paquete `{skimr}`).


```r
library(skimr)
iris %&gt;% skim()
```

&lt;img src="./img/skim.jpg" width="75%" style="display: block; margin: auto;" /&gt;

---

# Fase 2: .orange[EXPLORACI√ìN]

* No parece que tengamos **.bg-purple_light[problemas de codificaci√≥n o rango]**: los valores parecen valores permitidos seg√∫n lo que representa la variable.

--

* No tenemos **.bg-purple_light[datos ausentes]** (no hace falta decidir que hacemos con ellos), ya que `complete_rate` sale en todas 1 (`n_missing` est√° a cero).

--

* A la vista de los peque√±os histogramas y los percentiles, no parece que tengamos **.bg-purple_light[excesivos valores at√≠picos (outliers)]** (al menos muy evidentes, adem√°s la mediana y media se parecen entre s√≠). Quiz√°s la **.bg-purple_light[variable con mayor dispersi√≥n]** sea `Petal.Length`.

--

* Todas las **.bg-purple_light[variables predictoras son num√©ricas]**: recordemos que para aplicar las m√©tricas que conocemos en el KNN **.bg-purple_light[necesitamos que sean num√©ricas]**. En caso contrario nos tocar√≠a **.bg-purple_light[recategorizar]**

---

# Fase 2: .orange[EXPLORACI√ìN]


Otra de las acciones clave ser√° analizar c√≥mo se **.bg-purple_light[comporta la variable objetivo en funci√≥n de los valores de cada variable]**. ¬øLa longitud del s√©palo media es similar en cada especie de planta? ¬øY la anchura del p√©talo? Con ello podremos tener una idea preliminar de la **.bg-purple_light[importancia de las variables]** en la clasificaci√≥n. Para ello combinaremos `group_by()` con `summarise()` (nos construye res√∫menes num√©ricos, con la funci√≥n que le pidamos).

--


```r
iris %&gt;%
  group_by(Species) %&gt;% 
  summarise("mean_long_sep" = mean(Sepal.Length)) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 3 √ó 2
&gt;   Species    mean_long_sep
&gt;   &lt;fct&gt;              &lt;dbl&gt;
&gt; 1 setosa              5.01
&gt; 2 versicolor          5.94
&gt; 3 virginica           6.59
```

---

# Fase 2: .orange[EXPLORACI√ìN]

Podemos hacer varias a la vez usando `across()`: le tendremos que indicar las variables a recorrer, y la funci√≥n a aplicar en todas ellas.


```r
iris %&gt;%
  group_by(Species) %&gt;%
  summarise(mean = across(Sepal.Length:Petal.Width, mean)) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 3 √ó 2
&gt;   Species    mean$Sepal.Length $Sepal.Width $Petal.Length $Petal.Width
&gt;   &lt;fct&gt;                  &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt;
&gt; 1 setosa                  5.01         3.43          1.46        0.246
&gt; 2 versicolor              5.94         2.77          4.26        1.33 
&gt; 3 virginica               6.59         2.97          5.55        2.03
```

---

# Fase 2: .orange[EXPLORACI√ìN]


```r
iris %&gt;%
  group_by(Species) %&gt;%
  summarise(mean = across(Sepal.Length:Petal.Width, mean)) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 3 √ó 2
&gt;   Species    mean$Sepal.Length $Sepal.Width $Petal.Length $Petal.Width
&gt;   &lt;fct&gt;                  &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt;
&gt; 1 setosa                  5.01         3.43          1.46        0.246
&gt; 2 versicolor              5.94         2.77          4.26        1.33 
&gt; 3 virginica               6.59         2.97          5.55        2.03
```

Si nos fijamos en cada una de ellas:

* Las **.bg-purple_light[variables relacionadas con el s√©palo]** no parece que cambien mucho de una especie a otra: seguramente **.bg-purple_light[no sean influyentes]** en nuestra clasificaci√≥n.

* Las **.bg-purple_light[variables relacionadas con el p√©talo]** si parecen ser determinantes ya que la especie setosa tiene valores muy peque√±os. Seguramente lo m√°s complicado sea clasificar entre versicolor y virginica (se diferencia muy ligeramente)


---

# Fase 2: .orange[EXPLORACI√ìN]


Otro de los aspectos a considerar antes de tomar decisiones ser√° **.bg-purple_light[analizar la relaci√≥n entre las variables]**, empezando por la posible relaci√≥n lineal, calculando la matriz de correlaciones con las herramientas de la librer√≠a `{corrr}`. **.bg-red_light[Importante]**: solo podemos pasarle las variables num√©ricas de la tabla.


```r
library(corrr)
correlate(iris %&gt;% select(where(is.numeric)))
```

```
&gt; # A tibble: 4 √ó 5
&gt;   term         Sepal.Length Sepal.Width Petal.Length Petal.Width
&gt;   &lt;chr&gt;               &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
&gt; 1 Sepal.Length       NA          -0.118        0.872       0.818
&gt; 2 Sepal.Width        -0.118      NA           -0.428      -0.366
&gt; 3 Petal.Length        0.872      -0.428       NA           0.963
&gt; 4 Petal.Width         0.818      -0.366        0.963      NA
```

---

# Fase 2: .orange[EXPLORACI√ìN]



```r
library(corrr)
correlate(iris %&gt;% select(where(is.numeric)))
```

```
&gt; # A tibble: 4 √ó 5
&gt;   term         Sepal.Length Sepal.Width Petal.Length Petal.Width
&gt;   &lt;chr&gt;               &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
&gt; 1 Sepal.Length       NA          -0.118        0.872       0.818
&gt; 2 Sepal.Width        -0.118      NA           -0.428      -0.366
&gt; 3 Petal.Length        0.872      -0.428       NA           0.963
&gt; 4 Petal.Width         0.818      -0.366        0.963      NA
```


La matriz de correlaciones ser√° **siempre sim√©trica** y en la diagonal siempre ser√° 1 (podemos indicarle que queremos que nos muestre con el argumento `diagonal = ...`)

---

# Fase 2: .orange[EXPLORACI√ìN]

La matriz de correlaciones ser√° **siempre sim√©trica** y en la diagonal siempre ser√° 1 (podemos indicarle que queremos que nos muestre con el argumento `diagonal = ...`)



```r
correlate(iris %&gt;% select(where(is.numeric)), diagonal = "*")
```

```
&gt; # A tibble: 4 √ó 5
&gt;   term         Sepal.Length       Sepal.Width        Petal.Length      Petal.W‚Ä¶¬π
&gt;   &lt;chr&gt;        &lt;chr&gt;              &lt;chr&gt;              &lt;chr&gt;             &lt;chr&gt;    
&gt; 1 Sepal.Length *                  -0.117569784133002 0.871753775886583 0.817941‚Ä¶
&gt; 2 Sepal.Width  -0.117569784133002 *                  -0.42844010433054 -0.36612‚Ä¶
&gt; 3 Petal.Length 0.871753775886583  -0.42844010433054  *                 0.962865‚Ä¶
&gt; 4 Petal.Width  0.817941126271576  -0.366125932536439 0.962865431402796 *        
&gt; # ‚Ä¶ with abbreviated variable name ¬π‚ÄãPetal.Width
```

---

# Fase 2: .orange[EXPLORACI√ìN]


Tambi√©n podemos mostrarla algo m√°s est√©tica **.bg-red_light[redondeando los valores]** con `fashion()`


```r
correlate(iris %&gt;% select(where(is.numeric))) %&gt;% fashion()
```

```
&gt;           term Sepal.Length Sepal.Width Petal.Length Petal.Width
&gt; 1 Sepal.Length                     -.12          .87         .82
&gt; 2  Sepal.Width         -.12                     -.43        -.37
&gt; 3 Petal.Length          .87        -.43                      .96
&gt; 4  Petal.Width          .82        -.37          .96
```

---

# Fase 2: .orange[EXPLORACI√ìN]


Incluso visualizarla con el paquete `{corrplot}`

.pull-left[


```r
library(corrplot)
cor_matrix &lt;-
  cor(iris %&gt;% select(where(is.numeric)))
corrplot(cor_matrix)
```

]

.pull-right[


&lt;img src="./img/corrplot_1.jpg" width="100%" style="display: block; margin: auto;" /&gt;

]

---

# Fase 2: .orange[EXPLORACI√ìN]



.pull-left[


```r
corrplot(cor_matrix, method = "number")
```

]

.pull-right[


&lt;img src="./img/corrplot_2.jpg" width="100%" style="display: block; margin: auto;" /&gt;

]

---


# Fase 2: .orange[EXPLORACI√ìN]



.pull-left[


```r
corrplot(cor_matrix, method = "color")
```

]

.pull-right[


&lt;img src="./img/corrplot_3.jpg" width="100%" style="display: block; margin: auto;" /&gt;

]

---

# Fase 2: .orange[EXPLORACI√ìN]

.pull-left[


```r
corrplot(cor_matrix, method = "ellipse")
```

]

.pull-right[


&lt;img src="./img/corrplot_4.jpg" width="100%" style="display: block; margin: auto;" /&gt;

]


---

# Fase 2: .orange[EXPLORACI√ìN]


En este caso tenemos dos variables muy correlacionadas: `Petal.Length` y `Petal.Width`, con una correlaci√≥n de casi 1, lo que nos indica que nos van a aportar **.bg-red_light[informaci√≥n redundante]** una de la otra, provocando **.bg-red_light[problemas de colinealidad]**.

--


Nuestro caso ideal ser√≠a aquel en el que todas fuesen independientes (o al menos incorreladas entre s√≠, sin dependencia lineal), para **.bg-purple_light[maximizar la informaci√≥n de los datos]**. Si dos variables nos aportan lo mismo, una seguramente sobre (ya que solo nos va a aportar ruido). Veremos m√°s adelante otras herramientas para cuantificar la dependencia (no solo lineal, y no solo de variables cuanti)

--

Tambi√©n aprenderemos a **.bg-purple_light[visualizar los datos]**, un paso CLAVE en el an√°lisis exploratorio y la depuraci√≥n, pero m√°s adelante.

---

class: inverse center middle
name: clase-7

# CLASE 7: modelizando KNN con tidymodels

&amp;nbsp;

### [Depuraci√≥n iris](#depuracion-iris)

### [Tratamiento de outliers](#outliers)

### [Resumen knn](#knn-steps)

### [¬øQu√© es tidymodels?](#tidymodels)

---

name: depuracion-iris

# Fase 3: .orange[MODIFICACI√ìN/DEPURACI√ìN]

Con la informaci√≥n obtenida de la anterior fase, en la **.bg-purple_light[fase de modificaci√≥n o depuraci√≥n]** es donde tendremos que tomar decisiones para **.bg-purple_light[preparar nuestros datos]** de manera adecuada. Y para ello ser√° **.bg-purple_light[fundamental conocer el algoritmo]** que vamos a aplicar. ¬øQu√© necesitaremos en el caso del KNN?


*  **.bg-purple_light[Tipolog√≠a de las variables]**. ¬øTodas mis variables  **.bg-orange[predictoras son num√©ricas]** o debo? ¬øMi **.bg-orange[variable objetivo]** es categ√≥rica?


*  **.bg-purple_light[Codificaci√≥n de las variables]**. ¬øTodas mis variables tienen un **.bg-orange[rango coherente]** (por ejemplo, que una variable de peso no sea negativa)? ¬øEst√°n **.bg-orange[bien codificadas]**?


* **.bg-purple_light[At√≠picos y ausentes]**. ¬øTengo **.bg-orange[valores at√≠picos (outliers)]**? En caso afirmativo, ¬øc√≥mo tratarlos? Tras tratar at√≠picos, ¬øtengo **.bg-orange[datos ausentes]**?


* **.bg-purple_light[Selecci√≥n de variables]**. ¬øNecesito seleccionar variables? ¬øTengo alguna de varianza cero (es decir, sin informaci√≥n)? ¬øTengo **.bg-orange[problemas de dependencia o colinealidad]**? ¬øPuedo resumir mi info con un conjunto nuevo de variables incorreladas (componentes principales)?


---

# Fase 3: .orange[MODIFICACI√ìN/DEPURACI√ìN]


* **.bg-purple_light[Variables dummy]**. ¬øDebo **.bg-orange[recategorizar]** variables que no sean num√©ricas? Recuerda que el kNN de momento solo sabemos hacerlo con num√©ricas (en caso contrario, veremos como ¬´dummificar¬ª variables: crear 0-1 para tener n√∫meros)


* **.bg-purple_light[A√±adir info]**. ¬øDebo **.bg-orange[crear nuevas variables]** que nos aporte info extra?

* **.bg-purple_light[Normalizar variables]**. ¬øTengo ya mis variables preparadas (tras tratar lo anterior) para la m√©trica que vaya usar (**.bg-orange[estandarizadas]** por rango o **.bg-orange[tipificadas]** por media-varianza)?

  
---

name: outliers

# Tratamiento de .orange[OUTLIERS]

Una de las partes m√°s importantes de la fase de exploraci√≥n y modificaci√≥n es la **.bg-purple_light[detecci√≥n de outliers]**, pudiendo tener diferentes definiciones de valor at√≠pico:

* **.bg-purple_light[At√≠pico respecto a media]**: ser√° un dato muy alejado de la **.bg-purple_light[media de la variable]**. ¬øCu√°nto de alejado? Una definici√≥n habitual es definir un dato at√≠pico como aquel que se aleja de la media `\(k\)` veces la desviaci√≥n t√≠pica (un valor habitual es `\(k = 2.5\)`).

`$$x_i &gt; \overline{x} + k* s_{j} \quad \text{ o bien } \quad x_i &lt; \overline{x} - k *s_{j}$$`

Dicha definici√≥n de at√≠pico solo tendr√° sentido cuando la **.bg-purple_light[media sea representativa]** de tu distribuci√≥n, es decir, siempre y cuando tengamos cierta simetr√≠a (ya que sino, la media al ser poco robusta se perturbar√° f√°cilmente).

---

# Tratamiento de .orange[OUTLIERS]

Para detectarlos usaremos el paquete `{outliers}` y su funci√≥n `scores()`, que nos dar√° en cada caso una **.bg-purple_light["puntuaci√≥n" de cada observaci√≥n]**. En caso de que queramos **.bg-purple_light[detectarlos respecto a la media]**, le indicaremos que `type = "z"`: nos devolver√° precisamente el valor `\(k\)` (si aplicamos valor absoluto), ya que har√° cada observaci√≥n menos la media y la dividir√° entre la desviaci√≥n t√≠pica.



```r
library(outliers)
abs(scores(c(1, -1, 0, 5, 2, 1.5, 0.5, -0.3, 0, 2, 1.7, 0.2, -0.8), type = "z"))
```

```
&gt;  [1] 0.05794825 1.19759725 0.56982450 2.56903925 0.68572100 0.37183463
&gt;  [7] 0.25593812 0.75815632 0.56982450 0.68572100 0.49738918 0.44426995
&gt; [13] 1.07204270
```

De forma que podamos detectar muy f√°cil los outliers en funci√≥n de los estrictos que queramos ser con ese `\(k\)`. El tipo `type = "chisq"` nos hace algo parecido pero elevando las desviaciones al cuadrado y diviendo por la varianza.

---

# Tratamiento de .orange[OUTLIERS]

En el caso de nuestros datos, usaremos `\(k = 2.5\)`, y detectaremos aquellos datos que son outliers para luego pasarlos a un **.bg-purple_light[valor ausente]**.


```r
iris_na_outliers &lt;- 
  iris %&gt;% 
  mutate(Sepal.Width =
           ifelse(abs(scores(Sepal.Width, type = "z")) &gt; 2.5,
                  NA, Sepal.Width))
iris_na_outliers
```

```
&gt; # A tibble: 150 √ó 5
&gt;    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
&gt;           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
&gt;  1          5.1         3.5          1.4         0.2 setosa 
&gt;  2          4.9         3            1.4         0.2 setosa 
&gt;  3          4.7         3.2          1.3         0.2 setosa 
&gt;  4          4.6         3.1          1.5         0.2 setosa 
&gt;  5          5           3.6          1.4         0.2 setosa 
&gt;  6          5.4         3.9          1.7         0.4 setosa 
&gt;  7          4.6         3.4          1.4         0.3 setosa 
&gt;  8          5           3.4          1.5         0.2 setosa 
&gt;  9          4.4         2.9          1.4         0.2 setosa 
&gt; 10          4.9         3.1          1.5         0.1 setosa 
&gt; # ‚Ä¶ with 140 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---

# Tratamiento de .orange[OUTLIERS]


```r
iris_na_outliers %&gt;% filter(is.na(Sepal.Width))
```

```
&gt; # A tibble: 2 √ó 5
&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
&gt; 1          5.7          NA          1.5         0.4 setosa 
&gt; 2          5.5          NA          1.4         0.2 setosa
```

Tras ello tendremos **.bg-purple_light[dos opciones]**: **.bg-orange[eliminar]** dichas observaciones o **.bg-orange[imputar la media]** sin los ausentes (dado que los hemos detectado con la media)


```r
# opci√≥n 1
iris_outliers &lt;-
  iris_na_outliers %&gt;% 
  mutate(Sepal.Width =
           ifelse(is.na(Sepal.Width), mean(Sepal.Width, na.rm = TRUE), Sepal.Width))
```


```r
# opci√≥n 2
iris_outliers &lt;- iris_na_outliers %&gt;% drop_na(Sepal.Width)
```

---

# Tratamiento de .orange[OUTLIERS]

Si queremos hacer esto con varias variables a la vez, tendremos que usar de nuevo `across()`


```r
iris_na_outliers &lt;-
  iris %&gt;% 
  mutate(across(Sepal.Length:Petal.Width,
                function(x) { ifelse(abs(scores(x, type = "z")) &gt; 2.5, NA, Sepal.Length) }))
```

--

Con `if_any()` dentro del `filter()` podemos mostrar todo los registros detectados como outlier en alguna variable.


```r
iris_na_outliers %&gt;% filter(if_any(Sepal.Length:Petal.Width, is.na))
```

```
&gt; # A tibble: 2 √ó 5
&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
&gt; 1          5.7          NA          5.7         5.7 setosa 
&gt; 2          5.5          NA          5.5         5.5 setosa
```

---

# Tratamiento de .orange[OUTLIERS]

Trassu detecci√≥n y an√°lisis podemos o imputarles a todos la media (de la variable en cuesti√≥n) o eliminarlos.


```r
# opci√≥n 1
iris_outliers &lt;-
  iris_na_outliers %&gt;% 
  mutate(across(Sepal.Length:Petal.Width,
                function(x) { ifelse(is.na(x), mean(x, na.rm = TRUE), x) }))
```



```r
# opci√≥n 2
iris_outliers &lt;-
  iris_na_outliers %&gt;% drop_na()
```

---

# Tratamiento de .orange[OUTLIERS]

* **.bg-purple_light[At√≠pico respecto a mediana]**: ser√° un dato muy alejado de la **.bg-purple_light[mediana de la variable]**. ¬øCu√°nto de alejado? Una definici√≥n habitual (conocido como **filtro de Hampel**) es definir un dato at√≠pico como aquel que se aleja de la mediana `\(k\)` veces la mediana de las desviaciones absolutas (conocida como `\(MAD = Me \left(\left| x_i - Me_x \right| \right)\)`). Un valor habitual es `\(k = 3\)`.

`$$x_i &gt; Me_{x} + k*MAD\quad \text{ o bien } \quad x_i&lt; Me_{x} - k*MAD$$`

Para ello nos bastar√° usar `scores()` con `type = "mad"` (y nos devolver√° de nuevo ese `\(k\)`).


```r
abs(scores(c(1, -1, 0, 5, 2, 1.5, 0.5, -0.3, 0, 2, 1.7, 0.2, -0.8), type = "mad"))
```

```
&gt;  [1] 0.3372454 1.0117361 0.3372454 3.0352084 1.0117361 0.6744908 0.0000000
&gt;  [8] 0.5395926 0.3372454 1.0117361 0.8093889 0.2023472 0.8768380
```

El **.bg-purple_light[valor a imputar ser√≠a la mediana]**

---


# Tratamiento de .orange[OUTLIERS]


* **.bg-purple_light[At√≠pico respecto a percentiles]**: ser√° un dato muy alejado de los **.bg-purple_light[cuartiles de la variable]**. ¬øCu√°nto de alejado? Una definici√≥n habitual es definir un dato at√≠pico como aquel que se aleja de los cuartiles 1 y 3 (percentiles 25 y 75) `\(k\)` veces el rango intercuart√≠lico ($IQR = Q_3 - Q_1$). Un valor habitual es `\(k = 1.5\)`).

`$$x_i &gt; Q_3 + k* IQR \quad \text{ o bien } \quad x_i &lt; Q_1 - k*IQR$$`

Para ello nos bastar√° usar `scores()` con `type = "iqr"` (y nos devolver√° de nuevo ese `\(k\)`, siendo `\(k = 0\)` para lo que est√© dentro del IQR).


```r
abs(scores(c(1, -1, 0, 5, 2, 1.5, 0.5, -0.3, 0, 2, 1.7, 0.2, -0.8), type = "iqr"))
```

```
&gt;  [1] 0.0000000 0.5882353 0.0000000 1.9411765 0.1764706 0.0000000 0.0000000
&gt;  [8] 0.1764706 0.0000000 0.1764706 0.0000000 0.0000000 0.4705882
```

El **.bg-purple_light[valor a imputar ser√≠a la mediana]**

---

# Tratamiento de .orange[OUTLIERS]

Existen otros procedimientos **.bg-purple_light[basados en inferencia estad√≠stica]** (muchos de ellos en el paquete `{outliers}`)

* **.bg-purple_light[Tests de Grubbs y Dixon]**: ambos test nos permiten **.bg-purple_light[detectar si el valor m√°s alto (o bajo)]** de una varibale es un outlier, pudiendo detectar un solo outlier en cada iteraci√≥n (en caso de detectarlo, deber√≠amos tratarlo y volver a ejecutar el test)

`\(\mathcal{H}_0: \text{valor m√°s alto/bajo no es outlier}\)`

`\(\mathcal{H}_1: \text{ valor m√°s alto/bajo s√≠ es outlier}\)`


&amp;nbsp;

El test de Dixon (basado en una ordenaci√≥n) suele funcionar mejor cuando tenemos poca muestra que el test de Grubbs (basado en la media).

üìö Ver m√°s documentaci√≥n de su funcionamiento en &lt;https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h1.htm&gt; y &lt;https://www.statisticshowto.com/dixons-q-test/&gt;

---

# Tratamiento de .orange[OUTLIERS]

Por ejemplo, para el de Dixon existe `dixon.test()`


```r
x &lt;- c(1, -1, 0, 5, 2, 1.5, 0.5, -0.3, 0, 2, 1.7, 0.2, -0.8)
dixon.test(x, opposite = TRUE) # valor m√°s bajo
```

```
&gt; 
&gt; 	Dixon test for outliers
&gt; 
&gt; data:  x
&gt; Q = 0.23333, p-value = 0.8072
&gt; alternative hypothesis: lowest value -1 is an outlier
```


```r
x &lt;- c(1, -1, 0, 5, 2, 1.5, 0.5, -0.3, 0, 2, 1.7, 0.2, -0.8)
dixon.test(x, opposite = FALSE) # valor m√°s alto
```

```
&gt; 
&gt; 	Dixon test for outliers
&gt; 
&gt; data:  x
&gt; Q = 0.51724, p-value = 0.1055
&gt; alternative hypothesis: highest value 5 is an outlier
```

---


# Tratamiento de .orange[OUTLIERS]

* **.bg-purple_light[Test de Rosner]**: al contrario que los anteriores, nos permite **.bg-purple_light[detectar varios outliers]** a la vez, especialmente dise√±ado para evitar que un valor at√≠pico nos perturbe tanto que nos enmascare otro (basado en la media). Podemos ejecutarlo con la funci√≥n `rosnerTest()` del paquete `{EnvStats}`.

&amp;nbsp;

**.bg-red_light[IMPORTANTE]**: la detecci√≥n de outliers deber√° combinar el an√°lisis num√©rico y la visualizaci√≥n.

üìö Ver m√°s documentaci√≥n de su funcionamiento en &lt;https://vsp.pnnl.gov/help/vsample/rosners_outlier_test.htm&gt;


---

# Tratamiento de .orange[OUTLIERS]

En el caso de que tengamos **.bg-purple_light[variables categoricas (factores)]** la detecci√≥n m√°s inmediata ser√≠a haciendo uso de la tabla de frecuencias proporcionada por `fct_count()`



```r
datos &lt;- tibble("estado" = c(rep("grave", 18), rep("sano", 10), "muerto", "UCI"))

datos &lt;- 
  datos %&gt;% mutate(estado = factor(estado, levels = c("sano", "grave", "UCI", "muerto"), ordered = TRUE))
datos$estado %&gt;% fct_count() %&gt;% mutate(f = 100 * n/sum(n))
```

```
&gt; # A tibble: 4 √ó 2
&gt;       f     n
&gt;   &lt;dbl&gt; &lt;int&gt;
&gt; 1 33.3     10
&gt; 2 60       18
&gt; 3  3.33     1
&gt; 4  3.33     1
```

---

# Tratamiento de .orange[OUTLIERS]

Con `fct_lump_prop()` podemos **.bg-purple_light[agrupar niveles que no aparezcan un m√≠nimo]** de veces, por ejemplo que representen menos del 5% de los datos, con `prop = 0.05`. Y ese nivel "otros" podremos **.bg-purple_light[asignarle la moda]** del resto de valores.


```r
datos &lt;- 
  datos %&gt;%
  mutate(estado = fct_lump_prop(estado, prop = 0.05,
                                other_level = "otros"))
datos
```

```
&gt; # A tibble: 30 √ó 1
&gt;    estado
&gt;    &lt;ord&gt; 
&gt;  1 grave 
&gt;  2 grave 
&gt;  3 grave 
&gt;  4 grave 
&gt;  5 grave 
&gt;  6 grave 
&gt;  7 grave 
&gt;  8 grave 
&gt;  9 grave 
&gt; 10 grave 
&gt; # ‚Ä¶ with 20 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---

# Modificaci√≥n: .orange[reescalado/tipificaci√≥n]


Por √∫ltimo, antes de poder aplicar nuestra m√©trica necesitaremos **.bg-purple_light[reescalar por rango]** (para distancias geom√©tricas, con `rescale()` del paquete `{scales}`) o **.bg-purple_light[tipificar]** (para distancias probabil√≠sticas, con `scale()`)



```r
# Escalado
library(scales)
iris_final &lt;- 
  iris_outliers %&gt;% 
  mutate(across(Sepal.Length:Petal.Width, rescale))
```



```r
# Tipificado
iris_final &lt;- 
  iris_outliers %&gt;% 
  mutate(across(Sepal.Length:Petal.Width, scale))
```


---

name: knn-steps

# .orange[EXPLORACI√ìN] y .green[MODIFICACI√ìN]

* **.bg-purple_light[Muestreo]**:
  - ¬øHace falta? ¬øEstratificado? ¬øTenemos la variable objetivo balanceada?

* **.bg-purple_light[Exploraci√≥n]**:
  - Res√∫menes num√©ricos (¬øsimetr√≠a? ¬ødispersi√≥n? ¬øausentes? ¬øcodificaci√≥n?)
  - Dependencia entre variables (correlaci√≥n, dependencia, predictoras vs objetivo)
  - Visualizaci√≥n de datos (pendiente)

* **.bg-purple_light[Depuraci√≥n/modificaci√≥n]**:
  - An√°lisis de outliers (¬øse imputan? ¬øse mandan a NA? ¬øse eliminan?)
  - Tratamiento de ausentes (¬øse imputan? ¬øse eliminan?)
  - Selecci√≥n de variables (¬øcolinealidad? ¬øvarianza cero? ¬ønecesitamos tener solo num√©ricas?)
  - Recategorizar (dummy,cuanti a cuali, codificaci√≥n etc)
  - Estandarizar para m√©tricas (rango y media-varianza)
  - Crear nuevas variables
  
---

# Caso concreto: .orange[KNN EN IRIS]

* **.bg-purple_light[Muestreo]**:
  - **¬øHace falta?**  --&gt; En el caso del `iris` no necesitamos hacerlo ya que tenemos pocas observaciones y adem√°s la variable objetivo est√° balanceada, algo que podemos comprobar f√°cil con `count()` (podemos usar `mutate()` para construir la tabla de frecuencias).
  

```r
iris %&gt;%
  count(Species) %&gt;%
  mutate(porc = 100 * n/sum(n))
```

```
&gt; # A tibble: 3 √ó 3
&gt;   Species        n  porc
&gt;   &lt;fct&gt;      &lt;int&gt; &lt;dbl&gt;
&gt; 1 setosa        50  33.3
&gt; 2 versicolor    50  33.3
&gt; 3 virginica     50  33.3
```

---

# Caso concreto: .orange[KNN EN IRIS]

* **.bg-purple_light[Exploraci√≥n]**:
  - Res√∫menes num√©ricos (¬øsimetr√≠a? ¬ødispersi√≥n? ¬øausentes? ¬øcodificaci√≥n?)

.pull-left[


```r
library(skimr)
iris %&gt;% skim()
```

]

.pull-right[

&lt;img src="./img/skim.jpg" width="100%" style="display: block; margin: auto;" /&gt;

]

No parece que tengamos **.bg-purple_light[problemas de codificaci√≥n o rango]** y tampoco tenemos **.bg-purple_light[datos ausentes]** (`complete_rate` sale en todas 1). La **.bg-purple_light[variable con mayor dispersi√≥n]** es `Petal.Length`.

---

# Caso concreto: .orange[KNN EN IRIS]

* **.bg-purple_light[Exploraci√≥n]**:
  - Dependencia entre variables (correlaci√≥n, dependencia, **predictoras vs objetivo**)


```r
iris %&gt;%
  group_by(Species) %&gt;%
  summarise(mean = across(Sepal.Length:Petal.Width, mean)) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 3 √ó 2
&gt;   Species    mean$Sepal.Length $Sepal.Width $Petal.Length $Petal.Width
&gt;   &lt;fct&gt;                  &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt;
&gt; 1 setosa                  5.01         3.43          1.46        0.246
&gt; 2 versicolor              5.94         2.77          4.26        1.33 
&gt; 3 virginica               6.59         2.97          5.55        2.03
```

Las **.bg-purple_light[variables relacionadas con el s√©palo]** no parece que cambien mucho de una especie a otra. Las **.bg-purple_light[variables relacionadas con el p√©talo]** si parecen ser determinantes ya que la especie setosa tiene valores muy peque√±os. Seguramente lo m√°s complicado sea clasificar entre versicolor y virginica (se diferencian muy ligeramente)

---

# Caso concreto: .orange[KNN EN IRIS]

* **.bg-purple_light[Exploraci√≥n]**:
  - Dependencia entre variables (**correlaci√≥n**, dependencia, predictoras vs objetivo)


```r
library(corrr)
library(corrplot)
correlate(iris %&gt;% select(where(is.numeric)))
```

```
&gt; # A tibble: 4 √ó 5
&gt;   term         Sepal.Length Sepal.Width Petal.Length Petal.Width
&gt;   &lt;chr&gt;               &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
&gt; 1 Sepal.Length       NA          -0.118        0.872       0.818
&gt; 2 Sepal.Width        -0.118      NA           -0.428      -0.366
&gt; 3 Petal.Length        0.872      -0.428       NA           0.963
&gt; 4 Petal.Width         0.818      -0.366        0.963      NA
```

```r
# corrplot(iris %&gt;% %&gt;% select(where(is.numeric)) %&gt;% cor())
```

Parece que hay una **.bg-purple_light[alt√≠sima correlaci√≥n]** entre la anchura y la longitud del s√©palo (alguna habr√° que eliminar en la siguiente fase para evitar problemas de colinealidad)

---

# Caso concreto: .orange[KNN EN IRIS]

* **.bg-purple_light[Depuraci√≥n/modificaci√≥n]**:
  - **An√°lisis de outliers** --&gt; en este caso a las dos primeras variables (muy sim√©tricas) detectaremos por la media, en las dos √∫ltimas por mediana y lo pasamos a ausente.


```r
iris_na_outliers &lt;- 
  iris %&gt;% 
  mutate(across(Sepal.Length:Sepal.Width,
                function(x) { ifelse(abs(scores(x, type = "z")) &gt; 2.5, NA, x) }),
         across(Petal.Length:Petal.Width,
                function(x) { ifelse(abs(scores(x, type = "mad")) &gt; 3, NA, x) }))
iris_na_outliers %&gt;% 
  filter(if_any(Sepal.Length:Petal.Width, is.na))
```

```
&gt; # A tibble: 2 √ó 5
&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
&gt; 1          5.7          NA          1.5         0.4 setosa 
&gt; 2          5.5          NA          1.4         0.2 setosa
```

---

# Caso concreto: .orange[KNN EN IRIS]

* **.bg-purple_light[Depuraci√≥n/modificaci√≥n]**:
  - Tratamiento de **ausentes** --&gt; en este caso los imputaremos por media en las dos primeras y por mediana en las dos segundas.
  


```r
iris_outliers &lt;- 
  iris_na_outliers %&gt;% 
  mutate(across(Sepal.Length:Sepal.Width,
                function(x) { ifelse(is.na(x), mean(x, rm.na = TRUE), x) }),
         across(Petal.Length:Petal.Width,
                function(x) { ifelse(is.na(x), median(x, rm.na = TRUE), x) }))
```

---

# Caso concreto: .orange[KNN EN IRIS]

* **.bg-purple_light[Depuraci√≥n/modificaci√≥n]**:

  - Selecci√≥n de variables (¬øcolinealidad? ¬øvarianza cero? ¬ønecesitamos tener solo num√©ricas?) --&gt; en este caso ya tenemos solo predictoras num√©ricas y no tenemos varianza cero (variables de constantes), as√≠ que solo necesitamos **.bg-purple_light[volver a mirar correlaci√≥n]**
  
  

```r
correlate(iris_outliers %&gt;% select(where(is.numeric)))
```

```
&gt; # A tibble: 4 √ó 5
&gt;   term         Sepal.Length Sepal.Width Petal.Length Petal.Width
&gt;   &lt;chr&gt;               &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
&gt; 1 Sepal.Length       NA          -0.113        0.872       0.818
&gt; 2 Sepal.Width        -0.113      NA           -0.406      -0.344
&gt; 3 Petal.Length        0.872      -0.406       NA           0.963
&gt; 4 Petal.Width         0.818      -0.344        0.963      NA
```

Seguimos observando una alta correlaci√≥n entre `Petal.Length` y `Petal.Width`: eliminaremos la primera ya que es la que tiene una correlaci√≥n m√°s alta (en valor absoluto) con las dem√°s


```r
iris_colin &lt;-
  iris_outliers %&gt;% select(-Petal.Length)
```

---
  
# Caso concreto: .orange[KNN EN IRIS]

* **.bg-purple_light[Depuraci√≥n/modificaci√≥n]**:
  
  - **Recategorizar** --&gt; no necesitamos hacerlo en este caso
  - Crear **nuevas variables** --&gt; no necesitamos hacerlo en este caso
  - **Estandarizar** para m√©tricas --&gt; vamos a usar distancias geom√©tricas as√≠ que habr√° que normalizar por rango.


```r
library(scales)
iris_final &lt;-
  iris_colin %&gt;% 
  mutate(across(c(everything(), -Species), rescale))
iris_final
```

```
&gt; # A tibble: 150 √ó 4
&gt;    Sepal.Length Sepal.Width Petal.Width Species
&gt;           &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
&gt;  1       0.222        0.714      0.0417 setosa 
&gt;  2       0.167        0.476      0.0417 setosa 
&gt;  3       0.111        0.571      0.0417 setosa 
&gt;  4       0.0833       0.524      0.0417 setosa 
&gt;  5       0.194        0.762      0.0417 setosa 
&gt;  6       0.306        0.905      0.125  setosa 
&gt;  7       0.0833       0.667      0.0833 setosa 
&gt;  8       0.194        0.667      0.0417 setosa 
&gt;  9       0.0278       0.429      0.0417 setosa 
&gt; 10       0.167        0.524      0      setosa 
&gt; # ‚Ä¶ with 140 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

  
---

# Caso concreto: .orange[KNN EN IRIS]

Este ser√≠a el **.bg-purple_light[c√≥digo completo de nuestra depuraci√≥n]**


```r
iris_final &lt;-
  iris %&gt;% 
  mutate(across(Sepal.Length:Sepal.Width,
                function(x) { ifelse(abs(scores(x, type = "z")) &gt; 2.5,
                                     mean(x, rm.na = TRUE), x) }),
         across(Petal.Length:Petal.Width,
                function(x) { ifelse(abs(scores(x, type = "mad")) &gt; 3,
                                     median(x, rm.na = TRUE), x) })) %&gt;% 
  select(-Petal.Length) %&gt;% mutate(across(c(everything(), -Species), rescale))
iris_final
```

```
&gt; # A tibble: 150 √ó 4
&gt;    Sepal.Length Sepal.Width Petal.Width Species
&gt;           &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
&gt;  1       0.222        0.714      0.0417 setosa 
&gt;  2       0.167        0.476      0.0417 setosa 
&gt;  3       0.111        0.571      0.0417 setosa 
&gt;  4       0.0833       0.524      0.0417 setosa 
&gt;  5       0.194        0.762      0.0417 setosa 
&gt;  6       0.306        0.905      0.125  setosa 
&gt;  7       0.0833       0.667      0.0833 setosa 
&gt;  8       0.194        0.667      0.0417 setosa 
&gt;  9       0.0278       0.429      0.0417 setosa 
&gt; 10       0.167        0.524      0      setosa 
&gt; # ‚Ä¶ with 140 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```


---

name: tidymodels

# Modelando con .orange[TIDYMODELS]

Una vez que sabemos que proceso necesitamos aplicar a los datos, vamos a introducirnos en la idea del **.bg-purple_light[tidymodels]**: un marco de trabajo, bajo los principios de tidyverse, para aplicar **.bg-purple_light[modelos Machine Learning]**. Puedes ver documentaci√≥n en &lt;https://www.tidymodels.org/&gt;

.pull-left[


```r
install.packages("tidymodels")
library(tidymodels)
```



]

.pull-right[

&lt;img src="./img/tidymodels.jpg" width="80%" style="display: block; margin: auto auto auto 0;" /&gt;

]

---

# Modelando con .orange[TIDYMODELS]

En uno de los paquetes de `{tidymodels}`, el paquete `{rsample}`, nos proporciona **.bg-purple_light[herramientas para generar particiones]** de train-validaci√≥n-test al inicio de nuestro proceso.

--

&amp;nbsp;

Usaremos la funci√≥n `initial_split()`, de forma estratificada por la variable objetivo con

* `strata = Species` indic√°ndole la variable por la que estratificar
* `prop = 0.7` indic√°ndole que el 70% ser√° train y el 30% test (de momento sin validaci√≥n).


```r
library(tidymodels)
iris_split &lt;- initial_split(iris, strata = Species, prop = 0.7)
```

**.bg-red_light[IMPORTANTE]**: la partici√≥n deber√° hacer siempre DESPU√âS de un posible muestreo (si fuese necesario).



---

# Modelando con .orange[TIDYMODELS]

En `iris_split` no se **.bg-purple_light[ejecutado nada]**: solo est√°n guaradas las **.bg-purple_light[instrucciones]**.

.pull-left[


```r
iris_split
```

```
&gt; &lt;Analysis/Assess/Total&gt;
&gt; &lt;105/45/150&gt;
```

]

.pull-right[


```r
iris_train &lt;- training(iris_split)
iris_test &lt;- testing(iris_split)
```

]

--

Tras aplicar las instrucciones, comprobamos la estratificaci√≥n.


```r
iris_train %&gt;% count(Species) %&gt;% mutate(porc = n / sum(n))
```

```
&gt; # A tibble: 3 √ó 3
&gt;   Species        n  porc
&gt;   &lt;fct&gt;      &lt;int&gt; &lt;dbl&gt;
&gt; 1 setosa        35 0.333
&gt; 2 versicolor    35 0.333
&gt; 3 virginica     35 0.333
```

---

# Modelando con .orange[TIDYMODELS]

La idea detr√°s de la filosof√≠a  de `{tidymodels}` es tratar por separado la **.bg-purple_light[depuraci√≥n]** de los datos, el **.bg-purple_light[modelo]** o paradigma de aprendizaje que se quiere aplicar, la **.bg-purple_light[optimizaci√≥n de los par√°metros]** de dicho modelo, el **ajuste**, la **evaluaci√≥n** y la **predicci√≥n** correspondiente.

El objetivo ser√° crear un **.bg-purple_light[flujo de trabajo flexible]**, con una filosof√≠a similar a la que hay detr√°s de cocinar un plato:

* **.bg-purple_light[Escribimos la receta]**: una lista de pasos e instrucciones.

* **.bg-purple_light[Preparamos los utensilios de cocina]**: en nuestro caso, el modelo.

* **.bg-purple_light[Cocinamos]**: con la receta + utensilios podemos **.bg-purple_light[cocinar el plato muchas veces]**, con **.bg-purple_light[distintos lotes de ingredientes (datos)]**.

Tambi√©n podemos aplicar una **.bg-purple_light[receta distinta a distintos ingredientes]**, o incluso **.bg-purple_light[combinar partes de dos recetas]**. 

---

# Modelando con .orange[TIDYMODELS]

El primer paso en nuestra receta ser√° indicarle en `recipe()` los **.bg-purple_light[datos]** y la **.bg-purple_light[¬´f√≥rmula¬ª]** de nuestro modelo (en nuestro caso le indicaremos que vamos la objetivo ser√° `Species` frente al resto de predictoras num√©ricas). La receta **.bg-purple_light[guardar√° los roles]**: 4 predictoras y 1 objetivo


```r
iris_rec &lt;- recipe(data = iris_train, Species ~ .)
```

.pull-left[


```r
iris_rec
```

```
&gt; Recipe
&gt; 
&gt; Inputs:
&gt; 
&gt;       role #variables
&gt;    outcome          1
&gt;  predictor          4
```

]

.pull-right[


```r
summary(iris_rec)
```

```
&gt; # A tibble: 5 √ó 4
&gt;   variable     type    role      source  
&gt;   &lt;chr&gt;        &lt;chr&gt;   &lt;chr&gt;     &lt;chr&gt;   
&gt; 1 Sepal.Length numeric predictor original
&gt; 2 Sepal.Width  numeric predictor original
&gt; 3 Petal.Length numeric predictor original
&gt; 4 Petal.Width  numeric predictor original
&gt; 5 Species      nominal outcome   original
```

]


---

# Modelando con .orange[TIDYMODELS]

Una receta puede **.bg-purple_light[asignar varios roles]** a cada variable: una variable puede ser `predictor`, `outcome` o cualquier otro rol no predefinido.

* `update_role()`: **.bg-purple_light[modifica]** el rol (lo crea si no tiene, borra si lo ten√≠a).


```r
iris_rec &lt;-
  recipe(data = iris_train, Species ~ .) %&gt;% 
  update_role(starts_with("Sepal"), new_role = "sepal") %&gt;% 
  update_role(starts_with("Petal"), new_role = "petal")
```

.pull-left[


```r
iris_rec
```

```
&gt; Recipe
&gt; 
&gt; Inputs:
&gt; 
&gt;     role #variables
&gt;  outcome          1
&gt;    petal          2
&gt;    sepal          2
```

]

.pull-right[


```r
summary(iris_rec)
```

```
&gt; # A tibble: 5 √ó 4
&gt;   variable     type    role    source  
&gt;   &lt;chr&gt;        &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   
&gt; 1 Sepal.Length numeric sepal   original
&gt; 2 Sepal.Width  numeric sepal   original
&gt; 3 Petal.Length numeric petal   original
&gt; 4 Petal.Width  numeric petal   original
&gt; 5 Species      nominal outcome original
```

]

---

# Modelando con .orange[TIDYMODELS]

* `add_role()`: **.bg-purple_light[a√±ade]** un rol a una variable que ya tiene uno (no borra el ya existente)


```r
iris_rec &lt;-
  iris_rec %&gt;% 
  add_role(ends_with("Length"), new_role = "length") %&gt;% 
  add_role(ends_with("Width"), new_role = "width")
```

.pull-left[


```r
iris_rec
```

```
&gt; Recipe
&gt; 
&gt; Inputs:
&gt; 
&gt;     role #variables
&gt;   length          2
&gt;  outcome          1
&gt;    petal          2
&gt;    sepal          2
&gt;    width          2
```

]

.pull-right[


```r
summary(iris_rec)
```

```
&gt; # A tibble: 9 √ó 4
&gt;   variable     type    role    source  
&gt;   &lt;chr&gt;        &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   
&gt; 1 Sepal.Length numeric sepal   original
&gt; 2 Sepal.Length numeric length  original
&gt; 3 Sepal.Width  numeric sepal   original
&gt; 4 Sepal.Width  numeric width   original
&gt; 5 Petal.Length numeric petal   original
&gt; 6 Petal.Length numeric length  original
&gt; 7 Petal.Width  numeric petal   original
&gt; 8 Petal.Width  numeric width   original
&gt; 9 Species      nominal outcome original
```

]

---

# Modelando con .orange[TIDYMODELS]

* `remove_role()`: **.bg-purple_light[elimina]** un rol ya existente


```r
iris_rec &lt;-
  iris_rec %&gt;% remove_role(ends_with("Length"), old_role = "length") %&gt;% 
  remove_role(ends_with("Width"), old_role = "width") %&gt;% 
  remove_role(starts_with("Sepal"), old_role = "sepal") %&gt;% 
  remove_role(starts_with("Petal"), old_role = "petal")
```

.pull-left[


```r
iris_rec
```

```
&gt; Recipe
&gt; 
&gt; Inputs:
&gt; 
&gt;     role #variables
&gt;  outcome          1
&gt; 
&gt;   4 variables with undeclared roles
```

]

.pull-right[


```r
summary(iris_rec)
```

```
&gt; # A tibble: 5 √ó 4
&gt;   variable     type    role    source  
&gt;   &lt;chr&gt;        &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   
&gt; 1 Sepal.Length numeric &lt;NA&gt;    original
&gt; 2 Sepal.Width  numeric &lt;NA&gt;    original
&gt; 3 Petal.Length numeric &lt;NA&gt;    original
&gt; 4 Petal.Width  numeric &lt;NA&gt;    original
&gt; 5 Species      nominal outcome original
```

]

---

# Modelando con .orange[TIDYMODELS]

La idea es que las acciones que hagamos de depuraci√≥n podremos **.bg-purple_light[personalizarlas para cada tipo de rol]**. La idea es **.bg-purple_light[a√±adir pasos]** la `recipe()`, algo as√≠ como la receta escrita que tenemos guardada en un caj√≥n para preparar un plato: la receta por s√≠ sola no te cocina, simplemente es una lista de instrucciones, lista para cuando la necesites.

&amp;nbsp;

Las funciones que empiezan por `step_...()` tienen **.bg-purple_light[implementadas muchas de las funcionalidades tidyverse]**: la diferencia al incluirlo en la receta es que se **.bg-purple_light[ejecutar√° en todas las particiones]** cada vez que dicha receta se aplique (pudi√©ndose aplicar a diferentes modelos).

* `step_arrange()`
* `step_filter()`
* `step_count()`
* `step_mutate()`
* `step_select()`

---

# Modelando con .orange[TIDYMODELS]

En nuestro caso, en la receta indicaremos la **.bg-purple_light[lista de acciones que hemos decidido]** en diapositivas anteriores (con `step_...()`)



```r
iris_rec &lt;-
  recipe(data = iris_train, Species ~ .) %&gt;%
  step_mutate(across(Sepal.Length:Sepal.Width,
                     function(x) { ifelse(abs(scores(x, type = "z")) &gt; 2.5, mean(x, rm.na = TRUE), x) }),
              across(Petal.Length:Petal.Width,
                     function(x) { ifelse(abs(scores(x, type = "mad")) &gt; 3, median(x, rm.na = TRUE), x) })) %&gt;% 
  step_select(-Petal.Length) %&gt;%
  step_mutate(across(c(everything(), -Species), rescale))
```


---

# Modelando con .orange[TIDYMODELS]



```r
iris_rec
```

```
&gt; Recipe
&gt; 
&gt; Inputs:
&gt; 
&gt;       role #variables
&gt;    outcome          1
&gt;  predictor          4
&gt; 
&gt; Operations:
&gt; 
&gt; Variable mutation for across(Sepal.Length:Sepal.Width, function(...
&gt; Variables selected -Petal.Length
&gt; Variable mutation for across(c(everything(), -Species), rescale)
```

---

# .orange[TIDYMODELS]: .green[RECIPE]

Lo hecho anteriormente es una traducci√≥n literal (con `step_...()`) de lo que sab√≠amos hacer con tidyverse. Pero adem√°s de todo eso tendremos **.bg-purple_light[muchas funciones concretas para facilitar]** la depuraci√≥n de nuestras variables (por roles).

--

Dado que el tratamiento de outliers lo estamos haciendo de manera distinta en las variables de s√©palo que en las de p√©talo, lo primero que haremos es **.bg-purple_light[asignar]** roles (sin eliminar el rol de predictor que ya tiene, as√≠ que lo haremos con `add_role()`)


```r
iris_rec &lt;-
  recipe(data = iris_train, Species ~ .) %&gt;%
  add_role(starts_with("Sepal"), new_role = "sepal") %&gt;% 
  add_role(starts_with("Petal"), new_role = "petal")
```


---

# .orange[TIDYMODELS]: .green[RECIPE]

Tras ello **.bg-purple_light[detectaremos outliers]** (transformando a `NA`)


```r
iris_rec &lt;-
  iris_rec %&gt;% 
  step_mutate(across(starts_with("Sepal"), function(x) { ifelse(abs(scores(x, type = "z")) &gt; 2.5, NA, x) }),
              across(starts_with("Petal"), function(x) { ifelse(abs(scores(x, type = "mad")) &gt; 3, NA, x) }))
```

--

Y decidiremos c√≥mo **.bg-purple_light[tratar los ausentes]** (los existentes y los generados al detectar los outliers). Tenemos much√≠simas funciones para ello (ver `step_impute_...()`):

.pull-left[

* `step_impute_mean()`, `step_impute_median()` y `step_impute_mode()`: imputamos por media, mediana o moda.

* `step_impute_knn()`: usaremos un knn previo para imputar los ausentes.

]

.pull-right[


```r
iris_rec &lt;-
  iris_rec %&gt;% 
  step_impute_mean(has_role("sepal")) %&gt;% 
  step_impute_median(has_role("petal"))
```

F√≠jate la **.bg-purple_light[utilidad de los roles]**: con `has_role()` podemos indicarle a qu√© variables aplicar la acci√≥n.

]

---

# .orange[TIDYMODELS]: .green[RECIPE]

Para tratar los **.bg-purple_light[problemas de colinealidad]** usaremos directamente `step_corr()`, al que le tendremos que pasar un umbral en `threshold`: se queda solo con una variable de todo par de variables cuya **.bg-purple_light[correlaci√≥n en valor absoluto supere el umbral]** (en este caso usaremos `all_numeric_predictors()` para considerar solo las predictoras num√©ricas)



```r
iris_rec &lt;-
  iris_rec %&gt;% 
  step_corr(all_numeric_predictors(), threshold = 0.9)
```


--

Por √∫ltimo, le indicaremos con `step_range()` que nos **.bg-purple_light[normalice por rango]** las variables predictoras que sean num√©ricas, y a√±adimos siempre un √∫ltimo **.bg-purple_light[filtro de cero varianza]** para que nos elimine las variables con varianza constante.



```r
iris_rec &lt;-
  iris_rec %&gt;%
  step_range(all_numeric_predictors()) %&gt;% 
  step_zv(all_predictors())
```

---

# .orange[TIDYMODELS]: .green[RECIPE]


Esta ser√° por tanto nuestra **receta completa**:


```r
iris_rec &lt;-
  # F√≥rmula y datos
  recipe(data = iris_train, Species ~ .) %&gt;%
  # Roles
  add_role(starts_with("Sepal"), new_role = "sepal") %&gt;% 
  add_role(starts_with("Petal"), new_role = "petal") %&gt;% 
  # Detectar outliers
  step_mutate(across(starts_with("Sepal"), function(x) { ifelse(abs(scores(x, type = "z")) &gt; 2.5, NA, x) }),
              across(starts_with("Petal"), function(x) { ifelse(abs(scores(x, type = "mad")) &gt; 3, NA, x) })) %&gt;% 
  # Imputar ausentes
  step_impute_mean(has_role("sepal")) %&gt;% 
  step_impute_median(has_role("petal")) %&gt;% 
  # Filtro de correlaci√≥n
  step_corr(all_numeric_predictors(), threshold = 0.9) %&gt;% 
  # Normalizar por rango
  step_range(all_numeric_predictors()) %&gt;% 
  # Filtro de cero varianza
  step_zv(all_predictors())
```

---

# .orange[TIDYMODELS]: .green[RECIPE]


```r
iris_rec
```

```
&gt; Recipe
&gt; 
&gt; Inputs:
&gt; 
&gt;       role #variables
&gt;    outcome          1
&gt;      petal          2
&gt;  predictor          4
&gt;      sepal          2
&gt; 
&gt; Operations:
&gt; 
&gt; Variable mutation for across(starts_with("Sepal"), function(x) {...
&gt; Mean imputation for has_role("sepal")
&gt; Median imputation for has_role("petal")
&gt; Correlation filter on all_numeric_predictors()
&gt; Range scaling to [0,1] for all_numeric_predictors()
&gt; Zero variance filter on all_predictors()
```

---

# .orange[TIDYMODELS]: .green[RECIPE]

Tras ¬´redactar¬ª la receta **.bg-purple_light[hornear la receta]** a unos datos, haciiendo uso de `bake()`, y en `new_data` le podemos indicar el dataset al que aplicaremos la receta (si `new_data = NULL`, se har√° con el conjunto de entrenamiento).


```r
bake(iris_rec %&gt;% prep(), new_data = NULL)
```

```
&gt; # A tibble: 105 √ó 4
&gt;    Sepal.Length Sepal.Width Petal.Width Species
&gt;           &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
&gt;  1        0.222       0.714      0.0417 setosa 
&gt;  2        0.167       0.476      0.0417 setosa 
&gt;  3        0.111       0.571      0.0417 setosa 
&gt;  4        0.194       0.762      0.0417 setosa 
&gt;  5        0.194       0.667      0.0417 setosa 
&gt;  6        0.306       0.810      0.0417 setosa 
&gt;  7        0.139       0.667      0.0417 setosa 
&gt;  8        0.139       0.476      0      setosa 
&gt;  9        0           0.476      0      setosa 
&gt; 10        0.417       0.952      0.0417 setosa 
&gt; # ‚Ä¶ with 95 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```
  

---

# Fase 4: .orange[MODELIZACI√ìN]


Tras la receta vamos a **.bg-purple_light[definir el modelo en abstracto]**, sin pasarle a√∫n datos

* `nearest_neighbor()`: definimos el modelo KNN
  - `mode = ...`: puede ser **"classification"** o **"regression"**
  - `neighbors = ...`: n√∫mero k de vecinos.
  - `weight_func = ...`: m√©todo de ponderaci√≥n de distancias. Las diferentes opciones de las puedes ver en &lt;https://epub.ub.uni-muenchen.de/1769/&gt;
  - `dist_power = ...`: exponente a usar en nuestra familia de m√©tricas de Minkowski
  
* `set_engine("kknn")`: motor interno que usa para optimizar el modelo.
  

```r
knn_model &lt;-
  nearest_neighbor(mode = "classification", neighbors = 10,
                   weight_func = "inv", dist_power = 2) %&gt;%
  set_engine("kknn") # ¬´motor interno¬ª que realiza el ajuste
```


---

# Fase 4: .orange[MODELIZACI√ìN]



```r
knn_model &lt;-
  nearest_neighbor(mode = "classification", neighbors = 10,
                   weight_func = "inv", dist_power = 2) %&gt;%
  set_engine("kknn") # ¬´motor interno¬ª que realiza el ajuste
knn_model
```

```
&gt; K-Nearest Neighbor Model Specification (classification)
&gt; 
&gt; Main Arguments:
&gt;   neighbors = 10
&gt;   weight_func = inv
&gt;   dist_power = 2
&gt; 
&gt; Computational engine: kknn
```



---

# .orange[TIDYMODELS]: .green[FLUJO]


* Tenemos una **.bg-purple_light[receta]** para preprocesar los datos, una lista de instrucciones.
* Tenemos los **.bg-purple_light[utensilios de cocina]** (modelo).
* Tenemos los **.bg-purple_light[ingredientes (datos)]**

Todo ello lo **.bg-purple_light[juntaremos en un flujo de trabajo]** con `workflow()`


```r
iris_wflow &lt;-
  workflow() %&gt;% add_recipe(iris_rec) %&gt;% add_model(knn_model)
iris_wflow
```

```
&gt; ‚ïê‚ïê Workflow ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
&gt; Preprocessor: Recipe
&gt; Model: nearest_neighbor()
&gt; 
&gt; ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
&gt; 6 Recipe Steps
&gt; 
&gt; ‚Ä¢ step_mutate()
&gt; ‚Ä¢ step_impute_mean()
&gt; ‚Ä¢ step_impute_median()
&gt; ‚Ä¢ step_corr()
&gt; ‚Ä¢ step_range()
&gt; ‚Ä¢ step_zv()
&gt; 
&gt; ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
&gt; K-Nearest Neighbor Model Specification (classification)
&gt; 
&gt; Main Arguments:
&gt;   neighbors = 10
&gt;   weight_func = inv
&gt;   dist_power = 2
&gt; 
&gt; Computational engine: kknn
```


---

# .orange[TIDYMODELS]: .green[AJUSTE]

El siguiente paso, una vez que tenemos construido el flujo de trabajo, es **.bg-purple_light[aplicarlo al conjunto de entrenamiento]** con `fit(data = iris_train)` (es aqu√≠ donde el algoritmo aprender√° del conjunto de entrenamiento, aunque en el caso de knn deber√° calcular siempre la distancia de cada punto al resto)


```r
iris_knn_fit &lt;- iris_wflow %&gt;% fit(data = iris_train)
iris_knn_fit
```

```
&gt; ‚ïê‚ïê Workflow [trained] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
&gt; Preprocessor: Recipe
&gt; Model: nearest_neighbor()
&gt; 
&gt; ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
&gt; 6 Recipe Steps
&gt; 
&gt; ‚Ä¢ step_mutate()
&gt; ‚Ä¢ step_impute_mean()
&gt; ‚Ä¢ step_impute_median()
&gt; ‚Ä¢ step_corr()
&gt; ‚Ä¢ step_range()
&gt; ‚Ä¢ step_zv()
&gt; 
&gt; ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
&gt; 
&gt; Call:
&gt; kknn::train.kknn(formula = ..y ~ ., data = data, ks = min_rows(10,     data, 5), distance = ~2, kernel = ~"inv")
&gt; 
&gt; Type of response variable: nominal
&gt; Minimal misclassification: 0.03809524
&gt; Best kernel: inv
&gt; Best k: 10
```

---

# Fase 5: .orange[PREDICCI√ìN Y EVALUACI√ìN]


Tras realizar el ajuste, con `predict()` podremos **.bg-purple_light[obtener las predicciones]** de `Species` de nuestro **.bg-purple_light[conjunto de test]** (en este caso concreto del knn, lo que har√° ser√° calcular los vecinos de cada registro de test usando los registros de train)


```r
predict(iris_knn_fit, iris_test)
```

```
&gt; # A tibble: 45 √ó 1
&gt;    .pred_class
&gt;    &lt;fct&gt;      
&gt;  1 setosa     
&gt;  2 setosa     
&gt;  3 setosa     
&gt;  4 setosa     
&gt;  5 setosa     
&gt;  6 setosa     
&gt;  7 setosa     
&gt;  8 setosa     
&gt;  9 setosa     
&gt; 10 setosa     
&gt; # ‚Ä¶ with 35 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---

# Fase 5: .orange[PREDICCI√ìN Y EVALUACI√ìN]


Recuerda que el objetivo de estos algoritmos es **.bg-purple_light[estimar aquellas probabilidades de pertenencia]** te√≥ricas del clasificador Bayesiano (y que desconocemos), algo que podemos obtener a√±adiendo `type = "prob"`


```r
predict(iris_knn_fit, iris_test, type = "prob")
```

```
&gt; # A tibble: 45 √ó 3
&gt;    .pred_setosa .pred_versicolor .pred_virginica
&gt;           &lt;dbl&gt;            &lt;dbl&gt;           &lt;dbl&gt;
&gt;  1            1                0               0
&gt;  2            1                0               0
&gt;  3            1                0               0
&gt;  4            1                0               0
&gt;  5            1                0               0
&gt;  6            1                0               0
&gt;  7            1                0               0
&gt;  8            1                0               0
&gt;  9            1                0               0
&gt; 10            1                0               0
&gt; # ‚Ä¶ with 35 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---

# Fase 5: .orange[PREDICCI√ìN Y EVALUACI√ìN]


En muchas ocasiones querremos tener una **.bg-purple_light[visi√≥n conjunta]**: ver la clasificaci√≥n realizada de cada registro pero tambi√©n ver los valores de cada registro, juntando en una sola tabla los datos originales y las predicciones con `augment()`


```r
prob_test &lt;- augment(iris_knn_fit, iris_test)
prob_test
```

```
&gt; # A tibble: 45 √ó 9
&gt;    Sepal.Length Sepal.‚Ä¶¬π Petal‚Ä¶¬≤ Petal‚Ä¶¬≥ Species .pred‚Ä¶‚Å¥ .pred‚Ä¶‚Åµ .pred‚Ä¶‚Å∂ .pred‚Ä¶‚Å∑
&gt;           &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;fct&gt;   &lt;fct&gt;     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
&gt;  1          4.6      3.1     1.5     0.2 setosa  setosa        1       0       0
&gt;  2          5.4      3.9     1.7     0.4 setosa  setosa        1       0       0
&gt;  3          4.6      3.4     1.4     0.3 setosa  setosa        1       0       0
&gt;  4          4.4      2.9     1.4     0.2 setosa  setosa        1       0       0
&gt;  5          4.9      3.1     1.5     0.1 setosa  setosa        1       0       0
&gt;  6          4.8      3.4     1.9     0.2 setosa  setosa        1       0       0
&gt;  7          4.8      3.1     1.6     0.2 setosa  setosa        1       0       0
&gt;  8          5.4      3.4     1.5     0.4 setosa  setosa        1       0       0
&gt;  9          5.5      4.2     1.4     0.2 setosa  setosa        1       0       0
&gt; 10          5        3.2     1.2     0.2 setosa  setosa        1       0       0
&gt; # ‚Ä¶ with 35 more rows, and abbreviated variable names ¬π‚ÄãSepal.Width,
&gt; #   ¬≤‚ÄãPetal.Length, ¬≥‚ÄãPetal.Width, ‚Å¥‚Äã.pred_class, ‚Åµ‚Äã.pred_setosa,
&gt; #   ‚Å∂‚Äã.pred_versicolor, ‚Å∑‚Äã.pred_virginica
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---

# Fase 5: .orange[PREDICCI√ìN Y EVALUACI√ìN]


La **.bg-purple_light[matriz confusi√≥n]** de verdaderos positivos y negativos, y falsos positivos y negativos, de la que saldr√°n todas las m√©tricas que usemos para **.bg-purple_light[evaluar nuestro modelo]** se podr√°n obtener con `conf_mat(truth = ..., estimate = ...)`, indic√°ndole la **.bg-purple_light[columna con la clase real]** y la **.bg-purple_light[columna con la clase predicha]** (que como ves le podemos cambiar el nombre si queremos, por defecto es `.pred_class`)


```r
conf_mat_test &lt;- 
  prob_test %&gt;%
  rename(pred_species = .pred_class) %&gt;% 
  conf_mat(truth = Species, estimate = pred_species)
conf_mat_test
```

```
&gt;             Truth
&gt; Prediction   setosa versicolor virginica
&gt;   setosa         14          0         0
&gt;   versicolor      1         15         1
&gt;   virginica       0          0        14
```

---

# Fase 5: .orange[PREDICCI√ìN Y EVALUACI√ìN]

Por √∫ltimo podemos  **.bg-purple_light[obtener la mayor√≠a de m√©tricas]** haciendo uso de `summary()`, aplicado a dicha matriz de confusi√≥n


```r
conf_mat_test %&gt;% summary()
```

```
&gt; # A tibble: 13 √ó 3
&gt;    .metric              .estimator .estimate
&gt;    &lt;chr&gt;                &lt;chr&gt;          &lt;dbl&gt;
&gt;  1 accuracy             multiclass     0.956
&gt;  2 kap                  multiclass     0.933
&gt;  3 sens                 macro          0.956
&gt;  4 spec                 macro          0.978
&gt;  5 ppv                  macro          0.961
&gt;  6 npv                  macro          0.978
&gt;  7 mcc                  multiclass     0.935
&gt;  8 j_index              macro          0.933
&gt;  9 bal_accuracy         macro          0.967
&gt; 10 detection_prevalence macro          0.333
&gt; 11 precision            macro          0.961
&gt; 12 recall               macro          0.956
&gt; 13 f_meas               macro          0.956
```

---

# Fase 5: .orange[PREDICCI√ìN Y EVALUACI√ìN]



```r
conf_mat_test %&gt;%
  summary() %&gt;%
  filter(.metric %in% c("accuracy", "sens", "spec"))
```

```
&gt; # A tibble: 3 √ó 3
&gt;   .metric  .estimator .estimate
&gt;   &lt;chr&gt;    &lt;chr&gt;          &lt;dbl&gt;
&gt; 1 accuracy multiclass     0.956
&gt; 2 sens     macro          0.956
&gt; 3 spec     macro          0.978
```

F√≠jate que aunque no sea un problema de clasificaci√≥n binaria nos proporciona m√©tricas como la sensibilidad y especificidad: lo que es, **.bg-purple_light[para cada clase, construir una matriz de confusi√≥n]** (ser setosa vs no serlo, ser virginica vs no serlo, ser versicolor vs no serlo), y devuelve la **.bg-purple_light[media de las tres sensibilidad o especificidades]**


---

class: inverse center middle
name: clase-8

# CLASE 8: profundizando en tidymodels

&amp;nbsp;

### [Repaso knn en iris](#repaso-knn-iris)

### [Complicamos el asunto: hoteles](#knn-hoteles)

### [Fase 2: exploratorio](#fase2-hoteles)

### [Fase 3: modificaci√≥n](#fase3-hoteles)

### [Fase 4: modelizaci√≥n](#fase4-hoteles)

### [Fase 5: evaluaci√≥n](#fase5-hoteles)

---


# Fase 1: .orange[¬øMUESTREO?]


```r
iris %&gt;%
  count(Species) %&gt;%
  mutate(porc = 100 * n/sum(n))
```

```
&gt; # A tibble: 3 √ó 3
&gt;   Species        n  porc
&gt;   &lt;fct&gt;      &lt;int&gt; &lt;dbl&gt;
&gt; 1 setosa        50  33.3
&gt; 2 versicolor    50  33.3
&gt; 3 virginica     50  33.3
```

En el caso del `iris` no necesitamos hacerlo ya que tenemos pocas observaciones y, adem√°s, la **.bg-purple_light[variable objetivo est√° balanceada]**

---

# Fase 2: .orange[EXPLORACI√ìN]

* **.bg-purple_light[Resumen num√©rico]**: ausentes, medidas de centralizaci√≥n, medidas de dispersi√≥n, problemas de codificaci√≥n, etc.

.pull-left[


```r
library(skimr)
iris %&gt;% skim()
```

]

.pull-right[

&lt;img src="./img/skim.jpg" width="100%" style="display: block; margin: auto;" /&gt;

]

---

# Fase 2: .orange[EXPLORACI√ìN]

* **.bg-purple_light[Dependencia]**: correlaci√≥n entre predictoras, **predictoras vs objetivo**


```r
iris %&gt;%
  group_by(Species) %&gt;% summarise(mean = across(where(is.numeric), mean)) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 3 √ó 2
&gt;   Species    mean$Sepal.Length $Sepal.Width $Petal.Length $Petal.Width
&gt;   &lt;fct&gt;                  &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt;
&gt; 1 setosa                  5.01         3.43          1.46        0.246
&gt; 2 versicolor              5.94         2.77          4.26        1.33 
&gt; 3 virginica               6.59         2.97          5.55        2.03
```


```r
library(corrplot)
cor_matrix &lt;- iris %&gt;% select(where(is.numeric)) %&gt;% cor()
cor_matrix
```

```
&gt;              Sepal.Length Sepal.Width Petal.Length Petal.Width
&gt; Sepal.Length    1.0000000  -0.1175698    0.8717538   0.8179411
&gt; Sepal.Width    -0.1175698   1.0000000   -0.4284401  -0.3661259
&gt; Petal.Length    0.8717538  -0.4284401    1.0000000   0.9628654
&gt; Petal.Width     0.8179411  -0.3661259    0.9628654   1.0000000
```

```r
# corrplot(iris %&gt;% %&gt;% select(where(is.numeric)) %&gt;% cor())
```

---

# .orange[PARTICIONES]


```r
# Partici√≥n 70-30% de train y test (solo instrucciones)
iris_split &lt;- initial_split(iris, strata = Species, prop = 0.7)
iris_split
```

```
&gt; &lt;Analysis/Assess/Total&gt;
&gt; &lt;105/45/150&gt;
```

```r
# Aplicamos partici√≥n (ejecuta instrucciones)
iris_train &lt;- training(iris_split)
iris_test &lt;- testing(iris_split)

# Comprobamos estratos
iris_train %&gt;% count(Species) %&gt;% mutate(porc = 100 * n / sum(n))
```

```
&gt; # A tibble: 3 √ó 3
&gt;   Species        n  porc
&gt;   &lt;fct&gt;      &lt;int&gt; &lt;dbl&gt;
&gt; 1 setosa        35  33.3
&gt; 2 versicolor    35  33.3
&gt; 3 virginica     35  33.3
```

```r
iris_test %&gt;% count(Species) %&gt;% mutate(porc = 100 * n / sum(n))
```

```
&gt; # A tibble: 3 √ó 3
&gt;   Species        n  porc
&gt;   &lt;fct&gt;      &lt;int&gt; &lt;dbl&gt;
&gt; 1 setosa        15  33.3
&gt; 2 versicolor    15  33.3
&gt; 3 virginica     15  33.3
```

---

# Fase 3: .orange[MODIFICACI√ìN]


* **.bg-purple_light[Receta y roles]**: lo primero es **.bg-orange[definir la receta]** (indicando la partici√≥n de train y la objetivo vs todas) y los **.bg-orange[roles]** de las variables (permitiendo una depuraci√≥n personalizada)


```r
# Receta
iris_rec &lt;-
  recipe(data = iris_train, Species ~ .) %&gt;%
  # Roles
  add_role(starts_with("Sepal"), new_role = "sim√©trica") %&gt;% 
  add_role(starts_with("Petal"), new_role = "no sim√©trica")
iris_rec
```

```
&gt; Recipe
&gt; 
&gt; Inputs:
&gt; 
&gt;          role #variables
&gt;  no sim√©trica          2
&gt;       outcome          1
&gt;     predictor          4
&gt;     sim√©trica          2
```

---

# Fase 3: .orange[MODIFICACI√ìN]


* **.bg-purple_light[Tipolog√≠a de las variables]** --&gt; todas las predictoras son num√©ricas (no necesito recategorizar o dummys)

*  **.bg-purple_light[Codificaci√≥n de las variables]** --&gt; todas mis variables tienen un **.bg-orange[rango coherente]**

* **.bg-purple_light[At√≠picos y ausentes]**. ¬øTengo **.bg-orange[valores at√≠picos (outliers)]**? 



```r
iris_rec &lt;-
  iris_rec %&gt;%
  # Detectar outliers
  step_mutate(across(starts_with("Sepal"),
                     function(x) { ifelse(abs(scores(x, type = "z")) &gt; 2.5, NA, x) }),
              across(starts_with("Petal"),
                     function(x) { ifelse(abs(scores(x, type = "mad")) &gt; 3, NA, x) }))
```

---

# Fase 3: .orange[MODIFICACI√ìN]


* **.bg-purple_light[Ausentes]**: ¬øtengo **.bg-orange[datos ausentes]**? ¬øC√≥mo los imputo?


```r
iris_rec &lt;-
  iris_rec %&gt;%
  # Imputar ausentes
  step_impute_mean(has_role("sim√©trica")) %&gt;% 
  step_impute_median(has_role("no sim√©trica"))
```

* **.bg-purple_light[A√±adir info]** --&gt; en este caso no necesito **crear nuevas variables** que nos aporte info extra

---

# Fase 3: .orange[MODIFICACI√ìN]

* **.bg-purple_light[Selecci√≥n de variables]**. ¬øNecesito seleccionar variables? ¬øTengo **.bg-orange[problemas de dependencia o colinealidad]**? ¬øTengo alguna de varianza cero (es decir, sin informaci√≥n)? 

* **.bg-purple_light[Normalizar variables]**. ¬øTengo ya mis variables preparadas (tras tratar lo anterior) para la m√©trica que vaya usar?



```r
iris_rec &lt;-
  iris_rec %&gt;%
  # Filtro de correlaci√≥n
  step_corr(all_numeric_predictors(), threshold = 0.9)%&gt;% 
  # Filtro de cero varianza
  step_zv(all_predictors()) %&gt;%
  # Normalizar por rango
  step_range(all_numeric_predictors())
```

---

# .orange[HORNEADO]

**.bg-purple_light[Horneamos la receta]** sobre las particiones para comprobar que la fase 3 se ha realizado correctamente


```r
bake(iris_rec %&gt;% prep(), new_data = NULL)
```

```
&gt; # A tibble: 105 √ó 4
&gt;    Sepal.Length Sepal.Width Petal.Width Species
&gt;           &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
&gt;  1       0.200        0.682      0.0417 setosa 
&gt;  2       0.143        0.455      0.0417 setosa 
&gt;  3       0.0857       0.545      0.0417 setosa 
&gt;  4       0.0571       0.5        0.0417 setosa 
&gt;  5       0.171        0.727      0.0417 setosa 
&gt;  6       0.286        0.864      0.125  setosa 
&gt;  7       0.0571       0.636      0.0833 setosa 
&gt;  8       0            0.409      0.0417 setosa 
&gt;  9       0.114        0.636      0.0417 setosa 
&gt; 10       0.114        0.455      0      setosa 
&gt; # ‚Ä¶ with 95 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

```r
bake(iris_rec %&gt;% prep(), new_data = iris_test)
```

```
&gt; # A tibble: 45 √ó 4
&gt;    Sepal.Length Sepal.Width Petal.Width Species
&gt;           &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
&gt;  1       0.171        0.636      0.0417 setosa 
&gt;  2       0.143        0.5        0      setosa 
&gt;  3       0.286        0.773      0.0417 setosa 
&gt;  4       0            0.455      0      setosa 
&gt;  5       0.371        0.818      0.0833 setosa 
&gt;  6       0.286        0.636      0.0417 setosa 
&gt;  7       0.200        0.773      0.125  setosa 
&gt;  8       0.200        0.591      0.167  setosa 
&gt;  9       0.171        0.636      0.125  setosa 
&gt; 10       0.0857       0.545      0.0417 setosa 
&gt; # ‚Ä¶ with 35 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---

# Fase 4: .orange[MODELADO]

Definimos los **.bg-purple_light[par√°metros de nuestro modelo]**


```r
# Modelo knn
knn_model &lt;-
  nearest_neighbor(mode = "classification", neighbors = 10,
                   weight_func = "inv", dist_power = 2) %&gt;%
  set_engine("kknn") # el ¬´motor¬ª que realiza el ajuste
knn_model
```

```
&gt; K-Nearest Neighbor Model Specification (classification)
&gt; 
&gt; Main Arguments:
&gt;   neighbors = 10
&gt;   weight_func = inv
&gt;   dist_power = 2
&gt; 
&gt; Computational engine: kknn
```

---

# .orange[FLUJO Y AJUSTE]: receta (fase 3) + modelo (fase 4)


```r
# Flujo
iris_wflow &lt;-
  workflow() %&gt;%
  add_recipe(iris_rec) %&gt;%
  add_model(knn_model)

# Ajuste
iris_knn_fit &lt;- iris_wflow %&gt;% fit(data = iris_train)
```

---

# Fase 5: .orange[PREDICCI√ìN/EVALUACI√ìN]

Usando `predict()` obtenemos las predicciones (usando el ajuste, y le proporcionamos un archivo a clasificar, en este caso test). Nos **.bg-purple_light[devuelve la clase predicha]** 


```r
# Predecir el conjunto test: devuelve la clase
predict(iris_knn_fit, iris_test)
```

```
&gt; # A tibble: 45 √ó 1
&gt;    .pred_class
&gt;    &lt;fct&gt;      
&gt;  1 setosa     
&gt;  2 setosa     
&gt;  3 setosa     
&gt;  4 setosa     
&gt;  5 setosa     
&gt;  6 setosa     
&gt;  7 setosa     
&gt;  8 setosa     
&gt;  9 setosa     
&gt; 10 setosa     
&gt; # ‚Ä¶ with 35 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---

# Fase 5: .orange[PREDICCI√ìN/EVALUACI√ìN]

Con `type = prob` obtenemos la **.bg-purple_light[probabilidad estimada de pertenencia]** a cada clase predicha (recuerda que nuestro objetivo es estimar las probabilidades de pertenencia te√≥ricas que nos dar√≠a el clasificador Bayesiano)


```r
# Predecir las probabilidades (las necesitamos para la ROC)
predict(iris_knn_fit, iris_test, type = "prob")
```

```
&gt; # A tibble: 45 √ó 3
&gt;    .pred_setosa .pred_versicolor .pred_virginica
&gt;           &lt;dbl&gt;            &lt;dbl&gt;           &lt;dbl&gt;
&gt;  1            1                0               0
&gt;  2            1                0               0
&gt;  3            1                0               0
&gt;  4            1                0               0
&gt;  5            1                0               0
&gt;  6            1                0               0
&gt;  7            1                0               0
&gt;  8            1                0               0
&gt;  9            1                0               0
&gt; 10            1                0               0
&gt; # ‚Ä¶ with 35 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```


---

# Fase 5: .orange[PREDICCI√ìN/EVALUACI√ìN]

Con `augment()` podemos obtener **.bg-purple_light[predicciones y datos en una sola tabla]**


```r
# Incluir predicciones en tabla
prob_test &lt;- augment(iris_knn_fit, iris_test)
prob_test
```

```
&gt; # A tibble: 45 √ó 9
&gt;    Sepal.Length Sepal.‚Ä¶¬π Petal‚Ä¶¬≤ Petal‚Ä¶¬≥ Species .pred‚Ä¶‚Å¥ .pred‚Ä¶‚Åµ .pred‚Ä¶‚Å∂ .pred‚Ä¶‚Å∑
&gt;           &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;fct&gt;   &lt;fct&gt;     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
&gt;  1          5        3.4     1.5     0.2 setosa  setosa        1       0       0
&gt;  2          4.9      3.1     1.5     0.1 setosa  setosa        1       0       0
&gt;  3          5.4      3.7     1.5     0.2 setosa  setosa        1       0       0
&gt;  4          4.3      3       1.1     0.1 setosa  setosa        1       0       0
&gt;  5          5.7      3.8     1.7     0.3 setosa  setosa        1       0       0
&gt;  6          5.4      3.4     1.7     0.2 setosa  setosa        1       0       0
&gt;  7          5.1      3.7     1.5     0.4 setosa  setosa        1       0       0
&gt;  8          5.1      3.3     1.7     0.5 setosa  setosa        1       0       0
&gt;  9          5        3.4     1.6     0.4 setosa  setosa        1       0       0
&gt; 10          4.7      3.2     1.6     0.2 setosa  setosa        1       0       0
&gt; # ‚Ä¶ with 35 more rows, and abbreviated variable names ¬π‚ÄãSepal.Width,
&gt; #   ¬≤‚ÄãPetal.Length, ¬≥‚ÄãPetal.Width, ‚Å¥‚Äã.pred_class, ‚Åµ‚Äã.pred_setosa,
&gt; #   ‚Å∂‚Äã.pred_versicolor, ‚Å∑‚Äã.pred_virginica
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```


---

# Fase 5: .orange[PREDICCI√ìN/EVALUACI√ìN]

* **.bg-purple_light[Matriz de confusi√≥n]**: matriz con los valores enfrentando **.bg-orange[etiqueta real vs predicha]** (hay que pasarle la salida del `augment` e indicarle como `truth = ...` la clase real y como `estimate = ...` la clase predicha, que por defecto sale como `.pred_class`


```r
# Matriz de confusi√≥n: etiqueta real vs etiqueta predicha
conf_mat_test &lt;-
  prob_test %&gt;%
  conf_mat(truth = Species, estimate = .pred_class)
conf_mat_test 
```

```
&gt;             Truth
&gt; Prediction   setosa versicolor virginica
&gt;   setosa         15          0         0
&gt;   versicolor      0         14         1
&gt;   virginica       0          1        14
```

---

# Fase 5: .orange[PREDICCI√ìN/EVALUACI√ìN]

* **.bg-purple_light[M√©tricas]**: las obtenemos haciendo un `summary()` a la matriz de confusi√≥n


```r
# M√©tricas en test
metricas &lt;- conf_mat_test %&gt;% summary()
metricas
```

```
&gt; # A tibble: 13 √ó 3
&gt;    .metric              .estimator .estimate
&gt;    &lt;chr&gt;                &lt;chr&gt;          &lt;dbl&gt;
&gt;  1 accuracy             multiclass     0.956
&gt;  2 kap                  multiclass     0.933
&gt;  3 sens                 macro          0.956
&gt;  4 spec                 macro          0.978
&gt;  5 ppv                  macro          0.956
&gt;  6 npv                  macro          0.978
&gt;  7 mcc                  multiclass     0.933
&gt;  8 j_index              macro          0.933
&gt;  9 bal_accuracy         macro          0.967
&gt; 10 detection_prevalence macro          0.333
&gt; 11 precision            macro          0.956
&gt; 12 recall               macro          0.956
&gt; 13 f_meas               macro          0.956
```

---

# ¬øY AHORA?

¬øBasta con esto?

--

En realidad no: recuerda que nuestro objetivo es minimizar el error, y para saber si estamos en un modelo √≥ptimo, sobreajustado o bajoajustado, necesitamos **.bg-purple_light[ejecutar el paradigma de aprendizaje con diferentes par√°metros]**.

* Diferentes k (`neighbors = ...`),
                
* Diferentes m√©tricas (`dist_power = ...`) 

* Diferentes ponderaciones (`weight_func = ...`)

&amp;nbsp;

Dicha evaluaci√≥n la deber√≠amos hacer en **.bg-purple_light[validaci√≥n]** pero vamos a pasar a un ejemplo m√°s complicado con m√°s filas para ello.

---

name: knn-hoteles


# Ejemplo real: .orange[HOTELES]

Vamos ir a **ejemplo real**, haciendo uso de un **.bg-purple_light[dataset de reservas de hotel]**


```r
hoteles_bruto &lt;- read_csv(file = "./datos/hoteles.csv")
```

Los datos forman parte de un **.bg-purple_light[conjunto de reservas de hotel]** elaborado por Antonio et al., 2019 con 50 000 registros de reservas

üìö **Detalle de variables**: &lt;https://linkinghub.elsevier.com/retrieve/pii/S2352340918315191&gt;

---

# Ejemplo real: .orange[HOTELES]

Lo primero es conocer las variables.


```r
glimpse(hoteles_bruto)
```
--

* `hotel`: tipo de hotel (urbano o resort)
* `lead_time`: n√∫mero de d√≠as entre la reserva y la estancia.
* `stays_in_weekend_nights, stays_in_week_nights`: noches en fin de semana y entre semana
* `adults`: n√∫mero de adultos
* `children`: ¬øla reserva tiene ni√±os?
* `meal`: r√©gimen de comidas
* `country`: pa√≠s de origen
* `market_segment`: segmento de mercado de la reserva
* `distribution_channel`: canal de distribuci√≥n de la oferta
* `is_repeated_guest`: ¬ørepite como hu√©sped?

---

# Ejemplo real: .orange[HOTELES]


Lo primero es conocer las variables.


```r
glimpse(hoteles_bruto)
```


* `previous_cancellations`: cancelaciones previas
* `previous_bookings_not_canceled`: reservas previas (no canceladas)
* `reserved_room_type, assigned_room_type`: tipo de habitaci√≥n reservada/asignada
* `booking_changes`: cambios en la reserva
* `deposit_type`: tipo de dep√≥sito
* `days_in_waiting_list`: d√≠as en lista de espera
* `customer_type`: tipo de cliente
* `average_daily_rate`: tarifa media diaria
* `required_car_parking_spaces`: ¬øparking?
* `total_of_special_requests`: n√∫mero de requisitos especiales demandados
* `arrival_date`: fecha de llegada 


---

# Ejemplo real: .orange[HOTELES]



```r
glimpse(hoteles_bruto)
```

El objetivo ser√° **.bg-purple_light[predecir si una reserva incluye ni√±os/as o no]**, por lo que `children` ser√° nuestra variable objetivo. Primer paso: conocer c√≥mo se **.bg-purple_light[distribuyen los niveles de la objetivo]** (es binaria)


```r
hoteles_bruto %&gt;% 
  count(children) %&gt;%
  mutate(porc = 100*n/sum(n))
```

```
&gt; # A tibble: 2 √ó 3
&gt;   children     n  porc
&gt;   &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;
&gt; 1 children  4038  8.08
&gt; 2 none     45962 91.9
```

---

name: fase2-hoteles

# Fases 1-2-3: .orange[HOTELES]

Examina los datos y apunta las **.bg-purple_light[decisiones que deber√≠amos adoptar]**:

&amp;nbsp;

* ¬øNecesitamos **.bg-orange[muestreo]**? ¬øDe qu√© forma? ¬øPodremos permitirnos crear esta vez un dataset de **.bg-orange[validaci√≥n]**?

* ¬øDe qu√© **.bg-orange[tipo]** es cada variable? ¬øTenemos **.bg-orange[problemas de codificaci√≥n o rango]**?

* ¬øC√≥mo **.bg-orange[afectan las predictoras]** a los niveles de la variable objetivo?

* ¬øHay problemas de **.bg-orange[dependencia]** entre las variables?

* ¬øNecesitamos **.bg-orange[recategorizar]** las variables? ¬øTenemos variables de **.bg-orange[fecha]**?

* ¬øTenemos **.bg-orange[datos at√≠picos]**?  ¬øTenemos **.bg-orange[datos ausentes]**? ¬øC√≥mo imputarlos?

* ¬øTodas las variables son **.bg-orange[num√©ricas]** para poder aplicar la m√©trica?

&amp;nbsp;

**.bg-purple_light[Filosof√≠a]**: las modificaciones ¬´estructurales¬ª las hacemos fuera de la receta (modificando la base de datos), las modificaciones m√°s concretas para un algoritmo dentro de la receta (sin modificar la base de datos).


---

# Factores

* **.bg-purple_light[Factores]**: lo primero que debemos decidir es si las variables de tipo texto son **.bg-purple_light[variables cualitativas]** (factores) o meros id's.


```r
hoteles_bruto %&gt;% select(where(is.character)) %&gt;% glimpse()
```

```
&gt; Rows: 50,000
&gt; Columns: 11
&gt; $ hotel                       &lt;chr&gt; "City_Hotel", "City_Hotel", "Resort_Hotel"‚Ä¶
&gt; $ children                    &lt;chr&gt; "none", "none", "none", "none", "none", "n‚Ä¶
&gt; $ meal                        &lt;chr&gt; "BB", "BB", "BB", "HB", "HB", "SC", "BB", ‚Ä¶
&gt; $ country                     &lt;chr&gt; "DEU", "PRT", "GBR", "ROU", "PRT", "GBR", ‚Ä¶
&gt; $ market_segment              &lt;chr&gt; "Offline_TA/TO", "Direct", "Online_TA", "O‚Ä¶
&gt; $ distribution_channel        &lt;chr&gt; "TA/TO", "Direct", "TA/TO", "TA/TO", "Dire‚Ä¶
&gt; $ reserved_room_type          &lt;chr&gt; "A", "D", "A", "A", "F", "A", "C", "B", "D‚Ä¶
&gt; $ assigned_room_type          &lt;chr&gt; "A", "K", "A", "A", "F", "A", "C", "A", "D‚Ä¶
&gt; $ deposit_type                &lt;chr&gt; "No_Deposit", "No_Deposit", "No_Deposit", ‚Ä¶
&gt; $ customer_type               &lt;chr&gt; "Transient-Party", "Transient", "Transient‚Ä¶
&gt; $ required_car_parking_spaces &lt;chr&gt; "none", "none", "none", "none", "none", "n‚Ä¶
```

---

# Factores

Todas las variables de tipo texto representan **.bg-purple_light[categor√≠as de una cualitativa]** as√≠ que las convertimos todas ellas a factor.

--


```r
hoteles &lt;- 
  hoteles_bruto %&gt;%
  mutate(across(where(is.character), as_factor))
hoteles
```

```
&gt; # A tibble: 50,000 √ó 23
&gt;    hotel    lead_‚Ä¶¬π stays‚Ä¶¬≤ stays‚Ä¶¬≥ adults child‚Ä¶‚Å¥ meal  country marke‚Ä¶‚Åµ distr‚Ä¶‚Å∂
&gt;    &lt;fct&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;fct&gt;   &lt;fct&gt; &lt;fct&gt;   &lt;fct&gt;   &lt;fct&gt;  
&gt;  1 City_Ho‚Ä¶     217       1       3      2 none    BB    DEU     Offlin‚Ä¶ TA/TO  
&gt;  2 City_Ho‚Ä¶       2       0       1      2 none    BB    PRT     Direct  Direct 
&gt;  3 Resort_‚Ä¶      95       2       5      2 none    BB    GBR     Online‚Ä¶ TA/TO  
&gt;  4 Resort_‚Ä¶     143       2       6      2 none    HB    ROU     Online‚Ä¶ TA/TO  
&gt;  5 Resort_‚Ä¶     136       1       4      2 none    HB    PRT     Direct  Direct 
&gt;  6 City_Ho‚Ä¶      67       2       2      2 none    SC    GBR     Online‚Ä¶ TA/TO  
&gt;  7 Resort_‚Ä¶      47       0       2      2 childr‚Ä¶ BB    ESP     Direct  Direct 
&gt;  8 City_Ho‚Ä¶      56       0       3      0 childr‚Ä¶ BB    ESP     Online‚Ä¶ TA/TO  
&gt;  9 City_Ho‚Ä¶      80       0       4      2 none    BB    FRA     Online‚Ä¶ TA/TO  
&gt; 10 City_Ho‚Ä¶       6       2       2      2 childr‚Ä¶ BB    FRA     Online‚Ä¶ TA/TO  
&gt; # ‚Ä¶ with 49,990 more rows, 13 more variables: is_repeated_guest &lt;dbl&gt;,
&gt; #   previous_cancellations &lt;dbl&gt;, previous_bookings_not_canceled &lt;dbl&gt;,
&gt; #   reserved_room_type &lt;fct&gt;, assigned_room_type &lt;fct&gt;, booking_changes &lt;dbl&gt;,
&gt; #   deposit_type &lt;fct&gt;, days_in_waiting_list &lt;dbl&gt;, customer_type &lt;fct&gt;,
&gt; #   average_daily_rate &lt;dbl&gt;, required_car_parking_spaces &lt;fct&gt;,
&gt; #   total_of_special_requests &lt;dbl&gt;, arrival_date &lt;date&gt;, and abbreviated
&gt; #   variable names ¬π‚Äãlead_time, ¬≤‚Äãstays_in_weekend_nights, ‚Ä¶
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# Factores

* **.bg-purple_light[Ordinales]**: ¬øexiste alguna variable que pueda ser ordinal?

--

La variable `meal` si sigue una jerarqu√≠a: `SC` (sin nada) &lt; `BB` (Bed &amp; Breakfast) &lt; `HB` (Half board, media pensi√≥n) &lt; `FB` (Full board, pensi√≥n completa). Adem√°s tenemos un nivel para los desconocidos llamado `Undefined`


```r
hoteles %&gt;%
  count(meal) %&gt;% 
  mutate(porc = 100*n/sum(n))
```

```
&gt; # A tibble: 5 √ó 3
&gt;   meal          n   porc
&gt;   &lt;fct&gt;     &lt;int&gt;  &lt;dbl&gt;
&gt; 1 BB        38316 76.6  
&gt; 2 HB         6399 12.8  
&gt; 3 SC         4494  8.99 
&gt; 4 Undefined   580  1.16 
&gt; 5 FB          211  0.422
```

---

# Factores

* **.bg-purple_light[Ordinales]**: convertimos `meal` a cualitativa pero ordinal.


```r
hoteles &lt;-
  hoteles %&gt;%
  mutate(meal = factor(meal, levels = c("Undefined", "SC", "BB", "HB", "FB"),
                       ordered = TRUE))
```

--

Ahora podremos hacer **.bg-purple_light[operaciones asociadas a una jerarqu√≠a]** como comparar registros


```r
hoteles %&gt;%
* group_by(meal &lt; "HB") %&gt;%
  count() %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 2 √ó 2
&gt;   `meal &lt; "HB"`     n
&gt;   &lt;lgl&gt;         &lt;int&gt;
&gt; 1 FALSE          6610
&gt; 2 TRUE          43390
```



---

# Variable hotel

Una vez convertidas en cualitativas analicemos cada una de ellas. La variable `hotel` es **.bg-purple_light[binaria]**: urbanos vs resort (60% vs 40% aprox)


```r
hoteles %&gt;%
  count(hotel, sort = TRUE) %&gt;%
  mutate(porc = 100*n/sum(n))
```

```
&gt; # A tibble: 2 √ó 3
&gt;   hotel            n  porc
&gt;   &lt;fct&gt;        &lt;int&gt; &lt;dbl&gt;
&gt; 1 City_Hotel   30752  61.5
&gt; 2 Resort_Hotel 19248  38.5
```

---

# Variable hotel

Parece que cuando hay **.bg-purple_light[ni√±os en la reserva]** se opta ligeramente **.bg-purple_light[m√°s por los resort]**


```r
hoteles %&gt;%
  group_by(hotel) %&gt;% 
  count(children) %&gt;%
  mutate(porc = 100*n/sum(n)) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 4 √ó 4
&gt;   hotel        children     n  porc
&gt;   &lt;fct&gt;        &lt;fct&gt;    &lt;int&gt; &lt;dbl&gt;
&gt; 1 City_Hotel   none     28383 92.3 
&gt; 2 City_Hotel   children  2369  7.70
&gt; 3 Resort_Hotel none     17579 91.3 
&gt; 4 Resort_Hotel children  1669  8.67
```

---


# Variable meal

La variable `meal` toma **.bg-purple_light[5 modalidades]**: quiz√°s para algunos algoritmos haga falta reagrupar niveles (por ejemplo `Undefined` con `SC`)


```r
hoteles %&gt;%
  count(meal, sort = TRUE) %&gt;%
  mutate(porc = 100*n/sum(n))
```

```
&gt; # A tibble: 5 √ó 3
&gt;   meal          n   porc
&gt;   &lt;ord&gt;     &lt;int&gt;  &lt;dbl&gt;
&gt; 1 BB        38316 76.6  
&gt; 2 HB         6399 12.8  
&gt; 3 SC         4494  8.99 
&gt; 4 Undefined   580  1.16 
&gt; 5 FB          211  0.422
```




---

# Variable meal

Parece que **.bg-purple_light[cuando hay ni√±os]** en la reserva hay el **.bg-purple_light[doble de reservas con pensi√≥n completa]**: aunque haya pocos registros de `meal = "FB"` pueden ser determinantes. El 11% de la reservas sin ni√±os van sin nada, mientras que solo el 3% de las reservas con ni√±os.

.pull-left[


```r
hoteles %&gt;%
  group_by(meal) %&gt;% 
  count(children) %&gt;% 
  mutate(porc = 100*n/sum(n)) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 10 √ó 4
&gt;    meal      children     n  porc
&gt;    &lt;ord&gt;     &lt;fct&gt;    &lt;int&gt; &lt;dbl&gt;
&gt;  1 Undefined none       548 94.5 
&gt;  2 Undefined children    32  5.52
&gt;  3 SC        none      4388 97.6 
&gt;  4 SC        children   106  2.36
&gt;  5 BB        none     35071 91.5 
&gt;  6 BB        children  3245  8.47
&gt;  7 HB        none      5782 90.4 
&gt;  8 HB        children   617  9.64
&gt;  9 FB        none       173 82.0 
&gt; 10 FB        children    38 18.0
```

]

.pull-right[


```r
hoteles %&gt;%
  group_by(children) %&gt;% 
  count(meal) %&gt;% 
  mutate(porc = 100*n/sum(n)) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 10 √ó 4
&gt;    children meal          n   porc
&gt;    &lt;fct&gt;    &lt;ord&gt;     &lt;int&gt;  &lt;dbl&gt;
&gt;  1 none     Undefined   548  1.19 
&gt;  2 none     SC         4388  9.55 
&gt;  3 none     BB        35071 76.3  
&gt;  4 none     HB         5782 12.6  
&gt;  5 none     FB          173  0.376
&gt;  6 children Undefined    32  0.792
&gt;  7 children SC          106  2.63 
&gt;  8 children BB         3245 80.4  
&gt;  9 children HB          617 15.3  
&gt; 10 children FB           38  0.941
```

]

---

# Variable country

La variable `country` toma **.bg-purple_light[155 modalidades]** pero tan solo **.bg-purple_light[21 modalidades aparecen en m√°s del 0.5% de registros]** (una de ellas es NULL): quiz√°s sea m√°s pr√°ctico reagrupar niveles de esos pa√≠ses (representan juntos aprox el 10% del total).


```r
hoteles %&gt;%
  count(country, sort = TRUE) %&gt;%
  mutate(porc = 100*n/sum(n), cumul = cumsum(porc))
```

```
&gt; # A tibble: 155 √ó 4
&gt;    country     n  porc cumul
&gt;    &lt;fct&gt;   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
&gt;  1 PRT     14046 28.1   28.1
&gt;  2 GBR      6405 12.8   40.9
&gt;  3 FRA      5627 11.3   52.2
&gt;  4 ESP      4298  8.60  60.8
&gt;  5 DEU      4047  8.09  68.8
&gt;  6 IRL      1691  3.38  72.2
&gt;  7 ITA      1607  3.21  75.4
&gt;  8 BEL      1250  2.5   77.9
&gt;  9 NLD      1123  2.25  80.2
&gt; 10 USA      1059  2.12  82.3
&gt; # ‚Ä¶ with 145 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```


---


# Variable country

Aunque hay pa√≠ses que representa muy poco de los datos, parece que **.bg-purple_light[algunos son m√°s propensos a reservas con ni√±os]**.


```r
hoteles %&gt;%
  group_by(country) %&gt;% count(children) %&gt;% 
  mutate(porc_children = 100*n/sum(n)) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 237 √ó 4
&gt;    country children     n porc_children
&gt;    &lt;fct&gt;   &lt;fct&gt;    &lt;int&gt;         &lt;dbl&gt;
&gt;  1 DEU     none      3863         95.5 
&gt;  2 DEU     children   184          4.55
&gt;  3 PRT     none     12895         91.8 
&gt;  4 PRT     children  1151          8.19
&gt;  5 GBR     none      5997         93.6 
&gt;  6 GBR     children   408          6.37
&gt;  7 ROU     none       216         88.5 
&gt;  8 ROU     children    28         11.5 
&gt;  9 ESP     none      3824         89.0 
&gt; 10 ESP     children   474         11.0 
&gt; # ‚Ä¶ with 227 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```


---

# Variable market_segment

La variable `market_segment` toma **.bg-purple_light[7 modalidades]** aunque algunas representan menos del 1% del total.


```r
hoteles %&gt;%
  count(market_segment, sort = TRUE) %&gt;%
  mutate(porc = 100*n/sum(n), cumul = cumsum(porc))
```

```
&gt; # A tibble: 7 √ó 4
&gt;   market_segment     n   porc cumul
&gt;   &lt;fct&gt;          &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;
&gt; 1 Online_TA      23760 47.5    47.5
&gt; 2 Offline_TA/TO  10604 21.2    68.7
&gt; 3 Direct          7131 14.3    83.0
&gt; 4 Groups          5124 10.2    93.2
&gt; 5 Corporate       2832  5.66   98.9
&gt; 6 Complementary    427  0.854  99.8
&gt; 7 Aviation         122  0.244 100
```

---

# Variable market_segment

F√≠jate que aunque `market_segment = "Aviation"` representa muy pocos registros, el 100% son sin ni√±os (casi similar con `market_segment = "Corporate"` y `market_segment = "Groups"`)


```r
hoteles %&gt;%
  group_by(market_segment) %&gt;% 
  count(children) %&gt;% 
  mutate(porc = 100*n/sum(n)) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 13 √ó 4
&gt;    market_segment children     n    porc
&gt;    &lt;fct&gt;          &lt;fct&gt;    &lt;int&gt;   &lt;dbl&gt;
&gt;  1 Offline_TA/TO  none     10202  96.2  
&gt;  2 Offline_TA/TO  children   402   3.79 
&gt;  3 Direct         none      6138  86.1  
&gt;  4 Direct         children   993  13.9  
&gt;  5 Online_TA      none     21227  89.3  
&gt;  6 Online_TA      children  2533  10.7  
&gt;  7 Corporate      none      2799  98.8  
&gt;  8 Corporate      children    33   1.17 
&gt;  9 Groups         none      5084  99.2  
&gt; 10 Groups         children    40   0.781
&gt; 11 Aviation       none       122 100    
&gt; 12 Complementary  none       390  91.3  
&gt; 13 Complementary  children    37   8.67
```


---

# Variable distribution_channel

La variable `distribution_channel` toma **.bg-purple_light[5 modalidades]**  pero solo **.bg-purple_light[3 de ellas agrupan ya m√°s del 99%]** de los registros.


```r
hoteles %&gt;%
  count(distribution_channel, sort = TRUE) %&gt;%
  mutate(porc = 100*n/sum(n),
         cumul = cumsum(porc))
```

```
&gt; # A tibble: 5 √ó 4
&gt;   distribution_channel     n   porc cumul
&gt;   &lt;fct&gt;                &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;
&gt; 1 TA/TO                38349 76.7    76.7
&gt; 2 Direct                8083 16.2    92.9
&gt; 3 Corporate             3459  6.92   99.8
&gt; 4 GDS                    108  0.216 100. 
&gt; 5 Undefined                1  0.002 100
```

---

# Variable distribution_channel

F√≠jate que de `distribution_channel = "Undefined"` y `distribution_channel = "GDS"` representan **.bg-purple_light[muy pocos registros]**, y todos con una sola modalidad en la objetivo (pero solo pesan el 0.2% de los datos)


```r
hoteles %&gt;%
  group_by(distribution_channel) %&gt;% 
  count(children) %&gt;% 
  mutate(porc = 100*n/sum(n)) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 8 √ó 4
&gt;   distribution_channel children     n   porc
&gt;   &lt;fct&gt;                &lt;fct&gt;    &lt;int&gt;  &lt;dbl&gt;
&gt; 1 TA/TO                none     35388  92.3 
&gt; 2 TA/TO                children  2961   7.72
&gt; 3 Direct               none      7045  87.2 
&gt; 4 Direct               children  1038  12.8 
&gt; 5 Corporate            none      3421  98.9 
&gt; 6 Corporate            children    38   1.10
&gt; 7 GDS                  none       108 100   
&gt; 8 Undefined            children     1 100
```


---

# Variable reserved_room_type

La variable `reserved_room_type` toma **.bg-purple_light[9 modalidades]** (no nos especifican si hay jerarqu√≠a) pero **.bg-purple_light[solo 5 de ellas tienen un peso superior al 1%]** de los registros.


```r
hoteles %&gt;%
  count(reserved_room_type, sort = TRUE) %&gt;%
  mutate(porc = 100*n/sum(n),
         cumul = cumsum(porc))
```

```
&gt; # A tibble: 9 √ó 4
&gt;   reserved_room_type     n   porc cumul
&gt;   &lt;fct&gt;              &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;
&gt; 1 A                  34889 69.8    69.8
&gt; 2 D                   8675 17.4    87.1
&gt; 3 E                   3096  6.19   93.3
&gt; 4 F                   1299  2.60   95.9
&gt; 5 G                    899  1.80   97.7
&gt; 6 B                    488  0.976  98.7
&gt; 7 C                    417  0.834  99.5
&gt; 8 H                    235  0.47  100. 
&gt; 9 L                      2  0.004 100
```

---

# Variable reserved_room_type

F√≠jate que `reserved_room_type` ser√° **.bg-purple_light[tremendamente importante]**: si la habitaci√≥n es de tipo F, el 47% viene con ni√±os (frente al 8% global), del 70% incluso si es de tipo C


```r
hoteles %&gt;%
  group_by(reserved_room_type) %&gt;% 
  count(children) %&gt;% 
  mutate(porc = 100*n/sum(n)) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 17 √ó 4
&gt;    reserved_room_type children     n   porc
&gt;    &lt;fct&gt;              &lt;fct&gt;    &lt;int&gt;  &lt;dbl&gt;
&gt;  1 A                  none     33364  95.6 
&gt;  2 A                  children  1525   4.37
&gt;  3 D                  none      8210  94.6 
&gt;  4 D                  children   465   5.36
&gt;  5 F                  none       677  52.1 
&gt;  6 F                  children   622  47.9 
&gt;  7 C                  none       125  30.0 
&gt;  8 C                  children   292  70.0 
&gt;  9 B                  none       353  72.3 
&gt; 10 B                  children   135  27.7 
&gt; 11 E                  none      2828  91.3 
&gt; 12 E                  children   268   8.66
&gt; 13 G                  none       341  37.9 
&gt; 14 G                  children   558  62.1 
&gt; 15 H                  none        62  26.4 
&gt; 16 H                  children   173  73.6 
&gt; 17 L                  none         2 100
```

---

# Variable assigned_room_type

La variable `assigned_room_type` toma **.bg-purple_light[10 modalidades]** (no nos especifican si hay jerarqu√≠a) pero solo 7 de ellas tienen un peso superior al 1% de los registros.


```r
hoteles %&gt;%
  count(assigned_room_type, sort = TRUE) %&gt;%
  mutate(porc = 100*n/sum(n),
         cumul = cumsum(porc))
```

```
&gt; # A tibble: 10 √ó 4
&gt;    assigned_room_type     n   porc cumul
&gt;    &lt;fct&gt;              &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;
&gt;  1 A                  27357 54.7    54.7
&gt;  2 D                  12577 25.2    79.9
&gt;  3 E                   3924  7.85   87.7
&gt;  4 F                   1839  3.68   91.4
&gt;  5 C                   1305  2.61   94.0
&gt;  6 G                   1185  2.37   96.4
&gt;  7 B                   1079  2.16   98.5
&gt;  8 H                    313  0.626  99.2
&gt;  9 I                    239  0.478  99.6
&gt; 10 K                    182  0.364 100
```

Como suced√≠a antes `assigned_room_type` ser√° tremendamente importante

---

# Variable reserved_room_type vs assigned_room_type

Quiz√°s sea interesante, al margen del tipo de habitaci√≥n, ver que sucede cuando la **.bg-purple_light[asignada es distinta de la reservada]**. 


```r
hoteles %&gt;%
  mutate(same_room = as.character(reserved_room_type) == as.character(assigned_room_type)) %&gt;%
  group_by(same_room) %&gt;% 
  count(children) %&gt;% 
  mutate(porc = 100*n/sum(n)) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 4 √ó 4
&gt;   same_room children     n  porc
&gt;   &lt;lgl&gt;     &lt;fct&gt;    &lt;int&gt; &lt;dbl&gt;
&gt; 1 FALSE     none      8601 91.5 
&gt; 2 FALSE     children   794  8.45
&gt; 3 TRUE      none     37361 92.0 
&gt; 4 TRUE      children  3244  7.99
```

No parece que influya significativamente

---

# Variable deposit_type

La variable `deposit_type` toma **.bg-purple_light[3 modalidades]** pero el 99.6% de los registros es la misma.


```r
hoteles %&gt;%
  count(deposit_type, sort = TRUE) %&gt;%
  mutate(porc = 100*n/sum(n), cumul = cumsum(porc))
```

```
&gt; # A tibble: 3 √ó 4
&gt;   deposit_type     n   porc cumul
&gt;   &lt;fct&gt;        &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;
&gt; 1 No_Deposit   49839 99.7    99.7
&gt; 2 Refundable      92  0.184  99.9
&gt; 3 Non_Refund      69  0.138 100
```

---

# Variable deposit_type

Adem√°s de ser **.bg-purple_light[muy pocos]** los registros que no sean `No_Deposit`, pr√°cticamente su totalidad son **.bg-purple_light[sin ni√±os]** (clase ya mayoritaria en los datos).


```r
hoteles %&gt;%
  group_by(deposit_type) %&gt;% 
  count(children) %&gt;% 
  mutate(porc = 100*n/sum(n)) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 6 √ó 4
&gt;   deposit_type children     n  porc
&gt;   &lt;fct&gt;        &lt;fct&gt;    &lt;int&gt; &lt;dbl&gt;
&gt; 1 No_Deposit   none     45803 91.9 
&gt; 2 No_Deposit   children  4036  8.10
&gt; 3 Refundable   none        91 98.9 
&gt; 4 Refundable   children     1  1.09
&gt; 5 Non_Refund   none        68 98.6 
&gt; 6 Non_Refund   children     1  1.45
```

---

# Variable deposit_type

La variable `customer_type` toma **.bg-purple_light[4 modalidades]** pero **.bg-purple_light[dos de ellas representan m√°s del 95%]** de los registros.


```r
hoteles %&gt;%
  count(customer_type, sort = TRUE) %&gt;%
  mutate(porc = 100*n/sum(n),
         cumul = cumsum(porc))
```

```
&gt; # A tibble: 4 √ó 4
&gt;   customer_type       n   porc cumul
&gt;   &lt;fct&gt;           &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;
&gt; 1 Transient       35343 70.7    70.7
&gt; 2 Transient-Party 12430 24.9    95.5
&gt; 3 Contract         1864  3.73   99.3
&gt; 4 Group             363  0.726 100
```

---

# Variable deposit_type

El 88% de las reservas con ni√±os son de tipo `"Transient"`


```r
hoteles %&gt;%
  group_by(children) %&gt;% 
  count(customer_type) %&gt;% 
  mutate(porc = 100*n/sum(n)) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 8 √ó 4
&gt;   children customer_type       n   porc
&gt;   &lt;fct&gt;    &lt;fct&gt;           &lt;int&gt;  &lt;dbl&gt;
&gt; 1 none     Transient-Party 12075 26.3  
&gt; 2 none     Transient       31779 69.1  
&gt; 3 none     Contract         1762  3.83 
&gt; 4 none     Group             346  0.753
&gt; 5 children Transient-Party   355  8.79 
&gt; 6 children Transient        3564 88.3  
&gt; 7 children Contract          102  2.53 
&gt; 8 children Group              17  0.421
```


---


# Variable required_car_parking_spaces

La variable `required_car_parking_spaces` es binaria (muy desbalanceada).


```r
hoteles %&gt;%
  count(required_car_parking_spaces, sort = TRUE) %&gt;%
  mutate(porc = 100*n/sum(n),
         cumul = cumsum(porc))
```

```
&gt; # A tibble: 2 √ó 4
&gt;   required_car_parking_spaces     n  porc cumul
&gt;   &lt;fct&gt;                       &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
&gt; 1 none                        45019 90.0   90.0
&gt; 2 parking                      4981  9.96 100
```

---

# Variable required_car_parking_spaces

El % de las reservas con ni√±os es el doble cuando hay parking solicitado.


```r
hoteles %&gt;%
  group_by(children) %&gt;% 
  count(required_car_parking_spaces) %&gt;% 
  mutate(porc = 100*n/sum(n)) %&gt;% 
  ungroup()
```

```
&gt; # A tibble: 4 √ó 4
&gt;   children required_car_parking_spaces     n  porc
&gt;   &lt;fct&gt;    &lt;fct&gt;                       &lt;int&gt; &lt;dbl&gt;
&gt; 1 none     none                        41708 90.7 
&gt; 2 none     parking                      4254  9.26
&gt; 3 children none                         3311 82.0 
&gt; 4 children parking                       727 18.0
```

---

# Dependencia entre variables cualitativas

M√°s all√° del an√°lisis exploratorio num√©rico, podemos ejecutar un **.bg-purple_light[contraste de independencia]** (prueba `\(\chi^2\)` de independencia) para tener mayor certeza de si la predictora es dependiente o no de la variable objetivo (si fuera independiente, no tendr√≠a sentido mantenerla)


```r
chisq.test(hoteles$children, hoteles$hotel)
```

```
&gt; 
&gt; 	Pearson's Chi-squared test with Yates' continuity correction
&gt; 
&gt; data:  hoteles$children and hoteles$hotel
&gt; X-squared = 14.796, df = 1, p-value = 0.0001198
```

Si fijamos `\(\alpha = 0.05\)` (nivel de significaci√≥n), si p-valor &lt; 0.05 deber√≠amos rechazar la **.bg-purple_light[hip√≥tesis nula de independencia]** (bajo dicho nivel).

---

# Dependencia entre variables cualitativas


Podemos hacerlo con **.bg-purple_light[todas las variables a la vez]** enfrent√°ndola a la objetivo


```r
chisq &lt;-
  tibble("variable" = hoteles %&gt;% select(where(is.factor)) %&gt;% names(),
         "p_value" = hoteles %&gt;% select(where(is.factor)) %&gt;%
           map_dbl(.f = function(x) { chisq.test(hoteles$children, x)$p.value}))
chisq %&gt;% arrange(desc(p_value))
```

```
&gt; # A tibble: 11 √ó 2
&gt;    variable                      p_value
&gt;    &lt;chr&gt;                           &lt;dbl&gt;
&gt;  1 deposit_type                6.20e-  3
&gt;  2 hotel                       1.20e-  4
&gt;  3 country                     1.60e- 40
&gt;  4 meal                        4.23e- 55
&gt;  5 required_car_parking_spaces 1.22e- 70
&gt;  6 distribution_channel        3.17e-107
&gt;  7 customer_type               4.39e-145
&gt;  8 market_segment              8.40e-292
&gt;  9 children                    0        
&gt; 10 reserved_room_type          0        
&gt; 11 assigned_room_type          0
```

---

# Dependencia entre variables cualitativas




```r
chisq %&gt;% filter(p_value &gt; 0.05)
```

```
&gt; # A tibble: 0 √ó 2
&gt; # ‚Ä¶ with 2 variables: variable &lt;chr&gt;, p_value &lt;dbl&gt;
&gt; # ‚Ñπ Use `colnames()` to see all variable names
```

**.bg-purple_light[No hay evidencia suficiente para decir que existe predictora independiente de la objetivo]** (al 95% de confianza) seg√∫n la prueba de independencia realizada

---

# Resumen de las variables cuali

* `hotel` --&gt; **.bg-purple_light[no hacer nada]**.

* `meal`: aunque haya pocos registros de `meal = "FB"`, parece que pueden ser determinantes --&gt; **.bg-purple_light[reagrupar "Undefined" con "SC" y dejar "FB"]**.

* `country`: tan solo 21 de ellas aparecen en m√°s del 0.5% de registros (una de ellas es NULL) --&gt; **.bg-purple_light[reagrupar niveles de pa√≠ses minoritarios]** (representan juntos aprox el 10% del total) qued√°ndonos con aquellos que superen en un m√≠nimo de representatividad (m√°s fino: incluir tambi√©n los que sean m√°s propensos que otros a reservas con ni√±os).

* `market_segment`:  algunas representan menos del 1% del total, aunque para `market_segment = "Aviation"` el 100% son sin ni√±os (casi similar con `market_segment = "Corporate"` y `market_segment = "Groups"`) --&gt; **.bg-purple_light[agrupar los 3 junto con "complementary"]** (pesan muy poco estos √∫ltimos) en un `"others"`.

* `distribution_channel`: solo 3 de ellas agrupan ya m√°s del 99% de los registros --&gt; **.bg-purple_light[reagrupar "Corporate" (98.9% no children), "GDS" (100%  no children) y "Undefined" (solo 1 dato)]** en `"others"` (aprox. el 7% de los datos).

---

# Resumen de las variables cuali


* `reserved_room_type`: solo 5 de ellas tienen un peso superior al 1% de los registros, si es de tipo **.bg-purple_light[C, H o L]** (juntas suman el 1.3% de los datos aprox.), con ni√±os superan el 70% --&gt; **.bg-purple_light[reagrupamos las 3]** en un `"others"`

* `assigned_room_type`: con el mismo razonamiento que antes podemos **.bg-purple_light[reaagupar las categor√≠as H-I-K]** en `"others"` 

* `deposit_type`: el 99.6% de registros es la misma --&gt;  muy poca varianza y adem√°s casi todos de esas clases minoritarias son de la clase mayoritaria de la  objetivo  --&gt; **.bg-purple_light[eliminar]**

* `customer_type` --&gt; **.bg-purple_light[reagrupar "Transient" y "others"]**

* `required_car_parking_spaces` --&gt; **.bg-purple_light[no hacer nada]**


---

# Variables de tipo de fecha

Solo tenemos una `arrival_date`: ¬øqu√© parte de la fecha exactamente influye m√°s? ¬øEl a√±o? ¬øEl mes? ¬øEl d√≠a como n√∫mero en s√≠ o el d√≠a de la semana? Tras extraer info la eliminaremos.


```r
hoteles &lt;- 
  hoteles %&gt;% 
  mutate(m_arr = month(arrival_date), y_arr = year(arrival_date),
         wday_arr = wday(arrival_date))

hoteles %&gt;% group_by(y_arr) %&gt;% count(children) %&gt;% 
  mutate(porc = 100*n/sum(n))
```

```
&gt; # A tibble: 6 √ó 4
&gt; # Groups:   y_arr [3]
&gt;   y_arr children     n  porc
&gt;   &lt;dbl&gt; &lt;fct&gt;    &lt;int&gt; &lt;dbl&gt;
&gt; 1  2015 none      8623 93.9 
&gt; 2  2015 children   562  6.12
&gt; 3  2016 none     22161 91.8 
&gt; 4  2016 children  1981  8.21
&gt; 5  2017 none     15178 91.0 
&gt; 6  2017 children  1495  8.97
```

No parece que el a√±o influya mucho (veremos si influyen los d√≠as festivos en s√≠)

---

# Variables de tipo de fecha

Parece que los meses de julio, agosto y diciembre influye mucho al tener m√°s ni√±os --&gt; podemos agrupar los meses en `"month_holy"` y `"month_no_holy"`


```r
hoteles %&gt;%  group_by(m_arr) %&gt;% count(children) %&gt;% 
  mutate(porc = 100*n/sum(n))
```

```
&gt; # A tibble: 24 √ó 4
&gt; # Groups:   m_arr [12]
&gt;    m_arr children     n  porc
&gt;    &lt;dbl&gt; &lt;fct&gt;    &lt;int&gt; &lt;dbl&gt;
&gt;  1     1 none      2586 94.5 
&gt;  2     1 children   150  5.48
&gt;  3     2 none      3261 91.5 
&gt;  4     2 children   302  8.48
&gt;  5     3 none      4195 94.7 
&gt;  6     3 children   237  5.35
&gt;  7     4 none      4022 92.4 
&gt;  8     4 children   331  7.60
&gt;  9     5 none      4538 94.8 
&gt; 10     5 children   249  5.20
&gt; # ‚Ä¶ with 14 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```


---

# Variables de tipo de fecha

Parece que los viernes, s√°bados y domingos hay m√°s reservas con ni√±os --&gt; podemos agrupar los meses en `"weekend"` y `"workday"`


```r
hoteles %&gt;%  group_by(wday_arr) %&gt;%  count(children) %&gt;% 
  mutate(porc = 100*n/sum(n))
```

```
&gt; # A tibble: 14 √ó 4
&gt; # Groups:   wday_arr [7]
&gt;    wday_arr children     n  porc
&gt;       &lt;dbl&gt; &lt;fct&gt;    &lt;int&gt; &lt;dbl&gt;
&gt;  1        1 none      5768 91.5 
&gt;  2        1 children   537  8.52
&gt;  3        2 none      7324 92.1 
&gt;  4        2 children   628  7.90
&gt;  5        3 none      5777 92.7 
&gt;  6        3 children   456  7.32
&gt;  7        4 none      6468 93.7 
&gt;  8        4 children   432  6.26
&gt;  9        5 none      6969 92.3 
&gt; 10        5 children   579  7.67
&gt; 11        6 none      7094 92.0 
&gt; 12        6 children   620  8.04
&gt; 13        7 none      6562 89.3 
&gt; 14        7 children   786 10.7
```

---

# Variables num√©ricas

* `lead_time`: variable con una alta concentraci√≥n a la izquierda (cola pesada a la derecha), con un m√°ximo de d√≠as muy elevado.


```r
hoteles %&gt;% summarise(min_lead = min(lead_time), max_lead = max(lead_time))
```

```
&gt; # A tibble: 1 √ó 2
&gt;   min_lead max_lead
&gt;      &lt;dbl&gt;    &lt;dbl&gt;
&gt; 1        0      709
```

--

Quizas no tenga sentido tanto n√∫mero de d√≠as entre la reserva y la estancia --&gt; todo lo que **.bg-purple_light[supere 365, imputarle 366]** (representan adem√°s el 1.35% solo)


```r
hoteles %&gt;% group_by(lead_time &gt; 365) %&gt;% count()
```

```
&gt; # A tibble: 2 √ó 2
&gt; # Groups:   lead_time &gt; 365 [2]
&gt;   `lead_time &gt; 365`     n
&gt;   &lt;lgl&gt;             &lt;int&gt;
&gt; 1 FALSE             49326
&gt; 2 TRUE                674
```

---

# Variables num√©ricas

* `stays_in_weekend_nights`: en realidad es una variable cualitativa m√°s que cuantitativa, y a partir de 2 noches en festivo representa menos de 1% --&gt; podr√≠amos probar a **.bg-purple_light[dejarla tal cual o recategorizarla en 4 categor√≠as]** (ninguna - 1 - 2 - m√°s de 2)


```r
hoteles %&gt;%
  count(stays_in_weekend_nights, sort = TRUE) %&gt;% 
  mutate(porc = 100*n/sum(n), cumul = cumsum(porc))
```

```
&gt; # A tibble: 17 √ó 4
&gt;    stays_in_weekend_nights     n   porc cumul
&gt;                      &lt;dbl&gt; &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;
&gt;  1                       0 21640 43.3    43.3
&gt;  2                       2 13840 27.7    71.0
&gt;  3                       1 13031 26.1    97.0
&gt;  4                       4   826  1.65   98.7
&gt;  5                       3   564  1.13   99.8
&gt;  6                       6    41  0.082  99.9
&gt;  7                       5    22  0.044  99.9
&gt;  8                       8    18  0.036 100. 
&gt;  9                      10     4  0.008 100. 
&gt; 10                       7     2  0.004 100. 
&gt; 11                       9     2  0.004 100. 
&gt; 12                      12     2  0.004 100. 
&gt; 13                      13     2  0.004 100. 
&gt; 14                      14     2  0.004 100. 
&gt; 15                      16     2  0.004 100. 
&gt; 16                      18     1  0.002 100. 
&gt; 17                      19     1  0.002 100
```

---

# Variables num√©ricas

* `stays_in_week_nights`: en realidad es una variable cualitativa m√°s que cuantitativa, y a partir de 5 noches representa menos del 5% --&gt; podr√≠amos probar a **.bg-purple_light[dejarla tal cual o recategorizarla en 7 categor√≠as]** (ninguna - 1 - 2 - 3 - 4 - 5 - m√°s de 5)


```r
hoteles %&gt;%
  count(stays_in_week_nights, sort = TRUE) %&gt;% 
  mutate(porc = 100*n/sum(n), cumul = cumsum(porc))
```

```
&gt; # A tibble: 31 √ó 4
&gt;    stays_in_week_nights     n   porc cumul
&gt;                   &lt;dbl&gt; &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;
&gt;  1                    1 13619 27.2    27.2
&gt;  2                    2 12513 25.0    52.3
&gt;  3                    3  9161 18.3    70.6
&gt;  4                    5  4779  9.56   80.1
&gt;  5                    4  4020  8.04   88.2
&gt;  6                    0  3818  7.64   95.8
&gt;  7                    6   616  1.23   97.1
&gt;  8                   10   488  0.976  98.0
&gt;  9                    7   481  0.962  99.0
&gt; 10                    8   303  0.606  99.6
&gt; # ‚Ä¶ with 21 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---

# Variables num√©ricas

* `adults`: en realidad es una variable cualitativa m√°s que cuantitativa --&gt; podr√≠amos probar a **.bg-purple_light[dejarla tal cual o recategorizarla en 4 categor√≠as]** (ninguno - 1 - 2 - m√°s de 2)


```r
hoteles %&gt;% count(adults, sort = TRUE) %&gt;% 
  mutate(porc = 100*n/sum(n), cumul = cumsum(porc))
```

```
&gt; # A tibble: 5 √ó 4
&gt;   adults     n   porc cumul
&gt;    &lt;dbl&gt; &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;
&gt; 1      2 36271 72.5    72.5
&gt; 2      1 10831 21.7    94.2
&gt; 3      3  2675  5.35   99.6
&gt; 4      0   194  0.388  99.9
&gt; 5      4    29  0.058 100
```

---

# Variables num√©ricas

* `is_repeated_guest`: en realidad es **.bg-purple_light[binaria]** --&gt; hay que convertirla a cualitativa (factor)


```r
hoteles %&gt;% count(is_repeated_guest, sort = TRUE) %&gt;% mutate(porc = 100*n/sum(n))
```

```
&gt; # A tibble: 2 √ó 3
&gt;   is_repeated_guest     n  porc
&gt;               &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt;
&gt; 1                 0 47840 95.7 
&gt; 2                 1  2160  4.32
```

```r
hoteles %&gt;% group_by(is_repeated_guest) %&gt;% count(children) %&gt;% 
  mutate(porc = 100*n/sum(n)) %&gt;% ungroup()
```

```
&gt; # A tibble: 4 √ó 4
&gt;   is_repeated_guest children     n  porc
&gt;               &lt;dbl&gt; &lt;fct&gt;    &lt;int&gt; &lt;dbl&gt;
&gt; 1                 0 none     43863 91.7 
&gt; 2                 0 children  3977  8.31
&gt; 3                 1 none      2099 97.2 
&gt; 4                 1 children    61  2.82
```

---

# Variables num√©ricas

* `previous_cancellations`: el 99.238% son 0 (y la mayor√≠a de 1, sin ni√±os) --&gt; **.bg-purple_light[eliminar]**

* `previous_bookings_not_canceled`: el 95.47% son 0, el 1.9% son 1 --&gt; se podr√≠a probar a **.bg-purple_light[dejarla tal cual o recategorizar en 3 categor√≠as]**


```r
hoteles %&gt;% count(previous_cancellations == 0, sort = TRUE)
```

```
&gt; # A tibble: 2 √ó 2
&gt;   `previous_cancellations == 0`     n
&gt;   &lt;lgl&gt;                         &lt;int&gt;
&gt; 1 TRUE                          49619
&gt; 2 FALSE                           381
```

```r
hoteles %&gt;% count(previous_bookings_not_canceled, sort = TRUE) %&gt;%
  mutate(porc = 100*n/sum(n), cumul = cumsum(porc))
```

```
&gt; # A tibble: 57 √ó 4
&gt;    previous_bookings_not_canceled     n   porc cumul
&gt;                             &lt;dbl&gt; &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;
&gt;  1                              0 47735 95.5    95.5
&gt;  2                              1   956  1.91   97.4
&gt;  3                              2   370  0.74   98.1
&gt;  4                              3   210  0.42   98.5
&gt;  5                              4   148  0.296  98.8
&gt;  6                              5   112  0.224  99.1
&gt;  7                              6    76  0.152  99.2
&gt;  8                              7    50  0.1    99.3
&gt;  9                              9    42  0.084  99.4
&gt; 10                              8    39  0.078  99.5
&gt; # ‚Ä¶ with 47 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```


---

# Variables num√©ricas

* `booking_changes`: el 94.194% son 0 o 1 --&gt; se podr√≠a probar a **.bg-purple_light[dejarla num√©rica o recategorizar en 3 categor√≠as]**


```r
hoteles %&gt;% count(booking_changes, sort = TRUE) %&gt;% 
  mutate(porc = 100*n/sum(n), cumul = cumsum(porc))
```

```
&gt; # A tibble: 19 √ó 4
&gt;    booking_changes     n   porc cumul
&gt;              &lt;dbl&gt; &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;
&gt;  1               0 39823 79.6    79.6
&gt;  2               1  7274 14.5    94.2
&gt;  3               2  2018  4.04   98.2
&gt;  4               3   523  1.05   99.3
&gt;  5               4   212  0.424  99.7
&gt;  6               5    71  0.142  99.8
&gt;  7               6    31  0.062  99.9
&gt;  8               7    13  0.026  99.9
&gt;  9               8    11  0.022 100. 
&gt; 10               9     6  0.012 100. 
&gt; 11              10     4  0.008 100. 
&gt; 12              13     3  0.006 100. 
&gt; 13              15     3  0.006 100. 
&gt; 14              11     2  0.004 100. 
&gt; 15              17     2  0.004 100. 
&gt; 16              12     1  0.002 100. 
&gt; 17              16     1  0.002 100. 
&gt; 18              18     1  0.002 100. 
&gt; 19              21     1  0.002 100
```

---

# Variables num√©ricas

* `days_in_waiting_list`: el 98% de los registros son 0 (y de los que no son casi todos no tienen ni√±os) --&gt; **.bg-purple_light[eliminar variable]**


```r
hoteles %&gt;% count(days_in_waiting_list, sort = TRUE) %&gt;% 
  mutate(porc = 100*n/sum(n), cumul = cumsum(porc))
```

```
&gt; # A tibble: 92 √ó 4
&gt;    days_in_waiting_list     n   porc cumul
&gt;                   &lt;dbl&gt; &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;
&gt;  1                    0 49116 98.2    98.2
&gt;  2                   58   114  0.228  98.5
&gt;  3                   87    47  0.094  98.6
&gt;  4                   38    34  0.068  98.6
&gt;  5                   63    34  0.068  98.7
&gt;  6                  122    33  0.066  98.8
&gt;  7                   65    26  0.052  98.8
&gt;  8                  223    26  0.052  98.9
&gt;  9                   77    25  0.05   98.9
&gt; 10                   44    22  0.044  99.0
&gt; # ‚Ä¶ with 82 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---

# Variables num√©ricas

* `average_daily_rate`: es la √∫nica num√©rica continua pero tiene **.bg-purple_light[valores negativos o cero]** (deber√≠an ser estrictamente positivo) --&gt; el 2.33% tiene **.bg-purple_light[problemas de codificaci√≥n o rango]** que deberemos pasar a ausentes e imputarles un valores luego.


```r
hoteles %&gt;% count(average_daily_rate &lt;= 0) %&gt;% mutate(porc = 100*n/sum(n))
```

```
&gt; # A tibble: 2 √ó 3
&gt;   `average_daily_rate &lt;= 0`     n  porc
&gt;   &lt;lgl&gt;                     &lt;int&gt; &lt;dbl&gt;
&gt; 1 FALSE                     48833 97.7 
&gt; 2 TRUE                       1167  2.33
```

---

# Variables num√©ricas

* `total_of_special_requests`: m√°s del 96% son 0-1-2 --&gt; se podr√≠a **.bg-purple_light[dejar num√©rica o recategorizarla en 4 categor√≠as]**.


```r
hoteles %&gt;% count(total_of_special_requests, sort = TRUE) %&gt;% 
  mutate(porc = 100*n/sum(n), cumul = cumsum(porc))
```

```
&gt; # A tibble: 6 √ó 4
&gt;   total_of_special_requests     n   porc cumul
&gt;                       &lt;dbl&gt; &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;
&gt; 1                         0 24493 49.0    49.0
&gt; 2                         1 17234 34.5    83.5
&gt; 3                         2  6679 13.4    96.8
&gt; 4                         3  1358  2.72   99.5
&gt; 5                         4   213  0.426 100. 
&gt; 6                         5    23  0.046 100
```

---

# .orange[COLINEALIDAD]

Por √∫ltimo, nos falta comprobar los **.bg-purple_light[problemas de  colinealidad]** entre las predictoras num√©ricas. 

Podemos tratar las **.bg-orange[num√©ricas por separado]** (aunque tengamos muchas que en realidad hacen m√°s de cuali que de cuanti)


```r
library(corrr)
cor_matrix &lt;- hoteles %&gt;% select(where(is.numeric)) %&gt;% cor() %&gt;% round(2)
cor_matrix
```

```
&gt;                                lead_time stays_in_weekend_nights
&gt; lead_time                           1.00                    0.19
&gt; stays_in_weekend_nights             0.19                    1.00
&gt; stays_in_week_nights                0.28                    0.51
&gt; adults                              0.14                    0.13
&gt; is_repeated_guest                  -0.15                   -0.10
&gt; previous_cancellations             -0.04                   -0.02
&gt; previous_bookings_not_canceled     -0.08                   -0.05
&gt; booking_changes                     0.09                    0.07
&gt; days_in_waiting_list                0.18                   -0.05
&gt; average_daily_rate                  0.02                    0.04
&gt; total_of_special_requests           0.04                    0.07
&gt; m_arr                               0.10                    0.03
&gt; y_arr                               0.11                    0.01
&gt; wday_arr                            0.05                   -0.14
&gt;                                stays_in_week_nights adults is_repeated_guest
&gt; lead_time                                      0.28   0.14             -0.15
&gt; stays_in_weekend_nights                        0.51   0.13             -0.10
&gt; stays_in_week_nights                           1.00   0.13             -0.11
&gt; adults                                         0.13   1.00             -0.21
&gt; is_repeated_guest                             -0.11  -0.21              1.00
&gt; previous_cancellations                        -0.03  -0.06              0.25
&gt; previous_bookings_not_canceled                -0.06  -0.15              0.44
&gt; booking_changes                                0.12  -0.07              0.00
&gt; days_in_waiting_list                           0.01  -0.01             -0.02
&gt; average_daily_rate                             0.05   0.33             -0.16
&gt; total_of_special_requests                      0.06   0.20              0.00
&gt; m_arr                                          0.03   0.04             -0.05
&gt; y_arr                                          0.01   0.04              0.06
&gt; wday_arr                                      -0.01   0.06             -0.05
&gt;                                previous_cancellations
&gt; lead_time                                       -0.04
&gt; stays_in_weekend_nights                         -0.02
&gt; stays_in_week_nights                            -0.03
&gt; adults                                          -0.06
&gt; is_repeated_guest                                0.25
&gt; previous_cancellations                           1.00
&gt; previous_bookings_not_canceled                   0.52
&gt; booking_changes                                  0.00
&gt; days_in_waiting_list                            -0.01
&gt; average_daily_rate                              -0.04
&gt; total_of_special_requests                        0.02
&gt; m_arr                                           -0.03
&gt; y_arr                                            0.01
&gt; wday_arr                                        -0.01
&gt;                                previous_bookings_not_canceled booking_changes
&gt; lead_time                                               -0.08            0.09
&gt; stays_in_weekend_nights                                 -0.05            0.07
&gt; stays_in_week_nights                                    -0.06            0.12
&gt; adults                                                  -0.15           -0.07
&gt; is_repeated_guest                                        0.44            0.00
&gt; previous_cancellations                                   0.52            0.00
&gt; previous_bookings_not_canceled                           1.00            0.00
&gt; booking_changes                                          0.00            1.00
&gt; days_in_waiting_list                                    -0.01            0.00
&gt; average_daily_rate                                      -0.09            0.01
&gt; total_of_special_requests                                0.03            0.00
&gt; m_arr                                                   -0.03            0.00
&gt; y_arr                                                    0.04            0.03
&gt; wday_arr                                                -0.04            0.01
&gt;                                days_in_waiting_list average_daily_rate
&gt; lead_time                                      0.18               0.02
&gt; stays_in_weekend_nights                       -0.05               0.04
&gt; stays_in_week_nights                           0.01               0.05
&gt; adults                                        -0.01               0.33
&gt; is_repeated_guest                             -0.02              -0.16
&gt; previous_cancellations                        -0.01              -0.04
&gt; previous_bookings_not_canceled                -0.01              -0.09
&gt; booking_changes                                0.00               0.01
&gt; days_in_waiting_list                           1.00              -0.03
&gt; average_daily_rate                            -0.03               1.00
&gt; total_of_special_requests                     -0.07               0.22
&gt; m_arr                                          0.05               0.11
&gt; y_arr                                         -0.06               0.17
&gt; wday_arr                                       0.01               0.01
&gt;                                total_of_special_requests m_arr y_arr wday_arr
&gt; lead_time                                           0.04  0.10  0.11     0.05
&gt; stays_in_weekend_nights                             0.07  0.03  0.01    -0.14
&gt; stays_in_week_nights                                0.06  0.03  0.01    -0.01
&gt; adults                                              0.20  0.04  0.04     0.06
&gt; is_repeated_guest                                   0.00 -0.05  0.06    -0.05
&gt; previous_cancellations                              0.02 -0.03  0.01    -0.01
&gt; previous_bookings_not_canceled                      0.03 -0.03  0.04    -0.04
&gt; booking_changes                                     0.00  0.00  0.03     0.01
&gt; days_in_waiting_list                               -0.07  0.05 -0.06     0.01
&gt; average_daily_rate                                  0.22  0.11  0.17     0.01
&gt; total_of_special_requests                           1.00  0.03  0.12     0.01
&gt; m_arr                                               0.03  1.00 -0.53     0.00
&gt; y_arr                                               0.12 -0.53  1.00    -0.03
&gt; wday_arr                                            0.01  0.00 -0.03     1.00
```

---

# .orange[COLINEALIDAD]


```r
cor_matrix %&gt;%
  corrplot(method = "number", tl.cex = 0.55, number.cex = 0.7, type = "lower")
```

&lt;img src="./img/cor_hoteles.jpg" width="40%" style="display: block; margin: auto;" /&gt;

No parece existir una correlaci√≥n elevada entre ninguna.

---

name: fase3-hoteles

# Fase 3: .orange[MODIFICACI√ìN]

Con lo observado en la fase de exploraci√≥n deberemos tomar **.bg-purple_light[dos tipos decisiones]**:

* las que afectan a la **.bg-orange[base de datos en general]**: pasar a factores, problemas de codificaci√≥n o rango, variables que no aportan, creaci√≥n de variables en general, etc

* las que afectan a un **.bg-orange[algoritmo en concreto]**: normalizaci√≥n para la m√©trica, recategorizaci√≥n, tratamiento de outliers/ausentes, dummyficaci√≥n, etc.

---

# Fase 1: .orange[MUESTREO]

Pero antes...¬øhace falta **.bg-purple_light[muestreo]**? Parece que s√≠ dado que tenemos muchas filas (al menos para hacer pruebas) --&gt; muestreo **.bg-purple_light[estratificado]** (por ej., del 10%)


```r
hoteles_sample &lt;-
  hoteles %&gt;%
  group_by(children) %&gt;% 
  slice_sample(prop = 0.10) %&gt;%
  ungroup()

hoteles_sample %&gt;%
  count(children) %&gt;% 
  mutate(porc = 100*n/sum(n))
```

```
&gt; # A tibble: 2 √ó 3
&gt;   children     n  porc
&gt;   &lt;fct&gt;    &lt;int&gt; &lt;dbl&gt;
&gt; 1 none      4596 91.9 
&gt; 2 children   403  8.06
```



---

# Fase 3: .orange[MODIFICACI√ìN] (fuera receta)

* **.bg-purple_light[Selecci√≥n de variables]**: eliminamos aquellas cuya varianza es tan √≠nfima (y sin influencia real en la variable objetivo a nivel globla) que solo nos aporta ruido


```r
# Eliminar variables
hoteles_sample &lt;-
  hoteles_sample %&gt;%
* select(-c(deposit_type, days_in_waiting_list, previous_cancellations))
```

---

# Fase 3: .orange[MODIFICACI√ìN] (fuera receta)

* **.bg-purple_light[Convertimos a cuali]**: debemos siempre de tratar a cada variable como lo que es, as√≠ que toda variable de tipo texto que sea una variable estad√≠stica cualitativa deber√° ser convertida a factor (y de manera ordinal en caso de lo que sean)


```r
# Convertir a cuali
hoteles_sample &lt;-
  hoteles_sample %&gt;% 
  mutate(across(where(is.character), as_factor)) %&gt;%
  mutate(meal = factor(meal, levels = c("Undefined", "SC", "BB", "HB", "FB"),
                       ordered = TRUE))
```

---

# Fase 3: .orange[MODIFICACI√ìN] (fuera receta)

* **.bg-purple_light[Modificamos variables existentes]**: resolvemos fuera de la receta problemas de codificaci√≥n o rango ya que son errores intr√≠nsecos de la tabla.


```r
# Modificaciones de variables existentes
hoteles_sample &lt;-
  hoteles_sample %&gt;% 
  mutate(lead_time = ifelse(lead_time &gt; 365, 366, lead_time),
         average_daily_rate = ifelse(average_daily_rate &lt;= 0, NA, average_daily_rate),
         is_repeated_guest = as_factor(is_repeated_guest))
```

---

# .orange[RECETA]: .green[PARTICI√ìN]

Tras resolver esos problemas fuera de la receta dividimos en **.bg-purple_light[test y lo dem√°s]**, con `initial_split()`


```r
# Partici√≥n 10% de test
hoteles_split &lt;- initial_split(hoteles_sample, strata = children, prop = 0.9)
hoteles_split
```

```
&gt; &lt;Analysis/Assess/Total&gt;
&gt; &lt;4499/500/4999&gt;
```

```r
# Aplicamos partici√≥n
hoteles_train &lt;- training(hoteles_split)
hoteles_test &lt;- testing(hoteles_split)
```

---

# .orange[RECETA]: .green[PARTICI√ìN]


Podemos comprobar que los estratos se han mantenido.


```r
# Comprobamos estratos
hoteles_train %&gt;% count(children) %&gt;% mutate(porc = 100 * n / sum(n))
```

```
&gt; # A tibble: 2 √ó 3
&gt;   children     n  porc
&gt;   &lt;fct&gt;    &lt;int&gt; &lt;dbl&gt;
&gt; 1 none      4134 91.9 
&gt; 2 children   365  8.11
```

```r
hoteles_test %&gt;% count(children) %&gt;% mutate(porc = 100 * n / sum(n))
```

```
&gt; # A tibble: 2 √ó 3
&gt;   children     n  porc
&gt;   &lt;fct&gt;    &lt;int&gt; &lt;dbl&gt;
&gt; 1 none       462  92.4
&gt; 2 children    38   7.6
```

---

# .orange[RECETA]: .green[PARTICI√ìN]

Tras ello usamos `validation_split()` para **.bg-purple_light[dividir en train-validaci√≥n]** lo que ten√≠amos en `hoteles_train` (75% del 90% = 67.5% vs 22.5%)


```r
# Validaci√≥n
hoteles_val &lt;- validation_split(hoteles_train, strata = children,
                                prop = 0.75)
hoteles_val
```

```
&gt; # Validation Set Split (0.75/0.25)  using stratification 
&gt; # A tibble: 1 √ó 2
&gt;   splits              id        
&gt;   &lt;list&gt;              &lt;chr&gt;     
&gt; 1 &lt;split [3374/1125]&gt; validation
```

---

# .orange[RECETA]: .green[ROLES]



```r
# Receta
hoteles_rec &lt;-
  # F√≥rmula y datos
  recipe(data = hoteles_train, children ~ .)%&gt;%
  # Roles
  add_role(contains("date"), new_role = "date") %&gt;% 
  add_role(where(is.factor), new_role = "cuali") %&gt;% 
  add_role(where(is.numeric), new_role = "cuanti") %&gt;% 
  add_role(c(hotel, required_car_parking_spaces, is_repeated_guest), new_role = "binary") %&gt;% 
  add_role(where(is.numeric) &amp; !average_daily_rate, new_role = "maybe_cuali")
```


---

# .orange[RECETA]: .green[FECHAS]

* Con `step_date()` podemos indicarle directamente que extraiga de la fecha los elementos que le pidamos (en nuestro caso mes, d√≠a de la semana y a√±o).

* Con `listHolidays()` del paquete `{timeDate}` seleccionaremos festivos relevantes internacionalmente, y con `step_holiday()` marcaremos las fechas que lo sean. Tras ello eliminaremos la fecha original con `step_rm()`.


```r
library(timeDate)
# Receta
hoteles_rec &lt;-
  hoteles_rec %&gt;% 
  step_date(arrival_date, features = c("month", "dow", "year")) %&gt;% 
  step_holiday(arrival_date,
               holidays = c(listHolidays("\\Mary"), listHolidays("\\Easter"),
                            listHolidays("\\Christ"), "NewYearsDay")) %&gt;%
  # Eliminamos la variable
  step_rm(arrival_date)
```

---


# .orange[RECETA]: .green[OUTLIERS/AUSENTE]

Tras ello de momento vamos a **.bg-purple_light[detectar outliers a lo bruto]**: detectando por la media e imputando por la media, pero solo de `has_role("cuanti")`, para no incluir a las binarias. Las cuali por la moda en caso de haber ausentes.


```r
library(outliers)
# Receta
hoteles_rec &lt;-
  hoteles_rec %&gt;% 
  # Detectar outliers
  step_mutate(across(where(is.numeric), function(x) { ifelse(abs(scores(x, type = "z")) &gt; 2.5 &amp; !is.na(x), NA, x) })) %&gt;% 
  # Imputar ausentes
  step_impute_mean(has_role("cuanti")) %&gt;%
  step_impute_mode(has_role("cuali"))
```

---

# .orange[RECETA]: .green[TRANSFORMACIONES]

* Aplicamos un filtro de correlaci√≥n para **.bg-purple_light[prevenir problemas de colinealidad]**.

* **.bg-purple_light[Normalizamos por rango]** para la m√©trica.

* **.bg-purple_light[Dummyficamos]** las cualitativas: crea k-1 variables binarias por de cada cualitativa de k niveles.

* **.bg-purple_light[Filtro de cero varianza]**.


```r
# Receta
hoteles_rec &lt;-
  hoteles_rec %&gt;% 
  # Filtro de correlaci√≥n
  step_corr(has_role("cuanti"), threshold = 0.9) %&gt;% 
  # Normalizar por rango
  step_range(all_numeric_predictors()) %&gt;%
  # Dummyficamos
  step_dummy(all_nominal(), -all_outcomes()) %&gt;% 
  # Filtro de cero varianza
  step_zv(all_predictors())
```


---

name: fase4-hoteles

# Fase 4: .orange[MODELO Y FLUJO]


Una vez definida la receta, definimos el **.bg-purple_light[modelo]** y unimos con la receta creando un **.bg-purple_light[flujo de clasificaci√≥n]**


```r
# Modelo
knn_model &lt;-
  nearest_neighbor(mode = "classification", neighbors = 15,
                   weight_func = "inv", dist_power = 2) %&gt;%
  set_engine("kknn")

# Flujo de trabajo
hoteles_wflow &lt;-
  workflow() %&gt;%
  add_recipe(hoteles_rec) %&gt;%
  add_model(knn_model)
```

---

name: fase5-hoteles

# Fase 5: .orange[EVALUACI√ìN/PREDICCI√ìN] (validaci√≥n)

En este caso tenemos un conjunto de validaci√≥n guardado en `hoteles_val`. Para realizar el **.bg-purple_light[ajuste en train y despu√©s obtener las m√©tricas en validaci√≥n]** usaremos `fit_resamples()`, pas√°ndole como argumento los conjuntos de validaci√≥n que tengamos y las **.bg-purple_light[m√©tricas]** que queremos que evaluar (con `metric_set()` y el nombre de la m√©trica)


```r
# Solo contra un conjunto de validaci√≥n
hoteles_knn_fit_val &lt;-
  hoteles_wflow %&gt;%
  fit_resamples(hoteles_val,
                metrics = metric_set(accuracy, sensitivity,
                                     specificity, roc_auc))
```


---

# Fase 5: .orange[EVALUACI√ìN/PREDICCI√ìN] (validaci√≥n)

Con `collect_metrics()` obtenemos las m√©tricas pedidas (dado que solo tenemos un conjunto de validaci√≥n `n = 1` y `std_err = NA`, ya que no tiene con qu√© promediar al solor tener uno)


```r
collect_metrics(hoteles_knn_fit_val)
```

```
&gt; # A tibble: 4 √ó 6
&gt;   .metric     .estimator  mean     n std_err .config             
&gt;   &lt;chr&gt;       &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;fct&gt;               
&gt; 1 accuracy    binary     0.932     1      NA Preprocessor1_Model1
&gt; 2 roc_auc     binary     0.781     1      NA Preprocessor1_Model1
&gt; 3 sensitivity binary     0.987     1      NA Preprocessor1_Model1
&gt; 4 specificity binary     0.253     1      NA Preprocessor1_Model1
```

---

# Fase 5: .orange[EVALUACI√ìN] con .green[CURVA ROC]

Si te has fijado am√©n de la sensibilidad y la especificidad (y la tasa de bien de clasificados o accuracy), le hemos pedido una m√©trica llamada `roc_auc`: el **.bg-purple_light[√°rea bajo la curva ROC]**


```r
collect_metrics(hoteles_knn_fit_val)
```

```
&gt; # A tibble: 4 √ó 6
&gt;   .metric     .estimator  mean     n std_err .config             
&gt;   &lt;chr&gt;       &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;fct&gt;               
&gt; 1 accuracy    binary     0.932     1      NA Preprocessor1_Model1
&gt; 2 roc_auc     binary     0.781     1      NA Preprocessor1_Model1
&gt; 3 sensitivity binary     0.987     1      NA Preprocessor1_Model1
&gt; 4 specificity binary     0.253     1      NA Preprocessor1_Model1
```

--

¬øQu√© es la **.bg-purple_light[curva ROC]**? Si recuerdas, aunque la salida que usamos normalmente es la clase predicha directamente, nuestro objetivo subyacente es **.bg-purple_light[calcular la probabilidad estimada de pertenencia]**

---

# Fase 5: .orange[EVALUACI√ìN] con .green[CURVA ROC]

En clasificaci√≥n binaria, por defecto, estamos estableciendo que la **.bg-purple_light[predicci√≥n es 1]** si la probabilidad estimada de serlo es **.bg-purple_light[superior a 0.5]**. 

Imagina que el objetivo es clasificar si una vacuna puede salir al mercado. ¬øEs **.bg-purple_light[suficiente exigirle un umbral del 50%]** para asignar un 1?

--

La idea detr√°s de la curva ROC es **.bg-purple_light[mover dicho umbral de probabilidad]**, desde el 0 hasta el 1, para **.bg-purple_light[cada uno de esos umbrales]** calcular

* **sensibilidad** (% de 1's reales que han sido clasificados como tal)

* **especificidad** (% de 0's reales que han sido clasificados como tal)

Y pintarlos en un gr√°fico (eje x = 1 - especificidad, eje y = sensibilidad)

---

# Fase 5: .orange[EVALUACI√ìN] con .green[CURVA ROC]

.pull-left[

* Eje X: **.bg-purple_light[1 - especificidad]**, conocido como False Positive Rate (FPR), ya que es el % de 0's reales que han sido mal clasificados (como falsos positivos).

* Eje Y: **.bg-purple_light[sensibilidad]**, conocido como True Positive Rate (TPR), ya que es el % de 1's reales que han sido clasificados como tal (verdaders positivos).

* **.bg-purple_light[AUC ROC]**: √°rea bajo la curva ROC, medida que oscila entre 0 (no hay curva) y 1 (la curva es el cuadrado entero). Clasificador dummy aleatorio: 0.5.

]

.pull-right[


&lt;img src="./img/roc_curve.jpg" width="110%" style="display: block; margin: auto auto auto 0;" /&gt;

]

---

# Fase 5: .orange[EVALUACI√ìN] con .green[CURVA ROC]


&lt;img src="./img/pcr_roc_curve.jpg" width="50%" style="display: block; margin: auto;" /&gt;

---

class: inverse center middle
name: clase-9

# CLASE 9: validaci√≥n y ggplot

&amp;nbsp;

### [Resumen](#resumen)

### [Validaci√≥n con tune y paralelizada](#tune)

### [Sobremuestreo](#oversampling)

### [Validaci√≥n cruzada y bootstrap](#cv-hoteles)

### [Visualizaci√≥n de datos](#dataviz)

---

name: resumen

# .orange[RESUMEN]


* **.bg-purple_light[Fase 1: muestreo]** (si fuese necesario)


```r
# Muestreo
data_sample &lt;-
  raw_data %&gt;% group_by(var_outcome) %&gt;%  slice_sample(prop = ...) %&gt;% ungroup()
```

--

* **.bg-purple_light[Fase 2: exploraci√≥n]**: analizar problemas, relaciones entre variables y modificaciones a llevar a cabo (outliers, ausentes, colinealidad, variables independientes de la objetivo, recategorizaciones, problemas de codificaci√≥n y rango, dummyficaci√≥n si se necesita, nuevas variables, etc)

--

* **.bg-purple_light[Particiones otros-test]**


```r
# por ejemplo 10% para test
data_split &lt;-
  initial_split(data, strata = var_outcome, prop = 0.9)
data_train &lt;- training(data_split)
data_test &lt;- testing(data_split)
```

---

# .orange[RESUMEN]

* **.bg-purple_light[Particiones train-validacion]**: sobre lo que no es test, volvemos a dividir (se guardar√° en dicho conjunto las instrucciones para cuando hagamos a futuro el ajuste)


```r
# Validaci√≥n
data_val &lt;- validation_split(data_train, strata = var_outcome, prop = 0.75)
```

--

* **.bg-purple_light[Inicio de receta]**: definir la objetivo y roles para usarlos a futiro


```r
# Receta
model_rec &lt;-
  # F√≥rmula y datos
  recipe(data = data_train, var_outcome ~ .)%&gt;%
  # Roles
  add_role(..., new_role = ...) %&gt;% # A√±ade rol (a otros existentes)
  update_role(..., new_role = ...) %&gt;% # Modifica (machaca) rol
  remove_role(..., old_role = ...) # Eliminar roles
```

---

# .orange[RESUMEN]

* **.bg-purple_light[Fase 3: modificaci√≥n]**


```r
model_rec &lt;-
  model_rec %&gt;% 
  step_...(...) %&gt;% # funciones a usar
  step_mutate(...) %&gt;% # equivalente a mutate
  step_rm(...) %&gt;% # eliminar variables
  step_impute_...(...) %&gt;% # imputar ausentes
  step_corr(...) %&gt;% # Filtro correlaciones
  step_range(...) %&gt;% # Estandarizar por rango
  step_other(...) %&gt;% # Colapsar niveles poco representados
  step_dummy(...) %&gt;% # Dummyficar
  step_zv(...) # Filtro cero varianza
```
  
---

# .orange[RESUMEN]

* **.bg-purple_light[Fase 4: modelizaci√≥n]**


```r
# Modelo
knn_model &lt;-
  nearest_neighbor(mode = "classification", neighbors = ...,
                   weight_func = ..., dist_power = ...) %&gt;%
  set_engine("kknn")

# Flujo de trabajo
wflow &lt;- workflow() %&gt;% add_recipe(rec) %&gt;% add_model(knn_model)
```

---

# .orange[RESUMEN]

* **.bg-purple_light[Fase 5: evaluaci√≥n]** (en validaci√≥n)


```r
data_model_fit_val &lt;-
  wflow %&gt;%
  fit_resamples(data_val,
                metrics = metric_set(accuracy, sensitivity,
                                     specificity, roc_auc))
# Recopilamos m√©tricas (EN VALIDACI√ìN) dadas en metrics
collect_metrics(data_model_fit_val)
```

---

# .orange[RESUMEN]

**.bg-purple_light[Testeo]**

* `predict()`: nos permite obtener las predicciones, bien de la clase que ha asignado a cada registro, bien la probabilidad estimada de pertenencia a cada clase


```r
predict(data_model_fit_val, new_data)
predict(data_model_fit_val, new_data, type = "prob")
```

* `augment()`: nos permite juntar en una sola tabla los datos originales y las predicciones con `augment()`


```r
prob_data &lt;- augment(data_model_fit_val, new_data)
```

---

# .orange[RESUMEN]

**.bg-purple_light[Testeo]**

* `conf_mat()`: matriz de confusi√≥n (realidad vs predicci√≥n), indic√°ndole la columna con la clase real y la columna con la clase predicha (por defecto es `.pred_class`). Con `summary()` obtenemos las m√©tricas.


```r
conf_mat &lt;- prob_data %&gt;% conf_mat(truth = ..., estimate = .pred_class)
conf_mat %&gt;% summary()
```

* `roc_curve()`: curva roc (debemos indicarle las probabilidades de pertenencia, no la clase predicha.


```r
roc_data &lt;- prob_data %&gt;% roc_curve(truth = ..., ...)
roc_data %&gt;% autoplot() # ya aprenderemos a hacerlo mejor
```

---

name: tune

# .orange[TUNE]

Hasta ahora solo hemos probado un modelo pero la idea es **.bg-purple_light[entrenar varios modelos]** y **.bg-purple_light[evaluar en validaci√≥n]** su calidad o conveniencia.

Para ello lo que vamos a hacer al definir el modelo es **.bg-purple_light[no asignar una constante a los par√°metros]** sino que los vamos a dejar libres, asign√°ndoles `tune()`, para luego indicarle los ¬´diales¬ª en los que queremos que ¬´sintonice¬ª

* `neighbors = tune("k")`: dejamos libre el par√°metro y asignamos la etiqueta `"k"`
* `weight_func = tune("weight")`: dejamos libre y asignamos la etiqueta `"weight"`
* `dist_power = tune("dist")`: dejamos libre y asignamos la etiqueta `"dist"`


```r
# Modelo con tune
knn_model_tune &lt;-
  nearest_neighbor(mode = "classification", neighbors = tune("k"),
                   weight_func = tune("weight"),
                   dist_power = tune("dist")) %&gt;%
  set_engine("kknn")
```

---

# .orange[TUNE]

La ventaja de tener receta y modelo por separado es que solo necesitamos **.bg-purple_light[unir el nuevo modelo a la anterior receta]**


```r
# Nuevo flujo (con tune)
hoteles_wflow &lt;-
  workflow() %&gt;%
  add_recipe(hoteles_rec) %&gt;%
  add_model(knn_model_tune)
```


El anterior modelo **.bg-purple_light[no tiene par√°metros fijados]** a priori: vamos a definir un **.bg-purple_light[grid de par√°metros]** posibles, de forma que ejecutaremos todos ellos para entrenar en train y validar en validaci√≥n.

---

# .orange[TUNE]: .green[GRID MANUAL]

Por ejemplo, vamos definir **.bg-purple_light[manualmente]** un grid de 7 valores de `k` (el resto de par√°metros los dejamos constantes)


```r
grid_knn &lt;- 
  tibble("k" = seq(20, 140, by = 20), "weight" = rep("inv", 7),
         "dist" = rep(2, 7))
grid_knn
```

```
&gt; # A tibble: 7 √ó 3
&gt;       k weight  dist
&gt;   &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt;
&gt; 1    20 inv        2
&gt; 2    40 inv        2
&gt; 3    60 inv        2
&gt; 4    80 inv        2
&gt; 5   100 inv        2
&gt; 6   120 inv        2
&gt; 7   140 inv        2
```

---

# .orange[TUNE]: .green[GRID MANUAL]

Una vez definido el grid manual, con `tune_grid()` le indicaremos que **.bg-purple_light[en lugar de entrenar un solo modelo]** entre uno por cada fila que tenemos en `grid_knn` (cada fila representa una configuraci√≥n de par√°metros), y con `control_grid(verbose = TRUE)` le indicamos que nos informe del proceso.

.pull-left[

**.bg-orange[ANTES]** (solo un modelo)


```r
metricas &lt;-
  metric_set(accuracy, sensitivity,
             specificity, roc_auc)
hoteles_knn_fit_tune &lt;-
 hoteles_wflow %&gt;%
  fit_resamples(hoteles_val,
                metrics = metricas)
```

]

.pull-right[

**.bg-green_light[AHORA]** (muchos modelos a la vez)


```r
# Entrenamos y evaluamos los 7 modelos
hoteles_knn_fit_tune &lt;-
 hoteles_wflow %&gt;%
* tune_grid(resamples = hoteles_val,
*           grid = grid_knn,
            control =
              control_grid(verbose = TRUE),
            metrics = metricas)
```

]



---

# .orange[TUNE]: .green[GRID MANUAL]

Tras ello,  con `collect_metrics()` obtendremos de una sola vez la m√©trica (en validaci√≥n) de todos ellos.


```r
hoteles_knn_fit_tune %&gt;% collect_metrics()
```

---

# .orange[TUNE]: .green[GRID EXPANDIDO]

Ese grid tambi√©n podemos definirlo para el resto de par√°metros, definiendo los **.bg-purple_light[posibles valores para cada par√°metro]** y probar **.bg-purple_light[todas las combinaciones]** entre ellos. Para eso haremos uso de `expand_grid()`


```r
expand_grid("x" = 1:3, "y" = 8:9)
```

---

# .orange[TUNE]: .green[GRID EXPANDIDO]

Con dicha herramienta vamos a **.bg-purple_light[crear 18 modelos]**: 3 valores diferentes de vecinos, 2 tipos de promedios y 3 m√©tricas.


```r
grid_knn &lt;-
  expand_grid("k" = c(10, 50, 100),
              "weight" = c("inv", "gaussian"),
              "dist" = c(0.01, 2, 10))
grid_knn
```

---

# .orange[TUNE]: .green[GRID EXPANDIDO]

La forma de definir el grid cambia pero una vez definido, todo es igual que el ejemplo anterior


```r
# Entrenamos y evaluamos los 18 modelos
hoteles_knn_fit_tune &lt;-
 hoteles_wflow %&gt;%
* tune_grid(resamples = hoteles_val, grid = grid_knn,
            control = control_grid(verbose = TRUE),
            metrics = metric_set(accuracy, sensitivity,
                                 specificity, roc_auc))
hoteles_knn_fit_tune %&gt;% collect_metrics()
```

---

# .orange[TUNE]: .green[GRID AUTOM√ÅTICO]


Incluso podemos generar ese grid de una manera m√°s  **.bg-purple_light[autom√°tica]**: primero extraemos los par√°metros con `extract_parameter_set_dials()`, luego los actualizamos con `update()` indic√°ndole solo los rangos m√°ximos y m√≠nimos, y con `grid_regular()` le indicamos cuantos niveles queremos en cada par√°metro (fijo en todos).


```r
grid_knn &lt;-
  extract_parameter_set_dials(hoteles_wflow) %&gt;%
  # Actualizamos
  update(k = neighbors(range = c(5, 70)),
         weight = weight_func(values = c("inv", "gaussian")),
         dist = dist_power(range = c(0.1, 10))) %&gt;%
  grid_regular(levels = 3) 
grid_knn # 18 modelos (3 x 2 x 3)
```

---

# .orange[TUNE]: .green[GRID AUTOM√ÅTICO]

La forma de definir el grid cambia pero una vez definido, todo es igual que el ejemplo anterior



```r
# Entrenamos y evaluamos los 18 modelos
hoteles_knn_fit_tune &lt;-
 hoteles_wflow %&gt;%
  tune_grid(resamples = hoteles_val, grid = grid_knn,
            control = control_grid(verbose = TRUE),
            metrics = metric_set(accuracy, sensitivity,
                                 specificity, roc_auc))
hoteles_knn_fit_tune %&gt;% collect_metrics()
```

---

name: show-best

# .orange[SELECCI√ìN DEL MEJOR]

No solo vamos a poder trastear con tidyverse en esos resultados en validaci√≥n sino que tenemos **.bg-purple_light[dos funciones especialmente pensadas]** para ello: `show_best()` nos devuelve los mejores modelos seg√∫n la m√©trica pedida, `select_best()` nos selecciona el mejor


```r
hoteles_knn_fit_tune %&gt;% show_best("roc_auc")
hoteles_knn_fit_tune %&gt;% select_best("accuracy")
```

---

# .orange[SELECCI√ìN DEL MEJOR]

Una vez elegido **.bg-purple_light[finalizamos flujo con el mejor modelo]** (seg√∫n una m√©trica)


```r
best_knn_model_acc &lt;- hoteles_knn_fit_tune %&gt;% select_best("accuracy")
final_wf &lt;- 
  hoteles_wflow %&gt;% 
  finalize_workflow(best_knn_model_acc)
final_wf
```

---

# Fase 5: .orange[EVALUACI√ìN EN TEST]


Con `last_fit()` **.bg-purple_light[ajustamos a test]** con ese mejor modelo seleccionado en validaci√≥n, y calculamos m√©tricas en test.


```r
final_knn_fit &lt;- 
  final_wf %&gt;%
  last_fit(hoteles_split) 

# Calculamos m√©tricas en test (las indicadas)
final_knn_fit %&gt;% collect_metrics()
```


---

# Fase 5: .orange[PREDICCI√ìN EN TEST]

Podemos volver a usar `predict()`, extrayendo antes el flujo de ese ajuste final con `extract_workflow(final_knn_fit)`, para calcular las **.bg-purple_light[clases predichas]** en test.


```r
# Predecir el conjunto test: devuelve la clase
predict(extract_workflow(final_knn_fit), hoteles_test)
```

---

# Fase 5: .orange[PREDICCI√ìN EN TEST]


```r
# Predecir las probabilidades (las necesitamos para la ROC)
predict(extract_workflow(final_knn_fit), hoteles_test, type = "prob")
```

---

# Fase 5: .orange[PREDICCI√ìN EN TEST]

Con `augment()` podemos incluir en una sola tabla los datos en test y las predicciones, y con `conf_mat()` obtenemos la **.bg-purple_light[matriz de confusi√≥n]**



```r
# Incluir predicciones en tabla
prob_test &lt;- augment(extract_workflow(final_knn_fit), hoteles_test)

# Matriz de confusi√≥n: etiqueta real vs etiqueta predicha
conf_mat_test &lt;-
  prob_test %&gt;%
  conf_mat(truth = children, estimate = .pred_class)
conf_mat_test 
```

---

# Fase 5: .orange[PREDICCI√ìN EN TEST]


```r
# todas las m√©tricas en test
conf_mat_test %&gt;%
* summary()
```

---

# Fase 5: .orange[PREDICCI√ìN EN TEST]

Podemos **.bg-purple_light[dibujar la curva ROC]** haciendo uso de `roc_curve()` pas√°ndole el archivo con las predicciones, y usando las probabilidades de ser 1 (guardadas en `.pred_children` en nuestro conjunto). Aprenderemos a dibujarla mejor pero podemos mientras hacerlo con `autoplot()`


```r
roc_data &lt;- prob_test %&gt;% roc_curve(truth = children, .pred_children)
roc_data
```


---

name: parallel

# Computaci√≥n .orange[EN PARALELO]

Si queremos probar muchos modelos y/o nuestro volumen de datos es elevado, quiz√°s nos lleve demasiado tiempo: vamos a hacer una incursi√≥n a la **.bg-purple_light[programaci√≥n paralelizada]**. 


```r
library(parallel)
library(doParallel)
```

--

Ambos paquetes ser√°n los que nos permitan paralelizar de forma sencilla. La idea es **.bg-purple_light[mandar tareas independientes a procesadores distintos]**, de forma que si una tarea tarda 6 minutos en un pc, al mandarlo a otros dos procesadores, el tiempo pueda bajar hasta los 2 minutos (no es del todo lineal ya que hay un tiempo m√≠nimo necesario en cada paso).

---

# Computaci√≥n .orange[EN PARALELO]

En muchas empresas u organismos de investigaci√≥n se suele tener a disposici√≥n de los usuarios un conjunto de ordenadores (un cl√∫ster) com√∫n a todos de forma que cada persona pueda mandar sus hilos en paralelo. Pero‚Ä¶no tenemos de eso. ¬øEntonces?

&amp;nbsp;

Vamos a **.bg-purple_light[paralelizar en NUESTRO PROPIO ORDENADOR]**: un ordenador suele tener **.bg-purple_light[varios procesadores o cores]** que pueden funcionar de manera ¬´independiente¬ª uno de otro. Vamos a detectar la cantidad de n√∫cleos de los que podemos disponer con `detectCores()`.


```r
# Detectamos los cores que tenemos
detectCores()
```

---

# Computaci√≥n .orange[EN PARALELO]

A la hora de paralelizar es importante que lo hagamos con cuidado ya que puede que nuestro ordenador se quede colgado: mi consejo es que definas el n√∫mero de cores a usar como los que tienes menos uno.

Con `makeCluster()` montamos los **.bg-purple_light[cl√∫ster en cada nodo]** y con `registerDoParallel()` registramos la paralelizaci√≥n (puedes ver los hilos abiertos con `showConnections()`).


```r
# Iniciamos la paralelizaci√≥n
clusters &lt;- detectCores() - 1
make_cluster &lt;- makeCluster(clusters)
registerDoParallel(make_cluster)
showConnections()
```


---

# Computaci√≥n .orange[EN PARALELO]
 
El √∫nico cambio respecto a antes es indicarle `tune_grid()`  que queremos la **.bg-purple_light[validaci√≥n paralelizada]**, con `control = control_grid(allow_par = TRUE)`. Es importante que al **.bg-purple_light[acabar la paralelizaci√≥n le indiquemos que cerramos los cl√∫ster]**.


```r
hoteles_knn_fit_tune &lt;-
 hoteles_wflow %&gt;%
  tune_grid(resamples = hoteles_val, grid = grid_knn,
*           control = control_grid(verbose = TRUE, allow_par = TRUE,
                                   pkgs = c("outliers")),
            metrics = metric_set(accuracy, sensitivity, specificity, roc_auc))
# finalizamos clusters
stopCluster(make_cluster)
registerDoSEQ()

# M√©tricas
hoteles_knn_fit_tune %&gt;% collect_metrics()
```


---

name: oversampling

# .orange[SOBREMUESTREO] .green[BAJOMUESTREO]

Un paso que hemos obviado: si tenemos la **.bg-purple_light[variable objetivo desbalanceada]** solo aprender√° de la clase mayoritaria. Este desbalanceamiento podemos mitigarlo realizando **.bg-purple_light[sobremuestro/bajomuestreo]**, a√±adiendo `step_upsample()` (del paquete `{themis}`) a la receta (el par√°metro `over_ratio` nos cuantifica el % de la clase minoritaria entre la mayoritaria).


```r
hoteles_rec_oversampling &lt;-
  hoteles_rec %&gt;% 
* themis::step_upsample(children, over_ratio = 0.5)

bake(hoteles_rec_oversampling %&gt;% prep(), new_data = NULL) %&gt;%
  count(children) %&gt;% 
  mutate(porc = 100*n/sum(n))
```

---

# .orange[SOBREMUESTREO] .green[BAJOMUESTREO]

Es importante advertir que por defecto `themis::step_upsample()` tiene un par√°metro opcional `skip` puesto en `TRUE` (si te fijas en el resto de funciones tipo `step_...()` la mayor√≠a lo tienen en `FALSE`).

&amp;nbsp;

Si `skip = TRUE`, lo que indicamos ese que ese **.bg-purple_light[paso de la receta lo ignore cuando lo vayamos a aplicar a test]** (recuerda que la ventaja de tidymodels es que cuando le pides predecir en test, el solo aplica la receta de train a test, para calcular la predicci√≥n). De esta manera, el conjunto de test no ser√° sobre/bajomuestreado, ya que ser√≠a incorrecto "modificar" el conjunto de test dado (recuerda siempre que simula un conjunto nuevo que alguien te da).

Puedes poder `skip = TRUE` siempre que quieras que un paso se lo salte luego en test.

---

# .orange[SOBREMUESTREO] .green[BAJOMUESTREO]

Basta con repetir el proceso con la **receta con sobremuestreo**


```r
clusters &lt;- detectCores() - 1
make_cluster &lt;- makeCluster(clusters)
registerDoParallel(make_cluster)

# Flujo de trabajo
hoteles_wflow_oversampling &lt;-
  workflow() %&gt;%
  add_recipe(hoteles_rec_oversampling) %&gt;%
  add_model(knn_model_tune)

# Ajuste
hoteles_knn_fit_tune_oversampling &lt;-
  hoteles_wflow_oversampling %&gt;%
  tune_grid(resamples = hoteles_val, grid = grid_knn,
            control = control_grid(verbose = TRUE,
                                   allow_par = TRUE,
                                   pkgs = c("outliers")),
            metrics = metric_set(accuracy, sensitivity,
                                 specificity, roc_auc))
# finalizamos clusters
stopCluster(make_cluster)
registerDoSEQ()
```
  
---

# .orange[SOBREMUESTREO] .green[BAJOMUESTREO]

Tras ello volvemos a elegir el mejor modelo seg√∫n accuracy para compararlo


```r
best_knn_model_over_acc &lt;-
  hoteles_knn_fit_tune_oversampling %&gt;% select_best("accuracy")
```

Y con ese modelo seleccionado finalizamos flujo y ajustamos a test


```r
# Finalizamos flujo con el mejor modelo (seg√∫n una m√©trica)
final_wf_over &lt;- 
  hoteles_wflow %&gt;% 
  finalize_workflow(best_knn_model_over_acc)

# Ajustamos a test con ese modelo seleccionado en validaci√≥n
final_knn_fit_over &lt;- 
  final_wf_over %&gt;%
  last_fit(hoteles_split) 
```

---

# .orange[SOBREMUESTREO] .green[BAJOMUESTREO]


```r
# Calculamos m√©tricas en test (las indicadas)
final_knn_fit_over %&gt;% collect_metrics()
```


---

names: cv-hoteles

# Validaci√≥n .orange[CRUZADA]

Hasta ahora, hemos probado **.bg-purple_light[varios modelos]** sobre el **.bg-orange[mismo conjunto de validaci√≥n]**. Ese conjunto de validaci√≥n se ha hecho de manera aleatoria, as√≠ que nuestro resultado podr√≠a estar condicionado a la **buena o mala suerte** de esa partici√≥n.

En realidad cuando hemos hablado de **.bg-purple_light[sesgo y varianza]** no era exactamente esto, ya que para tener una media de lo que nos equivocamos y una varianza de las predicciones, necesitaremos no solo varios modelos sino, en cada una, **.bg-purple_light[varios conjuntos de validaci√≥n]**

&amp;nbsp;


**.bg-red_light[Problema]**: si necesitamos hacer muchas particiones de los datos, puede que nos quedemos sin tama√±o muestral suficiente.

---


# Validaci√≥n .orange[CRUZADA] aleatoria


* **.bg-purple_light[Validaci√≥n cruzada aleatoria]**: la forma m√°s simple (pero menos eficiente) es generar un ¬´bucle¬ª de k iteraciones, de forma que repitamos el proceso k veces, con conjuntos de validaci√≥n distintos, promediando las m√©tricas.

&lt;img src="./img/val_cruzada_aleatoria.jpg" width="55%" style="display: block; margin: auto;" /&gt;

La **.bg-red_light[principal cr√≠tica]** a este m√©todo no solo es la ineficiencia sino que adem√°s en cada iteraci√≥n podemos tener solapamiento: nada nos garantiza que el conjunto de validaci√≥n sea el mismo en dos iteraciones.

---

# Validaci√≥n .orange[CRUZADA] v-folds


* **.bg-purple_light[Validaci√≥n cruzada v-folds]**: la forma m√°s habitual es mediante validaci√≥n cruzada v-folds, basada en **.bg-purple_light[generar artificialmente conjuntos de validaci√≥n]** a partir de los datos originales.

&lt;img src="./img/val_cruzad_vfolds.jpg" width="51%" style="display: block; margin: auto;" /&gt;

Los datos se dividen en **.bg-purple_light[v subsubconjuntos de igual tama√±o]**: en cada iteraci√≥n i (de 1 a v) se usa como
**.bg-purple_light[conjunto train todo menos el subconjunto i-√©simo]**, el cual es usado para validar (obteniendo un promedio de v iteraciones).


---


# Validaci√≥n .orange[CRUZADA] v-folds

* **Iteraci√≥n i**: entrenamos el modelo con los **conjuntos {1,...,i-1, i+1, ..., v}** y validamos con el **conjunto i-√©simo**.


En muchas ocasiones ese proceso se **.bg-purple_light[repite un n√∫mero k de veces]** con el objetivo de **.bg-purple_light[eliminar el efecto de la forma de subdivisi√≥n]** en v subconjuntos, obteniendo un promedio de `\(k*v\)` conjuntos de validaci√≥n, y tomar decisiones sobre los par√°metros.


```r
hoteles_split &lt;- initial_split(hoteles_sample, strata = children, prop = 0.9)
hoteles_train &lt;- training(hoteles_split)
hoteles_test &lt;- testing(hoteles_split)

*hoteles_cv_folds &lt;- vfold_cv(data = hoteles_train, v = 4, repeats = 2, strata = children)
hoteles_cv_folds
```

---

# Validaci√≥n .orange[CRUZADA] v-folds

Todo igual salvo el conjunto de `resamples` que le pasamos


```r
clusters &lt;- detectCores() - 1
make_cluster &lt;- makeCluster(clusters)
registerDoParallel(make_cluster)

hoteles_knn_fit_tune &lt;-
 hoteles_wflow %&gt;%
* tune_grid(resamples = hoteles_cv_folds,
            grid = grid_knn,
*           control = control_grid(verbose = TRUE, allow_par = TRUE,
                                   pkgs = c("outliers")),
            metrics = metric_set(accuracy, sensitivity, specificity, roc_auc))
# finalizamos clusters
stopCluster(make_cluster)
registerDoSEQ()
```

---

# Validaci√≥n .orange[CRUZADA] v-folds


Ahora tendremos una m√©trica media con su desviaci√≥n t√≠pica.


```r
hoteles_knn_fit_tune
```

---

# Validaci√≥n .orange[CRUZADA] v-folds

Incluso podemos usar `select_by_one_std_err()` para elegir el **.bg-purple_light[mejor modelo seg√∫n sesgo-varianza]**, siguiendo la one-standard error rule propuesta por Breiman et al.  (1984). Ver &lt;https://www.cs.ubc.ca/~murphyk/Teaching/CS340-Fall07/L4_knn.pdf&gt;




```r
hoteles_knn_fit_tune %&gt;% select_by_one_std_err(metric = "accuracy", k)  
hoteles_knn_fit_tune %&gt;% collect_metrics()
```


---

names: bootstrap-val-hoteles

# Validaci√≥n .orange[BOOTSTRAP]

Cuando los **.bg-purple_light[datos son tan escasos que incluso la validaci√≥n v-folds]** nos dejar√≠a conjuntos muy poco representativos por su tama√±o, podemos aplicar un **.bg-purple_light[remuestreo con reemplazamiento (bootstrap)]**.

En este caso, en cada iteraci√≥n, realizaremos un **.bg-purple_light[remuestreo con reemplazamiento pero SOLO de una parte de los datos]**, obteniendo un conjunto de igual tama√±o al inicial. Con los datos que no entraron en el remuestreo con reemplazamiento anterior construimos el **.bg-purple_light[conjunto para la validaci√≥n (Out-of-Bag - OOB - sample)]**.


```r
hoteles_boots &lt;- bootstraps(hoteles_train, times = 7)
hoteles_boots
```

```
&gt; # Bootstrap sampling 
&gt; # A tibble: 7 √ó 2
&gt;   splits              id        
&gt;   &lt;list&gt;              &lt;chr&gt;     
&gt; 1 &lt;split [4499/1641]&gt; Bootstrap1
&gt; 2 &lt;split [4499/1694]&gt; Bootstrap2
&gt; 3 &lt;split [4499/1667]&gt; Bootstrap3
&gt; 4 &lt;split [4499/1670]&gt; Bootstrap4
&gt; 5 &lt;split [4499/1678]&gt; Bootstrap5
&gt; 6 &lt;split [4499/1656]&gt; Bootstrap6
&gt; 7 &lt;split [4499/1640]&gt; Bootstrap7
```

---

name: dataviz

# .orange[DATAVIZ]: .green[HISTORIA]


La aparici√≥n de gr√°ficos estad√≠sticos es **.bg-purple_light[relativamente reciente en la ciencia]** ya que hasta la Edad Media la √∫nica visualizaci√≥n de datos estaba en los **.bg-purple_light[mapas]** (representaci√≥n de nuestra realidad en superficies bidimensionales).

De hecho las propias palabras _chart_ y _cartography_ derivan del mismo origen latino, _charta_, aunque el primer uso datado de coordenadas parece venir de los egipcios. &lt;sup&gt;2,3&lt;/sup&gt;


.footnote[[1] [¬´Gram√°tica de las gr√°ficas: pistas para mejorar las representaciones de datos¬ª de Joaqu√≠n Sevilla](http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)

[2] [¬´Presentation Graphics¬ª de Leland Wilkinson. International Encyclopedia of the Social &amp; Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

[3] [¬´Quantitative Graphics in Statistics: A Brief History¬ª de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)]

---


# .orange[NAVEGACI√ìN] y .green[ASTRONOM√çA]

.pull-left[

No es hasta la Edad Media, cuando la **.bg-purple_light[navegaci√≥n y la astronom√≠a]** empezaban a tomar relevancia cient√≠fica, cuando aparece la que se considera la primera gr√°fica (aunque no propiamente estad√≠stica) &lt;sup&gt;3&lt;/sup&gt;, representando el **movimiento c√≠clico de los planetas** (entre los siglos X y XI)

]

.pull-right[


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/dataviz_historico_1.png" alt="Gr√°fica extra√≠da de Beniger y Robyn (1978)" width="110%" /&gt;
&lt;p class="caption"&gt;Gr√°fica extra√≠da de Beniger y Robyn (1978)&lt;/p&gt;
&lt;/div&gt;

]

[3] [¬´Quantitative Graphics in Statistics: A Brief History¬ª de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)


---

# .orange[PRIMER] gr√°fico estad√≠stico

La mayor√≠a de expertos, como Tufte &lt;sup&gt;6,7&lt;/sup&gt;, consideran este gr√°fico casi longitudinal como la **.bg-purple_light[primera visualizaci√≥n de datos]** de la historia, hecha por **Van Langren** en 1644, representando la **.bg-purple_light[distancia entre Toledo y Roma]** (un poco mal medida ya que la distancia real es de 16.5¬∫).

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/longitud_dataviz.jpg" alt="Extra√≠da de Friendly y Valero-Mora (2010)" width="100%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de Friendly y Valero-Mora (2010)&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/dataviz_historico_3.jpeg" alt="Extra√≠da de Friendly y Valero-Mora (2010)" width="100%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de Friendly y Valero-Mora (2010)&lt;/p&gt;
&lt;/div&gt;

]

[6] [¬´Visual explanations: images and quantities, evidence and narrative¬ª de E. Tufte](https://archive.org/details/visualexplanatio00tuft)

[7] [¬´PowerPoint is evil¬ª de E. Tufte](https://www.wired.com/2003/09/ppt2/)

---

# ¬øQu√© es una .orange[GR√ÅFICA] estad√≠stica?

¬øPor qu√© ese gr√°fico se considera la primera visualizaci√≥n estad√≠stica de la historia? ¬øQu√© es lo que hace que una visualizaci√≥n sea una gr√°fica estad√≠stica y no las anteriores? ¬øCu√°l es la **.bg-purple_light[frontera entre una ilustraci√≥n y una gr√°fica]** (de datos)?


.pull-left[

¬øEs una gr√°fica estad√≠stica? ¬øPor qu√© s√≠ o por qu√© no?

]

.pull-right[


&lt;img src="./img/cuadro_dataviz.jpg" width="45%" style="display: block; margin: auto;" /&gt;

]

--

No hay  **.bg-purple_light[ninguna INFORMACI√ìN]** representada


---

# ¬øQu√© es una .orange[GR√ÅFICA] estad√≠stica?

¬øPor qu√© ese gr√°fico se considera la primera visualizaci√≥n estad√≠stica de la historia? ¬øQu√© es lo que hace que una visualizaci√≥n sea una gr√°fica estad√≠stica y no las anteriores? ¬øCu√°l es la **.bg-purple_light[frontera entre una ilustraci√≥n y una gr√°fica]** (de datos)?

.pull-left[

¬øEs una gr√°fica estad√≠stica? ¬øPor qu√© s√≠ o por qu√© no?

]

.pull-right[


&lt;img src="./img/horoscopo_dataviz.jpg" width="65%" style="display: block; margin: auto;" /&gt;

]

--

No hay **.bg-purple_light[ning√∫n PROCESO DE MEDIDA]** representado, no cuantifica nada (real).


---

# ¬øQu√© es una .orange[GR√ÅFICA] estad√≠stica?

¬øPor qu√© ese gr√°fico se considera la primera visualizaci√≥n estad√≠stica de la historia? ¬øQu√© es lo que hace que una visualizaci√≥n sea una gr√°fica estad√≠stica y no las anteriores? ¬øCu√°l es la **.bg-purple_light[frontera entre una ilustraci√≥n y una gr√°fica]** (de datos)?


.pull-left[

¬øEs una gr√°fica estad√≠stica? ¬øPor qu√© s√≠ o por qu√© no?

]

.pull-right[


&lt;img src="./img/celsius_dataviz.jpg" width="110%" style="display: block; margin: auto;" /&gt;

]

--

No hay **.bg-purple_light[ning√∫n DATO]** representado en √©l, es una magnitud f√≠sica te√≥rica, no un dato (medido emp√≠ricamente o simulado).


---

# ¬øQu√© es una .orange[GR√ÅFICA] estad√≠stica?

¬øPor qu√© ese gr√°fico se considera la primera visualizaci√≥n estad√≠stica de la historia? ¬øQu√© es lo que hace que una visualizaci√≥n sea una gr√°fica estad√≠stica y no las anteriores? ¬øCu√°l es la **.bg-purple_light[frontera entre una ilustraci√≥n y una gr√°fica]** (de datos)?


.pull-left[

¬øEs una gr√°fica estad√≠stica? ¬øPor qu√© s√≠ o por qu√© no?

]

.pull-right[


&lt;img src="./img/mapa_infografia_dataviz.jpg" width="60%" style="display: block; margin: auto;" /&gt;

]

--

El proceso de representaci√≥n **.bg-purple_light[no es REVERSIBLE]** ni comparable (al menos no f√°cilmente): es una infograf√≠a, no un gr√°fico estad√≠stico.



---

# ¬øQu√© es una .orange[GR√ÅFICA] estad√≠stica?

Esas mismas preguntas se hizo **Joaqu√≠n Sevilla** &lt;sup&gt;1&lt;/sup&gt;, proporcionando **.bg-purple_light[3 requisitos]**:

.pull-left[

1. Que se base en el esquema de composici√≥n de **.bg-purple_light[eje m√©trico]** (proceso de medida): debe **.bg-orange[medir algo]**.

2. Debe incluir **.bg-purple_light[informaci√≥n (datos)]**

3. La **.bg-purple_light[relaci√≥n de representatividad]** debe ser **.bg-purple_light[reversible]**: los datos deber√≠an poder ¬´recuperarse¬ª a partir de la gr√°fica (es un tipo particular de **.bg-orange[¬´aplicaci√≥n¬ª matem√°tica]**).

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/grafica_dinero_sevilla.jpg" alt="Ejemplo de met√°fora visual bien ejecutada (extra√≠da del manual de J. Sevilla)" width="70%" /&gt;
&lt;p class="caption"&gt;Ejemplo de met√°fora visual bien ejecutada (extra√≠da del manual de J. Sevilla)&lt;/p&gt;
&lt;/div&gt;

]

[1] [¬´Gram√°tica de las gr√°ficas: pistas para mejorar las representaciones de datos¬ª de Joaqu√≠n Sevilla](http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)


---

# Abolici√≥n de .orange[DIAGRAMAS DE TARTAS]

Hay muchas formas de hacer una gr√°fica estad√≠stica, y no suele pasar por hacer un **.bg-purple_light[gr√°fico de tartas o sectores]** ya que tienen un grave **.bg-purple_light[problema de reversibilidad]**:

.pull-left[

* Si hay **muchas variables**: salvo que conozcas el montante total y tengas un transportador de √°ngulos a mano, es **.bg-purple_light[imposible que tus ojos midan √°ngulos]**

* Si hay **pocas variables**: ¬øaporta algo distinto (y/o mejor) que una tabla?

]

.pull-right[

&lt;img src="./img/sectores_3D.jpg" width="99%" style="display: block; margin: auto;" /&gt;

]

---

# .orange[VIZFAILS]: ejempos mal


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/persona_dataviz.jpg" alt="Ejemplo de met√°fora visual mal ejecutada" width="50%" /&gt;
&lt;p class="caption"&gt;Ejemplo de met√°fora visual mal ejecutada&lt;/p&gt;
&lt;/div&gt;

---

# .orange[VIZFAILS]: ejempos mal

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/persona_dataviz.jpg" alt="Ejemplo de met√°fora visual mal ejecutada" width="99%" /&gt;
&lt;p class="caption"&gt;Ejemplo de met√°fora visual mal ejecutada&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

* La figura elegida (persona caminando) sin relaci√≥n con lo visualizado: **.bg-purple_light[mala met√°fora visual]**.

* Los **.bg-purple_light[sectores se√±alados sin relaci√≥n con el √≠tem]** a representar, lo que dificulta su interpretaci√≥n.

* Los **.bg-purple_light[colores sin codificar]**: no dan informaci√≥n de ning√∫n tipo.

* Las **.bg-purple_light[formas irregulares impiden la comparaci√≥n]** de las √°reas (am√©n de que la suma total supera el 100%).

* **.bg-purple_light[Sin fuente]** de la procedencia de los datos.

]


---

# .orange[VIZFAILS]: ejempos mal


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/viz_fail_covid.jpg" alt="Ejemplo de una buena idea mal ejecutada (de un vicerrector de tecnolog√≠a...)" width="50%" /&gt;
&lt;p class="caption"&gt;Ejemplo de una buena idea mal ejecutada (de un vicerrector de tecnolog√≠a...)&lt;/p&gt;
&lt;/div&gt;

---

# .orange[VIZFAILS]: ejempos mal

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/viz_fail_covid.jpg" alt="Ejemplo de una buena idea mal ejecutada (de un vicerrector de tecnolog√≠a...)" width="100%" /&gt;
&lt;p class="caption"&gt;Ejemplo de una buena idea mal ejecutada (de un vicerrector de tecnolog√≠a...)&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

* **.bg-purple_light[Uso de dos ejes]** (a izquierda para mortalidad, a derecha para letalidad) **.bg-purple_light[sin indicarlo]** adecuadamente. Cuidado con los dos ejes: puede ser confuso.

* **.bg-purple_light[Leyenda mal referenciada]** y muy peque√±a.

* **.bg-purple_light[Tama√±o de la l√≠nea desproporcionado]** que impide la reversibilidad y la comparaci√≥n.

* **.bg-purple_light[Compara celdas geogr√°ficas incomparables]** por tama√±o y contexto: ¬øGalicia vs Alemania?

]



---

# .orange[VIZFAILS]: ejempos mal


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/viz_fail_uk.jpg" alt="Ejemplo de una mala codificaci√≥n" width="40%" /&gt;
&lt;p class="caption"&gt;Ejemplo de una mala codificaci√≥n&lt;/p&gt;
&lt;/div&gt;


---

# .orange[VIZFAILS]: ejempos mal

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/viz_fail_uk.jpg" alt="Ejemplo de una mala codificaci√≥n" width="60%" /&gt;
&lt;p class="caption"&gt;Ejemplo de una mala codificaci√≥n&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

* **.bg-purple_light[Desagregaci√≥n incorrecta]**: distritos geogr√°ficos muy grandes que se podr√≠an representar en una tabla de 9 filas.

* **.bg-purple_light[Leyenda desproporcionada]** que atrae la atenci√≥n m√°s que el propio gr√°fico.

* Ejemplo de los **.bg-purple_light[colores no son algo meramente est√©tico]**: hay que codificarlos adecuadamente. El gradiente de una paleta de colores puede convertir una buena idea en una p√©sima visualizaci√≥n.

]

---

# La importancia del .orange[CONTEXTO]

Una **buena idea** puede estar mal ejecutada: la forma de llevarla a cabo es importante

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/semaforos.jpg" alt="Ejemplo de buena idea mal ejecutada" width="28%" /&gt;
&lt;p class="caption"&gt;Ejemplo de buena idea mal ejecutada&lt;/p&gt;
&lt;/div&gt;

---

# Dataviz: .orange[HISTORIA]

En el siglo XVII hubo un boom de la estad√≠stica al empezar a aplicarse en **.bg-purple_light[demograf√≠a]**. Uno de los autores m√°s importantes fue **.bg-purple_light[J. Graunt]**, autor de ¬´Natural and Political Observations Made upon the Bills of Mortality¬ª (1662), estimando la poblaci√≥n de Londres con las **.bg-purple_light[primeras tablas de natalidad y mortalidad]**.

.pull-left[

Son precisamente las tablas de Graunt las que us√≥ **.bg-purple_light[Christiaan Huygens]** para generar la **.bg-purple_light[primera gr√°fica de densidad]** de una distribuci√≥n continua (esperanza de vida vs edad).

]

.pull-right[


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/primera_densidad.jpg" alt="Primera funci√≥n de densidad, extra√≠da de https://omeka.lehigh.edu/exhibits/show/data_visualization/vital_statistics/huygen" width="100%" /&gt;
&lt;p class="caption"&gt;Primera funci√≥n de densidad, extra√≠da de https://omeka.lehigh.edu/exhibits/show/data_visualization/vital_statistics/huygen&lt;/p&gt;
&lt;/div&gt;

]

---

# Los gr√°ficos de .orange[Playfair]

La figura que cambi√≥ el dataviz fue, sin lugar a dudas, el economista y pol√≠tico **.bg-purple_light[William Playfair (1759-1823)]**, publicando en 1786 el **¬´Atlas pol√≠tico y comercial¬ª** con 44 gr√°ficas (43 series temporales y el diagrama de barras m√°s famoso de la historia).

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/playfair_1.jpg" alt="Extra√≠das de Funkhouser y Walker (1935)" width="70%" /&gt;
&lt;p class="caption"&gt;Extra√≠das de Funkhouser y Walker (1935)&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/playfair_2.jpg" alt="Extra√≠das de Funkhouser y Walker (1935)" width="25%" /&gt;
&lt;p class="caption"&gt;Extra√≠das de Funkhouser y Walker (1935)&lt;/p&gt;
&lt;/div&gt;

]

[10] [¬´Atlas pol√≠tico y comercial¬ª de William Playfair (1786)](https://www.amazon.es/Playfairs-Commercial-Political-Statistical-Breviary/dp/0521855543)

[11] [¬´Playfair and his charts¬ª de H. Gray Funkhouser and  Helen M. Walker (1935)](https://www.jstor.org/stable/45366440)

---


# Los gr√°ficos de .orange[Playfair]

Playfair no solo fue el primero en usar el dataviz para entender (y no solo describir): fue el primero en usar **.bg-purple_light[conceptos modernos]** como _grid_, tema o color

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/playfair_3.jpg" alt="Extra√≠da de https://friendly.github.io/HistDataVis" width="90%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://friendly.github.io/HistDataVis&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/playfair_4.png" alt="Extra√≠da de la wikipedia." width="90%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de la wikipedia.&lt;/p&gt;
&lt;/div&gt;

]

---

# Los gr√°ficos de .orange[Playfair]

Playfair es adem√°s el autor del **.bg-purple_light[gr√°fico de barras m√°s famoso]** (no fue el primero pero s√≠ quien lo hizo _mainstream_).

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/playfair_5.jpg" alt="Gr√°ficas de Playfair de importaciones (barras grises) y exportaciones (negras) de Escocia en 1781, extra√≠das de la wikipedia." width="90%" /&gt;
&lt;p class="caption"&gt;Gr√°ficas de Playfair de importaciones (barras grises) y exportaciones (negras) de Escocia en 1781, extra√≠das de la wikipedia.&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/playfair_6.jpg" alt="Primer diagrama de barras (P. Buache y G. de L‚ÄôIsle), visualizando los niveles del Sena (1732 - 1766), extra√≠da de https://friendly.github.io/HistDataVis" width="90%" /&gt;
&lt;p class="caption"&gt;Primer diagrama de barras (P. Buache y G. de L‚ÄôIsle), visualizando los niveles del Sena (1732 - 1766), extra√≠da de https://friendly.github.io/HistDataVis&lt;/p&gt;
&lt;/div&gt;

]

---

# Los gr√°ficos de .orange[Playfair]


Playfair adem√°s fue el primero en **.bg-purple_light[combinar gr√°ficos en la misma visualizaci√≥n]**

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/playfair_7.jpg" alt="Visualiza 3 series temporales: precios (barras) del trigo, salarios (l√≠nea) y time-line con reinados, extra√≠da de https://friendly.github.io/HistDataVis." width="85%" /&gt;
&lt;p class="caption"&gt;Visualiza 3 series temporales: precios (barras) del trigo, salarios (l√≠nea) y time-line con reinados, extra√≠da de https://friendly.github.io/HistDataVis.&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/playfair_8.png" alt="Time-line hist√≥rico, extra√≠da de https://friendly.github.io/HistDataVis." width="85%" /&gt;
&lt;p class="caption"&gt;Time-line hist√≥rico, extra√≠da de https://friendly.github.io/HistDataVis.&lt;/p&gt;
&lt;/div&gt;

]

[12] [¬´A Letter on Our Agricultural Distresses, Their Causes and Remedies¬ª de W. Playfair (1821)](http://onlinebooks.library.upenn.edu/webbin/book/lookupid?key=ha009726110)

[13] [¬´An Inquiry Into the Permanent Causes of the Decline and Fall of Powerful and Wealthy Nations¬ª de William Playfair (1821)](https://www.amazon.com/Permanent-Powerful-Nations-Prosperity-Prolonged/dp/140691830X)

---

# Mapas de .orange[Minard]

Otro pionero en **.bg-purple_light[combinar visualizaciones]** fue Minard, autor del famoso ¬´Carte figurative des pertes successives en hommes de l'Arm√©e Fran√ßaise dans la campagne de Russie 1812-1813¬ª, seg√∫n Tufte **.bg-purple_light[¬´el mejor gr√°fico estad√≠stico jam√°s dibujado¬ª]**, publicado en 1869 sobre la desastrosa campa√±a rusa de Napole√≥n en 1812 (3 variables en un gr√°fico bidimensional)

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/minard_2.png" alt="Extra√≠da de https://friendly.github.io/HistDataVis." width="60%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://friendly.github.io/HistDataVis.&lt;/p&gt;
&lt;/div&gt;

---

# Primer .orange[SCATTER PLOT]

Seg√∫n Sevilla &lt;sup&gt;1&lt;/sup&gt;, se considera al astr√≥nomo brit√°nico **John Frederick William Herschel** el autor del **.bg-purple_light[primer diagrama de dispersi√≥n o scatterplot]** en 1833, visualizando el movimiento de la estrella doble Virginis (tiempo en el eje horizontal, posici√≥n angular en el eje vertical)


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/herschel.jpg" alt="Extra√≠do de https://friendly.github.io/HistDataVis." width="35%" /&gt;
&lt;p class="caption"&gt;Extra√≠do de https://friendly.github.io/HistDataVis.&lt;/p&gt;
&lt;/div&gt;

---

# Primera .orange[PIR√ÅMIDE POBLACIONAL]

La **.bg-purple_light[primera pir√°mide de poblaci√≥n]** (doble histograma de poblaci√≥n), fue publicada por **Francis Amasa Walker**, superintendente del censo de EE.UU., en 1874.

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/walker_piramide.jpg" alt="Extra√≠da de https://www.depauw.edu/learn/dew/wpaper/workingpapers/DePauw2016-02-Barreto-DemographyEconomics.pdf" width="45%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://www.depauw.edu/learn/dew/wpaper/workingpapers/DePauw2016-02-Barreto-DemographyEconomics.pdf&lt;/p&gt;
&lt;/div&gt;

---

# .orange[FLORENCE NIGTHINGALE]

.pull-left[


* El 21 de octubre de 1854 **.bg-purple_light[Florence Nigthingale]** fue enviada para mejorar las **condiciones sanitarias** de los soldados brit√°nicos en la guerra de Crimea. 

* A su regreso se dedic√≥ a demostrar que los **.bg-purple_light[soldados fallec√≠an por las condiciones sanitarias]**: eran **muertes evitables**. Nigthingale es la creadora del famoso y pionero **.bg-purple_light[diagrama de rosa]**, permitiendo pintar tres variables a la vez y su estacionalidad.

* El 8 de febrero de 1955, The Times la describi√≥ como la **¬´√°ngel guardi√°n¬ª de los hospitales**, y al finalizar la contienda, fue recibida como una hero√≠na, conocida como **.bg-purple_light[¬´The Lady with the Lamp¬ª]**.

]

.pull-right[

&lt;img src="./img/the_lady_with_the_lamp.png" width="75%" style="display: block; margin: auto;" /&gt;

]

---

# .orange[DIAGRAMA DE ROSA]

Florence Nigthingale es la creadora del famoso **.bg-purple_light[diagrama de rosa]**, permitiendo pintar **.bg-purple_light[tres variables a la vez y su estacionalidad]**: **tiempo** (cada **gajo** es un mes), **n¬∫ de muertes** (**√°rea** del gajo) y **causa** de la muerte (**color** del gajo: azules enfermedades infecciosas, rojas por heridas, negras otras causas).


&lt;img src="./img/rosa_nightingale.jpg" width="60%" style="display: block; margin: auto;" /&gt;

---


# .orange[RECURSOS] de dataviz


üìö [¬´The Functional Art: an introduction to information graphics and visualization¬ª de Alberto Cairo](https://www.amazon.es/Functional-Art-Voices-That-Matter/dp/0321834739)


üìö [¬´Gram√°tica de las gr√°ficas: pistas para mejorar las representaciones de datos¬ª de Joaqu√≠n Sevilla](https://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)


üìö [¬´A Brief History of Visualization¬ª de Friendly et al. (2008)](https://www.researchgate.net/publication/226400313_A_Brief_History_of_Data_Visualization)

üìö [¬´Quantitative Graphics in Statistics: A Brief History¬ª de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)]

üìö [¬´Presentation Graphics¬ª de Leland Wilkinson. International Encyclopedia of the Social &amp; Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

üìö [¬´The Grammar of Graphics¬ª de Leland Wilkinson](https://www.amazon.es/Grammar-Graphics-Statistics-Computing/dp/0387245448)


üìö [¬´The Minard System: The Graphical Works of Charles-Joseph Minard¬ª de Sandra Rendgen](https://www.amazon.es/gp/product/1616896337/ref=sw_img_1?smid=A1AT7YVPFBWXBL&amp;psc=1)

üìö [¬´The Visual Display of Quantitative Information¬ª de E. W. Tufte](https://www.amazon.es/Visual-Display-Quantitative-Information/dp/0961392142)

---

name: intro-ggplot2



# Dataviz en R: .orange[ggplot2]

.pull-left[

El paquete `{ggplot2}` se basa en la idea propuesta por Wilkinson en **.bg-purple_light[¬´Grammar of graphics¬ª]**: dotar a los gr√°ficos de una gram√°tica propia. Una de las principales fortalezas de `R` no solo es la flexibilidad y rapidez de `{tidyverse}`, tambi√©n la **.bg-purple_light[visualizaci√≥n]** con el paquete `{ggplot2}`.


```r
library(ggplot2)
```


La **.bg-purple_light[visualizaci√≥n de datos]** deber√≠a ser una parte fundamental de todo an√°lisis de datos. No es solo una cuesti√≥n est√©tica, es fundamental para **.bg-purple_light[convertir el dato en informaci√≥n]**.

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/telling_dataviz.jpg" alt="Imagen extra√≠da de Reddit" width="71%" /&gt;
&lt;p class="caption"&gt;Imagen extra√≠da de Reddit&lt;/p&gt;
&lt;/div&gt;

]


---

# Dataviz en R: .orange[ggplot2]


.pull-left[

La filosof√≠a detr√°s de `{ggplot2}` es entender los **.bg-purple_light[gr√°ficos como parte del flujo]** de trabajo, dot√°ndoles de una **.bg-purple_light[gram√°tica]**, bas√°ndose en la idea de Wilkinson.

El objetivo es empezar con un lienzo en blanco e ir **.bg-purple_light[a√±adiendo capas a tu gr√°fico]**. La ventaja de `{ggplot2}` es poder **.bg-purple_light[mapear atributos est√©ticos]** (color, forma, tama√±o) de objetos geom√©tricos (puntos, barras, l√≠neas) en funci√≥n de los datos.

&amp;nbsp;


La **documentaci√≥n** del paquete puedes consultarla en &lt;https://ggplot2-book.org/introduction.html&gt; 

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/grammar_ggplot2.jpg" alt="Idea detr√°s de la ¬´Grammar of graphics¬ª de Wilkinson" width="100%" /&gt;
&lt;p class="caption"&gt;Idea detr√°s de la ¬´Grammar of graphics¬ª de Wilkinson&lt;/p&gt;
&lt;/div&gt;

]

---

# Dataviz en R: .orange[ggplot2]

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/tarta_ggplot2.png" alt="Extra√≠da de https://twitter.com/tanya_shapiro" width="75%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://twitter.com/tanya_shapiro&lt;/p&gt;
&lt;/div&gt;

---

# Dataviz en R: .orange[ggplot2]

.pull-left[


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/tarta_recortada_ggplot2.jpg" alt="Extra√≠da de https://twitter.com/tanya_shapiro" width="80%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://twitter.com/tanya_shapiro&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

Un gr√°fico se podr√° componer de las siguientes **.bg-purple_light[capas]**

* **.bg-purple_light[Datos (data)]**
* **.bg-purple_light[Mapeado (aesthetics)]** de elementos est√©ticos: ejes, color, forma, tama√±o, etc (en funci√≥n de los datos)
* **.bg-purple_light[Geometr√≠a (geom)]**: puntos, l√≠neas, barras, pol√≠gonos, etc.
* **.bg-purple_light[Componer gr√°ficas (facet)]**: visualizar varias gr√°ficas a la vez.
* **.bg-purple_light[Transformaciones (stat)]**: ordenar, resumir, agrupar, etc.
* **.bg-purple_light[Coordenadas (coord)]**: coordenadas cartesianas, polares, grids, etc.
* **.bg-purple_light[Temas (theme)]**: fuente, tama√±o de letra, subt√≠tulos, captions, leyenda, ejes, etc.

]


---

# Primer intento: .orange[SCATTER PLOT]

Veamos un **primer intento** para entender la filosof√≠a ggplot. Imagina que queremos dibujar un **.bg-purple_light[scatter plot]** (diagrama de dispersi√≥n de puntos). Para ello vamos a usar el conjunto de datos `gapminder`, del paquete hom√≥nimo: un fichero con **datos de esperanzas de vida, poblaciones y renta per c√°pita** de distintos pa√≠ses en distintos momentos temporales.


```r
library(gapminder)
gapminder
```

```
&gt; # A tibble: 1,704 √ó 6
&gt;    country     continent  year lifeExp      pop gdpPercap
&gt;    &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;
&gt;  1 Afghanistan Asia       1952    28.8  8425333      779.
&gt;  2 Afghanistan Asia       1957    30.3  9240934      821.
&gt;  3 Afghanistan Asia       1962    32.0 10267083      853.
&gt;  4 Afghanistan Asia       1967    34.0 11537966      836.
&gt;  5 Afghanistan Asia       1972    36.1 13079460      740.
&gt;  6 Afghanistan Asia       1977    38.4 14880372      786.
&gt;  7 Afghanistan Asia       1982    39.9 12881816      978.
&gt;  8 Afghanistan Asia       1987    40.8 13867957      852.
&gt;  9 Afghanistan Asia       1992    41.7 16317921      649.
&gt; 10 Afghanistan Asia       1997    41.8 22227415      635.
&gt; # ‚Ä¶ with 1,694 more rows
&gt; # ‚Ñπ Use `print(n = ...)` to see more rows
```

---

# Primer intento: .orange[SCATTER PLOT]

El fichero consta de 1704 registros y 6 variables: `country`, `continent`, `year`, `lifeExp` (esperanza de vida), `pop` (poblaci√≥n)  y `gdpPercap` (renta per c√°pita).


```r
glimpse(gapminder)
```

```
&gt; Rows: 1,704
&gt; Columns: 6
&gt; $ country   &lt;fct&gt; "Afghanistan", "Afghanistan", "Afghanistan", "Afghanistan", ‚Ä¶
&gt; $ continent &lt;fct&gt; Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, ‚Ä¶
&gt; $ year      &lt;int&gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, ‚Ä¶
&gt; $ lifeExp   &lt;dbl&gt; 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8‚Ä¶
&gt; $ pop       &lt;int&gt; 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12‚Ä¶
&gt; $ gdpPercap &lt;dbl&gt; 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, ‚Ä¶
```

Para empezar con algo sencillo **.bg-purple_light[filtraremos solo los datos de 1997]**

--


```r
gapminder_1997 &lt;- gapminder %&gt;% filter(year == 1997)
```

---

# .orange[INGREDIENTES]: .green[(x, y)]


¬øQu√© **.bg-purple_light[elementos necesitamos]** para realizar un diagrama de puntos? Para iniciar el lienzo necesitamos una base de datos y dos variables a representar.

--

.pull-left[

* **.bg-purple_light[Datos (data)]**: conjunto `gapminder_1997`.

* **.bg-purple_light[Mapeado (aes)]**: indicarle dentro de `aes()` (aesthetics) las variables en cada coordenada. Todo lo que est√© **.bg-purple_light[dentro de aes() ser√°n mapeados de los datos]**


```r
ggplot(data = gapminder_1997,
*      aes(x = gdpPercap, y = pop))
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-811-1.png" width="80%" /&gt;
]

---


# .orange[PRIMERA GEOMETR√çA]: .green[geom_point()]


.pull-left[

* **.bg-purple_light[Geometr√≠a (geom)]**: optaremos por **.bg-orange[puntos]** usando `geom_point()`.


```r
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop)) +
* geom_point()
```

]


.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-813-1.png" width="93%" /&gt;

]

---

# .orange[ROL DE LOS EJES]: .green[(x, y)]



.pull-left[

Vamos a profundizar en ese mapeado: ¬øc√≥mo **.bg-purple_light[cambiar el rol]** de los ejes (poblaci√≥n en el eje X y renta per c√°pita en el eje Y)? 

* **Eje X**: poblaci√≥n (variable `pop`)
* **Eje Y**: renta per c√°pita (variable `gdpPercap`)



```r
ggplot(gapminder_1997,
*      aes(y = gdpPercap, x = pop)) +
  geom_point() 
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-815-1.png" width="93%" /&gt;

]

---

# .orange[ROL DE LOS EJES]: .green[(x, y)]



.pull-left[

¬øY un scatter plot con **esperanza de vida** en eje X frente a **renta per c√°pita**?


* **Eje X**: esperanza de vida (variable `lifeExp`)
* **Eje Y**: renta per c√°pita (variable `gdpPercap`)



```r
ggplot(gapminder_1997,
*      aes(y = gdpPercap, x = lifeExp)) +
  geom_point()
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-817-1.png" width="91%" /&gt;
]

---


# .orange[COLOR], .green[SIZE], .purple[SHAPE]: fijos


.pull-left[

Dentro de `geom_point()` tenemos varios argumentos a usar:


* `na.rm = ...`: si queremos que nos quite ausentes.

* `color = ...`: color (si tiene dimensi√≥n, color del contorno)

* `fill = ...`: color el relleno.

Empezaremos por un **color fijo**, por ejemplo `"red"` (existen otros como `"blue"`, `"black"`, `"yellow"`, etc)


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
* geom_point(color = "red")
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-819-1.png" width="91%" /&gt;

]

---

# .orange[COLOR], .green[SIZE], .purple[SHAPE]: fijos



.pull-left[

* `size = ...`: tama√±o  de la geometr√≠a (en este caso el **tama√±o de los punto**), cuanto mayor sea el n√∫mero, mayor ser√° el tama√±o de la geometr√≠a.

  

```r
# Color con palabra reservada
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red",
*            size = 7)
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-821-1.png" width="91%" /&gt;

]

---

# .orange[COLOR], .green[SIZE], .purple[SHAPE]: fijos


.pull-left[

* `alpha = ...`: grado de opacidad del color (1 totalmente opaco, 0 totalmente transparente)


```r
# Color con palabra reservada
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7,
*            alpha = 0.4)
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-823-1.png" width="91%" /&gt;

]

---

# .orange[COLOR], .green[SIZE], .purple[SHAPE]: fijos


.pull-left[

* `shape = ...`: forma de la geometr√≠a, en este caso del ¬´punto¬ª (ver todas las opciones en `vignette("ggplot2-specs")`)


&lt;img src="./img/shape_ggplot.jpg" width="32%" style="display: block; margin: auto;" /&gt;



```r
# Color con palabra reservada
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7,
*            alpha = 0.4, shape = 5)
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-826-1.png" width="91%" /&gt;

]

---

# .orange[COLOR], .green[SIZE], .purple[SHAPE]: fijos


.pull-left[

* `shape = ...`: forma de la geometr√≠a, en este caso del ¬´punto¬ª (ver todas las opciones en `vignette("ggplot2-specs")`)


&lt;img src="./img/shape_ggplot.jpg" width="32%" style="display: block; margin: auto;" /&gt;



```r
# Color con palabra reservada
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7, alpha = 0.4,
*            shape = 22, fill = "black")
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-829-1.png" width="91%" /&gt;

]


---

# .orange[COLOR], .green[SIZE], .purple[SHAPE]: fijos


.pull-left[

* `stroke = ...`: tama√±o del contorno


```r
# Color con palabra reservada
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7,
*            alpha = 0.4, stroke = 0)
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-831-1.png" width="91%" /&gt;

]


---

# .orange[COLOR], .green[SIZE], .purple[SHAPE]: fijos


.pull-left[

Los colores tambi√©n podemos asign√°rselos por su **c√≥digo hexadecimal**, consultando en la p√°gina &lt;https://htmlcolorcodes.com/es/&gt;, eligiendo el color que queramos. El c√≥digo hexadecimal siempre comenzar√° con `#`



```r
# Color en hexadecimal
# https://htmlcolorcodes.com/es/
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
* geom_point(color = "#A02B85",
             alpha = 0.4, size = 7) 
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-833-1.png" width="91%" /&gt;

]

  
---

# Mapeado de atributos est√©ticos: .orange[aes()]

.pull-left[

Hasta ahora los **atributos est√©ticos** se los hemos pasado fijos y **constantes**.  Pero la verdadera potencia y versatilidad de `ggplot` es que podemos **.bg-purple_light[mapear los atributos est√©ticos en funci√≥n de los datos]** en `aes()` para que dependan de variables de los datos

Por ejemplo, vamos a asignar un **.bg-purple_light[color a cada dato en funci√≥n de su continente]** con `aes(color = continent)`


```r
# Tama√±o fijo
# Color por continentes
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
*          color = continent)) +
  geom_point(size = 7)
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-835-1.png" width="91%" /&gt;

]

---

# Mapeado de atributos est√©ticos: .orange[aes()]


.pull-left[
  
Podemos combinarlo con lo que hemos hecho anteriormente:

* **.bg-purple_light[color]** en funci√≥n del **.bg-orange[continente]**.

* **.bg-purple_light[tama√±o]** en funci√≥n de la **.bg-orange[poblaci√≥n]**.

* **.bg-purple_light[transparencia]** la fijamos  **.bg-orange[constante]** del 50%.


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent,
           size = pop)) +
  geom_point(alpha = 0.7)
```

A este scatter plot particular se le conoce **.bg-purple_light[bubble chart]**

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-837-1.png" width="91%" /&gt;

]

---

# Visualizaci√≥n .orange[MULTIVARIANTE]

.pull-left[
  
Reflexionemos sobre el gr√°fico anterior:

* **color** en funci√≥n del **continente**.
* **tama√±o** en funci√≥n de la **poblaci√≥n**
* **transparencia** fija del 50%

Usando los datos hemos conseguido dibujar en un **.bg-purple_light[gr√°fico bidimensional 4 variables]**: `lifeExp` y `gdpPercap` en los ejes , `continent` como color y `pop` como tama√±o de la geometr√≠a, con muy pocas l√≠neas de c√≥digo.


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7)
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-839-1.png" width="91%" /&gt;

]

---

# .orange[GEOMETR√çA]: .green[geom()]

Vamos a modificar la **.bg-purple_light[capa de geometr√≠a]** (al igual que hemos usado `geom_point()`)

.pull-left[

* **.bg-purple_light[l√≠neas]**: la geometr√≠as como l√≠nea con `geom_line()`.


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_line(alpha = 0.8, size = 1.5)
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-841-1.png" width="85%" /&gt;

]
  
---

# .orange[GEOMETR√çA]: .green[geom()]



Vamos a modificar la **.bg-purple_light[capa de geometr√≠a]** (al igual que hemos usado `geom_point()`)

.pull-left[

Asignado los  **.bg-purple_light[colores a la variable continent]**, autom√°ticamente obtenemos autom√°ticamente una **.bg-purple_light[curva por continente]**.

* **.bg-purple_light[l√≠neas]**: la geometr√≠as como l√≠nea con `geom_line()`.


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent)) +
  geom_line(alpha = 0.8, size = 1.5)
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-843-1.png" width="85%" /&gt;

]

---


# .orange[GEOMETR√çA]: .green[geom()]


Vamos a modificar la **.bg-purple_light[capa de geometr√≠a]** (al igual que hemos usado `geom_point()`)

.pull-left[

* **.bg-purple_light[hex√°gonos]**: la geometr√≠as como hex√°gonos con `geom_hex()`. Dado que ahora nuestra geometr√≠a tiene **.bg-purple_light[volumen]** tendremos dos par√°metros: `color`  para el contorno y `fill` para el relleno.


```r
ggplot(gapminder_1997 %&gt;%
         filter(continent != "Oceania"),
       aes(y = gdpPercap, x = lifeExp,
           fill = continent, size = pop)) +
  geom_hex(alpha = 0.8)
```

]


.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-845-1.png" width="85%" /&gt;

]


---

# .orange[GEOMETR√çA]: .green[geom()]


Vamos a modificar la **.bg-purple_light[capa de geometr√≠a]** (al igual que hemos usado `geom_point()`)

.pull-left[

* **.bg-purple_light[textos]**: la geometr√≠as como textos con `geom_text()` (aparezcan textos que tengamos en alguna variable, que mapearemos en `aes()` por el par√°metro `label = ...`



```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop,
*          label = country)) +
  geom_text(alpha = 0.8)
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-847-1.png" width="85%" /&gt;

]

---

# .orange[ESCALAS (scale)]: .green[coordenadas]

A veces querremos representar alguna de las variables usando **.bg-purple_light[escalas que no sean la lineal]**.


.pull-left[

Una muy habitual es la **.bg-purple_light[escala logar√≠tmica]** (importante indicarlo en el gr√°fico), lo que podemos hacer facilmente con `scale_x_log10()` y `scale_y_log10()`.


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  # Eje Y con escala logar√≠tmica
* scale_y_log10()
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-849-1.png" width="85%" /&gt;

]
  
---

# .orange[ESCALAS (scale)]: .green[coordenadas]

A veces querremos mantener la escala pero **.bg-purple_light[fijar l√≠mites en los ejes]**.


.pull-left[

Eso lo podemos hacer dentro de las funciones `scale_x_...()` y `scale_y_...()` con `limits = ...`


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() + 
  scale_x_continuous(
*   limits = c(0, 100))
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-851-1.png" width="85%" /&gt;

]

---

# .orange[ESCALAS (scale)]: .green[coordenadas]

La capa de escalas tambi√©n nos sirve para **.bg-purple_light[formatear los ejes]**


.pull-left[

Por ejemplo, con `breaks = ...` podemos determinar el **.bg-purple_light[espaciado exacto]** que queremos en la gr√°fica.


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() + 
  scale_x_continuous(
*   breaks = seq(35, 85, by = 5))
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-853-1.png" width="85%" /&gt;

]

---

# .orange[ESCALAS (scale)]: .green[coordenadas]

La capa de escalas tambi√©n nos sirve para **.bg-purple_light[formatear los ejes]**

.pull-left[

Haciendo uso del paquete `{scales}` podemos a√±adir **.bg-purple_light[prefijo/sufijo a las etiquetas]** mostradas en los ejes, asign√°ndoselo al par√°metro `labels = ...`


```r
library(scales)
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() + 
  scale_x_continuous(
    breaks = seq(35, 85, by = 5),
    labels =
*     label_number(suffix = " a√±os"))
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-855-1.png" width="85%" /&gt;

]

---

# .orange[ESCALAS (scale)]: .green[coordenadas]

.pull-left[

Tenemos funciones concretas para **.bg-purple_light[formatear ejes]** como fechas (`scale_x_date()`), porcentajes (`labels = label_percent()`) o incluso **unidades monetarias** (`labels = label_dollar()`).


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10(
    labels =
      label_dollar(big.mark = ".",
                   accuracy = 3,
                   prefix = "",
                   suffix = "$")) + 
  scale_x_continuous(
    breaks = seq(35, 85, by = 5),
    labels =
*     label_number(suffix = " a√±os"))
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-857-1.png" width="85%" /&gt;

]

---

# .orange[ESCALAS (scale)]: .green[colores]

La capa de escalas tambi√©n nos sirve para **.bg-purple_light[proporcionar una paleta de colores]**

.pull-left[

ggplot selecciona autom√°ticamente una paleta de colores, pero podemos indicarle alguna concreta. La primera y m√°s inmediata es indicarle los **.bg-purple_light[colores manualmente]** con `scale_color_manual()`.


```r
pal &lt;- c("#A02B85", "#2DE86B", "#4FB2CA",
         "#E8DA2D", "#E84C2D")
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
* scale_color_manual(values = pal)
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-859-1.png" width="85%" /&gt;

]

---

# .orange[ESCALAS (scale)]: .green[colores]

La capa de escalas tambi√©n nos sirve para **.bg-purple_light[proporcionar una paleta de colores]**

.pull-left[

Otra opci√≥n es elegir alguna de las **.bg-purple_light[paletas de colores dise√±adas]** en el paquete `{ggthemes}`:

* `scale_color_economist()`: paleta de colores basada en los colores de **.bg-purple_light[The Economist]**.


```r
library(ggthemes)
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
* scale_color_economist()
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-861-1.png" width="85%" /&gt;

]

---

# .orange[ESCALAS (scale)]: .green[colores]

La capa de escalas tambi√©n nos sirve para **.bg-purple_light[proporcionar una paleta de colores]**

.pull-left[

Otra opci√≥n es elegir alguna de las **.bg-purple_light[paletas de colores dise√±adas]** en el paquete `{ggthemes}`:

* `scale_color_excel()`: paleta de colores basada en los colores del **.bg-purple_light[Excel]**.



```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
* scale_color_excel()
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-863-1.png" width="85%" /&gt;

]

---

# .orange[ESCALAS (scale)]: .green[colores]

La capa de escalas tambi√©n nos sirve para **.bg-purple_light[proporcionar una paleta de colores]**

.pull-left[

Otra opci√≥n es elegir alguna de las **.bg-purple_light[paletas de colores dise√±adas]** en el paquete `{ggthemes}`:

* `scale_color_tableau()`: paleta de colores basada en los colores de  **.bg-purple_light[Tableau]**.



```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
* scale_color_tableau()
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-865-1.png" width="85%" /&gt;

]


---

# .orange[ESCALAS (scale)]: .green[colores]


Tambi√©n existen **m√∫ltiples paquetes** que nos proporcionan **paletas de colores** 


.pull-left[

* **.bg-purple_light[pel√≠culas]**: paquete `{harrypotter}` (repositorio de Github `aljrico/harrypotter`) usando `scale_color_hp_d()`.


```r
library(devtools)
repo &lt;- "aljrico/harrypotter"
*install_github(repo = repo)

library(harrypotter)
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.9) +
  scale_y_log10() +
  scale_color_hp_d(
*   option = "ravenclaw")
```

]

.pull-right[


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://raw.githubusercontent.com/aljrico/harrypotter/master/readme_raw_files/palettes/ravenclaw.png" alt="Paleta basada en la casa Ravenclaw" width="15%" /&gt;
&lt;p class="caption"&gt;Paleta basada en la casa Ravenclaw&lt;/p&gt;
&lt;/div&gt;

&lt;img src="index_files/figure-html/unnamed-chunk-868-1.png" width="70%" /&gt;

]

---

# .orange[ESCALAS (scale)]: .green[colores]


.pull-left[

* **.bg-purple_light[cuadros]**: paquete `{MetBrewer}` (repositorio de Github `BlakeRMills/MetBrewer`) usando `scale_colour_manual(values = met.brewer(...))`.


```r
repo &lt;- "BlakeRMills/MetBrewer"
*install_github(repo = repo)

library(MetBrewer)
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.9) +
  scale_y_log10() +
  scale_color_manual(
*   values = met.brewer("Hokusai"))
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-870-1.png" width="85%" /&gt;

]



---


# .orange[ESCALAS (scale)]: .green[colores]


.pull-left[

* **.bg-purple_light[discos]**: paquete `{peRReo}` (repositorio de Github `jbgb13/peRReo`) usando `scale_colour_manual(values = latin_palette())`.



```r
library(devtools)
repo &lt;- "jbgb13/peRReo"
*install_github(repo = repo)

library(peRReo)
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.9) +
  scale_y_log10() +
  scale_color_manual(
*   values = latin_palette("rosalia"))
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-872-1.png" width="85%" /&gt;

]


---

# .orange[COMPONER]: .green[facet()]

Tambi√©n podemos **.bg-purple_light[dividir/desagregar los gr√°ficos (facetar)]** por variables.

.pull-left[

Por ejemplo, vamos a crear un **.bg-purple_light[gr√°fico por continente]**, mostrando todos los gr√°ficos a la vez pero por separado, con `facet_wrap(~continent)`.


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(alpha = 0.9) +
  scale_y_log10() +
* facet_wrap(~continent)
```


]

.pull-right[


&lt;img src="index_files/figure-html/unnamed-chunk-874-1.png" width="85%" /&gt;

]

---

# .orange[COMPONER]: .green[facet()]

Tambi√©n podemos **.bg-purple_light[dividir/desagregar los gr√°ficos (facetar)]** por variables.

.pull-left[

Tambi√©n le podemos pasar argumentos opcionales para indicarle el **.bg-purple_light[n√∫mero de columnas o filas]** que queremos.



```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(alpha = 0.9) +
  scale_y_log10() +
* facet_wrap(~continent, nrow = 3)
```


]

.pull-right[


&lt;img src="index_files/figure-html/unnamed-chunk-876-1.png" width="85%" /&gt;

]

---

# .orange[COMPONER]: .green[facet()]

Tambi√©n podemos **.bg-purple_light[dividir/desagregar los gr√°ficos (facetar)]** por variables.

.pull-left[

Tambi√©n le podemos pasar dos argumentos (variables) para formar un **.bg-purple_light[grid de gr√°ficas]**



```r
*ggplot(gapminder,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(alpha = 0.9) +
  scale_y_log10() +
* facet_grid(continent ~ year)
```


]

.pull-right[


&lt;img src="index_files/figure-html/unnamed-chunk-878-1.png" width="85%" /&gt;

]


---

# .orange[ESTAD√çSTICA]: .green[stat_...()]

Tambi√©n podemos a√±adir **.bg-purple_light[capas estad√≠sticas]**

.pull-left[

* `stat_smooth()`: visualiza un **.bg-purple_light[ajuste suavizado]** (con glm, loess, o regresi√≥n lineal por ejemplo).


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(alpha = 0.7, size = 5) +
  scale_y_log10() +
  scale_color_tableau() +
* stat_smooth(method = "lm")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-880-1.png" width="85%" /&gt;

]

---


# .orange[ESTAD√çSTICA]: .green[stat_...()]

Tambi√©n podemos a√±adir **.bg-purple_light[capas estad√≠sticas]**

.pull-left[

Podemos indicarle en `se = FALSE` que no pinte los intervalos de confianza.


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(alpha = 0.7, size = 5) +
  scale_y_log10() +
  scale_color_tableau() +
  stat_smooth(method = "lm",
*             se = FALSE)
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-882-1.png" width="85%" /&gt;

]

---


# .orange[ESTAD√çSTICA]: .green[stat_...()]

Tambi√©n podemos a√±adir **.bg-purple_light[capas estad√≠sticas]**

.pull-left[

Si las trazas est√°n separadas realizada el suavizado de todas ellas. 


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent)) +
  geom_point(alpha = 0.7, size = 5) +
  scale_y_log10() +
  scale_color_tableau() +
  stat_smooth(method = "lm",
              se = FALSE)
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-884-1.png" width="85%" /&gt;

]



---


# .orange[ETIQUETAR]: .green[geom_text()]

.pull-left[

Podemos combinarlo con `geom_text()` para  **.bg-purple_light[a√±adir la ecuaci√≥n del ajuste]**


```r
lm_fit &lt;-
  lm(data = gapminder_1997,
     formula = gdpPercap ~ lifeExp)
a &lt;- round(coef(lm_fit)[1], 2)
b &lt;- round(coef(lm_fit)[2], 2)

ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(alpha = 0.7, size = 5) +
  scale_y_log10() +
  stat_smooth(method = "lm",
              se = FALSE) +
  geom_text(x = 45, y = log10(30000),
            label =
              glue("Y = {a} + {b}X"),
            size = 5)
```

]

.pull-right[


&lt;img src="index_files/figure-html/unnamed-chunk-886-1.png" width="85%" /&gt;


]

---

# .orange[ESTAD√çSTICA]: .green[stat_...()]

Tambi√©n podemos a√±adir **.bg-purple_light[capas estad√≠sticas]**

.pull-left[

Con `stat_summary()` podemos incluso a√±adir estad√≠sticas por grupos, como la media o mediana.


```r
ggplot(gapminder,
       aes(y = gdpPercap, x = year)) +
  geom_point(alpha = 0.7, size = 3) +
  stat_summary(fun = "mean", size = 0.3,
               color = "coral") + 
  stat_summary(fun = "median", size = 0.3,
               color = "darkcyan")
```

]

.pull-right[


&lt;img src="index_files/figure-html/unnamed-chunk-888-1.png" width="85%" /&gt;

]

---

# .orange[ESTAD√çSTICA]: .green[stat_...()]

Tambi√©n podemos a√±adir **.bg-purple_light[capas estad√≠sticas]**

.pull-left[

F√≠jate que si no tenemos una variable cuali, la media la hace con `n = 1` (es decir, es el propio punto).


```r
ggplot(gapminder,
       aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.7, size = 3) +
  stat_summary(fun = "mean",
               size = 0.2,
               color = "black")
```

]

.pull-right[


&lt;img src="index_files/figure-html/unnamed-chunk-890-1.png" width="85%" /&gt;

]


---


# .orange[TEMA]: .green[theme()]


Por √∫ltimo podemos **.bg-purple_light[personalizar el tema]** de los gr√°ficos.

.pull-left[

Por ejemplo, podemos **.bg-purple_light[a√±adir t√≠tulos,  subt√≠tulos y pie de gr√°fica]** con `labs()`,


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau() +
  labs(
    title = "Primer scatter plot",
    subtitle = "Datos de 1997",
    caption = "Autor: J. √Ålvarez")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-892-1.png" width="85%" /&gt;

]

---

# .orange[TEMA]: .green[theme()]


Tambi√©n podemos personalizar el **.bg-purple_light[t√≠tulo de los ejes]** o el **.bg-purple_light[t√≠tulo de las leyendas]**.

.pull-left[


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau() +
  labs(
    title = "Primer scatter plot",
    subtitle = "Datos de 1997",
    caption = "Autor: J. √Ålvarez",
    x = "Esperanza de vida",
    y = "Renta per c√°pita",
    color = "Continente",
    size = "Poblaci√≥n")
```

]


.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-894-1.png" width="85%" /&gt;

]

---

# .orange[TEMA]: .green[theme()]


Tambi√©n podemos **.bg-purple_light[ocultar el nombre de la leyenda]** asign√°ndole un `NULL`.

.pull-left[



```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau() +
  labs(
    title = "Primer scatter plot",
    subtitle = "Datos de 1997",
    caption = "Autor: J. √Ålvarez",
    x = "Esperanza de vida",
    y = "Renta per c√°pita",
    color = NULL, size = "Poblaci√≥n")
```

]

.pull-right[


&lt;img src="index_files/figure-html/unnamed-chunk-896-1.png" width="85%" /&gt;

]

---


# .orange[TEMA]: .green[theme()]


Incluso podemos **.bg-purple_light[ocultar la leyenda]** de alguna de las variables con `guides()`


.pull-left[


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau() +
* guides(size = "none") +
  labs(
    title = "Primer scatter plot",
    subtitle = "Datos de 1997",
    caption = "Autor: J. √Ålvarez",
    x = "Esperanza de vida",
    y = "Renta per c√°pita",
    color = NULL)
```

]


.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-898-1.png" width="85%" /&gt;

]

---


# .orange[TEMA]: .green[theme()]

Tenemos adem√°s algunos temas ya predefinidos en el paquete `{ggthemes}`



.pull-left[


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau() +
  guides(size = "none") + 
  labs(
    title = "Primer scatter plot",
    subtitle = "Datos de 1997",
    caption = "Autor: J. √Ålvarez",
    x = "Esperanza de vida",
    y = "Renta per c√°pita",
    color = NULL) +
* theme_excel()
```

]


.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-900-1.png" width="85%" /&gt;

]

---



# .orange[TEMA]: .green[theme()]

Tenemos adem√°s algunos temas ya predefinidos en el paquete `{ggthemes}`



.pull-left[


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau() +
  guides(size = "none") + 
  labs(
    title = "Primer scatter plot",
    subtitle = "Datos de 1997",
    caption = "Autor: J. √Ålvarez",
    x = "Esperanza de vida",
    y = "Renta per c√°pita",
    color = NULL) +
* theme_fivethirtyeight()
```

]


.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-902-1.png" width="85%" /&gt;

]


---

# .orange[TEMA]: .green[theme()]

Tenemos adem√°s algunos temas ya predefinidos en el paquete `{ggthemes}`



.pull-left[


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau() +
  guides(size = "none") + 
  labs(
    title = "Primer scatter plot",
    subtitle = "Datos de 1997",
    caption = "Autor: J. √Ålvarez",
    x = "Esperanza de vida",
    y = "Renta per c√°pita",
    color = NULL) +
* theme_economist()
```

]


.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-904-1.png" width="85%" /&gt;

]

---


# .orange[TEMA]: .green[theme()]

Tenemos adem√°s algunos temas ya predefinidos en el paquete `{ggthemes}`



.pull-left[


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau() +
  guides(size = "none") + 
  labs(
    title = "Primer scatter plot",
    subtitle = "Datos de 1997",
    caption = "Autor: J. √Ålvarez",
    x = "Esperanza de vida",
    y = "Renta per c√°pita",
    color = NULL) +
* theme_bw()
```

]


.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-906-1.png" width="85%" /&gt;

]


---


# .orange[TEMA]: .green[theme()]

Una opci√≥n muy habitual es usar `theme_minimal()`, ya que es un tema muy limpio, y luego con `theme_update()` configurarlo a nuestro gusto.


.pull-left[


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau() +
  guides(size = "none") + 
  labs(
    title = "Primer scatter plot",
    subtitle = "Datos de 1997",
    caption = "Autor: J. √Ålvarez",
    x = "Esperanza de vida",
    y = "Renta per c√°pita",
    color = NULL) +
* theme_minimal()
```

]


.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-908-1.png" width="83%" /&gt;

]


---

# .orange[TEMA]: .green[theme()]

* `sysfonts::font_add_google()`: le indicaremos la tipograf√≠a de &lt;https://fonts.google.com/&gt;

* `showtext_auto()` del paquete `{showtext}` nos permite su posterior uso.

* `theme_set()`: inicializamos el tema con la fuente

* `theme_update()`: configuramos cada elemento a nuestro gusto (mira `? theme`).



```r
sysfonts::font_add_google(name = "Roboto") # Fuente de google
# Usar fuentes a futuro
library(showtext)
showtext_auto()

theme_set(theme_minimal(base_family = "Roboto")) # Definir tema base

# Configurar tema
theme_update(
  plot.title = element_text(color = "#C34539", face = "bold", size = 27),
  plot.subtitle = element_text(color = "#3E6FCB", face = "bold", size = 17))
```

---


# .orange[TEMA]: .green[theme()]

Una vez definido el tema, **.bg-purple_light[todas las gr√°ficas que hagas lo tendr√°n incluido]**, y as√≠ evitas programarlo en cada una

.pull-left[


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau() +
  guides(size = "none") + 
  labs(
    title = "Primer scatter plot",
    subtitle = "Datos de 1997",
    caption = "Autor: J. √Ålvarez",
    x = "Esperanza de vida",
    y = "Renta per c√°pita",
    color = NULL)
```

]


.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-911-1.png" width="85%" /&gt;

]

---

# .orange[UNIR] gr√°ficas

Con el paquete `{patchwork}` podremos **.bg-purple_light[combinar varias gr√°ficas]** (ver documentaci√≥n en &lt;https://patchwork.data-imaginist.com/&gt;)


Por ejemplo, vamos a combinar en una gr√°fica los datos de 1987, de 2007 y la media en todos los a√±os

--


```r
gapminder_1987 &lt;-
  gapminder %&gt;% filter(year == 1987)

gapminder_2007 &lt;-
  gapminder %&gt;% filter(year == 2007)

gapminder_mean &lt;-
  gapminder %&gt;% 
  group_by(continent, country) %&gt;% 
  summarise(gdpPercap = mean(gdpPercap),
            lifeExp = mean(lifeExp),
            pop = pop) %&gt;% 
  ungroup()
```


---

# .orange[UNIR] gr√°ficas

Tras ello vamos a definir cada gr√°fica por separado


```r
plot_1987 &lt;-
  ggplot(gapminder_1987, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau() +
  labs(x = "Esperanza de vida", y = "Renta per c√°pita", subtitle = "1987")

plot_2007 &lt;-
  ggplot(gapminder_2007, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau() +
  labs(x = "Esperanza de vida", y = "Renta per c√°pita", subtitle = "2007")

plot_mean &lt;-
  ggplot(gapminder_mean, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau() +
  labs(x = "Esperanza de vida", y = "Renta per c√°pita", subtitle = "Media (1952-2007)")
```

---

# .orange[UNIR] gr√°ficas

Por √∫ltimo con `{patchwork}` podemos combinar las gr√°ficas sum√°ndolas `+` (con `|` podremos poner una al lado de la otra), y con `&amp;` podremos modificar aspectos de las mismas, de todas ellas a la vez.

.pull-left[

Con `plot_layout(guides = "collect")` le indicamos que unifique leyenda y con `plot_annotation()` anotaciones globales.


```r
library(patchwork)
plot_combined &lt;-
  (plot_mean | (plot_1987 + plot_2007)) &amp;
  theme(legend.position = "bottom") &amp;
  labs(color = "continente")

plot_combined + 
  plot_annotation(
    title = "Uni√≥n de gr√°ficas",
    caption = "Autor: J. √Ålvarez") +
  plot_layout(guides = "collect")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-915-1.png" width="85%" /&gt;

]

---

# .orange[EXPORTAR] gr√°ficas

Con `ggsave()` podemos adem√°s **.bg-purple_light[exportar nuestros gr√°ficos]**


```r
plot_combined &lt;-
  (plot_mean | (plot_1987 + plot_2007)) &amp;
  theme(legend.position = "bottom") &amp;
  labs(color = "continente")

plot_combined &lt;-
  plot_combined + 
  plot_annotation(
    title = "Uni√≥n de gr√°ficas",
    caption = "Autor: J. √Ålvarez") +
  plot_layout(guides = "collect")

*ggsave("./gapminder.pdf")
*ggsave("./gapminder.png")
```



---

class: inverse center middle
name: clase-10

# CLASE 10: √°rboles

&amp;nbsp;

### [Introducci√≥n te√≥rica](#intro-teoria)

---

name: intro-teoria

# .orange[√ÅRBOLES]: divide and conquer

Los **.bg-purple_light[arboles de clasificaci√≥n y regresi√≥n]** (empezaremos por los primeros), conocidos como CART, fueron
propuestos por Breiman et al. en 1984.

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/arboles_segmentar.jpg" alt="Extra√≠da de https://bookdown.org/content/2031/arboles-de-decision-parte-i.htmlque-son-los-arboles-de-decision30" width="63%" /&gt;
&lt;p class="caption"&gt;Extra√≠da de https://bookdown.org/content/2031/arboles-de-decision-parte-i.htmlque-son-los-arboles-de-decision30&lt;/p&gt;
&lt;/div&gt;

**.bg-orange[Idea]**: segmentar el espacio de predictores (variables independientes) en **.bg-purple_light[regiones distintas y no solapadas]** a partir de un conjunto de reglas de decisi√≥n simples aplicadas de forma secuencial.


---

# .orange[√ÅRBOLES]: introducci√≥n te√≥rica

Un √°rbol estar√° formado por los siguientes elementos:

.pull-left[

* **.bg-purple_light[Nodos]**: segmentos del √°rbol que contienen subconjuntos de la muestra.

* **.bg-purple_light[Nodo ra√≠z]**: segmento original (arranque inicial del √°rbol) que contiene a la **.bg-purple_light[totalidad]** de los datos.

* **.bg-purple_light[Nodo padre/hijo]**: nodos predecesor/sucesor de otro nodo.

* **.bg-purple_light[Rama]**: nodo y el conjunto de sus sucesores

* **.bg-purple_light[Hojas]**: nodos sin hijos em los que **.bg-purple_light[finaliza una rama]** y que usaremos para asignar las clases predichas.

]

.pull-right[


&lt;img src="./img/arbol_colesterol.jpg" width="99%" style="display: block; margin: auto;" /&gt;

]

---

# .orange[√ÅRBOLES]: construcci√≥n

.pull-left[

* **.bg-purple_light[Paso 1]**: partimos de un nodo ra√≠z con todas las observaciones.

* **.bg-purple_light[Paso 2]**: decidir la **.bg-purple_light[regla de decisi√≥n √≥ptima]** (tomaremos decisiones binarias)
  - Decidir el **.bg-purple_light[mejor punto de corte de todas]** las variables a elegir.
  - Una vez que tenemos calculado el punto de corte √≥ptimo de todas, nos quedamos con la mejor variable (¬øqu√© es mejor?)

* **.bg-purple_light[Paso 3]**: repetimos proceso anterior hasta criterio de parada

]

.pull-right[

&lt;img src="./img/arboles_cortes.jpg" width="100%" style="display: block; margin: auto;" /&gt;

Esta forma de construcci√≥n de √°rbol **.bg-purple_light[no asegura obtener el mejor √°rbol posible]**: no se eval√∫an todas las combinaciones posibles, es **.bg-purple_light[algoritmo greedy o voraz]**.

]

---

# Criterios de .orange[PARADA]

Existen muchos criterios de parada pero los m√°s habituales son los siguientes:

* **.bg-purple_light[Mejora insuficiente]**: ninguna de las variables y cortes posibles produce una mejora suficiente que compense sobreajustar el modelo.

* **.bg-purple_light[Tama√±o de hoja]**: los posibles hijos tienen pocas observaciones (tama√±o inferior a un valor/porcentaje de la muestra fijado) para seguir dividiendo.

* **.bg-purple_light[Tama√±o de divisi√≥n]**: n√∫mero de observaciones en la hoja actual (nodo susceptible de ser segmentado) demasiado peque√±o. Tendr√° relaci√≥n con el criterio anterior.

* **.bg-purple_light[Profundidad del √°rbol]**: distancia (en n√∫mero de nodos entre ra√≠z y hoja m√°s alejada) que supere un umbral predefinido para evitar el sobreajuste.

---

# .orange[ASIGNACI√ìN] de clase


.pull-left[

* **.bg-purple_light[√Årbol de clasificaci√≥n]**: para variables objetivo cualitativa se calcular√°n las **.bg-purple_light[probabilidades estimadas]** como la proporci√≥n de eventos en dicho
nodo. Lo habitual es asignar al nodo la **.bg-purple_light[categor√≠a modal]**.

* **.bg-purple_light[√Årbol de regresi√≥n]**: para variables objetivo cuantitativa se calcular√° la **.bg-purple_light[estimaci√≥n de continua]** como la media de los valores en dicho nodo.

]

.pull-right[


&lt;img src="./img/arbol_colesterol.jpg" width="99%" style="display: block; margin: auto;" /&gt;

]

---

# Criterios de .orange[MEJORA/DIVISI√ìN]


* **.bg-purple_light[Criterios basados en la impureza]**: llamaremos impureza a la cantidad de **.bg-purple_light[¬´ruido¬ª]** que quedar√≠a en nuestros nodos en caso de realizar la divisi√≥n. Un **.bg-orange[nodo puro tendr√° impureza nula]** (solo elementos de una clase) .

&lt;img src="./img/impureza.jpg" width="70%" style="display: block; margin: auto;" /&gt;


* **.bg-purple_light[Criterios basados en inferencia]**: los conocidos como **.bg-purple_light[√°rboles condicionados o inferenciales]** la selecci√≥n de ramas se realiza en base a un **.bg-purple_light[contraste de independencia]**. Si el contraste nos pide rechazar la hip√≥tresis nula de independencia, significa hay una dependencia entre el corte y el reparto de clases de la objetivo (corte √∫til para segmentar. 

---

# Impureza: .orange[√çNDICE DE GINI]

* **.bg-purple_light[Criterio del √≠ndice de Gini]**: criterio basado en la impureza, definida como la **.bg-purple_light[probabilidad]** de, **.bg-purple_light[extra√≠dos dos elementos de un nodo]** (con remplazamiento), que **.bg-purple_light[no sean de la misma clase]**. Si tenemos una objetivo con `\(k\)` categor√≠as entonces, llamaremos `\(P(C_i)\)` a la probabilidad de que los dos elementos sean de la categor√≠a `\(C_i\)`, con `\(i=1, \ldots, C\)`

Para cada nodo, la **.bg-purple_light[probabilidad de que ambos sean de la misma categor√≠a]** (clases no solapadas, la intersecci√≥n es nula) ser√° por tanto

`$$P(C_1 \cup C_2 \cup \ldots \cup C_k) = \sum_{i=1}^{k}P(C_i) = \sum_{i=1}^{k} \left(\frac{n(C_i)}{n(nodo)}\right)^2$$`

--

La impureza entonces queda definida como su complementario

`$$Gini(nodo) = 1 - \sum_{i=1}^{k} \left(\frac{n(C_i)}{n(nodo)}\right)^2$$`

---

# Impureza: .orange[√çNDICE DE GINI]

La impureza entonces queda definida como

`$$Gini(nodo) = 1 - \sum_{i=1}^{k} \left(\frac{n(C_i)}{n(nodo)}\right)^2$$`

* **.bg-purple_light[Mejor caso]**: que todos sean de la misma clase, por ejemplo `\(C_1\)`, tal que `\(Gini(nodo) = 1 - \left(\frac{n(C_1)}{n(nodo)}\right)^2 = 0\)`

* **.bg-purple_light[Peor caso]**: que tengas las clases igual de repartidas tal que `\(Gini(nodo) = 1 - \sum_{i=1}^{k} \left(\frac{n(nodo) / k}{n(nodo)}\right)^2 = 1-\sum_{i=1}^{k} \frac{1}{k^2} = 1 - \frac{1}{k}\)` (0.5 en el caso de que tengamos `\(k=2\)`)

--

La **.bg-purple_light[impureza total del √°rbol]** se calcular√° como la suma de las impurezas de cada nodo ponderadas por su tama√±o (n√∫mero de observaciones de cada nodo).

---

# Impureza: .orange[ENTROP√çA]

* **.bg-purple_light[Criterio de entrop√≠a]**: criterio basado en la impureza, definida como la **.bg-purple_light[cantidad de informaci√≥n necesaria para ¬´explicar¬ª el nodo]**. La entrop√≠a en teor√≠a de la informaci√≥n se define como `\(H = -\sum_{i=1}^{k}p_i log_2(pi)\)`, donde `\(p_i\)` es la probabilidad de cada uno de los posibles evenetos (se usa log en base 2 porque se asume que la informaci√≥n ser√° representada en c√≥digo binario)

--

Para cada nodo, la **.bg-purple_light[entrop√≠a]** ser√° definida por tanto como

`$$H(nodo) = -\sum_{i=1}^{k}\frac{n(C_i)}{n(nodo)} log_2\left( \frac{n(C_i)}{n(nodo)} \right)$$`

---



# Impureza: .orange[ENTROP√çA]

Para cada nodo, la **.bg-purple_light[entrop√≠a]** ser√° definida por tanto como

`$$H(nodo) = -\sum_{i=1}^{k}\frac{n(C_i)}{n(nodo)} log_2\left( \frac{n(C_i)}{n(nodo)} \right)$$`

* **.bg-purple_light[Mejor caso]**: que todos sean de la misma clase, por ejemplo `\(C_1\)`, tal que `\(H(nodo) =-\frac{n(C_1)}{n(nodo)} log_2\left(\frac{n(C_1)}{n(nodo)} \right) = -log_2(1) = 0\)`

* **.bg-purple_light[Peor caso]**: que tengas las clases igual de repartidas tal que `\(H(nodo) = -\sum_{i=1}^{k}\frac{n(nodo)/k}{n(nodo)} log_2\left( \frac{n(nodo)/k}{n(nodo)} \right) = -\sum_{i=1}^{k}\frac{1}{k} log_2\left( \frac{1}{k} \right)\)` (1 en el caso de que tengamos `\(k=2\)`)

--

La **.bg-purple_light[impureza total del √°rbol]** se calcular√° como la suma de las entrop√≠as de cada nodo ponderadas por su tama√±o (n√∫mero de observaciones de cada nodo).

---

# Impureza: .orange[caso pr√°ctico]

Determina la impureza seg√∫n ambos criterios en el ejemplo de la imagen, para cada uno de los posibles cortes, con la variable objetivo definida como ¬´juega al cricket¬ª (binaria)

&lt;img src="./img/impureza.jpg" width="100%" style="display: block; margin: auto;" /&gt;

---

# .orange[RECURSOS] y .green[BIBLIOGRAF√çA]

&amp;nbsp;


#### üìö **.bg-purple_light[Art√≠culos o libros]** cient√≠ficos que han sido sometidos a revisi√≥n por pares.

&amp;nbsp;

#### üîó **.bg-green_light[Recursos online]** recomendados

&amp;nbsp;

#### üíª Recursos para la **.bg-orange[programaci√≥n en R]**

---

# Bibliograf√≠a general

üìö **¬´Statistical tests, P values, confidence intervals, and power: a guide to misinterpretations¬ª**. Greenland et al. (2016) &lt;https://github.com/dadosdelaplace/teaching/blob/main/data_mining/biblio/p-value_Greenland_etal_2016.pdf&gt;

üíª **Tidy Data Tutor**: para visualizar la mec√°nica interna de `{tidyverse}`. &lt;https://tidydatatutor.com/&gt;

üîó Web con recursos para la **introducci√≥n a la estad√≠stica y Machine Learning en R** &lt;https://artofstat.com/&gt;

üíª **Manual introductorio de R** (Javier √Ålvarez Li√©bana): &lt;https://dadosdelaplace.github.io/courses-intro-R/&gt;


---

# Bibliograf√≠a general

üìö **¬´The reproducibility of research and the misinterpretation of p-values¬ª**. Colquhoun (2017) &lt;https://github.com/dadosdelaplace/teaching/blob/main/data_mining/biblio/p-values_Colquhoun_2017.pdf&gt;


üìö **¬´An Introduction to Multivariate Statistical Analysis¬ª**. Anderson (1958) &lt;https://github.com/dadosdelaplace/teaching/blob/main/data_mining/biblio/introduction_mva_anderson_2003.pdf&gt;

üìö **¬´A New Measure of Rank Correlation¬ª**. Kendall (1938) &lt;https://github.com/dadosdelaplace/teaching/blob/main/data_mining/biblio/correlation_kendall_1938.pdf&gt;

üìö **¬´The generalised product moment distribution in samples from a normal multivariate population¬ª**. Wishart (1928) &lt;https://github.com/dadosdelaplace/teaching/blob/main/data_mining/biblio/multivariate_normal_wishart_1928.pdf&gt;

üìö **¬´On lines and planes of closest fit to systems of points in space¬ª**. Pearson (1901) &lt;https://github.com/dadosdelaplace/teaching/blob/main/data_mining/biblio/fit_pearson_1901.pdf&gt;


---

# Recursos dataviz

### Dataviz

üìö **¬´Gram√°tica de las gr√°ficas: pistas para mejorar las representaciones de datos¬ª**. Sevilla (2005) &lt;http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf&gt;

üìö **¬´Quantitative Graphics in Statistics: A Brief History¬ª**. Beniger and Robyn (1978) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/graphics_beniger_robin_1978.pdf&gt;
 
 
üíª **¬´Analizando datos, visualizando informaci√≥n, contando historias¬ª** (curso de dataviz en R). √Ålvarez-Li√©bana y Valverde-Castilla (2022) &lt;https://dadosdelaplace.github.io/curso-dataviz-ECI-2022&gt;

üìö **¬´40 years of boxplots¬ª**. Wickham and Stryjewski (2011) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/boxplot_Wickham_Stryjewski_2011.pdf&gt;
 
 


---

# Bibliograf√≠a componentes principales

üíª **Componentes principales** en `{tidymodels}`. &lt;https://www.tmwr.org/dimensionality.html#beans&gt;


üìö **¬´Principal Component Analysis¬ª**. Jolliffe (2002) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/pca_jolliffe_2002.pdf&gt;

üìö **¬´Principal Component Analysis¬ª**. Herv√© and Lynne (2010) &lt;http://staff.ustc.edu.cn/~zwp/teach/MVA/abdi-awPCA2010.pdf&gt;

üìö **¬´Principal Component Analysis: a review and recent developments¬ª**. Jolliffe and Cadima (2016) &lt;https://royalsocietypublishing.org/doi/10.1098/rsta.2015.0202&gt;

üîó **¬´The Mathematics Behind Principal Component Analysis¬ª**. Dubey (2018).  &lt;https://towardsdatascience.com/the-mathematics-behind-principal-component-analysis-fff2d7f4b643&gt;


üîó **¬´A One-Stop Shop for Principal Component Analysis¬ª**. Brems (2017). &lt;https://towardsdatascience.com/a-one-stop-shop-for-principal-component-analysis-5582fb7e0a9c&gt;

üìö **¬´On the number of principal components: a test of dimensionality based on measurements of similarity between matrices¬ª**. Dray (2008) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/numer_pca_dray_2008.pdf&gt;


---
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"slideNumberFormat": "%current%",
"highlightStyle": "github",
"highlightLines": true,
"ratio": "16:9",
"countIncrementalSlides": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
