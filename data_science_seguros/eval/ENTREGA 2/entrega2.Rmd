---
title: "Entrega II"
description: |
  Practicando tidyverse
author:
  - name: C. Tangana (DNI 0000000-A)
    affiliation: Universidad Complutense de Madrid
    affiliation_url: 
date: "`r Sys.Date()`"
output:
    distill::distill_article:
        highlight: kate
        colorlinks: true
        code_folding: false
        toc: true            
        toc_depth: 3     
---

```{r setup, include = FALSE}
# Ajuste comunes de los chunk
knitr::opts_chunk$set(fig.width = 9, fig.asp = 1, out.width = "100%",
                      message = FALSE, warning = FALSE,
                      echo = TRUE, res = 400)
```

# Instrucciones (leer antes de empezar)

* Modifica dentro del documento `.Rmd` tus datos personales (nombre y DNI) ubicados en la cabecera del archivo.

* Asegúrate, **ANTES de seguir editando** el documento, que el archivo `.Rmd` se teje correctamente (botón Knit) y se genera el `.html` correspondiente.

* Los chunks (cajas de código) creados están o vacíos o incompletos, de ahí que la mayoría tengan la opción `eval = FALSE`. Una vez que edites lo que consideres debes ir cambiando cada chunck a `eval = TRUE` para que se ejecuten.

* Recuerda que puedes ejecutar chunk a chunk con el botón _play_ o ejecutar todos los chunk hasta uno dado (con el botón a la izquierda del anterior).

# Caso práctico I : análisis de los datos de billboard

## Paquetes necesarios

Necesitaremos los siguientes paquetes:

```{r paquetes}
# Borramos variables del environment
rm(list = ls())
library(glue)
library(lubridate)
library(tidyverse)
```


## Carga de datos

El archivo de datos (`billboard`) a usar lo cargaremos del paquete`{tidyr}` dentro de `{tidyverse}`

```{r}
billboard
```

En él tenemos los datos de diferentes canciones en el año 2000 y su ranking en el top 100 de Billboard (algo así como los 40 principales) de forma que cuánto más bajo sea el ranking, mejor posición tiene la canción (tener ranking 1 es la mejor posición).


## Ejercicio 1:

> Selecciona solo las primeras 52 semanas haciendo uso de `num_range()`


```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE
billboard %>% select(...)
```

## Ejercicio 2:

> ¿El dataset es tidydata? ¿Por qué no? ¿Qué se necesitaría (sin hacerlo aún) para que sí lo fuese

[Detalla aquí lo que consideres]

## Ejercicio 3:

> Convierte el dataset a tidydata, ausentes incluidos (deberías obtener 16 484 filas y 5 columnas).

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE
billboard %>% pivot_...(...)
```

## Ejercicio 4:

> Convierte el dataset a tidydata pero eliminando ausentes (deberías obtener 5280 filas y 5 columnas). Guarda la tabla tidy

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE
billboard_tidy <- billboard %>% pivot_...(...)
```

## Ejercicio 5:

> La variable `week` procésala para que sea numérica

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE
billboard_tidy <- billboard_tidy %>% mutate(...)
```

## Ejercicio 6:

> Crea una nueva variable llamada `quarter` que nos codifique el cuatrimestre de cada registro (usando `data.entered`). Crea otra variable con el mes en `month`

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE
billboard_tidy <- billboard_tidy %>% mutate(...)
```

## Ejercicio 7:

> Extrae la lista de artistas distintos que aparecen en la tabla (y cuántas veces aparece cada uno)

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE
billboard_tidy %>%
  distinct(...) %>% 
  pull(...)

billboard_tidy %>% count(...)
```

## Ejercicio 8:

> Determina las canciones que más semanas aparecen en la lista de éxitos. Extrae las 10 que más semanas aparecen

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE
billboard_tidy %>%
  group_by(...) %>% 
  slice_...(...)
```

## Ejercicio 9

> Extrae los 10 artistas cuya canción aparece más semanas (cuidado: un artista tiene varias canciones)

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE
billboard_tidy %>%
  count(..., ...) %>% 
  slice_...(...)
```


## Ejercicio 10 (sin ayuda a partir de aquí)

> Determina el artista con más canciones en la lista

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE
billboard_tidy %>% ...
```

## Ejercicio 11:

> Calcula el número de canciones distintas que aparecen en la lista

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE
billboard_tidy %>% ...
```

## Ejercicio 12:

> Calcula la posición más alta en la que ha estado cada canción

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE
billboard_tidy %>% ...
```

## Ejercicio 13:

> Calcula la posición más alta en la que ha estado un artista

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE
billboard_tidy %>% ...
```

## Ejercicio 14:

> Obtén una tabla con el ranking medio de cada artista (contando solo el ranking más alto alcanzado por sus canciones), así como el número de canciones (distintas) que ha colocado en el top 100

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE
billboard_tidy %>% ...
```

## Ejercicio 15:

> Realiza un muestreo extrayendo solo los registros de Enrique Iglesias y The Backstreet Boys.

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE
billboard_tidy %>% ...
```

## Ejercicio 16:

> Obtén una tabla con el número de registros por quatrimestre (y su proporción respecto al total). Realiza un muestreo aleatorio estratificado, extrayendo el 50% de los datos pero manteniendo la proporción de datos entre los distintos cuatrimestres.

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE
billboard_tidy %>% ...
```
  






# Caso práctico II: datos de la OMS


## Carga de datos

El archivo de datos a usar lo cargaremos del paquete`{tidyr}` dentro de `{tidyverse}`

```{r}
who
```

En él tenemos un caso bastante real de lo que nos podemos encontrar con **datos reales**. En el archivo tenemos datos relacionados con casos de tuberculosis **desagregados por año, país, edad, género y el tipo**. Los datos son del año 2014 y fueron recopilados por la OMS. Fuente: <http://www.who.int/tb/country/data/download/en/>.


* `country`, `iso2`, `iso3`: país (en nombre, en código con dos letras y en código con tres letras).

* `year`: año

* El resto de nombres de columnas siguen el siguiente patrón:
  - Las 3 primeras letras nos dicen si son casos nuevos o antiguos.
  - Las dos siguientes letras nos dicen el tipo: `rel` para casos de recaída, `ep` para casos de tuberculosis extrapulmonar, `sn` para casos de tuberculosis pulmonar que podrían no haber sido diagnosticados con un frotis positivo (smear negative), `sp` para casos de tuberculosis pulmonar diagnosticados con un frotis positivo (smear positive).

  - La sexta letra nos dice el sexo del paciente.
  - El resto de números nos dan el tramo etario (por ejemplo, `...4554` se refiere al tramo de 45 a 54 años)

Echa un vistazo a los datos.


## Ejercicio 1:


> Tras analizar la tabla, construye partir de ella una nueva pero recolocados de tal forma que sea tidydata (depurando ausentes)

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE 
who1 <- who %>% pivot_...(...)
who1
```


## Ejercicio 2:


> Determina cuantos registros tienes de cada tipo (agrupando todos los países y todos los años)

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE 
who1 %>% count(...)
```

## Ejercicio 3:

> Observando la salida anterior, ¿deberíamos de cambiar algo de la variable que nos indica la tipología? ¿Hay coherencia en todas ellas?

[Detalla aquí lo que consideres]

## Ejercicio 4:

> Con la tabla del ejercicio 3 ejecuta este código modificando las partes que consideres para que funcione

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE 
who2 <- [tabla_ej3] %>% 
  mutate(... = str_replace(..., "newrel", "new_rel"))
who2
```

> ¿Qué crees que hemos hecho?

[Detalla aquí lo que consideres]

## Ejercicio 5:

> Construye nuevas columnas `"new"`, `"type"` y `"sexage"`, que nos separe el código de la tipología en cada una de sus partes (y se guarde en columnas nuevas)

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE 
who3 <- who2 %>% ...
who3
```

## Ejercicio 6:

> Con la tabla anterior, separa correctamente el sexo de la edad creando dos variables `"sex"` y `"age"`

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE 
who4 <- who3 %>% ...
who4
```

## Ejercicio 7:

> Haciendo uso de `select()`, mirando la chuleta de `{dplyr}`, ¿sabrías como eliminar dos de las 3 columnas redundantes de país?

```{r eval = FALSE}
# Completa el código y cambia a eval = TRUE
who5 <- who4 %>% ...
who5
```
