<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>GESTIÓN DE BASES DE DATOS</title>
    <meta charset="utf-8" />
    <meta name="author" content="Javier Álvarez Liébana (Fac. Estudios Estadísticos - UCM)" />
    <link href="index_files/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="index_files/tile-view-0.2.6/tile-view.js"></script>
    <link href="index_files/animate.css-3.7.2/animate.xaringan.css" rel="stylesheet" />
    <link href="index_files/tachyons-4.12.0/tachyons.min.css" rel="stylesheet" />
    <link href="index_files/xaringanExtra-extra-styles-0.2.6/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <script src="index_files/clipboard-2.0.6/clipboard.min.js"></script>
    <link href="index_files/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="index_files/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Click para copiar código","success":"Código copiado","error":"Ctrl+C para copiar"})</script>
    <link href="index_files/panelset-0.2.6/panelset.css" rel="stylesheet" />
    <script src="index_files/panelset-0.2.6/panelset.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# GESTIÓN DE BASES DE DATOS
## Máster en Bioestadística
### Javier Álvarez Liébana (Fac. Estudios Estadísticos - UCM)
### Última actualización: 10-10-2022

---










class: inverse center middle

# ATAJOS DE LAS DIAPOSITIVAS





`$$\\[2in]$$`

.left[Pulsa &lt;kbd-black&gt;O&lt;/kbd-black&gt; para ver el **PANEL DE DIAPOSITIVAS**]
.left[Pulsa &lt;kbd-black&gt;H&lt;/kbd-black&gt; para ver **OTROS ATAJOS**]

---

# .orange[MATERIAL] de las clases


.pull-left[

- **.bg-purple_light[Diapositivas]** del curso:
&lt;https://dadosdelaplace.github.io/teaching/bioestad/slides&gt;

- **.bg-red_light[Evaluación]** de la asignatura
&lt;https://github.com/dadosdelaplace/teaching/tree/main/bioestad/eval&gt;

- **.bg-yellow[Scripts]** de la asignatura
&lt;https://github.com/dadosdelaplace/teaching/tree/main/bioestad/scripts&gt;

- **.bg-orange[Bibliografía]**: &lt;https://github.com/dadosdelaplace/teaching/tree/main/bioestad/biblio&gt;

&amp;nbsp;

- **.bg-green_light[Manual introductorio de R]**: &lt;https://dadosdelaplace.github.io/courses-intro-R/&gt;

]

---

# Me presento: la turra

.pull-left[

&lt;img src="./img/me.jpeg" width="80%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

* **.bg-purple_light[Javier Álvarez Liébana]**, nacido en 1989 en Carabanchel Bajo (Madrid)

* Licenciado (UCM) en **Matemáticas** (Erasmus en Bologna mediante). **Máster (UCM) en Ingeniería Matemática** (2013-2014)


* **.bg-orange[Doctorado en estadística]** por la Universidad de Granada


* Encargado de la **visualización y análisis de datos covid** de la Consejería de Salud del **Principado de Asturias**

]


Intentando eso de la **.bg-yellow[divulgación]** por **Twitter** (@dadosdelaplace) e **Instagram** (@javieralvarezliebana)

---

name: objetivos

# .orange[OBJETIVOS] de la asignatura


El **.bg-purple_light[propósito]** de esta asignatura será triple

- **.bg-orange[Quitarnos el miedo]** a programar: a programar se aprende programando, no hace falta ser Julian Assange para ello

--

- Aprender a **.bg-orange[abstraer ideas]** para implementarlas en un lenguaje de programación, así como adquirir una base para el **.bg-orange[preprocesamiento, análisis y visualización de datos]**.

--

- Amén de no tener miedo a hacerlo, encontrarle la **.bg-orange[utilidad]** y entender las facilidades que nos ofrece `R` frente a otras opciones como Excel o SPSS.


&amp;nbsp;

📚 Estas **diapositivas** han sido elaboradas con el propio `R` haciendo uso de los paquetes `{xaringan}`, `{xaringanExtra}` y `{xaringanthemer}`.

---

# .orange[CASOS REALES] de uso de R


.pull-left[

&lt;img src="./img/covid_isciii.jpg" width="97%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

&lt;img src="./img/momo_isciii.jpg" width="97%" style="display: block; margin: auto auto auto 0;" /&gt;


]

Las webs del Instituto de Salud Carlos III &lt;https://cnecovid.isciii.es/covid19/&gt; y &lt;https://momo.isciii.es/panel_momo/&gt; están hechas con `R` (con `{shiny}` y `{plotly}` )

---

# .orange[CASOS REALES] de uso de R

.pull-left[

&lt;img src="./img/elpais_R.jpg" width="99%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

El **.bg-purple_light[equipo de datos]** (Borja Andrino, Kiko Llaneras y Daniele Grasso) trabaja con `R` para elaborar sus análisis, desde los datos electorales hasta el cambio climático.

Es una de las razones por las que son capaces de realizar brillantes análisis de grandes volúmenes de datos de forma rápida y ágil: la **.bg-purple_light[automatización de procesos]** que nos permite programar en `R` puede ser fundamental para analizar datos que hasta entonces no podíamos.

]


---

class: inverse center middle

# CLASES

&amp;nbsp;

.pull-left[

#### [CLASE 1: intro a R](#clase-1)

#### [CLASE 2: variables y vectores](#clase-2)

#### [CLASE 3: vectores y matrices](#clase-3)

#### [CLASE 4: primeros datos](#clase-4)

#### [CLASE 5: estructuras de control](#clase-5)

#### [CLASE 6: tidydata](#clase-6)

#### [ENTREGA I (clase 6)](#entrega-I)

]

.pull-right[


#### [CLASE 7: listas y funciones](#clase-7)

#### [CLASE 8: introducción a dplyr (tidyverse)](#clase-8)

#### [CLASE 9: tidyverse. resúmenes estadísticos](#clase-9)

#### [CLASE 10: importar/exportar y cruzando tablas](#clase-10)

#### [CLASE 11: factores y textos](#clase-11)

#### [ENTREGA II (clase 12)](#entrega-II)

]

---

class: inverse center middle

# CLASES

&amp;nbsp;

.pull-left[

#### [CLASE 9: introducción a dplyr (tidyverse)](#clase-9)

#### [CLASE 10: profundizando en dplyr](#clase-10)

#### [CLASE 11: resumiendo datos con dplyr](#clase-11)

#### [CLASE 12: factores (forcats) y textos (stringr)](#clase-12)


#### [CLASE 13: cruzando tablas](#clase-13)

#### [Entrega III (clase 13)](#entrega-III)

#### [CLASE 14: introducción al dataviz)](#clase-14)

]

.pull-right[

#### [CLASE 15: profundizando en ggplot](#clase-15)

#### [CLASE 16: ...](#...)

#### [CLASE 17: ...](#...)

#### [CLASE 18: ...](#...)

#### [CLASE 19: ...](#...)

#### [CLASE 20: ...](#...)

#### [CLASE 21: ...](#...)

]

---

class: inverse center middle
name: clase-1

# CLASE 1: introducción a R desde cero.

&amp;nbsp;

### [Instalación](#instalacion)

### [¿Qué es R?](#que-es-R)

### [Primeros pasos](#primeros-pasos)

### [Ejercicios](#ejercicios1)

---

name: instalacion

# Requisitos

Para la asignatura los únicos **.bg-purple_light[requisitos]** serán:

--

1. **.bg-orange[Conexión a internet]** (para la descarga de algunos datos y paquetes).

--

2. **.bg-orange[Instalar R]**: será nuestro lenguaje, nuestro **.bg-yellow[castellano]** para poder «comunicarnos con el ordenador. La descarga la haremos (gratuitamente) desde &lt;https://cran.r-project.org/&gt;

--

3. **.bg-orange[Instalar R Studio]**. De la misma manera que podemos escribir castellano en un Word o en un tuit, podemos usar **distintos IDE** (entornos de desarrollo integrados, nuestro Office), para que el trabajo sea más cómodo. Nuestro **.bg-yellow[Word]** para nosotros será **RStudio**.

.left[
  &lt;img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/cran-R.jpg" alt = "cran-R" align = "left" width = "460" style = "margin-top: 2vh"&gt;
]

.right[
  &lt;img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/R-studio.jpg" alt = "RStudio" align = "right" width = "460" style = "margin-top: 2vh;"&gt;
]


---

# Instalación de R

El lenguaje `R` será nuestra **.bg-purple_light[gramática]**, nuestra ortografía y nuestro diccionario

.pull-left[



- **Paso 1**: entra en &lt;https://cran.r-project.org/&gt; y selecciona **.bg-purple_light[sistema operativo]**.

- **Paso 2**: para **.bg-purple_light[Mac]** basta con que hacer click en el archivo .pkg, y abrirlo una vez descargado. Para sistemas **.bg-purple_light[Windows]**, debemos clickar en `install R for the first time` y en la siguiente pantalla en `Download R for Windows`. Una vez descargado, abrirlo como cualquier archivo de instalación.

- **Paso 3**: abrir el **ejecutable**.

]

.pull-right[

&lt;img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/cran-R.jpg" alt = "cran-R" align = "left" width = "900" style = "margin-top: 1vh"&gt;

]

**.bg-green_light[Consejito]**: siempre que tengas que descargar algo de CRAN (ya sea el propio R o un paquete), asegúrate de tener conexión a **.bg-orange[internet]**.


---

# Primera operación

Para comprobar que se ha instalado correctamente, tras abrir `R`, deberías ver una **pantalla blanca** similar a esta (en realidad se llama **.bg-purple_light[consola]**). Vamos a escribir nuestra **.bg-orange[primera operación]** en la consola:

.pull-left[

* A una variable llamada `a` le asignaremos el valor 1 (asignamos con `&lt;-`, como una flecha)


```r
# Una variable a con valor --&gt; 1
*a &lt;- 1
```

]

--

.pull-right[

* A otra variable llamada `b` le asignaremos el valor 2 (cambia a la izquierda el nombre, cambia a la derecha el valor).


```r
# Una variable b con valor --&gt; 2
*b &lt;- 2
```

]

--

.pull-left[

* Sumamos las variables haciendo `a + b`.


```r
# Primera operación
a &lt;- 1 # Una variable a con valor --&gt; 1
b &lt;- 2 # Una variable b con valor --&gt; 2
*a + b
```
]

--

.pull-right[

* El resultado que nos devuelve será `3`.


```
&gt; [1] 3
```

]

---

# .orange[INSTALACIÓN] de RStudio

El **.bg-purple_ligth[Word]** que usaremos para trabajar y escribir en nuestro lenguaje será **.bg-purple_ligth[RStudio]** (lo que se conoce como un **IDE**, un entorno integrado de desarrollo).

.pull-left[

* **Paso 1**: entra en la [web oficial de RStudio](https://www.rstudio.com/products/rstudio/download/#download) y selecciona la **.bg-purple_light[descarga gratuita]**.

* **Paso 2**: selecciona el ejecutable que te aparezca, acorde a tu sistema operativo.

* **Paso 3**: tras descargar el ejecutable, hay que abrirlo como otro cualquier otro ejecutable y dejar que **.bg-purple_light[termine la instalación]**.

]

.pull-right[

&lt;img src="./img/R-studio.jpg" width="80%" style="display: block; margin: auto auto auto 0;" /&gt;


]

---

# .orange[ORGANIZACIÓN] de RStudio

.pull-left[

&lt;img src="./img/inicio_rstudio_2.jpg" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

* **.bg-purple_light[Consola]**: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo código que antes (la suma) en ella. La consola será donde **.bg-orange[ejecutaremos órdenes]** y **.bg-yellow[mostraremos resultados]**.
]

---

# .orange[ORGANIZACIÓN] de RStudio

.pull-left[

&lt;img src="./img/inicio_rstudio_3.jpg" width="75%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

* **.bg-purple_light[Environment]** (entorno de variables): la pantalla pequeña (puedes ajustar los márgenes con el ratón) que tenemos en la parte superior derecha. Nos mostrará las **variables que tenemos definidas, el tipo y su valor**.

]

---

# .orange[ORGANIZACIÓN] de RStudio

.pull-left[

&lt;img src="./img/inicio_rstudio_4.jpg" width="85%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

* **.bg-purple_light[Panel multiusos]**: la ventana que tenemos en la parte inferior derecha no servirá para buscar **.bg-orange[ayuda de funciones]**, además de para **.bg-yellow[visualizar gráficos]**. 

]

---

name: que-es-R

# ¿Qué es R?


&lt;img src = "https://logos.turbio.repl.co/rlang.svg" alt = "Rstudio" align = "left" width = "300" style = "margin-top: 1vh;margin-right: 2rem;"&gt;

`R` es un **.bg-purple_light[lenguaje estadístico]**, creado por y para la estadística, con 4 ventajas fundamentales:

--

* **.bg-purple_light[Software libre]** (como C++, Python, etc). no solo es gratis, sino que permite **.bg-orange[acceder libremente a código ajeno]**.

--

* **.bg-purple_light[Lenguaje modular]**: en la instalación que hemos realizado solo se ha instalado el mínimo para poder funcionar. Al ser software libre, existen **.bg-orange[trozos de código]** hechos por otras personas (**.bg-yellow[paquetes]**) que podemos instalar según necesidades.

--

* **.bg-purple_light[Gran comunidad de usuarios]**: `R` tiene una comunidad de usuarios gigante para hacer estadística (Python tiene una comunidad más enfocada al Machine Learning), con más de 18 000 paquetes.

--

* **.bg-purple_light[Lenguaje de alto nivel]**. Los lenguajes de alto nivel, como `R` o `Python`, facilitan la programación al usuario (menor curva de aprendizaje, aunque más lentos en ejecución).

---

class: inverse center middle

**COMPRAR** libro --&gt; instalar un paquete (una sola vez) `install.packages()`
&lt;figure&gt;
&lt;img src = "https://cdn.cienradios.com/wp-content/uploads/sites/14/2020/09/Book-Depository-2.jpg" alt = "comprar-libros" align = "middle" width = "480" style = "margin-top: 1vh;"&gt;
&lt;/figure&gt;

**SELECCIONAR** libro (ya comprado) --&gt; acceder a un paquete instalado (en cada sesión que queramos usarlo) `library()`
&lt;figure&gt;
&lt;img src = "https://cdn.sincroguia.tv/uploads/programs/l/a/-/la-biblioteca-de-los-libros-rechazados-704306_SPA-77.jpg" alt = "comprar-libros-2" align = "middle" width = "480" style = "margin-top: 1vh;"&gt;
&lt;/figure&gt;


---

# Paquetes en R

A lo largo del curso usaremos varios de esos **.bg-purple_light[paquetes]**, como por ejemplo el paquete `{ggplot2}`, un paquete para la elaboración de **.bg-purple_light[visualizaciones de datos]**. Vamos a instalarlo (necesitamos internet para ello) con la orden `install.packages("ggplot")`


```r
install.packages("ggplot2")
```

&amp;nbsp;


&amp;nbsp;



La **.bg-purple_light[instalación]** de un paquete es el equivalente a **.bg-orange[comprar a un libro]**: solo lo debemos hacer **la primera vez** que lo usemos en un ordenador. Una vez que tenemos comprado nuestro libro, para poder usarlo, simplemente debemos indicar al programa que nos lo **.bg-purple_light[acerque de la estantería]** con `library(ggplot2)`.


```r
library(ggplot2)
```

---

class: center middle

# ¿Por qué .orange[NO] usar Excel?

![](./img/meme_barco.jpg)

---

# ¿Por qué .orange[NO] usar Excel?

Excel es una **.bg-purple_light[hoja de cálculo]**, ni más ni menos, y el propio **Microsoft desaconseja su uso** para el análisis de datos. El Excel es una herramienta maravillosa para ser usada como una sencilla hoja de cálculo (llevar cuentas de tu familia, declaración de Renta, planificar viajes, etc).

&amp;nbsp;

**.bg-red_light[NO ESTÁ DISEÑADO]** para ser una base de datos, y muchos menos pensado para generar un entorno flexible para el análisis estadístico:

* **.bg-red_light[Software de pago]**

* **.bg-red_light[Software cerrado]**: solo podemos hacer lo que Excel ha creído que interesante que podamos hacer.

* **.bg-red_light[Alto consumo de memoria]**.

* **.bg-red_light[No es universal]**: no solo es de pago sino que además, dependiendo de la versión que tengas de Excel, tendrá un formato distinto para datos como fechas, teniendo incluso extensiones distintas.

---

# .orange[Incel] vs excel

&lt;img src="./img/incel.jpg" width="75%" style="display: block; margin: auto;" /&gt;

---



# .red[EPIC FAILS] en Excel

Problemas de **.red[versiones]**


&lt;img src="./img/excel_genes.jpg" width="37%" style="display: block; margin: auto auto auto 0;" /&gt;


📚 Ver **.bg-green_light[bibliografía]** en &lt;https://github.com/dadosdelaplace/teaching/tree/main/bioestad/biblio&gt;


---

# .red[EPIC FAILS] en Excel

Problemas de **.red[memoria]**

&lt;img src="./img/excel_uk.jpg" width="50%" style="display: block; margin: auto auto auto 0;" /&gt;


📚 Ver **.bg-green_light[bibliografía]** en &lt;https://github.com/dadosdelaplace/teaching/tree/main/bioestad/biblio&gt;


---

# .red[EPIC FAILS] en Excel

Problemas de **.red[codificación]**

&lt;img src="./img/excel_edades.jpg" width="50%" style="display: block; margin: auto auto auto 0;" /&gt;

📚 Ver **.bg-green_light[bibliografía]** en &lt;https://github.com/dadosdelaplace/teaching/tree/main/bioestad/biblio&gt;

---

name: primeros-pasos

# Primeros pasos en R: .orange[CALCULADORA]

Empecemos por lo sencillo: **.bg-purple-light[¿cómo usar R como una calculadora?]** Si escribimos `2 + 1` en la consola y pulsamos ENTER, la consola nos mostrará el resultado de la suma.


```r
2 + 1
```

```
&gt; [1] 3
```

--

Si dicha suma la quisiéramos utilizar para un segundo cálculo: ¿y si la **.bg-purple-light[almacenamos en alguna variable]**? Por ejemplo, vamos a guardar la suma en una variable `x`


```r
*x &lt;- 2 + 1
```

--

Si te fijas ahora `x` aparece definida en nuestro **.bg-yellow[environment]**, y puede ser usada de nuevo


```r
x + 3
```

```
&gt; [1] 6
```

---

# Primeros pasos en R: .orange[CALCULADORA]

### Multiplicación


```r
*x * y
```

### Elevar al cuadrado


```r
*x^2
```

### Valor absoluto


```r
*abs(x)
```

---

# .red[Errores]

Durante tu aprendizaje va a ser **muy habitual** que las cosas no salgan a la primera, apareciendo en consola **.bg-purple_light[mensajes de error]** en un **.bg-red_light[color rojo]**. No te asustes: lo peor que puede pasar es que tengas que reiniciar `R`).

&amp;nbsp;

* Mensajes de **.bg-red_light[ERROR]**: irán precedidos de la frase **.bg-yellow[«Error in…»]**, y serán aquellos fallos que **impidan la ejecución del código** 


```r
"a" + 1 # intentando sumar 1 a un texto
```

```
&gt; Error in "a" + 1: argumento no-numérico para operador binario
```

&amp;nbsp;

**.bg-green_light[CONSEJO]**: lee siempre los mensajes de error para aprender de ellos (ya que suelen dar pistas de cómo resolverlos).

---

# .red[Errores]

Durante tu aprendizaje va a ser **muy habitual** que las cosas no salgan a la primera, apareciendo en consola **.bg-purple_light[mensajes de error]** en un **.bg-red_light[color rojo]**. No te asustes: lo peor que puede pasar es que tengas que reiniciar `R`).

&amp;nbsp;
 
* Mensajes de **.bg-orange[WARNING]**: irán precedidos de la frase **.bg-yellow[«Warning in…»]**, y son los fallos más delicados ya que son posibles incoherencias pero sin que tu código deje de ejecutarse.


```r
sqrt(-1) # raiz cuadrada de número negativo
```

```
&gt; Warning in sqrt(-1): Se han producido NaNs
```

```
&gt; [1] NaN
```

&amp;nbsp;

**¿Ha ejecutado la orden?** Sí, pero te advierte de que el resultado de la operación es un `NaN`, **Not A Number**, un valor que no existe (al menos dentro de los números reales).


---

# ¿Dónde programamos? .orange[SCRIPTS]

Un **.bg-purple_light[script]** será el documento en el que programamos, nuestro equivalente a un archivo .doc, pero aquí será un archivo con extensión `.R`, donde **escribiremos las órdenes**. Para **.bg-purple_light[abrir nuestro primero script]**, haz click en el menú superior en `File &lt;&lt; New File &lt;&lt; R Script`.

&amp;nbsp;


.pull-left[


&lt;img src="./img/inicio_rstudio_5.jpg" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

**.bg-green_light[CONSEJO]**: intenta no abusar de la consola, ya que todo lo que no escribas en un script, cuando cierres `RStudio`, lo **habrás perdido** (cómo si en lugar de escribir en un Word y guardarlo, nunca guardases el documento).

]

---


Ahora tenemos una **cuarta ventana**: la ventana donde **escribiremos nuestros códigos**


### **¿Cómo ejecutar nuestro script?**

.pull-left[

&lt;img src="./img/inicio_rstudio_6.jpg" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]

.pull-right[

1. **.bg-purple_light[Escribimos el código]** a ejecutar.

2. **.bg-purple_light[Guardamos]** el archivo `.R` haciendo click en `Save current document`.

3. El código **no se ejecuta salvo que se lo indiquemos**. Tenemos tres opciones:
  - **.orange[Copiar y pegar]** en consola.
  - **.orange[Seleccionar líneas]** y clickar en `Run`.
  - Activar `Source on save` a la **derecha de guardar**: no solo guarda sino que ejecuta el código completo.

]

---

name: ejercicios1

# Primeros ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: añade debajo otra línea para definir una variable `b` con el valor `5`. Tras asignarles valores, multiplica los números en consola.


```r
a &lt;- 2
```

* 📝 **Ejercicio 2**: modifica el código inferior para definir dos variables `c` y `d`, con valores 3 y -1.


```r
c &lt;- # deberías asignarle el valor 3
d &lt;- # deberías asignarle el valor -1
```

* 📝 **Ejercicio 3**: con las variables `a` y `b` del ej. 1, crea una nueva variable `e` guardando el resultado de su multiplicación `a * b`. Escribe `e` en consola para ver su resultado

]

.panel[.panel-name[Solución ej. 1]


```r
# Para poner comentarios en el código se usa #

# Definición de variables
a &lt;- 2
b &lt;- 5

# Multiplicación
a * b
```

```
&gt; [1] 10
```
]

.panel[.panel-name[Solución ej. 2]


```r
# Definición de variables
c &lt;- 3
d &lt;- -1
```
]

.panel[.panel-name[Solución ej. 3]


```r
# Variables
a &lt;- 2
b &lt;- 5

# Resultado
e &lt;- a * b

# Muestro en consola
e
```

```
&gt; [1] 10
```

]
]

---

# Primeros ejercicios


.panelset[
.panel[.panel-name[Ejercicios extra]


* 📝 **Ejercicio 4**: asigna un valor positivo a `x` y calcula su raíz cuadrada; asigna otro negativo y calcula su valor absoluto con la función `abs()`.


* 📝 **Ejercicio 5**: usando la variable `x` ya definida, completa/modifica el código inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.


```r
z &lt;- ? - ? # completa el código
z
```

* 📝 **Ejercicio 6**: usando las variables `x` e `y` ya definidas, calcula el máximo de ambas (función `max()`), y guárdalo en una nueva variable `t`.

]

.panel[.panel-name[Solución ej. 4]


```r
# Raíz cuadrada
x &lt;- 73 # por ejemplo
sqrt(x)
```

```
&gt; [1] 8.544004
```

```r
# Valor absoluto
y &lt;- -19 # por ejemplo
abs(y)
```

```
&gt; [1] 19
```
]

.panel[.panel-name[Solución ej. 5]


```r
z &lt;- x - 5
z
```

```
&gt; [1] 68
```
]

.panel[.panel-name[Solución ej. 6]


```r
t &lt;- max(x, y)
t
```

```
&gt; [1] 73
```

]
]


---

class: inverse center middle
name: clase-2

# CLASE 2: primeros datos en R

&amp;nbsp;

### [Variables individuales: numéricas y caracteres](#variables)

### [Primer paquete y primera función](#primer-paquete)

### [Vectores: numéricos y de caracteres](#vectores)

### [Variables lógicas y de tipo fecha](#logicas)

### [Ejercicios](#ejercicios2)

---

name: variables

# De la .orange[celda] a la .green[tabla]
 

¿De qué tipo pueden ser los datos que tenemos contenidos en cada celda de una «tabla»?


&lt;img src="./img/celdas.jpg" width="55%" style="display: block; margin: auto;" /&gt;

* **.bg-purple_light[Celda]**: un dato **.bg-orange[individual]** de un tipo concreto.
* **.bg-purple_light[Variable]**: una **.bg-orange[concatenación de valores]** del mismo tipo (**vectores**).
* **.bg-purple_light[Matriz]**: **.bg-orange[concatenación de variables]** del **.bg-yellow[mismo tipo]** y longitud.
* **.bg-purple_light[Tabla]**: **.bg-orange[concatenación de variables]** de **.bg-yellow[distinto tipo]** pero igual longitud.

---

# .orange[Celdas]: tipos de datos individuales

¿Existen **variables más allá de los números**?

&amp;nbsp;

Piensa por ejemplo en los **datos guardados de una persona**:

* La edad o el peso será un **.bg-purple_light[número]**.
* Su nombre será una cadena de **.bg-purple_light[texto]**.
* Su fecha de nacimiento será precisamente eso, una **.bg-purple_light[fecha]**.
* A la pregunta «¿está usted soltero/a?» la respuesta será lo que llamamos una **.bg-purple_light[variable lógica]** (`TRUE` si está soltero/a o `FALSE` en otro caso).

&lt;img src="./img/celdas.jpg" width="40%" style="display: block; margin: auto;" /&gt;

---

# Variables .orange[NUMÉRICAS]

El **dato más sencillo**, dato que ya hemos usado en nuestros primeros pasos como calculadora, serán las variables que guardan simplemente números


```r
a &lt;- 1
b &lt;- 2
a + b
```

```
&gt; [1] 3
```

--

En el código anterior, tanto `a` como `b` como la suma `a + b` son de **.bg-purple_light[tipo numérico]**


```r
*class(a)
```

```
&gt; [1] "numeric"
```

```r
*typeof(a)
```

```
&gt; [1] "double"
```


---

# Variables .orange[NUMÉRICAS]

Como ya hemos visto, con los datos numéricos podemos realizar todas las **.bg-purple_light[operaciones aritméticas]** que se nos ocurriría hacer en una **calculadora** como sumar (`+`), restar (`-`), multiplicar (`+`), dividir (`/`), raíz cuadrada (`sqrt()`), valor absoluto (`abs()`), elevar al cuadrado (`^2`), elevar al cubo (`^3`), etc.




```r
a &lt;- 5
a^3 # Elevar al cubo
```

```
&gt; [1] 125
```


```r
b &lt;- -43
abs(b) # valor absoluto
```

```
&gt; [1] 43
```

---

# Variables de .orange[TEXTO]

No solo de números viven los datos: imagina que además de la edad de una persona queremos **guardar su nombre** (**.bg-purple_light[tipo caracter]**: una **cadena de texto**)


```r
*nombre &lt;- "Javier"
class(nombre)
```

```
&gt; [1] "character"
```

--

Las cadenas de texto son un **tipo especial de dato** con los que obviamente no podremos hacer operaciones aritméticas (pero sí **.bg-purple_light[otras operaciones]** como pegar o localizar patrones).


```r
nombre + 1 # error al sumar número a texto
```

```
&gt; Error in nombre + 1: argumento no-numérico para operador binario
```

&amp;nbsp;

--

**.bg-green_light[IMPORTANTE]**: las variables de tipo texto van **.bg-red_light[SIEMPRE ENTRE comillas]**.

---

name: primer-paquete

# .orange[PRIMERA FUNCIÓN]: paste

Una **.bg-purple_light[función]** es un **trozo de código encapsulado** bajo un nombre, que depende de unos **.bg-purple_light[argumentos de entrada]**.

--

Nuestra primera función será `paste()`: dadas dos cadenas de texto como argumento de entrada nos permite pegarlas, indicándole en el argumento `sep = ` el caracter que queremos entre medias.


```r
# todo junto, sin espacios, igual a paste0("Javier", "Álvarez")
paste("Javier", "Álvarez", sep = "") 
```

```
&gt; [1] "JavierÁlvarez"
```




```r
paste("Javier", "Álvarez", sep = "?*?") # separados por un ?*?
```

```
&gt; [1] "Javier?*?Álvarez"
```


---

# .orange[PRIMERA FUNCIÓN]: paste



```r
*paste("Javier", "Álvarez")
```

```
&gt; [1] "Javier Álvarez"
```

Por defecto, `paste()` añade un espacio, es decir, `sep = " "`. Muchas funciones en `R` tendrán lo que llamamos **.bg-purple_light[argumentos por defecto]**, el valor que tomará sino se le asigna otro. Puedes mirar la **.bg-green_light[ayuda de la función]** escribiendo en consola `? paste`

Existe una función similar llamada `paste0()` que pega por defecto con `sep = ""` (sin nada).


```r
paste0("Javier", "Álvarez") 
```

```
&gt; [1] "JavierÁlvarez"
```

```r
paste("Javier", "Álvarez", sep = "") 
```

```
&gt; [1] "JavierÁlvarez"
```

---

# .orange[PRIMER PAQUETE]: glue

Otra forma **más intuitiva de trabajar con textos** es usar el **paquete** `{glue}`.


```r
library(glue) # solo la 1ª vez install.packages("glue")
```

--

Con dicho paquete podemos **.bg-purple_light[usar variables dentro de cadenas]** de texto. Por ejemplo, la frase «la edad es de ... años», donde la edad concreta la tenemos guardada en una variable.


```r
edad &lt;- 33
*glue("La edad es de {edad} años")
```

```
&gt; La edad es de 33 años
```

Dentro de las llaves también podemos ejecutar operaciones


```r
unidades &lt;- "días"
*glue("La edad es de {edad * 365} {unidades}")
```

```
&gt; La edad es de 12045 días
```

---


# .orange[VECTORES]: concatenación

¿Y si en lugar de querer almacenar un solo elemento, por ejemplo , tenemos una **colección de elementos**?

Hasta ahora solo hemos operado con el contenido de las **celdas**, pero cuando trabajamos con datos normalmente tendremos columnas que representan variables o características: llamaremos **.bg-purple_light[vectores]** a una **.bg-orange[concatenación]** de variables del **.bg-orange[mismo tipo]**
 
--

La forma más sencilla es con el comando `c()` (c de concatenar), y basta con introducir sus **elementos entre paréntesis y separados por comas** (por ejemplo, la edad de 4 personas).


```r
*edades &lt;- c(33, 27, 60, 61)
edades
```

```
&gt; [1] 33 27 60 61
```


&amp;nbsp;

--

**.bg-green_light[IMPORTANTE]**: un número individual (`x &lt;- 1`) es en realidad un vector de longitud uno. 

---

# .orange[VECTORES]: concatenación


Como ves ahora en el `environment` tenemos una **.bg-purple_light[colección de elementos]** guardada

.pull-left[


```r
edades
```

```
&gt; [1] 33 27 60 61
```

]


.pull-right[
&lt;img src="./img/vectores_enviroment.jpg" width="80%" style="display: block; margin: auto auto auto 0;" /&gt;
]

--

.pull-left[

La **.bg-purple_light[longitud de un vector]** se puede calcular con `length()`


```r
*length(edades)
```

```
&gt; [1] 4
```

]


.pull-right[

También podemos **.bg-purple_light[concatenar vectores]**


```r
c(edades, edades, 8)
```

```
&gt; [1] 33 27 60 61 33 27 60 61  8
```

]

---

# Vectores: .orange[SECUENCIAS NUMÉRICAS]

En muchas ocasiones querremos **.bg-purple_light[crear secuencias numéricas]** mucho más rápido (por ejemplo, un vector con los días del mes). El comando `seq()` nos permite crear una **secuencia** desde un elemento inicial hasta un elemento final, avanzando de uno en uno.


```r
seq(1, 31)
```

```
&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
&gt; [26] 26 27 28 29 30 31
```

--

El comando `1:n` nos devuelve lo mismo que la orden `seq(1, n)`. Además, si el elemento inicial es mayor que el final, `R` entenderá solo que la secuencia es **decreciente**.


```r
n &lt;- 5
n:1
```

```
&gt; [1] 5 4 3 2 1
```

---

# Vectores: .orange[SECUENCIAS NUMÉRICAS]

También podemos definir **.bg-purple_light[otro tipo de distancia]** (**.bg-orange[paso de discretización]**) entre dos elementos consecutivos


```r
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
```

```
&gt;  [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0
```

--

Otras veces nos interesará definir una **.bg-purple_light[secuencia con un número concreto]** de elementos.


```r
seq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7
```

```
&gt; [1]  1.000000  9.166667 17.333333 25.500000 33.666667 41.833333 50.000000
```

--

También podemos crear **.bg-purple_light[vectores de elementos repetidos]** con la función `rep()`


```r
rep(0, 7) # vector de 7 ceros
```

```
&gt; [1] 0 0 0 0 0 0 0
```


---

# Vectores: .orange[CARACTERES]

Un vector es una **.bg-purple_light[concatenación de elementos del mismo tipo]**, pero no tienen porque ser necesariamente números. Vamos a crear una frase de ejemplo, con 4 elementos.

.pull-left[


```r
*vector &lt;- c("Me", "llamo", "Javi")
vector
```

```
&gt; [1] "Me"    "llamo" "Javi"
```

```r
length(vector)
```

```
&gt; [1] 3
```

]

.pull-right[


```r
frase &lt;- "Mi llamo Javi"
frase
```

```
&gt; [1] "Mi llamo Javi"
```

```r
length(frase)
```

```
&gt; [1] 1
```

]

Fíjate la **diferencia** entre tenerlo guardado en un vector o tenerlo como una sola cadena de texto (unida).

---

# Vectores: .orange[CARACTERES]

Cuando usamos la función `paste()` con variables diferentes, usábamos `sep = ...`. Cuando la función `paste()` la aplicamos a un vector de caracteres, decidiremos que caracter queremos que vaya entre palabra con el argumento `collapse = ...`.


```r
paste(vector, collapse = ".") # separados por un punto
```

```
&gt; [1] "Me.llamo.Javi"
```

Podemos **combinar las secuencias de números y un vector de caracteres** con `glue()`


```r
edad &lt;- 10:12 # edades
glue("La edad es de {edad} años")
```

```
&gt; La edad es de 10 años
&gt; La edad es de 11 años
&gt; La edad es de 12 años
```

---

name: logicas

# Datos de tipo .orange[LÓGICO]

Un tipo de datos muy importante en todo lenguaje de programación: los **.bg-purple_light[valores lógicos]**. Un valor lógico puede tomar **tres valores**:

* `TRUE` (guardado internamente como un `1`).
* `FALSE` (guardado internamente como un `0`).
* `NA` (**.bg-purple_light[dato ausente]**, son las siglas de **.bg-orange[not available]**).

--

Los valores lógicos suelen ser resultado de evaluar **.bg-purple_light[condiciones lógicas]** (preguntar a los datos). Por ejemplo, imaginemos que definimos un vector de temperaturas. ¿Qué días hizo menos de 22 grados?


```r
x &lt;- c(15, 20, 31, 27, 15, 29)
*x &lt; 22
```

```
&gt; [1]  TRUE  TRUE FALSE FALSE  TRUE FALSE
```

Nos devolverá un **vector lógico** con `TRUE` o `FALSE` en cada hueco, en función de si cumple o no la condición pedida.

---

# Datos de tipo .orange[LÓGICO]


Dicha condición lógica puede hacerse con `&lt;=` (menor o igual), `&gt;` (mayor) o `&gt;=` (mayor igual).


```r
x &lt;= 22
```

```
&gt; [1]  TRUE  TRUE FALSE FALSE  TRUE FALSE
```

--


```r
x &gt; 30
```

```
&gt; [1] FALSE FALSE  TRUE FALSE FALSE FALSE
```

--


```r
x &gt;= 15
```

```
&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE
```

---

# Datos de tipo .orange[LÓGICO]

También podemos comparar **.bg-purple_light[si es igual a otro elemento]**, para lo que usaremos el operador `==`, pudiendo usar también su opuesto `!=` («distinto de»).


```r
x == 15
```

```
&gt; [1]  TRUE FALSE FALSE FALSE  TRUE FALSE
```

```r
x != 15
```

```
&gt; [1] FALSE  TRUE  TRUE  TRUE FALSE  TRUE
```

--

Si tuviéramos un **.bg-purple_light[dato ausente]** (por error del aparato ese día, marcado como `NA`), la condición evaluada también sería `NA`


```r
y &lt;- c(15, 20, NA, 31, 27, 7, 29, 10)
y &lt; 22
```

```
&gt; [1]  TRUE  TRUE    NA FALSE FALSE  TRUE FALSE  TRUE
```

---

# Datos de tipo .orange[LÓGICO]

Las **.bg-purple_light[condiciones pueden ser combinadas]**, principalmente de dos maneras:

.pull-left[

* **.bg-purple_light[Intersección]**: **.bg-orange[TODAS]** las condiciones concatenadas se deben cumplir (conjunción y) para devolver un `TRUE`.


```r
x
```

```
&gt; [1] 15 20 31 27 15 29
```

```r
x &lt; 30 &amp; x &gt; 15
```

```
&gt; [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE
```

]

.pull-right[

* **.bg-purple_light[Unión]**: basta con que **.bg-orange[AL MENOS UNA]** de las condiciones se cumpla (conjunción o) para devolver un `TRUE`.


```r
x
```

```
&gt; [1] 15 20 31 27 15 29
```

```r
x &lt; 30 | x &gt; 15
```

```
&gt; [1] TRUE TRUE TRUE TRUE TRUE TRUE
```

]

---

name: fecha

# Datos de tipo .orange[FECHA]


Un tipo de datos muy especial: los **.bg-purple_light[datos de tipo fecha]**. 


```r
# Cadena de texto
fecha_char &lt;- "2021-04-21"
class(fecha_char)
```

```
&gt; [1] "character"
```

Podríamos pensar que no tiene nada de especial ya que parece una simple cadena de texto pero representa un **.bg-purple_light[instante en el tiempo]**, que deberíamos poder operar como tal.

--

¿Qué sucedería si **sumamos un 1 (un día)** a una fecha definida como una cadena de texto?


```r
fecha_char + 1
```

```
&gt; Error in fecha_char + 1: argumento no-numérico para operador binario
```

--

Si guardamos las fechas como un cadena de texto **.bg-red_light[no podemos operar con ellas]**

---

# Datos de tipo .orange[FECHA]

Para trabajar con fechas tenemos el paquete `{lubridate}`, y su función `as_date()`: nos **.bg-purple_light[convierte texto a fecha]**.


```r
library(lubridate)
*fecha &lt;- as_date(fecha_char)
class(fecha)
```

```
&gt; [1] "Date"
```

--


```r
fecha + 1 # día siguiente
```

```
&gt; [1] "2021-04-22"
```

--


```r
fecha - 3 # 3 días antes
```

```
&gt; [1] "2021-04-18"
```

--

Al convertir texto a fecha, aunque se visualice como un texto, **.bg-purple_light[internamente es un número]**. 

---

# Datos de tipo .orange[FECHA]

La función `as_date()` tiene un argumento opcional, el **.bg-purple_light[formato]**, que por defecto será `format = "yyyy-mm-dd"` (que podemos cambiar)



```r
*as_date("10-03-2020", format = "%d-%m-%Y")
```

```
&gt; [1] "2020-03-10"
```

--


```r
as_date("10-03-20", format = "%d-%m-%y")
```

```
&gt; [1] "2020-03-10"
```

--


```r
as_date("03-10-2020", format = "%m-%d-%Y")
```

```
&gt; [1] "2020-03-10"
```

--


```r
as_date("Octubre 21, 1995 21:24", format = "%B %d, %Y %H:%M")
```

```
&gt; [1] "1995-10-21"
```

---

# Datos de tipo .orange[FECHA]

Para facilitar conversiones de formatos habituales, el paquete también tiene a nuestra disposición diferentes funciones preparadas para directamente **.bg-purple_light[convertir fechas en distintos formatos]**, como la función `ymd_hms()` o `ydm_hms()`


```r
ymd_hms("2017-11-28 14:02:00") # convertir a fecha una cadena año-mes-día + hora
```

```
&gt; [1] "2017-11-28 14:02:00 UTC"
```

```r
ydm_hms("2017-22-12 10:00:00") # convertir a fecha una cadena año-día-mes + hora
```

```
&gt; [1] "2017-12-22 10:00:00 UTC"
```

--

De la misma manera tenemos la función `dmy_hms()`


```r
dmy_hms("1 Jan 2017 23:59:59") # convertir a fecha una cadena textual de fecha + hora
```

```
&gt; [1] "2017-01-01 23:59:59 UTC"
```

 
---

# Datos de tipo .orange[FECHA]


También podemos hacerlo de forma muy simplificada con `ymd()`


```r
ymd(20170131)
```

```
&gt; [1] "2017-01-31"
```

--

Otra de las funcionalidades que nos proporciona dicho paquete es obtener automáticamente la **.bg-purple_light[fecha de hoy]**, haciendo uso de la función `today()`


```r
*hoy &lt;- today()
hoy
```

```
&gt; [1] "2022-10-10"
```

--

También podemos obtener el **.bg-purple_light[«hoy y ahora»]** con la función `now()`


```r
*now()
```

```
&gt; [1] "2022-10-10 12:19:24 CEST"
```
 
---

# Datos de tipo .orange[FECHA]

También tenemos disponibles funciones para **.bg-purple_light[extraer facilmente algunas variables]**.

.pull-left[


```r
year(fecha)
```

```
&gt; [1] 2021
```

```r
month(fecha)
```

```
&gt; [1] 4
```

```r
hour(fecha)
```

```
&gt; [1] 0
```

```r
second(fecha)
```

```
&gt; [1] 0
```

]

.pull-right[

```r
week(fecha)
```

```
&gt; [1] 16
```

```r
wday(fecha)
```

```
&gt; [1] 4
```

```r
wday(fecha, week_start = 1) # Día de la semana 
```

```
&gt; [1] 3
```

]


---

# Datos de tipo .orange[FECHA]


También podemos **.bg-purple_light[realizar comparaciones]**


```r
fecha_actual &lt;- today()
fecha_actual &gt; ymd(20170131) # Actual vs 2017-01-31
```

```
&gt; [1] TRUE
```

```r
fecha_actual &gt; ymd(21000131) # Actual vs 2100-01-31
```

```
&gt; [1] FALSE
```
 
--

Con la función `leap_year()` podremos saber si la fecha **.bg-purple_light[corresponde a un año bisiesto]**


```r
leap_year(as_date(ymd(20190131)))
```

```
&gt; [1] FALSE
```

---

# Datos de tipo .orange[FECHA]

.pull-left[

&lt;div class="figure" style="text-align: right"&gt;
&lt;img src="./img/lubridate.png" alt="Chuleta de https://lubridate.tidyverse.org/" width="101%" /&gt;
&lt;p class="caption"&gt;Chuleta de https://lubridate.tidyverse.org/&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

También podemos hacer uso de diferentes funciones para **.bg-purple_light[añadir intervalos]** de tiempo.


```r
fecha + weeks(0:2)
```

```
&gt; [1] "2021-04-21" "2021-04-28" "2021-05-05"
```

```r
fecha + seconds(2)
```

```
&gt; [1] "2021-04-21 00:00:02 UTC"
```

]

---


name: ejercicios2

# Ejercicios


.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: define una variable `edad` que guarde tu edad y otra `nombre` con tu nombre.

* 📝 **Ejercicio 2**: define otra variable con tus apellidos y junta las variables `nombre` y `apellidos` en una sola cadena de texto que guardes en `nombre_completo`.
 
* 📝 **Ejercicio 3**: define un vector que contenga los números `1`, `10`, `-1` y `2`, y guárdalo en una variable llamada `vector_num`. Obtén la longitud del vector anterior.
 
* 📝 **Ejercicio 4**: crea una secuencia de -2 a 17 de forma que salte de uno en uno (y también de forma decreciente). Repite el proceso pero saltando de 3 en 3.


]

.panel[.panel-name[Solución ej. 1]


```r
# variable numérica
edad &lt;- 33
edad
```

```
&gt; [1] 33
```

```r
# variable de tipo texto
nombre &lt;- "Javi"
nombre
```

```
&gt; [1] "Javi"
```
]

.panel[.panel-name[Solución ej. 2]


```r
apellidos &lt;- "Álvarez Liébana"

# Opción 1
nombre_completo &lt;- glue("{nombre} {apellidos}")
nombre_completo
```

```
&gt; Javi Álvarez Liébana
```

```r
# Opción 2
nombre_completo &lt;- paste(nombre, apellidos)
nombre_completo
```

```
&gt; [1] "Javi Álvarez Liébana"
```
]

.panel[.panel-name[Solución ej. 3]


```r
vector_num &lt;- c(1, 10, -1, 2)
vector_num
```

```
&gt; [1]  1 10 -1  2
```

```r
# longitud
length(vector_num)
```

```
&gt; [1] 4
```

]

.panel[.panel-name[Solución ej. 4]


```r
secuencia &lt;- -2:17
secuencia
```

```
&gt;  [1] -2 -1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
```

```r
# otra forma
secuencia &lt;- seq(-2, 17, by = 1)

# decreciente
17:-2
```

```
&gt;  [1] 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 -1 -2
```

```r
# de 3 en 3
seq(-2, 17, by = 3)
```

```
&gt; [1] -2  1  4  7 10 13 16
```

]

]

---

# Ejercicios


.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 5**: crea una secuencia que repita 7 veces el patrón -1, 2, 4. Después crea otra que repita dicho patrón pero de forma intercalada.
 
* 📝 **Ejercicio 6**: crea una secuencia de 7 valores lógicos en los que haya 2 valores ciertos, 3 valores falsos y 2 valores ausentes.


* 📝 **Ejercicio 7**: toma el vector `vector_num` del ejercicio 3 y obtén un vector lógico que nos diga que valores son mayores de 0. Obtén otro vector lógico que nos diga que valores están entre 0 y 7. Obtén otro vector lógico que nos diga que valores son distintos de 1 en valor absoluto.

* 📝 **Ejercicio 8**: obtén la fecha de hoy, define la fecha de tu cumpleaños, y calcula la diferencia de días.
 
* 📝 **Ejercicio 9**: suma un mes y una semana a la fecha de tu cumpleaños

 

]

.panel[.panel-name[Sol ej. 5]


```r
secuencia &lt;- rep(c(-1, 2, 4), 7)
secuencia
```

```
&gt;  [1] -1  2  4 -1  2  4 -1  2  4 -1  2  4 -1  2  4 -1  2  4 -1  2  4
```

```r
# intercalada
rep(c(-1, 2, 4), each = 7)
```

```
&gt;  [1] -1 -1 -1 -1 -1 -1 -1  2  2  2  2  2  2  2  4  4  4  4  4  4  4
```

]

.panel[.panel-name[Sol ej. 6]


```r
secuencia &lt;- c(FALSE, TRUE, NA, FALSE, NA, TRUE, FALSE)
secuencia
```

```
&gt; [1] FALSE  TRUE    NA FALSE    NA  TRUE FALSE
```

]

.panel[.panel-name[Sol ej. 7]


```r
vector_num &gt; 0
```

```
&gt; [1]  TRUE  TRUE FALSE  TRUE
```

```r
vector_num &gt; 0 &amp; vector_num &lt; 7
```

```
&gt; [1]  TRUE FALSE FALSE  TRUE
```

```r
abs(vector_num) != 1
```

```
&gt; [1] FALSE  TRUE FALSE  TRUE
```

]


.panel[.panel-name[Sol ej. 8]


```r
library(lubridate)
hoy &lt;- today()
cumple &lt;- as_date("1989-09-10")
hoy - cumple
```

```
&gt; Time difference of 12083 days
```

]

.panel[.panel-name[Sol ej. 9]


```r
cumple + months(1) + weeks(1)
```

```
&gt; [1] "1989-10-17"
```

]

]

---

# Ejercicios extras

.panelset[
.panel[.panel-name[Ejercicios extra]


* 📝 **Ejercicio 10**: construye con `glue()` una frase que diga «Hola, me llamo … y tengo … años».

* 📝 **Ejercicio 11**: modifica el código inferior para crear un vector de nombre `vector_num` que contenga los números 1, 5 y -7.


```r
# Vector de números
vector_num &lt;- c(1)
vector_num
```

* 📝 **Ejercicio 12**:  extrae el mes, año y día de la semana de tu cumpleaños

]

.panel[.panel-name[Solución ej. 10]


```r
nombre &lt;- "Javi"
edad &lt;- 33
glue("Hola, me llamo {nombre} y tengo {edad} años")
```

```
&gt; Hola, me llamo Javi y tengo 33 años
```
]

.panel[.panel-name[Solución ej. 11]


```r
# Vector de números
vector_num &lt;- c(1, 5, -7)
vector_num
```

```
&gt; [1]  1  5 -7
```

```r
# longitud
length(vector_num)
```

```
&gt; [1] 3
```

]

.panel[.panel-name[Solución ej. 12]


```r
library(lubridate)
cumple &lt;- as_date("1989-09-10")
month(cumple)
```

```
&gt; [1] 9
```

```r
day(cumple)
```

```
&gt; [1] 10
```

```r
year(cumple)
```

```
&gt; [1] 1989
```

```r
wday(cumple, week_start = 1, label = TRUE)
```

```
&gt; [1] dom
&gt; Levels: lun &lt; mar &lt; mié &lt; jue &lt; vie &lt; sáb &lt; dom
```

]


]


---

class: inverse center middle
name: clase-3

# CLASE 3: primeros datos

&amp;nbsp;

### [Operaciones con vectores](#operaciones-vectores)

### [Ejercicios vectores](#ejercicios-vectores)

### [Matrices](#matrices)

### [Ejercicios matrices](#ejercicios-matrices)

---

name: operaciones-vectores

# .green[OPERACIONES] .orange[ARITMÉTICAS]
 
Dado que un **.bg-purple_light[número es un vector]** de longitud 1, toda **.bg-orange[operación aritmética]** (suma, resta, multiplicación, etc) que podamos hacer con un número la vamos a poder a hacer con un vector de números.

--

Si hacemos por ejemplo la operación `2 * x`, siendo `x` un vector, lo que sucederá es que la operación se realizará en **.bg-purple_light[CADA ELEMENTO]** del vector (una sola línea de código paro realizar operaciones en 10, 20, 1000 o 100000 elementos).


```r
# Multiplicamos por 2 a CADA ELEMENTO del vector
x &lt;- c(2, 4, 6)
*2 * x
```

```
&gt; [1]  4  8 12
```

--

&amp;nbsp;

**.bg-green_light[IMPORTANTE]**: el **.bg-purple_light[resultado]** de una operación aritmética sobre un vector será **.bg-orange[otro vector]**.

---

# .green[OPERACIONES] .orange[ARITMÉTICAS]
 
 
De la misma manera podemos **.bg-purple_light[sumar o restar una constante]** al vector


```r
# Sumamos 3 a CADA ELEMENTO DEL VECTOR
x + 3
```

```
&gt; [1] 5 7 9
```

--

Los vectores también pueden **.bg-purple_light[interactuar entre ellos]**, así que podemos definir sumas de vectores, como `x + y`


```r
y &lt;- c(1, 3, 5)

# suma de vectores 
*x + y
```

```
&gt; [1]  3  7 11
```

--

**.bg-green_light[IMPORTANTE]**: salvo que especifiquemos lo contrario, toda operación aritmética que hagas a un vector será **.bg-purple_light[elemento a elemento]**.

 
---

# .green[OPERACIONES] .orange[ARITMÉTICAS]
 

Dado que la operación (por ejemplo, una suma) se realiza elemento a elemento, ¿qué sucederá si **.bg-purple_light[sumamos dos vectores de distinta longitud]**?

--

Por ejemplo, definamos `z` con los 4 primeros impares, e intentemos hacer la suma `x + z`.


```r
z &lt;- c(1, 3, 5, 7)
x + z
```

```
&gt; [1]  3  7 11  9
```

--

.pull-left[


&lt;img src="./img/recycle.jpg" width="99%" style="display: block; margin: auto auto auto 0;" /&gt;


]

.pull-right[

`R` intenta molestarte lo menos posible, así que lo que hace es **.bg-purple_light[reciclar elementos]**: si tiene un vector de 4 elementos y le intentas sumar uno de 3 elementos, lo que hará será reciclar elementos del vector con menor longitud: hará `1 + 2`, `3 + 4`, `5 + 6` pero… `7 + 2` (vuelve al primero).

]

---


# .green[OPERACIONES] .orange[ARITMÉTICAS]


Los **.bg-purple_light[valores lógicos]** `TRUE` y `FALSE` son **.bg-orange[guardados internamente]** como `0` y `1`, por lo que podemos usar operaciones aritméticas con ellos.

--

Por ejemplo, si queremos **.bg-purple_light[averiguar el número de elementos que cumplen una condición]** (por ejemplo, `&lt; 3`), los que lo hagan tendrán asignado un 1 y los que no un 0, por lo que basta con sumar dicho vector lógico para obtener el número de elementos que cumplen dicha condición (elementos que son `TRUE`).


```r
# sumamos el vector de TRUE/FALSE
x
```

```
&gt; [1] 2 4 6
```

```r
sum(x &lt; 3) 
```

```
&gt; [1] 1
```

---

# .green[OPERACIONES] .orange[ESTADÍSTICAS]

También podemos realizar **.bg-purple_light[operaciones estadísticas]** con los vectores, como calcular su **suma**, su **media**, su **mediana**, entre otros.

--

Hagamos antes un **.bg-purple_light[breve repaso]** de algunos términos estadísticos:

* **.bg-purple_light[Media]**: medida de **.bg-orange[centralización]** que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados (función `mean()`). La más conocida pero la menos robusta: dado un conjunto, si se introducen valores atípicos o outliers (valores muy grandes o muy pequeños), la media se perturba con mucha facilidad.

`$$\overline{x} = \frac{1}{n} \sum_{i=1}^{n} x_i$$`


```r
x &lt;- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
mean(x)
```

```
&gt; [1] 169.8889
```

---

# .green[OPERACIONES] .orange[ESTADÍSTICAS]

También podemos realizar **.bg-purple_light[operaciones estadísticas]** con los vectores, como calcular su **suma**, su **media**, su **mediana**, entre otros.


Hagamos antes un **.bg-purple_light[breve repaso]** de algunos términos estadísticos:

* **.bg-purple_light[Mediana]**: medida de **.bg-orange[centralización]** (función `median()`) que consiste en, tras **.bg-orange[ordenar]** los datos de menor a mayor, quedarnos con el valor que ocupa el medio (deja tantos números por debajo como por encima). 


`$$Me_{x} = \displaystyle \arg \min_{x_i} \left\lbrace F_i &gt; 0.5 \right\rbrace, \quad F_i = \frac{\# \left\lbrace x_j \leq x_i \right\rbrace}{n}$$`


```r
x &lt;- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

```
&gt; [1] 170
```

---

# .green[OPERACIONES] .orange[ESTADÍSTICAS]

También podemos realizar **.bg-purple_light[operaciones estadísticas]** con los vectores, como calcular su **suma**, su **media**, su **mediana**, entre otros.


Hagamos antes un **.bg-purple_light[breve repaso]** de algunos términos estadísticos:

* **.bg-purple_light[Moda]**: medida de **.bg-orange[centralización]** que consiste en encontrar el **.bg-orange[valor o valores más repetidos]**. Es la medida de centralización más robusta. 

`$$Mo_{x} = \displaystyle \arg \max_{x_i}  f_i , \quad f_i = \frac{\# \left\lbrace x_j = x_i \right\rbrace}{n}$$`

&amp;nbsp;

**.bg-red_light[PROBLEMA]**: la moda no siempre es fácil de calcular (aunque existen paquetes para calcularla como `{modeest}`)


---

# .green[OPERACIONES] .orange[ESTADÍSTICAS]

Otra de las funciones más útil es la **.bg-purple_light[suma de elementos]** de un vector con `sum()`


```r
# suma
*sum(x)
```

```
&gt; [1] 1529
```

```r
sum(x) / length(x) # media artesanal
```

```
&gt; [1] 169.8889
```

--

Otra función útil es la **.bg-purple_light[suma acumulada]** de un vector haciendo uso de `cumsum()`


```r
# suma acumulada
*cumsum(c(1, 2, 4, 7, 7, 10))
```

```
&gt; [1]  1  3  7 14 21 31
```

---

# .green[OPERACIONES] .orange[ESTADÍSTICAS]

No solo de medidas de centralización vive la estadística: **.bg-purple_light[¿cómo calcular las medidas de dispersión?]**

* **.bg-purple_light[Varianza]**: definida como la media de desviaciones (respecto a la media) al cuadrado, tal que `\(s_{x}^{2} = \frac{1}{n} \sum_{i = 1}^{n} \left(x_i - \overline{x} \right)^2 = \overline{x^2} - \overline{x}^2\)`


```r
var(x)
```

```
&gt; [1] 159.8611
```

--

**.bg-green_light[IMPORTANTE]**: las funciones de `R` (y de cualquier calculadora) nos devuelve la **.bg-red_light[cuasivarianza]** (dividido entre `\(n-1\)`)
 

```r
# Varianza real
mean((x - mean(x))^2)
```

```
&gt; [1] 142.0988
```

---


# .green[OPERACIONES] .orange[ESTADÍSTICAS]

No solo de medidas de centralización vive la estadística: **.bg-purple_light[¿cómo calcular las medidas de dispersión?]**

* **.bg-purple_light[Desv. típica (standard deviation)]**: definida como la raíz cuadrada de la varianza, tal que `\(s_{x} = \sqrt{s_{x}^{2} }\)`


```r
sd(x)
```

```
&gt; [1] 12.64362
```

--

**.bg-green_light[IMPORTANTE]**: las funciones de `R` (y de cualquier calculadora) nos devuelve la **.bg-red_light[cuasidesviación típica]** (raíz de la cuasivarianza, dividida entre `\(n-1\)`)
 

```r
# Desv. típica real
sqrt(mean((x - mean(x))^2))
```

```
&gt; [1] 11.92052
```


---

# .green[OPERACIONES] .orange[ESTADÍSTICAS]

También pueden sernos útiles las **.bg-purple_light[medidas de posición/localización]**, como los **.bg-orange[percentiles]** (valores que nos dividen en partes iguales los datos).


```r
y &lt;- c(1, 2, 5, 5, 10, 10, 10, 13, 15, 20, 25)

# Percentiles por defecto: cuartiles
*quantile(y)
```

```
&gt;   0%  25%  50%  75% 100% 
&gt;    1    5   10   14   25
```

--

En `quantile()` hay un argumento por defecto `probs = c(0, 0.25, 0.5, 0.75, 1)` (**percentiles** a calcular) que puede ser cambiado, por ejemplo, para percentiles 20%-30%-70%-90%.


```r
quantile(y, probs = c(0.2, 0.3, 0.7, 0.9))
```

```
&gt; 20% 30% 70% 90% 
&gt;   5   5  13  20
```

---

# .green[OPERACIONES] con .orange[AUSENTES]

Imagina que tenemos un vector de temperaturas pero varios de los días el aparato de medición no funcionaba, por lo que tenemos un **.bg-purple_light[dato ausente]** marcado como `NA`.


```r
x &lt;- c(21, NA, 13, NA, NA, 25, 36, 17, 19, 5)
sum(x)
```

```
&gt; [1] NA
```

--

Dado que hay días que no tenemos disponibles, la suma tampoco la podemos conocer.  Para evitar que nos impida hacer ciertas operaciones, en muchas funciones de `R` podemos añadir el **argumento** `na.rm = TRUE`: primero elimina ausentes, y luego ejecuta la función.


```r
# eliminando datos ausentes antes de aplicar la función
*sum(x, na.rm = TRUE)
```

```
&gt; [1] 136
```

```r
mean(x, na.rm = TRUE)
```

```
&gt; [1] 19.42857
```


---

# .green[OPERACIONES] con .orange[AUSENTES]

Para **comprobar** si tenemos un **dato ausente**  podemos hacer uso de la función `is.na()`


```r
is.na(x)
```

```
&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE
```

--

También puede aparecernos un **.bg-purple_light[resultado no permitido]**, marcado como `NaN` (not a number): no es un dato ausente, es un dato resultado de una **operación no permitida**.


```r
x &lt;- c(1, NA, 3, 4, 6, 7, sqrt(-1), NA)
x
```

```
&gt; [1]   1  NA   3   4   6   7 NaN  NA
```

```r
is.nan(x)
```

```
&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE
```


---

# .orange[SELECCIONAR] elementos

Otra operación muy habitual es la **.bg-purple_light[extraer un subconjunto del mismo]**. La forma más sencilla es **usar el operador de selección** `[i]` para **acceder al elemento i-ésimo**


```r
edades &lt;- c(20, 30, 33, NA, 61)

# accedemos a la edad de la tercera persona en la lista
*edades[3]
```

```
&gt; [1] 33
```

```r
# accedemos a la edad de la cuarta persona
edades[4]
```

```
&gt; [1] NA
```

---

# .orange[SELECCIONAR] elementos

Un número no es más que un vector de longitud uno, así que esta operación también la podemos aplicar usando un **.bg-purple_light[vector de índices a seleccionar]**


```r
# Tercer y cuarto elemento
*edades[c(3, 4)]
```

```
&gt; [1] 33 NA
```

--

Esta lógica para acceder a elementos también sirve para **vectores de caracteres**.


```r
y &lt;- c("hola", "qué", "tal", "todo", "ok", "?")
y[1:2]
```

```
&gt; [1] "hola" "qué"
```

--

**.bg-green_light[TIP]**: para **.bg-purple_light[acceder al último elemento]** podemos pasarle como índice la longitud del vector 


```r
y[length(y)] 
```

```
&gt; [1] "?"
```

---


# Valores .orange[UNICOS]

Con la función `unique()` podemos también extraer los **.bg-purple_light[valores únicos de una variable]**


```r
colores &lt;- c("azul", "azul", "verde", "amarillo",
             "azul", "rojo", "rojo", "azul", "rojo",
             "verde", "morado")
*unique(colores)
```

```
&gt; [1] "azul"     "verde"    "amarillo" "rojo"     "morado"
```

---



# .orange[FILTRAR] elementos


Otras veces no querremos seleccionar un elemento en concreto sino **.bg-purple_light[filtrar algunos elementos en concreto]** y no extraerlos, **.bg-orange[eliminarlos]**.

Deberemos repetir la misma operación pero con el signo `-` delante: el operador `[-i]` **no selecciona** el elemento i-ésimo del vector sino que lo **elimina**


```r
y
```

```
&gt; [1] "hola" "qué"  "tal"  "todo" "ok"   "?"
```

```r
y[-2] 
```

```
&gt; [1] "hola" "tal"  "todo" "ok"   "?"
```

---

# .orange[FILTRAR] elementos

Lo habitual es que dicho filtro lo hagamos **.bg-purple_light[en base a una condición lógica]**. Supongamos que tenemos las edades de dos grupos de personas y que queremos quedarnos **solo con los mayores edad**: vamos a seleccionar los **elementos que cumplen una condición dada**.


```r
edades_1 &lt;- c(7, 20, 18, 3, 19, 9, 13, 3, 45)
edades_2 &lt;- c(17, 21, 58, 33, 15, 59, 13, 1, 45)
```

--


```r
*edades_1[edades_1 &gt;= 18]
```

```
&gt; [1] 20 18 19 45
```

```r
edades_2[edades_2 &gt;= 18]
```

```
&gt; [1] 21 58 33 59 45
```

Lo que hemos hecho ha sido pasar como **índices a seleccionar un vector lógico** `TRUE/FALSE`: solo filtrará los lugares donde se guarde un `TRUE`.

---

# .orange[FILTRAR] elementos

Esto también nos puede servir para **.bg-purple_light[limpiar de datos ausentes]**, combinando la función `is.na()`: nos localiza el lugar que ocupan los ausentes, con el operador `!` (**negar el valor lógico** que venga detrás).


```r
x &lt;- c(7, NA, 20, 3, 19, 21, 25, 80, NA)
x[is.na(x)] # solo valores ausentes
```

```
&gt; [1] NA NA
```

```r
x[!is.na(x)] # sin valores ausentes: ! es el símbolo de 
```

```
&gt; [1]  7 20  3 19 21 25 80
```

--

También podemos probar a **combinar condiciones lógicas** para nuestra selección.


```r
x[x &gt;= 18 &amp; x &lt;= 25] # los valores que cumplen ambas (&amp;): entre 18 y 25 años
```

```
&gt; [1] NA 20 19 21 25 NA
```

---
 

# .green[SELECCIONAR] elementos: .orange[WHICH]

A veces no querremos el elemento en sí, sino el **.bg-purple_light[lugar que ocupa]**: ¿qué valores de un vector cumplen una condición lógica? Para obtener dicho índice usaremos la función `which()`.


```r
x &lt;- c(7, NA, 20, 3, 19, 21, 25, 80, NA)
which(x &gt;= 18) # Obtenemos los lugares 
```

```
&gt; [1] 3 5 6 7 8
```

--

Esta función es muy útil especialmente cuando queremos el valor que ocupa el **.bg-purple_light[máximo/mínimo]** de un vector, con las funciones `which.max()` y `which.min()`.


```r
max(x, na.rm = TRUE)
```

```
&gt; [1] 80
```

```r
which.max(x) # Lugar que ocupa el máximo
```

```
&gt; [1] 8
```


---

# .green[SELECCIONAR] elementos: .orange[any/all]
 

Existen dos funciones muy útiles para saber si **.bg-purple_light[todos o alguno de los elementos]** de un vector cumple una condición: `all()` y `any()` nos devolverá un único valor lógico.


```r
x &lt;- c(1, 2, 3, 4, 5, NA, 7)
*all(x &lt; 3)
```

```
&gt; [1] FALSE
```

```r
any(x &lt; 3)
```

```
&gt; [1] TRUE
```

```r
all(x &gt; 0)
```

```
&gt; [1] NA
```


---

# .orange[NOMBRAR] elementos

`R` nos permite dar **.bg-purple_light[significado léxico a nuestros valores]** (significan algo, no solo números), pudiendo poner **nombres a los elementos** de un vector.


```r
x &lt;- c("edad" = 31, "tlf" = 613910687, "cp" = 33007)
x
```

```
&gt;      edad       tlf        cp 
&gt;        31 613910687     33007
```

--

Esto es una ventaja ya que nos permite su **.bg-purple_light[selección usando dichos nombres]**


```r
x[c("edad", "cp")] # seleccionamos los elementos que tienen ese nombre asignado
```

```
&gt;  edad    cp 
&gt;    31 33007
```

--

Con la función `names()` podemos, no solo **.bg-purple_light[consultar los nombres]** sino **cambiarlos**.

---

# .orange[ORDENAR] vectores


Una acción también habitual al trabajar con datos es saber **.bg-purple_light[ordenarlos]**: de menor a mayor edad, datos más recientes vs antiguos, etc. Para ello tenemos la función `sort()`, que podemos usar directamente para ordenar de **menor a mayor**.


```r
edades &lt;- c(81, 7, 25, 41, 65, 20, 33, 23, 77)

# orden de joven a mayor
*sort(edades)
```

```
&gt; [1]  7 20 23 25 33 41 65 77 81
```

--

Por defecto, `sort()` ordena de menor a mayor. Con el argumento opcional `decreasing = TRUE` podemos **ordenar de mayor a menor**.


```r
# orden de mayor a joven
*sort(edades, decreasing = FALSE)
```

```
&gt; [1]  7 20 23 25 33 41 65 77 81
```

---

# .orange[ORDENAR] vectores

Otra forma de ordenar es obtener los **índices de los elementos ordenados**, y luego usar dichos índices para **reorganizar los elementos**, con la función `order()`.


```r
*order(x)
```

```
&gt; [1] 1 3 2
```

```r
x[order(x)]
```

```
&gt;      edad        cp       tlf 
&gt;        31     33007 613910687
```

---


# .orange[MEDIR] tiempos de ejecución

Hay un paquete muy útil para **.bg-purple_light[medir tiempos de distintas órdenes]** que hacen lo mismo (el paquete `{microbenchmark}`). Vamos a comparar `order()` y `sort()`.


```r
library(microbenchmark) # instalar primera vez
x &lt;- rnorm(1e3) # 1000 elementos aleatorias
*microbenchmark(sort(x), x[order(x)], times = 1e3)
```

```
&gt; Unit: microseconds
&gt;         expr    min      lq     mean median      uq     max neval cld
&gt;      sort(x) 43.016 45.3920 51.86443 47.470 50.4335 186.957  1000   b
&gt;  x[order(x)] 29.885 31.9245 35.53252 33.051 35.1065 139.806  1000  a
```

--

# .orange[DIFERENCIA] de conjuntos
 
Por último, una función muy útil para ver las **.bg-purple_light[diferencias entre dos conjuntos]** es `setdiff()`, una función que nos devuelve los elementos distintos entre dos conjuntos.


```r
y &lt;- 1:10
z &lt;- c(1, 3, 7, 10)
setdiff(y, z)
```

```
&gt; [1] 2 4 5 6 8 9
```


---

name: ejercicios-vectores

# Ejercicios de vectores


.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: define el vector `x` como la concatenación de los 5 primeros números impares, y calcula su suma.
 
* 📝 **Ejercicio 2**: obtén los elementos de `x` mayores que 4. Determina los lugares que ocupan. Calcula el número de elementos de `x` mayores que 4.

* 📝 **Ejercicio 3**: calcula el vector `1/x` y obtén la versión ordenada (de menor a mayor).

* 📝 **Ejercicio 4**: define un vector con tu estatura y peso, y nombra cada elemento.

 
]

.panel[.panel-name[Solución ej. 1]


```r
x &lt;- c(1, 3, 5, 7, 9)

# otra forma
x &lt;- seq(1, 9, by = 2)

# Suma
sum(x)
```

```
&gt; [1] 25
```
]

.panel[.panel-name[Solución ej. 2]


```r
# Elementos mayores que 4
x[x &gt; 4]
```

```
&gt; [1] 5 7 9
```

```r
# Lugares que ocupan
which(x &gt; 4)
```

```
&gt; [1] 3 4 5
```

```r
# Cantidad de elementos mayores que 4
sum(x &gt; 4)
```

```
&gt; [1] 3
```
]

.panel[.panel-name[Solución ej. 3]


```r
y &lt;- 1/x

# una forma
sort(y)
```

```
&gt; [1] 0.1111111 0.1428571 0.2000000 0.3333333 1.0000000
```

```r
# otra forma
y[order(y)]
```

```
&gt; [1] 0.1111111 0.1428571 0.2000000 0.3333333 1.0000000
```

]


.panel[.panel-name[Solución ej. 4]


```r
x &lt;- c("estatura" = 180, "peso" = 80)
x
```

```
&gt; estatura     peso 
&gt;      180       80
```

]

]

---

# Ejercicios de vectores

.panelset[
.panel[.panel-name[Ejercicios]

 
* 📝 **Ejercicio 5**:  encuentra del vector `x` del ejercicio 1 los elementos mayores (estrictos) que 1 y menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.
 
 
* 📝 **Ejercicio 6**: define el vector `x &lt;- c(-1, 0, -2, 5, 3, 7)` y obtén los elementos que ocupan una posición impar.
 
 
* 📝 **Ejercicio 7**: define el vector de los primeros números impares (hasta el 21) y extrae los elementos que ocupan los lugares `1, 4, 5, 8`. Elimina del vector el segundo elemento

 
* 📝 **Ejercicio 8**: define un vector de 8 valores y determina la media, la mediana y los cuartiles.

]

.panel[.panel-name[Solución ej. 5]


```r
x &lt;- c(1, 3, 5, 7, 9)
# valores &gt;1 y &lt;7
x[x &gt; 1 &amp; x &lt; 7]
```

```
&gt; [1] 3 5
```

```r
# ¿Todos positivos?
all(x &gt; 0)
```

```
&gt; [1] TRUE
```

```r
sum(all(x &lt;= 0)) # debe dar 0
```

```
&gt; [1] 0
```

]

 
 
.panel[.panel-name[Solución ej. 6]


```r
x &lt;- c(-1, 0, -2, 5, 3, 7)
x[seq(1, length(x), by = 2)]
```

```
&gt; [1] -1 -2  3
```

]

.panel[.panel-name[Solución ej. 7]


```r
x &lt;- seq(1, 21, by = 2)

# posiciones pedidas
x[c(1, 4, 5, 8)]
```

```
&gt; [1]  1  7  9 15
```

```r
# sin las posiciones pedidas
x[-c(1, 4, 5, 8)]
```

```
&gt; [1]  3  5 11 13 17 19 21
```

```r
# eliminamos del vector el segundo elemento
x[-2]
```

```
&gt;  [1]  1  5  7  9 11 13 15 17 19 21
```
]

.panel[.panel-name[Solución ej. 8]


```r
x &lt;- c(0, -2, 3, 7, -5, 9, 3, 1)
mean(x)
```

```
&gt; [1] 2
```

```r
median(x)
```

```
&gt; [1] 2
```

```r
quantile(x)
```

```
&gt;   0%  25%  50%  75% 100% 
&gt; -5.0 -0.5  2.0  4.0  9.0
```
]


]

---

name: matrices

# De la .orange[celda] a la .green[tabla]
 

&lt;img src="./img/celdas.jpg" width="55%" style="display: block; margin: auto;" /&gt;

* **.bg-purple_light[Celda]**: un dato **.bg-orange[individual]** de un tipo concreto.

* **.bg-purple_light[Variable]**: una **.bg-orange[concatenación de valores]** del mismo tipo (**vectores**).


&amp;nbsp;

--

**.bg-purple_light[Matriz]**: **.bg-orange[concatenación de variables]** del **.bg-yellow[mismo tipo]** y longitud.

---

# .orange[MATRICES]: concatenando variables


Cuando analizamos datos solemos tener varias **variables distintas** de cada individuo: necesitamos una «tabla» con **.bg-purple_light[distintas variables]** (de **.bg-orange[IGUAL longitud]**).

Las **.bg-purple_light[matrices]** son una concatenación de variables, del **.bg-orange[mismo tipo e igual longitud]**, dispuestas en **p columnas** (datos p-dimensionales) 

--

&amp;nbsp;

Vamos a empezar definiendo una **matriz sencilla**: imagina que tenemos las estaturas y pesos de 5 personas. ¿Cómo juntar las dos variables creando nuestro primer conjunto de datos? Fíjate que son del mismo tipo e igual longitud.


```r
estaturas &lt;- c(150, 160, 170, 180, 190)
pesos &lt;- c(60, 70, 80, 90, 100)
```

---

# .orange[MATRICES]: concatenando variables


```r
estaturas &lt;- c(150, 160, 170, 180, 190)
pesos &lt;- c(60, 70, 80, 90, 100)
```

¿Cómo juntar las dos variables creando nuestro primer conjunto de datos? Vamos a **.bg-purple_light[crear una matriz]**, un conjunto de números organizado en 2 columnas (una por variable) y 5 filas o registros (una por persona). Para ello usaremos la función `cbind()`, que nos **concatena vectores de igual longitud en columnas**.

 

```r
# Construimos la matriz por columnas
*datos_matriz &lt;- cbind(estaturas, pesos)
datos_matriz
```

```
&gt;      estaturas pesos
&gt; [1,]       150    60
&gt; [2,]       160    70
&gt; [3,]       170    80
&gt; [4,]       180    90
&gt; [5,]       190   100
```

---

# .orange[MATRICES]: concatenando variables


.pull-left[

&lt;img src="./img/datos_matriz_1.jpg" width="99%" style="display: block; margin: auto auto auto 0;" /&gt;


]


.pull-right[


```r
View(datos_matriz)
```

Podemos **.bg-purple_light[visualizar la matriz]** en un formato «excelizado» con la función `View()`.


También podemos **.bg-purple_light[construir la matriz por filas]** con la función `rbind()` (aunque lo recomendable es tener cada variable en  columna y cada individuo en fila).


```r
# Construimos la matriz por filas
rbind(estaturas, pesos) 
```

```
&gt;           [,1] [,2] [,3] [,4] [,5]
&gt; estaturas  150  160  170  180  190
&gt; pesos       60   70   80   90  100
```

]

---
 
 
# .orange[MATRICES]: concatenando variables

Podemos comprobar las **.bg-purple_light[dimensiones de una matriz]** con `dim()`, `nrow()` y `ncol()`: nuestros datos están **.bg-orange[tabulados]**:


```r
dim(datos_matriz) # vector
```

```
&gt; [1] 5 2
```

```r
nrow(datos_matriz)
```

```
&gt; [1] 5
```

```r
ncol(datos_matriz)
```

```
&gt; [1] 2
```

---

# .orange[MATRICES]: concatenando variables


Veamos un ejemplo con **tres variables/columnas**: edades, teléfonos y códigos postales.


```r
edades &lt;- c(14, 24, 56, 31, 20, 87, 73) 
tlf &lt;- c(NA, 683839390, 621539732, 618211286, NA, 914727164, NA)
cp &lt;- c(33007, 28019, 37005, 18003, 33091, 25073, 17140)

# Construimos la matriz por columnas
*datos_matriz &lt;- cbind(edades, tlf, cp)
datos_matriz
```

```
&gt;      edades       tlf    cp
&gt; [1,]     14        NA 33007
&gt; [2,]     24 683839390 28019
&gt; [3,]     56 621539732 37005
&gt; [4,]     31 618211286 18003
&gt; [5,]     20        NA 33091
&gt; [6,]     87 914727164 25073
&gt; [7,]     73        NA 17140
```


---

# .orange[MATRICES]: añadir registros/variables

Las funciones `cbind()` y `rbind()` no solo nos permiten crear matrices desde cero sino también **.bg-purple_light[añadir filas o columnas]** a matrices existentes.


```r
# Añadimos una fila
rbind(datos_matriz, c(27, 620125780, 28051))
```

```
&gt;      edades       tlf    cp
&gt; [1,]     14        NA 33007
&gt; [2,]     24 683839390 28019
&gt; [3,]     56 621539732 37005
&gt; [4,]     31 618211286 18003
&gt; [5,]     20        NA 33091
&gt; [6,]     87 914727164 25073
&gt; [7,]     73        NA 17140
&gt; [8,]     27 620125780 28051
```

---

# .orange[MATRICES]: transpuesta

También podemos «darle vuelta» (**.bg-purple_light[matriz transpuesta]**) con `t()`.


```r
datos_matriz
```

```
&gt;      edades       tlf    cp
&gt; [1,]     14        NA 33007
&gt; [2,]     24 683839390 28019
&gt; [3,]     56 621539732 37005
&gt; [4,]     31 618211286 18003
&gt; [5,]     20        NA 33091
&gt; [6,]     87 914727164 25073
&gt; [7,]     73        NA 17140
```

```r
*t(datos_matriz)
```

```
&gt;         [,1]      [,2]      [,3]      [,4]  [,5]      [,6]  [,7]
&gt; edades    14        24        56        31    20        87    73
&gt; tlf       NA 683839390 621539732 618211286    NA 914727164    NA
&gt; cp     33007     28019     37005     18003 33091     25073 17140
```

---

# .orange[MATRICES]: valores repetidos

Podemos definir una **.bg-purple_light[matriz de nº repetidos]** con `matrix(..., nrow = ..., ncol = ...)`


```r
# matriz de ceros de 3 filas, 2 columnas,
*matrix(0, nrow = 3, ncol = 2)
```

```
&gt;      [,1] [,2]
&gt; [1,]    0    0
&gt; [2,]    0    0
&gt; [3,]    0    0
```

--

También podemos definir una **.bg-purple_light[matriz a partir de un vector numérico]**, reorganizando los valores en forma de matriz (sabiendo que los elementos se van colocando por columnas).


```r
matrix(1:15, ncol = 5) # Matriz con el vector 1:15
```

```
&gt;      [,1] [,2] [,3] [,4] [,5]
&gt; [1,]    1    4    7   10   13
&gt; [2,]    2    5    8   11   14
&gt; [3,]    3    6    9   12   15
```

---

# .green[OPERACIONES] con .orange[MATRICES]

Con las matrices sucede como con los vectores: cuando aplicamos una **.bg-purple_light[operación aritmética]** lo hacemos **.bg-orange[elemento a elemento]**


```r
z &lt;- matrix(1:15, ncol = 5) 
z / 5
```

```
&gt;      [,1] [,2] [,3] [,4] [,5]
&gt; [1,]  0.2  0.8  1.4  2.0  2.6
&gt; [2,]  0.4  1.0  1.6  2.2  2.8
&gt; [3,]  0.6  1.2  1.8  2.4  3.0
```

```r
z + 3
```

```
&gt;      [,1] [,2] [,3] [,4] [,5]
&gt; [1,]    4    7   10   13   16
&gt; [2,]    5    8   11   14   17
&gt; [3,]    6    9   12   15   18
```

---

# .orange[MATRICES] de .green[CARACTERES]

También podemos crear matrices de otros tipos de datos, siempre y cuando las **.bg-purple_light[columnas sean del mismo tipo e igual longitud]**, por ejemplo una **.bg-orange[matriz de caracteres]**.


```r
# matriz de caracteres
nombres &lt;- c("Javier", "Carlos", "María")
apellidos &lt;- c("Álvarez", "García", "Pérez")
cbind(nombres, apellidos)
```

```
&gt;      nombres  apellidos
&gt; [1,] "Javier" "Álvarez"
&gt; [2,] "Carlos" "García" 
&gt; [3,] "María"  "Pérez"
```

--


```r
# matriz de valores lógicos
cbind(c(TRUE, FALSE), c(FALSE, TRUE))
```

```
&gt;       [,1]  [,2]
&gt; [1,]  TRUE FALSE
&gt; [2,] FALSE  TRUE
```

---

# .orange[SELECCIONAR] elementos

Si recuerdas para los vectores, usábamos el operador `[i]` para **acceder al elemento i-ésimo**. En el caso de las matrices la lógica será la misma:

* para **.bg-purple_light[acceder a la fila i-ésima]** se usa el operador `[i, ]` (dejando libre la columna).


```r
datos_matriz[1, ] # fila 1
```

```
&gt; edades    tlf     cp 
&gt;     14     NA  33007
```

---

# .orange[SELECCIONAR] elementos

Si recuerdas para los vectores, usábamos el operador `[i]` para **acceder al elemento i-ésimo**. En el caso de las matrices la lógica será la misma:

* para **.bg-purple_light[acceder a la columna j-ésima]** se usa el operador `[, j]` (dejando libre la fila).


```r
datos_matriz[, 3] # columna 3
```

```
&gt; [1] 33007 28019 37005 18003 33091 25073 17140
```


---

# .orange[SELECCIONAR] elementos

Si recuerdas para los vectores, usábamos el operador `[i]` para **acceder al elemento i-ésimo**. En el caso de las matrices la lógica será la misma:

* para **.bg-purple_light[acceder conjuntamente al elemento (i, j)]** se usa el operador `[i, j]`.


```r
datos_matriz[1, 3] # elemento (1, 3)
```

```
&gt;    cp 
&gt; 33007
```

```r
datos_matriz[2, 2] # elemento (1, 3)
```

```
&gt;       tlf 
&gt; 683839390
```


---

# .orange[NOMBRAR] variables

Una matriz por defecto adopta los nombres de los vectores como los nombres de columnas, pero podemos 
**.bg-purple_light[personalizar los nombres de las variables]**


```r
estaturas &lt;- c(150, 160, 170)
pesos &lt;- c(60, 70, 80)
cbind("altura" = estaturas, "pesaje" = pesos)
```

```
&gt;      altura pesaje
&gt; [1,]    150     60
&gt; [2,]    160     70
&gt; [3,]    170     80
```


--

Si las columnas tienen nombres podemos hacer uso de ellos para **acceder a las columnas**


```r
datos_matriz[, c("edades", "tlf")]
```

```
&gt;      edades       tlf
&gt; [1,]     14        NA
&gt; [2,]     24 683839390
&gt; [3,]     56 621539732
&gt; [4,]     31 618211286
&gt; [5,]     20        NA
&gt; [6,]     87 914727164
&gt; [7,]     73        NA
```

---

# .orange[NOMBRAR] variables

También podemos **.bg-purple_light[asignar nombres]** a las filas de una matriz con `row.names()` y acceder a filas y columnas por nombres.


```r
row.names(datos_matriz) &lt;- c("Javi", "Laura", "Patricia", "Carlos", "Juan", "Luis", "Carla")
datos_matriz
```

```
&gt;          edades       tlf    cp
&gt; Javi         14        NA 33007
&gt; Laura        24 683839390 28019
&gt; Patricia     56 621539732 37005
&gt; Carlos       31 618211286 18003
&gt; Juan         20        NA 33091
&gt; Luis         87 914727164 25073
&gt; Carla        73        NA 17140
```

```r
datos_matriz["Javi", "edades"]
```

```
&gt; [1] 14
```

---

# .orange[OPERACIONES] por filas/columnas

Normalmente, para explicar las **operaciones con matrices** en un lenguaje de programación al uso, necesitaríamos hablar de una **herramienta llamada bucles**. Lo mencionaremos más adelante pero no los vamos a necesitar de momento (cuántos menos los usemos en `R`, mejor)

--

Imagina que tuviésemos nuestra matriz de estaturas y pesos.


```r
datos_matriz &lt;- cbind(estaturas, pesos)
datos_matriz
```

```
&gt;      estaturas pesos
&gt; [1,]       150    60
&gt; [2,]       160    70
&gt; [3,]       170    80
```

--

¿Cómo podemos **.bg-purple_light[aplicar una operación para cada una de las filas o columnas]** de una matriz?

---

# .orange[OPERACIONES] por filas/columnas

Imagina que queremos obtener la **.bg-purple_light[media de cada columna]**. Lo haremos con la función `apply()`, y le indicaremos como argumentos la matriz, el **.bg-orange[sentido de la operación]** (`MARGIN = 1` por filas, `MARGIN = 2` por columnas) y la **función a aplicar**


```r
# Media (mean) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "mean")
```

```
&gt; estaturas     pesos 
&gt;       160        70
```

--

Si la función **requiere de argumentos extras** se lo podemos indicar al final.


```r
estaturas_bis &lt;- c(150, NA, 170, 180, 190)
datos_matriz_bis &lt;- cbind(estaturas_bis, pesos) 
apply(datos_matriz_bis, MARGIN = 2, FUN = "mean")
```

```
&gt; estaturas_bis         pesos 
&gt;            NA            68
```

---

name: ejercicios-matrices

# Ejercicios de matrices

.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: modifica el código para definir una matriz `x` de ceros de 3 filas y 7 columnas.
 

```r
# Matriz
x &lt;- matrix(0, nrow = 2, ncol = 3)
x
```

* 📝 **Ejercicio 2**: a la matriz anterior, suma un 1 a cada número de la matriz y divide el resultado entre 5.
 

* 📝 **Ejercicio 3**: tras definir la matriz `x` calcula su transpuesta y obtén sus dimensiones
 

]

.panel[.panel-name[Solución ej. 1]


```r
x &lt;- matrix(0, nrow = 3, ncol = 7)
x
```

```
&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
&gt; [1,]    0    0    0    0    0    0    0
&gt; [2,]    0    0    0    0    0    0    0
&gt; [3,]    0    0    0    0    0    0    0
```

]

.panel[.panel-name[Solución ej. 2]


```r
# sumamos 1
x + 1
```

```
&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
&gt; [1,]    1    1    1    1    1    1    1
&gt; [2,]    1    1    1    1    1    1    1
&gt; [3,]    1    1    1    1    1    1    1
```

```r
# dividimos entre 5
(x + 1) / 5
```

```
&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
&gt; [1,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2
&gt; [2,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2
&gt; [3,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2
```

]

.panel[.panel-name[Solución ej. 3]


```r
# dimensiones originales
dim(x)
```

```
&gt; [1] 3 7
```

```r
# transpuesta
y &lt;- t(x)
y
```

```
&gt;      [,1] [,2] [,3]
&gt; [1,]    0    0    0
&gt; [2,]    0    0    0
&gt; [3,]    0    0    0
&gt; [4,]    0    0    0
&gt; [5,]    0    0    0
&gt; [6,]    0    0    0
&gt; [7,]    0    0    0
```

```r
dim(y)
```

```
&gt; [1] 7 3
```

]


]

---

# Ejercicios de matrices

.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 4**: define la matriz `x &lt;- matrix(1:12, nrow = 4)`. Obtén la primera fila, la tercera columna, y el elemento (4, 1).

* 📝 **Ejercicio 5**: en la matriz anterior, pon a cada fila `i` el nombre `fila_i` (fila_1, fila_2, fila_3, fila_4).

* 📝 **Ejercicio 6**: con la matriz anterior definida como `matrix(1:12, nrow = 4)`, calcula la media de todos los elementos, la media de cada fila y la media de cada columna. Calcula la suma de de cada fila y de cada columna

]

.panel[.panel-name[Solución ej. 4]


```r
x &lt;- matrix(1:12, nrow = 4)

# primera fila
x[1, ]
```

```
&gt; [1] 1 5 9
```

```r
# tercera columna
x[, 3]
```

```
&gt; [1]  9 10 11 12
```

```r
# (4, 1)
x[4, 1]
```

```
&gt; [1] 4
```

]

.panel[.panel-name[Solución ej. 5]


```r
x
```

```
&gt;      [,1] [,2] [,3]
&gt; [1,]    1    5    9
&gt; [2,]    2    6   10
&gt; [3,]    3    7   11
&gt; [4,]    4    8   12
```

```r
row.names(x) &lt;- glue("fila_{1:4}")
x
```

```
&gt;        [,1] [,2] [,3]
&gt; fila_1    1    5    9
&gt; fila_2    2    6   10
&gt; fila_3    3    7   11
&gt; fila_4    4    8   12
```

]

.panel[.panel-name[Solución ej. 6]


```r
# media por filas
apply(x, MARGIN = 1, FUN = mean)
```

```
&gt; fila_1 fila_2 fila_3 fila_4 
&gt;      5      6      7      8
```

```r
# media por columnas
apply(x, MARGIN = 2, FUN = mean)
```

```
&gt; [1]  2.5  6.5 10.5
```

```r
# suma por filas
apply(x, MARGIN = 1, FUN = sum)
```

```
&gt; fila_1 fila_2 fila_3 fila_4 
&gt;     15     18     21     24
```

```r
# suma por columnas
apply(x, MARGIN = 2, FUN = sum)
```

```
&gt; [1] 10 26 42
```

]

]


---

# Ejercicios extras (matrices y vectores)

.panelset[
.panel[.panel-name[Ejercicios extra]

* 📝 **Ejercicio 1**: define un vector `y` que contenga los 5 primeros pares, y otro `x` con los 5 primeros impares. Haz la suma de `x` (ejercicio 1 anterior) e `y`.
 
* 📝 **Ejercicio 2**: encuentra del vector `x &lt;- c(-1, 0, -2, 5, 3, 7)` el lugar (el índice) que ocupa su mínimo y su máximo.
 

* 📝 **Ejercicio 3**: define el vector `c(-1, 0, 4, 5, -2)`, calcula la raíz cuadrada del vector y determina que lugares son de tipo `NaN`.

* 📝 **Ejercicio 4**:  el siguiente código define una matriz de dimensiones `4 x 3` y calcula la suma por columnas. Modifica el código para que realice la suma por filas.
 

```r
matriz &lt;- matrix(1:12, nrow = 4)
apply(matriz, MARGIN = 2, FUN = "sum")
```

]

.panel[.panel-name[Solución ej. 1]


```r
y &lt;- c(0, 2, 4, 6, 8)
x &lt;- y + 1 # forma más rápida de (1, 3, 5, 7, 9)
x + y
```

```
&gt; [1]  1  5  9 13 17
```

]

.panel[.panel-name[Solución ej. 2]


```r
x &lt;- c(-1, 0, -2, 5, 3, 7)
which.max(x)
```

```
&gt; [1] 6
```

```r
which.min(y)
```

```
&gt; [1] 1
```

]

.panel[.panel-name[Solución ej. 3]


```r
x &lt;- c(-1, 0, 4, 5, -2)
sqrt(x)
```

```
&gt; [1]      NaN 0.000000 2.000000 2.236068      NaN
```

```r
is.nan(sqrt(x))
```

```
&gt; [1]  TRUE FALSE FALSE FALSE  TRUE
```

]

.panel[.panel-name[Solución ej. 4]


```r
matriz &lt;- matrix(1:12, nrow = 4)
apply(matriz, MARGIN = 1, FUN = "sum")
```

```
&gt; [1] 15 18 21 24
```

]

]

---

class: inverse center middle
name: clase-4

# CLASE 4: primeros datos

&amp;nbsp;

### [data.frame](#data.frame)

### [tibble](#tibble)

### [Ejercicios datasets](#ejercicios-tibble)

### [Rmarkdown](#rmd)


---

name: data.frame

# .orange[TABLAS]: variables .green[data.frame]
 


&lt;img src="./img/celdas.jpg" width="45%" style="display: block; margin: auto;" /&gt;

* **.bg-purple_light[Celda]**: un dato **.bg-orange[individual]** de un tipo concreto.

* **.bg-purple_light[Variable]**: una **.bg-orange[concatenación de valores]** del mismo tipo (**vectores**).

* **.bg-purple_light[Matriz]**: **.bg-orange[concatenación de variables]** del **.bg-yellow[mismo tipo]** y longitud.

&amp;nbsp;

--

* **.bg-purple_light[data.frame (tabla)]**: **.bg-orange[concatenación de variables]** de **.bg-yellow[DISTINTO tipo]** e igual longitud.


---

# .red[PROBLEMAS] de las .green[MATRICES]


Retomemos nuestra matriz de edades, teléfonos y códigos postales.


```r
edades &lt;- c(14, 24, 56, 31, 20, 87) 
tlf &lt;- c(NA, 683839390, 621539732, 618211286, NA, 914727164)
cp &lt;- c(33007, 28019, 37005, 18003, 33091, 25073)

# Construimos la matriz por columnas
*datos_matriz &lt;- cbind(edades, tlf, cp)
datos_matriz
```

```
&gt;      edades       tlf    cp
&gt; [1,]     14        NA 33007
&gt; [2,]     24 683839390 28019
&gt; [3,]     56 621539732 37005
&gt; [4,]     31 618211286 18003
&gt; [5,]     20        NA 33091
&gt; [6,]     87 914727164 25073
```

--

¿Qué sucederá si ahora **.bg-purple_light[añadimos una columna con los nombres]** (tipo caracter) de cada persona?

---


# .red[PROBLEMAS] de las .green[MATRICES]


```r
nombres &lt;- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")
datos_matriz_nueva &lt;- cbind(nombres, datos_matriz)
```


```
&gt;      nombres  edades tlf         cp     
&gt; [1,] "Sonia"  "14"   NA          "33007"
&gt; [2,] "Carla"  "24"   "683839390" "28019"
&gt; [3,] "Pepito" "56"   "621539732" "37005"
&gt; [4,] "Carlos" "31"   "618211286" "18003"
&gt; [5,] "Lara"   "20"   NA          "33091"
&gt; [6,] "Sandra" "87"   "914727164" "25073"
```

**.bg-red_light[¿Has visto lo que ha sucedido?]**

--

Como una **.bg-purple_light[matriz solo puedes tener un tipo de dato]**, al añadir una variable de tipo texto, `R` se ha visto obligado a **convertir los números en texto** (poniéndole **comillas**). 


```r
datos_matriz_nueva[, "edades"] + 1
```

```
&gt; Error in datos_matriz_nueva[, "edades"] + 1: argumento no-numérico para operador binario
```

---

# .red[PROBLEMAS] de las .green[MATRICES]

Las **.bg-purple_light[matrices]** nos permiten almacenar distintas variables SIEMPRE Y CUANDO tengan

* **.bg-orange[Misma longitud]**.
* **.bg-orange[Mismo tipo]** de dato (sin mezclar).

Esto es bastante limitante en la vida real nuestros datos tendrán variables de todo tipo: supongamos que queremos **guardar de 7 personas las siguientes variables**.



```r
# Nombres
nombres &lt;- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")

# Apellidos
apellidos &lt;- c(NA, "González", "Fernández", "Martínez", "Liébana", "García", "Ortiz")

# Código postal
cp &lt;- c(28019, 28001, 34005, 18410, 33007, 34500, 28017)

# Edades
edades &lt;- c(45, 67, NA, 31, 27, 19, 50)
```

---


# .red[PROBLEMAS] de las .green[MATRICES]

Las **.bg-purple_light[matrices]** nos permiten almacenar distintas variables SIEMPRE Y CUANDO tengan

* **.bg-orange[Misma longitud]**.
* **.bg-orange[Mismo tipo]** de dato (sin mezclar).

Esto es bastante limitante en la vida real nuestros datos tendrán variables de todo tipo: supongamos que queremos **guardar de 7 personas las siguientes variables**.



```r
# Teléfono
tlf &lt;- c(618910564, 914718475, 934567891, 620176565, NA, NA, 688921344)

# Estado civil (no lo sabemos de una persona)
casado &lt;- c(TRUE, FALSE, FALSE, NA, TRUE, FALSE, FALSE)

# Fecha de creación (fecha en el que esa persona entra en el sistema)
# lo convertimos a tipo fecha
fecha_creacion &lt;-
  as_date(c("2021-03-04", "2020-10-12", "1990-04-05",
            "2019-09-10", "2017-03-21", "2020-07-07",
            "2000-01-28"))
```


---

# .red[PROBLEMAS] de las .green[MATRICES]

Aahora tenemos un **popurrí de variables**, de la misma longitud pero de tipos distintos:

* `(edades, tlf, cp)` son variables **numéricas**.
* `(nombres, apellidos)` son variables de **texto**.
* `casado` es una variable **lógica**.
* `fecha_creacion` de tipo **fecha**.

¿Qué sucedería si **.bg-purple_light[intentamos mezclar todo en una matriz]**?

--


```r
# Juntamos por columnas
datos_matriz &lt;-
  cbind(nombres, apellidos, edades, tlf, cp, casado, fecha_creacion)
datos_matriz
```

```
&gt;      nombres  apellidos   edades tlf         cp      casado  fecha_creacion
&gt; [1,] "Sonia"  NA          "45"   "618910564" "28019" "TRUE"  "18690"       
&gt; [2,] "Carla"  "González"  "67"   "914718475" "28001" "FALSE" "18547"       
&gt; [3,] "Pepito" "Fernández" NA     "934567891" "34005" "FALSE" "7399"        
&gt; [4,] "Carlos" "Martínez"  "31"   "620176565" "18410" NA      "18149"       
&gt; [5,] "Lara"   "Liébana"   "27"   NA          "33007" "TRUE"  "17246"       
&gt; [6,] "Sandra" "García"    "19"   NA          "34500" "FALSE" "18450"       
&gt; [7,] "Javi"   "Ortiz"     "50"   "688921344" "28017" "FALSE" "10984"
```

---

# .red[PROBLEMAS] de las .green[MATRICES]


```r
datos_matriz
```

```
&gt;      nombres  apellidos   edades tlf         cp      casado  fecha_creacion
&gt; [1,] "Sonia"  NA          "45"   "618910564" "28019" "TRUE"  "18690"       
&gt; [2,] "Carla"  "González"  "67"   "914718475" "28001" "FALSE" "18547"       
&gt; [3,] "Pepito" "Fernández" NA     "934567891" "34005" "FALSE" "7399"        
&gt; [4,] "Carlos" "Martínez"  "31"   "620176565" "18410" NA      "18149"       
&gt; [5,] "Lara"   "Liébana"   "27"   NA          "33007" "TRUE"  "17246"       
&gt; [6,] "Sandra" "García"    "19"   NA          "34500" "FALSE" "18450"       
&gt; [7,] "Javi"   "Ortiz"     "50"   "688921344" "28017" "FALSE" "10984"
```

Dado que en una **.bg-purple_light[matriz solo podemos almacenar datos del mismo tipo]**, los números los convierte a texto, las variables lógicas las convierte a texto (`TRUE` era un valor lógico, `"TRUE"` es un texto, sin significado de verdadero/falso) y las fechas las ha convertido a texto.


```r
datos_matriz[1, "fecha_creacion"] - datos_matriz[2, "fecha_creacion"]
```

```
&gt; Error in datos_matriz[1, "fecha_creacion"] - datos_matriz[2, "fecha_creacion"]: argumento no-numérico para operador binario
```

---

# .orange[TABLAS]: variables .green[data.frame]

Vamos a aprender cómo juntar variables de distinto tipo, sin **modificar la integridad** del dato. El formato de **.bg-purple_light[tabla de datos]** que vamos a empezar a usar se llama `data.frame`: una **.bg-purple_light[colección de variables de igual longitud]** pero cada una puede ser de un **.bg-orange[tipo distinto]**.

--

Para crearlo basta con usar la función `data.frame()`, pasándole como argumentos (separados por comas) las variables que queremos reunir.


```r
# Creamos nuestro primer data.frame
tabla &lt;- data.frame(nombres, apellidos, edades, tlf,
*                   cp, casado, fecha_creacion)
tabla
```

```
&gt;   nombres apellidos edades       tlf    cp casado fecha_creacion
&gt; 1   Sonia      &lt;NA&gt;     45 618910564 28019   TRUE     2021-03-04
&gt; 2   Carla  González     67 914718475 28001  FALSE     2020-10-12
&gt; 3  Pepito Fernández     NA 934567891 34005  FALSE     1990-04-05
&gt; 4  Carlos  Martínez     31 620176565 18410     NA     2019-09-10
&gt; 5    Lara   Liébana     27        NA 33007   TRUE     2017-03-21
&gt; 6  Sandra    García     19        NA 34500  FALSE     2020-07-07
&gt; 7    Javi     Ortiz     50 688921344 28017  FALSE     2000-01-28
```

---

# .orange[TABLAS]: variables .green[data.frame]


```r
tabla
```

```
&gt;   nombres apellidos edades       tlf    cp casado fecha_creacion
&gt; 1   Sonia      &lt;NA&gt;     45 618910564 28019   TRUE     2021-03-04
&gt; 2   Carla  González     67 914718475 28001  FALSE     2020-10-12
&gt; 3  Pepito Fernández     NA 934567891 34005  FALSE     1990-04-05
&gt; 4  Carlos  Martínez     31 620176565 18410     NA     2019-09-10
&gt; 5    Lara   Liébana     27        NA 33007   TRUE     2017-03-21
&gt; 6  Sandra    García     19        NA 34500  FALSE     2020-07-07
&gt; 7    Javi     Ortiz     50 688921344 28017  FALSE     2000-01-28
```

```r
class(tabla)
```

```
&gt; [1] "data.frame"
```

```r
dim(tabla)
```

```
&gt; [1] 7 7
```

---

# .orange[TABLAS]: variables .green[data.frame]

Al igual que con matrices, podemos **.bg-purple_light[crear un data.frame]** indicando **nombre de columnas**


```r
tabla &lt;- data.frame("nombre" = nombres, "apellido" = apellidos, "edad" = edades, "teléfono" = tlf, 
                    "cp" = cp, "casado" = casado, "fecha_registro" = fecha_creacion)
tabla
```

```
&gt;   nombre  apellido edad  teléfono    cp casado fecha_registro
&gt; 1  Sonia      &lt;NA&gt;   45 618910564 28019   TRUE     2021-03-04
&gt; 2  Carla  González   67 914718475 28001  FALSE     2020-10-12
&gt; 3 Pepito Fernández   NA 934567891 34005  FALSE     1990-04-05
&gt; 4 Carlos  Martínez   31 620176565 18410     NA     2019-09-10
&gt; 5   Lara   Liébana   27        NA 33007   TRUE     2017-03-21
&gt; 6 Sandra    García   19        NA 34500  FALSE     2020-07-07
&gt; 7   Javi     Ortiz   50 688921344 28017  FALSE     2000-01-28
```

&amp;nbsp;

**.bg-green_light[¡TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!]** Puedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`

---

# .orange[TABLAS]: variables .green[data.frame]

Si tenemos uno ya creado y queremos **.bg-purple_light[añadir una columna]** es tan simple como usar la `función data.frame()` que ya hemos visto para concatenar la columna. Vamos añadir por ejemplo una nueva variable, el **número de hermanos** de cada individuo.


```r
# Añadimos una nueva columna con nº de hermanos/as
hermanos &lt;- c(0, 0, 1, 5, 2, 3, 0)
tabla &lt;- data.frame(tabla, "n_hermanos" = hermanos)
tabla
```

```
&gt;   nombre  apellido edad  teléfono    cp casado fecha_registro n_hermanos
&gt; 1  Sonia      &lt;NA&gt;   45 618910564 28019   TRUE     2021-03-04          0
&gt; 2  Carla  González   67 914718475 28001  FALSE     2020-10-12          0
&gt; 3 Pepito Fernández   NA 934567891 34005  FALSE     1990-04-05          1
&gt; 4 Carlos  Martínez   31 620176565 18410     NA     2019-09-10          5
&gt; 5   Lara   Liébana   27        NA 33007   TRUE     2017-03-21          2
&gt; 6 Sandra    García   19        NA 34500  FALSE     2020-07-07          3
&gt; 7   Javi     Ortiz   50 688921344 28017  FALSE     2000-01-28          0
```

---

# .orange[TABLAS]: variables .green[data.frame]

Si queremos **.bg-purple_light[acceder a una columna, fila o elemento]** en concreto, los `data.frame` tienen las mismas ventajas que una matriz, así que bastaría con usar los mismos operadores.


```r
tabla[5, ] # Accedemos a la quinta fila
```

```
&gt;   nombre apellido edad teléfono    cp casado fecha_registro n_hermanos
&gt; 5   Lara  Liébana   27       NA 33007   TRUE     2017-03-21          2
```

--

.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/tabla_dolar.jpg" alt="Menú desplegable de variables (columnas)" width="99%" /&gt;
&lt;p class="caption"&gt;Menú desplegable de variables (columnas)&lt;/p&gt;
&lt;/div&gt;
]

.pull-right[

No solo tiene las ventajas de una matriz sino que también tiene las **.bg-purple_light[ventajas de una «base» de datos]**: podemos aceder a las variables por el índice de columna que ocupan pero también **.bg-purple_light[acceder por su nombre]**, poniendo el nombre de la tabla, el símbolo `$` y, con el tabulador, nos aparecerá un menú de columnas a elegir.

]

---

# Primer .orange[ANÁLISIS DE DATOS]

.panelset[
.panel[.panel-name[USArrests]

Nuestro primer conjunto será `USArrests`, un dataset de **.bg-purple_light[arrestos en EE.UU.]** del paquete `{datasets}` (si escribimos `datasets::` y pulsamos tabulador, se nos abre un desplegable con distintos conjuntos de datos para ser usado)


```r
# install.packages("datasets") # Descomentar si nunca se ha instalado
library(datasets)
datasets::USArrests
```

```
&gt;                Murder Assault UrbanPop Rape
&gt; Alabama          13.2     236       58 21.2
&gt; Alaska           10.0     263       48 44.5
&gt; Arizona           8.1     294       80 31.0
&gt; Arkansas          8.8     190       50 19.5
&gt; California        9.0     276       91 40.6
&gt; Colorado          7.9     204       78 38.7
&gt; Connecticut       3.3     110       77 11.1
&gt; Delaware          5.9     238       72 15.8
&gt; Florida          15.4     335       80 31.9
&gt; Georgia          17.4     211       60 25.8
&gt; Hawaii            5.3      46       83 20.2
&gt; Idaho             2.6     120       54 14.2
&gt; Illinois         10.4     249       83 24.0
&gt; Indiana           7.2     113       65 21.0
&gt; Iowa              2.2      56       57 11.3
&gt; Kansas            6.0     115       66 18.0
&gt; Kentucky          9.7     109       52 16.3
&gt; Louisiana        15.4     249       66 22.2
&gt; Maine             2.1      83       51  7.8
&gt; Maryland         11.3     300       67 27.8
&gt; Massachusetts     4.4     149       85 16.3
&gt; Michigan         12.1     255       74 35.1
&gt; Minnesota         2.7      72       66 14.9
&gt; Mississippi      16.1     259       44 17.1
&gt; Missouri          9.0     178       70 28.2
&gt; Montana           6.0     109       53 16.4
&gt; Nebraska          4.3     102       62 16.5
&gt; Nevada           12.2     252       81 46.0
&gt; New Hampshire     2.1      57       56  9.5
&gt; New Jersey        7.4     159       89 18.8
&gt; New Mexico       11.4     285       70 32.1
&gt; New York         11.1     254       86 26.1
&gt; North Carolina   13.0     337       45 16.1
&gt; North Dakota      0.8      45       44  7.3
&gt; Ohio              7.3     120       75 21.4
&gt; Oklahoma          6.6     151       68 20.0
&gt; Oregon            4.9     159       67 29.3
&gt; Pennsylvania      6.3     106       72 14.9
&gt; Rhode Island      3.4     174       87  8.3
&gt; South Carolina   14.4     279       48 22.5
&gt; South Dakota      3.8      86       45 12.8
&gt; Tennessee        13.2     188       59 26.9
&gt; Texas            12.7     201       80 25.5
&gt; Utah              3.2     120       80 22.9
&gt; Vermont           2.2      48       32 11.2
&gt; Virginia          8.5     156       63 20.7
&gt; Washington        4.0     145       73 26.2
&gt; West Virginia     5.7      81       39  9.3
&gt; Wisconsin         2.6      53       66 10.8
&gt; Wyoming           6.8     161       60 15.6
```

Contiene **.bg-purple_light[estadísticas de arrestos en 1973 (por cada 100 000 habitantes)]** por agresión, asesinato y violación, en cada uno de los 50 estados de Estados Unidos.
]

.panel[.panel-name[Visualizar]

Con `View()` se nos abrirá el conjunto en un formato «excelizado». Además con `head()` podemos **.bg-purple_light[visualizar la cabecera]** (primeras) del conjunto de datos.


```r
head(USArrests)
```

```
&gt;            Murder Assault UrbanPop Rape
&gt; Alabama      13.2     236       58 21.2
&gt; Alaska       10.0     263       48 44.5
&gt; Arizona       8.1     294       80 31.0
&gt; Arkansas      8.8     190       50 19.5
&gt; California    9.0     276       91 40.6
&gt; Colorado      7.9     204       78 38.7
```

]

.panel[.panel-name[Variables]

Con la función `names()` podemos obtener directamente el **.bg-purple_light[nombre de las variables]** (también podemos usarlo para renombrarlas)


```r
names(USArrests)
```

```
&gt; [1] "Murder"   "Assault"  "UrbanPop" "Rape"
```

El conjunto contiene los **3 tipos de delito** mencionados (para cada estado), y además el **porcentaje de población que vive en áreas urbanas**. Esto lo podemos saber ejecutando la ayuda con `? datasets::USArrests`.

]

.panel[.panel-name[Individuos]

Con la función `row.names()` podemos obtener el **.bg-purple_light[nombre de las filas]** (de los estados) para cada uno de ellos.


```r
row.names(USArrests)
```

```
&gt;  [1] "Alabama"        "Alaska"         "Arizona"        "Arkansas"      
&gt;  [5] "California"     "Colorado"       "Connecticut"    "Delaware"      
&gt;  [9] "Florida"        "Georgia"        "Hawaii"         "Idaho"         
&gt; [13] "Illinois"       "Indiana"        "Iowa"           "Kansas"        
&gt; [17] "Kentucky"       "Louisiana"      "Maine"          "Maryland"      
&gt; [21] "Massachusetts"  "Michigan"       "Minnesota"      "Mississippi"   
&gt; [25] "Missouri"       "Montana"        "Nebraska"       "Nevada"        
&gt; [29] "New Hampshire"  "New Jersey"     "New Mexico"     "New York"      
&gt; [33] "North Carolina" "North Dakota"   "Ohio"           "Oklahoma"      
&gt; [37] "Oregon"         "Pennsylvania"   "Rhode Island"   "South Carolina"
&gt; [41] "South Dakota"   "Tennessee"      "Texas"          "Utah"          
&gt; [45] "Vermont"        "Virginia"       "Washington"     "West Virginia" 
&gt; [49] "Wisconsin"      "Wyoming"
```

]


.panel[.panel-name[Dimensiones]

¿Cómo averiguar el **.bg-purple_light[número de registros y el número de variables]**?


```r
dim(USArrests)
```

```
&gt; [1] 50  4
```

```r
nrow(USArrests)
```

```
&gt; [1] 50
```

```r
ncol(USArrests)
```

```
&gt; [1] 4
```

]

.panel[.panel-name[Selección]

Al igual que antes, podemos **.bg-purple_light[seleccionar filas por índices]** y **.bg-purple_light[variables nombre]**.



```r
USArrests[c(2, 10), c("Murder", "Assault")]
```

```
&gt;         Murder Assault
&gt; Alaska    10.0     263
&gt; Georgia   17.4     211
```

También podemos usar las ventajas de los `data.frame` para acceder a las variables.


```r
USArrests$Murder
```

```
&gt;  [1] 13.2 10.0  8.1  8.8  9.0  7.9  3.3  5.9 15.4 17.4  5.3  2.6 10.4  7.2  2.2
&gt; [16]  6.0  9.7 15.4  2.1 11.3  4.4 12.1  2.7 16.1  9.0  6.0  4.3 12.2  2.1  7.4
&gt; [31] 11.4 11.1 13.0  0.8  7.3  6.6  4.9  6.3  3.4 14.4  3.8 13.2 12.7  3.2  2.2
&gt; [46]  8.5  4.0  5.7  2.6  6.8
```

]

.panel[.panel-name[subset]

En el caso de los `data.frame` tenemos además a nuestro disposición una **herramienta muy potente**: la función `subset()`. Dicha función nos va a permitir **.bg-purple_light[seleccionar filas y columnas a la vez]**, tomando de entrada la tabla, `subset = ...` igual a la **condición lógica** para filtrar registros (filas) y `select = ...` igual al  nombre de las columnas que queremos seleccionar.


```r
subset(USArrests, subset = UrbanPop &gt; 70, select = c("Murder"))
```

```
&gt;               Murder
&gt; Arizona          8.1
&gt; California       9.0
&gt; Colorado         7.9
&gt; Connecticut      3.3
&gt; Delaware         5.9
&gt; Florida         15.4
&gt; Hawaii           5.3
&gt; Illinois        10.4
&gt; Massachusetts    4.4
&gt; Michigan        12.1
&gt; Nevada          12.2
&gt; New Jersey       7.4
&gt; New York        11.1
&gt; Ohio             7.3
&gt; Pennsylvania     6.3
&gt; Rhode Island     3.4
&gt; Texas           12.7
&gt; Utah             3.2
&gt; Washington       4.0
```

]

.panel[.panel-name[Caso práctico]

* 📝 **Ejercicio**: filtra aquellos estados cuyo porcentaje de población urbana sea inferior al 70% y donde las agresiones sean superiores a 250 por cada 100 000 habitantes, seleccionando solo las variables.

]

.panel[.panel-name[Caso práctico]

* 📝 **Ejercicio**: filtra aquellos estados cuyo porcentaje de población urbana sea inferior al 70% y donde las agresiones sean superiores a 250 por cada 100 000 habitantes, seleccionando solo las variables.


```r
subset(USArrests, subset = UrbanPop &lt; 70 &amp; Assault &gt; 250,
       select = c("Murder", "Rape"))
```

```
&gt;                Murder Rape
&gt; Alaska           10.0 44.5
&gt; Maryland         11.3 27.8
&gt; Mississippi      16.1 17.1
&gt; North Carolina   13.0 16.1
&gt; South Carolina   14.4 22.5
```

]

]

---

name: tibble

# Mejorando los data.frame: .orange[TIBBLE]
 
Las tablas en formato `tibble` (con `tibble()` del paquete `{tibble}`, su clase será `tbl_df`) son un tipo de `data.frame` mejorado, para una gestión **.bg-purple_light[más ágil, eficiente y coherente]**. Las tablas en formato `tibble` tienen **.bg-purple_light[4 ventajas principales]**

&lt;img src="./img/tibble.svg" width="30%" style="display: block; margin: auto;" /&gt;

---

# Mejorando los data.frame: .orange[TIBBLE]


*  Muestran **.bg-purple_light[metainformación de las variables]**, y solo imprime por defecto las primeras filas.


```r
library(tibble)
tabla_tb &lt;- tibble("x" = 1:50, "y" = rep(c("a", "b", "c", "d", "e"), 10),
                   "logica" = rep(c(TRUE, FALSE), 25))
tabla_tb
```

```
&gt; # A tibble: 50 × 3
&gt;        x y     logica
&gt;    &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; 
&gt;  1     1 a     TRUE  
&gt;  2     2 b     FALSE 
&gt;  3     3 c     TRUE  
&gt;  4     4 d     FALSE 
&gt;  5     5 e     TRUE  
&gt;  6     6 a     FALSE 
&gt;  7     7 b     TRUE  
&gt;  8     8 c     FALSE 
&gt;  9     9 d     TRUE  
&gt; 10    10 e     FALSE 
&gt; # … with 40 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```



---

# Mejorando los data.frame: .orange[TIBBLE]
 
Puedes **imprimir las filas y columnas** que quieras con `print()`


```r
*print(tabla_tb, n = 12, width = Inf)
```

```
&gt; # A tibble: 50 × 3
&gt;        x y     logica
&gt;    &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; 
&gt;  1     1 a     TRUE  
&gt;  2     2 b     FALSE 
&gt;  3     3 c     TRUE  
&gt;  4     4 d     FALSE 
&gt;  5     5 e     TRUE  
&gt;  6     6 a     FALSE 
&gt;  7     7 b     TRUE  
&gt;  8     8 c     FALSE 
&gt;  9     9 d     TRUE  
&gt; 10    10 e     FALSE 
&gt; 11    11 a     TRUE  
&gt; 12    12 b     FALSE 
&gt; # … with 38 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

---

# Mejorando los data.frame: .orange[TIBBLE]
 

* La función `tibble()` **.bg-purple_light[construye las variables secuencialmente]**, pudiendo hacer uso en la propia definición de variables recién definidas en dicha definición.


```r
# data.frame
data.frame("x1" = 1:3, "x2" = 4:6, "y" = x1 * x2)
```

```
&gt; Error in data.frame(x1 = 1:3, x2 = 4:6, y = x1 * x2): objeto 'x1' no encontrado
```


```r
# tibble
tibble("x1" = 1:3, "x2" = 4:6, "y" = x1 * x2)
```

```
&gt; # A tibble: 3 × 3
&gt;      x1    x2     y
&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;
&gt; 1     1     4     4
&gt; 2     2     5    10
&gt; 3     3     6    18
```


---

# Mejorando los data.frame: .orange[TIBBLE]
 
* Si accedes a una **.bg-purple_light[columna que no existe]** avisa con un **.bg-red[warning]**.


```r
tabla_df &lt;- data.frame("x" = 1:50, "y" = rep(c("a", "b", "c", "d", "e"), 10),
                   "logica" = rep(c(TRUE, FALSE), 25))
```

.pull-left[


```r
# data.frame
tabla_df$variable_inexistente
```

```
&gt; NULL
```

]

.pull-right[


```r
# tibble
tabla_tb$variable_inexistente
```

```
&gt; Warning: Unknown or uninitialised column: `variable_inexistente`.
```

```
&gt; NULL
```

]

---


# Mejorando los data.frame: .orange[TIBBLE]

* No solo no te cambiará el tipo de datos sino que **.bg-purple_light[no te cambiará el nombre de las variables]**.

.pull-left[


```r
data.frame(":)" = "emoticono",
           " " = "en blanco",
           "2000" = "número")
```

```
&gt;         X..        X.  X2000
&gt; 1 emoticono en blanco número
```

]

.pull-right[


```r
tibble(":)" = "emoticono",
       " " = "en blanco",
       "2000" = "número")
```

```
&gt; # A tibble: 1 × 3
&gt;   `:)`      ` `       `2000`
&gt;   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt; 
&gt; 1 emoticono en blanco número
```

]

---


# Mejorando los data.frame: .orange[TIBBLE]

Si ya tienes un `data.frame` es altamente recomendable **.bg-purple_light[convertirlo a tibble]** con `as_tibble()` (del paquete `{dplyr}`)


```r
library(dplyr)
as_tibble(USArrests)
```

```
&gt; # A tibble: 50 × 4
&gt;    Murder Assault UrbanPop  Rape
&gt;     &lt;dbl&gt;   &lt;int&gt;    &lt;int&gt; &lt;dbl&gt;
&gt;  1   13.2     236       58  21.2
&gt;  2   10       263       48  44.5
&gt;  3    8.1     294       80  31  
&gt;  4    8.8     190       50  19.5
&gt;  5    9       276       91  40.6
&gt;  6    7.9     204       78  38.7
&gt;  7    3.3     110       77  11.1
&gt;  8    5.9     238       72  15.8
&gt;  9   15.4     335       80  31.9
&gt; 10   17.4     211       60  25.8
&gt; # … with 40 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

Puedes consultar **más funcionalidades** de dichos datos en &lt;https://tibble.tidyverse.org/&gt;

---

# Mejorando los data.frame: .orange[TIBBLE]

Una de las ventajas es la función `glimpse()`, que nos permite obtener el **.bg-purple_light[resumen de columnas]** (no es para tener un resumen de los datos sino para ver las variables que tenemos y su tipo).


```r
glimpse(tabla_tb)
```

```
&gt; Rows: 50
&gt; Columns: 3
&gt; $ x      &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, …
&gt; $ y      &lt;chr&gt; "a", "b", "c", "d", "e", "a", "b", "c", "d", "e", "a", "b", "c"…
&gt; $ logica &lt;lgl&gt; TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE…
```

---

# Mejorando los data.frame: .orange[TIBBLE]

Amén de poder convetir con `as_tibble()` podemos **.bg-purple_light[crearlos por filas]** (como copiar y pegar de una tabla en documento) en lugar de por columnas con `tribble()`


```r
datos &lt;- tribble(
  ~colA, ~colB,
  "a",   1,
  "b",   2)
datos
```

```
&gt; # A tibble: 2 × 2
&gt;   colA   colB
&gt;   &lt;chr&gt; &lt;dbl&gt;
&gt; 1 a         1
&gt; 2 b         2
```

&amp;nbsp;

--

**.bg-green_light[CONSEJO]**: prueba además el paquete `{datapasta}`, que nos permite **.bg-purple_light[copiar y pegar tablas de páginas web]**


---

name: ejercicios-tibble

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: carga del paquete `{datasets}` el conjunto de datos `airquality` (contiene variables de la calidad del aire de la ciudad de Nueva York desde mayo hasta septiembre de 1973). ¿Es el conjunto de datos airquality de tipo tibble? En caso negativo, conviértelo a `tibble`.

* 📝 **Ejercicio 2**: obtén el nombre de las variables y las dimensiones del conjunto de datos. ¿Cuántas variables hay? ¿Cuántos días se han medido?
 
* 📝 **Ejercicio 3**:  modifica el código inferior para que nos filtre solo los datos del mes de agosto.
 

```r
# Filtramos filas
filtro_fila &lt;- subset(., subset = Month &lt; 6)
filtro_fila
```

]

.panel[.panel-name[Solución ej. 1]


```r
library(datasets)
class(airquality) # no es data.frame
```

```
&gt; [1] "data.frame"
```

```r
# Convertimos a tibble
airquality &lt;- as_tibble(airquality)
class(airquality)
```

```
&gt; [1] "tbl_df"     "tbl"        "data.frame"
```

]

.panel[.panel-name[Solución ej. 2]


```r
names(airquality)
```

```
&gt; [1] "Ozone"   "Solar.R" "Wind"    "Temp"    "Month"   "Day"
```

```r
dim(airquality)
```

```
&gt; [1] 153   6
```

```r
# Número variables
ncol(airquality)
```

```
&gt; [1] 6
```

```r
# Número días
nrow(airquality)
```

```
&gt; [1] 153
```

]


.panel[.panel-name[Solución ej. 3]


```r
# Filtramos filas
filtro_fila &lt;- subset(airquality, subset = Month == 8)
filtro_fila
```

```
&gt; # A tibble: 31 × 6
&gt;    Ozone Solar.R  Wind  Temp Month   Day
&gt;    &lt;int&gt;   &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
&gt;  1    39      83   6.9    81     8     1
&gt;  2     9      24  13.8    81     8     2
&gt;  3    16      77   7.4    82     8     3
&gt;  4    78      NA   6.9    86     8     4
&gt;  5    35      NA   7.4    85     8     5
&gt;  6    66      NA   4.6    87     8     6
&gt;  7   122     255   4      89     8     7
&gt;  8    89     229  10.3    90     8     8
&gt;  9   110     207   8      90     8     9
&gt; 10    NA     222   8.6    92     8    10
&gt; # … with 21 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```
]

]

---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 4**: del conjunto selecciona aquellos datos que no sean ni de julio ni de agosto.

* 📝 **Ejercicio 5**: modifica el siguiente código para quedarte solo con las variable de ozono y temperatura.
 

```r
filtro_col &lt;- subset(.,  select = c("Ozone"))
filtro_col
```

* 📝 **Ejercicio 6**:  selecciona los datos de temperatura y viento de agosto. Traduce a castellano el nombre de las columnas del conjunto filtrado.


* 📝 **Ejercicio 7**: añade a los datos originales una columna con la fecha completa (recuerda que es del año 1973 todas las observaciones).

]

.panel[.panel-name[Solución ej. 4]


```r
subset(airquality, subset = !(Month %in% c(7, 8)))
```

```
&gt; # A tibble: 91 × 6
&gt;    Ozone Solar.R  Wind  Temp Month   Day
&gt;    &lt;int&gt;   &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
&gt;  1    41     190   7.4    67     5     1
&gt;  2    36     118   8      72     5     2
&gt;  3    12     149  12.6    74     5     3
&gt;  4    18     313  11.5    62     5     4
&gt;  5    NA      NA  14.3    56     5     5
&gt;  6    28      NA  14.9    66     5     6
&gt;  7    23     299   8.6    65     5     7
&gt;  8    19      99  13.8    59     5     8
&gt;  9     8      19  20.1    61     5     9
&gt; 10    NA     194   8.6    69     5    10
&gt; # … with 81 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

]

.panel[.panel-name[Solución ej. 5]


```r
# Filtramos columnas
filtro_col &lt;- subset(airquality,  select = c("Ozone", "Temp"))
filtro_col
```

```
&gt; # A tibble: 153 × 2
&gt;    Ozone  Temp
&gt;    &lt;int&gt; &lt;int&gt;
&gt;  1    41    67
&gt;  2    36    72
&gt;  3    12    74
&gt;  4    18    62
&gt;  5    NA    56
&gt;  6    28    66
&gt;  7    23    65
&gt;  8    19    59
&gt;  9     8    61
&gt; 10    NA    69
&gt; # … with 143 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

]

.panel[.panel-name[Solución ej. 6]


```r
datos &lt;- subset(airquality, subset = Month == 8, select = c("Temp", "Wind"))
datos 
```

```
&gt; # A tibble: 31 × 2
&gt;     Temp  Wind
&gt;    &lt;int&gt; &lt;dbl&gt;
&gt;  1    81   6.9
&gt;  2    81  13.8
&gt;  3    82   7.4
&gt;  4    86   6.9
&gt;  5    85   7.4
&gt;  6    87   4.6
&gt;  7    89   4  
&gt;  8    90  10.3
&gt;  9    90   8  
&gt; 10    92   8.6
&gt; # … with 21 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

```r
# Traducimos a castellano el nombre
names(datos) &lt;- c("temperatura", "viento")
glimpse(datos)
```

```
&gt; Rows: 31
&gt; Columns: 2
&gt; $ temperatura &lt;int&gt; 81, 81, 82, 86, 85, 87, 89, 90, 90, 92, 86, 86, 82, 80, 79…
&gt; $ viento      &lt;dbl&gt; 6.9, 13.8, 7.4, 6.9, 7.4, 4.6, 4.0, 10.3, 8.0, 8.6, 11.5, …
```

]

.panel[.panel-name[Solución ej. 7]


```r
nuevos_datos &lt;- 
  tibble(airquality, "fecha" = as_date(glue("1973-{Month}-{Day}")))
nuevos_datos
```

```
&gt; # A tibble: 153 × 7
&gt;    Ozone Solar.R  Wind  Temp Month   Day fecha     
&gt;    &lt;int&gt;   &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;date&gt;    
&gt;  1    41     190   7.4    67     5     1 1973-05-01
&gt;  2    36     118   8      72     5     2 1973-05-02
&gt;  3    12     149  12.6    74     5     3 1973-05-03
&gt;  4    18     313  11.5    62     5     4 1973-05-04
&gt;  5    NA      NA  14.3    56     5     5 1973-05-05
&gt;  6    28      NA  14.9    66     5     6 1973-05-06
&gt;  7    23     299   8.6    65     5     7 1973-05-07
&gt;  8    19      99  13.8    59     5     8 1973-05-08
&gt;  9     8      19  20.1    61     5     9 1973-05-09
&gt; 10    NA     194   8.6    69     5    10 1973-05-10
&gt; # … with 143 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

]


]

---

# Ejercicios extras

.panelset[
.panel[.panel-name[Ejercicios extras]


* 📝 **Ejercicio 8**: define un `tibble` con tres variables numéricas `a, b, c`, tal que la tercera sea el producto de las dos primeras `c = a * b`.

* 📝 **Ejercicio 9**:  define un tibble con tres variables de nombres `variable`, `2`, `tercera` y `:)`, e intenta acceder a ellas.
 
* 📝 **Ejercicio 10**:  obten de los paquetes `{dplyr}` y `{gapminder}` los conjuntos de datos `starwars` y `gapminder`. Comprueba el número de variables, de registros e imprime los datos

]

.panel[.panel-name[Solución ej. 8]


```r
tibble("a" = 1:4, "b" = 11:14, "c" = a * b)
```

```
&gt; # A tibble: 4 × 3
&gt;       a     b     c
&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;
&gt; 1     1    11    11
&gt; 2     2    12    24
&gt; 3     3    13    39
&gt; 4     4    14    56
```

]

.panel[.panel-name[Solución ej. 9]


```r
datos &lt;- tibble("variable" = 1, "2" = "a", "tercera" = 3, ":)" = "b")

# Accedemos
datos$variable
```

```
&gt; [1] 1
```

```r
datos$`2`
```

```
&gt; [1] "a"
```

```r
datos$tercera
```

```
&gt; [1] 3
```

```r
datos$`:)`
```

```
&gt; [1] "b"
```

]

.panel[.panel-name[Solución ej. 10]


```r
library(dplyr)
dim(starwars)
```

```
&gt; [1] 87 14
```

```r
library(gapminder)
dim(gapminder)
```

```
&gt; [1] 1704    6
```

]

]

---

name: rmd

# .orange[COMUNICANDO] resultados: archivos .green[.Rmd] 


Una de las principales **.bg-purple_light[fortalezas]** de `R` es la facilidad para generar informes, libros, webs, **.bg-purple_light[apuntes y hasta diapositivas]** (este material por ejemplo).

&amp;nbsp;

Para ello instalaremos antes el paquete `{rmarkdown}` que nos permitirá generar documentos `.Rmd`


```r
install.packages("rmarkdown")
```

---

# .orange[COMUNICANDO] resultados: archivos .green[.Rmd] 

¿Cuál son las **ventajas** de generarlos desde **.bg-purple_light[rmarkdown]**?

--

* Al hacerlo desde `RStudio`, puedes generar un informe o una presentación **.bg-purple_light[sin salirte del entorno]** de programación en el que estás trabajando

--

* Podrás analizar los datos, resumirlos y a la vez **.bg-purple_light[comunicarlos]**. 

--

* Permite **.bg-purple_light[integrar fácilmente código]** `R`, de forma que no solo podremos integrar las salidas de nuestro trabajo sino también el código con el que lo hemos generado.

---

# ¿Qué es .orange[RMARKDOWN]? 


Una herramienta que nos permite crear de forma sencilla **documentos combinando**:

--

* **.bg-purple_light[Markdown]**: creado en 2004 por John Gruber, y de uso libre, es un «lenguaje» que nos permite crear contenido de una manera sencilla de escribir, y que en todo momento mantenga un diseño legible, con algunas de las ventajas de un HTML (si acostumbras a escribir en wordpress o blogs, seguramente hayas escrito de esta forma).

--

* **.bg-green_light[Matemáticas (latex)]**: herramienta (lenguaje en realidad) para escribir notación matemática como `\(x^2\)` o `\(\sqrt{2}\)` (si escribes notación similar en editores de texto, seguramente sin saberlo estés usando ya latex).

--

* **.bg-purple_light[Código]** y salidas de `R`: podremos no solo mostrar el paso final sino el código que has ido realizando, con **cajitas de código** como las del manual.

--

* **.bg-green_light[Imágenes y tablas]**.

--

* **.bg-purple_light[Estilos]** (css, js, etc).

---

# Creando nuestro .orange[PRIMER INFORME] 

.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/file_rmarkdown.jpg" alt="Creando el primer fichero .rmd" width="80%" /&gt;
&lt;p class="caption"&gt;Creando el primer fichero .rmd&lt;/p&gt;
&lt;/div&gt;


]

.pull-right[

Vamos a crear el **.bg-purple_light[primer fichero]** con extensión `.Rmd` (la extensión de los archivos R Markdown).

&amp;nbsp;

Haz click en el botón `File &lt;&lt; New File &lt;&lt; R Markdown`.

]

---

# Creando nuestro .orange[PRIMER INFORME] 

.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/new_rmd.jpg" alt="Creando el primer fichero .rmd" width="80%" /&gt;
&lt;p class="caption"&gt;Creando el primer fichero .rmd&lt;/p&gt;
&lt;/div&gt;


]

.pull-right[

Tras hacerlo, nos aparecerán **.bg-purple_light[varias opciones]**de formatos de salida:

* archivo `.pdf`

* archivo `.html` (**.bg-purple_light[recomendable]**): documento dinámico, permite la interacción con el usuario, como una «página web»)

* archivo `.doc` (nada recomendable)

De momento dejaremos marcado el **.bg-purple_light[formato HTML que viene por defecto]**, y escribiremos el título de nuestro documento. Tras ello tendremos nuestro archivo `.Rmd` (ya no es un script `.R` como los que hemos abierto hasta ahora)

]

---


# Creando nuestro .orange[PRIMER INFORME] 

Un fichero `.Rmd` se divide básicamente en **.bg-purple_light[tres partes]**

1. **.bg-purple_light[Cabecera]**: la parte que tienes al inicio entre `---`.

2.  **.bg-purple_light[Texto]**: que podremos formatear y mejorar con **negritas** (escrito como `**negritas**`, con doble astérisco al inicio y final), _cursivas_ (`_cursivas_`, con barra baja al inicio y final) o destacar nombres de funciones o variables de `R` (con ``R`). Recuerda que puedes añadir además ecuaciones como `\(x^2\)` (he escrito `$x^2$`, la ecuación entre dólares).

3. **.bg-purple_light[Código R]**.

---

# .orange[PRIMER INFORME]: .green[CABECERA]


La cabecera están en formato `YAML`, y contiene los **.bg-purple_light[metadatos del documento]**: título, autor, fecha, estilos (si los tuviésemos), etc. Para probar, vamos a cambiar la cabecera que nos ha generado por defecto de la siguiente forma:


```r
---
title: "Probando Probando"
author: "Señor/a X"
date: "11/7/2014"
output: html_document
---
```

Tras tunear nuestra cabecera borraremos todo lo que viene después para **.bg-purple_light[empezar desde cero]**.

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/rmd_vacio.jpg" alt="Fichero .Rmd vacío, solo con la cabecera" width="27%" /&gt;
&lt;p class="caption"&gt;Fichero .Rmd vacío, solo con la cabecera&lt;/p&gt;
&lt;/div&gt;

---

# .orange[PRIMER INFORME]: .green[TEXTO]

Solo hay una cosa **.bg-purple_light[importante]** a tener en cuenta en este entorno: salvo que indiquemos lo contrario, **.bg-purple_light[TODO lo que vamos a escribir en el documento es texto]**. No código R. Texto plano que podremos mejorar un poco con algun detalle, pero texto.

Vamos a empezar nuestro documento escribiendo por ejemplo la siguiente frase



```r
Este material ha sido diseñado por el profesor Javier Álvarez Liébana,
docente en la Universidad Complutense de Madrid
```

---

# .orange[PRIMER INFORME]: .green[TEXTO]


.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/html_con_texto.jpg" alt="Primer informe html" width="99%" /&gt;
&lt;p class="caption"&gt;Primer informe html&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

Una vez que hemos escrito el texto vamos a **.bg-purple_light[guardar el archivo .Rmd]** haciendo click en el botón `Guardar` (yo he llamado al archivo `primer_rmarkdown.Rmd`). Tras guardar el documento, **.bg-purple_light[«tejeremos» nuestro documento]** haciendo click en el botón `Knit`.

Al «tejer» se nos habrá generado (seguramente en una ventana al margen) un archivo .html, que podemos incluso **.bg-purple_light[abrir en nuestro navegador]**. Hemos creado nuestro primer informe, obviamente vacío de momento. 


]



---

# .orange[PRIMER INFORME]: .green[TEXTO]


.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/rmd_con_formato.jpg" alt="Tuneando nuestro primer informe html" width="99%" /&gt;
&lt;p class="caption"&gt;Tuneando nuestro primer informe html&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

Vamos a **.bg-purple_light[mejorar]** un poco el texto haciendo lo siguiente:

* Vamos a añadir **.bg-purple_light[negrita]** al nombre (poniendo `**` al inicio y al final).

* Vamos añadir _cursiva_ a la palabra `material` (poniendo `_` al inicio y al final).

*  Vamos añadir un enlace `https://www.ucm.es`, asociándolo al nombre de la Universidad. Para ello el título lo ponemos entre corchetes y justo detrás el enlace entre paréntesis `[«Universidad Complutense de Madrid»](https://www.ucm.es)`

]

---


# .orange[PRIMER INFORME]: .green[CHUNKS] de R

Para añadir **.bg-purple_light[código R]** debemos crear nuestras **.bg-purple_light[cajas de código]** llamadas **.bg-orange[chunks]**: altos en el camino en nuestro texto markdown donde podremos incluir **código**. Para incluir uno deberá de ir encabezado de la siguiente forma.

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/chunk_1.jpg" alt="Encabezado/final del chunk" width="90%" /&gt;
&lt;p class="caption"&gt;Encabezado/final del chunk&lt;/p&gt;
&lt;/div&gt;

---

# .orange[PRIMER INFORME]: .green[CHUNKS] de R


Dentro de dicha **.bg-purple_light[cajita]** (que tiene ahora **otro color** en el documento) escribiremos **.bg-purple_light[código R]**, como lo veníamos haciendo hasta ahora. Vamos por ejemplo a **.bg-purple_light[definir dos variables]** y su suma de la siguiente manera, escribiendo dicho código en nuestro `.Rmd` (dentro de ese chunk)

.pull-left[


```r
# Código R
x &lt;- 1
y &lt;- 2
x + y
```

```
&gt; [1] 3
```

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/rmd_3.jpg" alt="Primer chunk con código" width="99%" /&gt;
&lt;p class="caption"&gt;Primer chunk con código&lt;/p&gt;
&lt;/div&gt;

]

---

# .orange[PRIMER INFORME]: .green[CHUNKS] de R

.pull-left[


```r
# Código R
x &lt;- 1
y &lt;- 2
x + y
```

```
&gt; [1] 3
```

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/rmd_3.jpg" alt="Primer chunk con código" width="70%" /&gt;
&lt;p class="caption"&gt;Primer chunk con código&lt;/p&gt;
&lt;/div&gt;

]

Como ves dentro de esos _chunks_ puedes **.bg-purple_light[comentar código]** con `#` (ahora veremos que hace `#` fuera de esas cajas de código). Tras hacerlo tejemos de nuevo y obtenemos ahora un documento que tiene una caja de código y su salida.

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/html_rmd_3.jpg" alt="Salida del html con el primer chunk" width="40%" /&gt;
&lt;p class="caption"&gt;Salida del html con el primer chunk&lt;/p&gt;
&lt;/div&gt;



---

# .orange[PRIMER INFORME]: .green[CHUNKS] de R


Somos capaces de **.bg-purple_light[escribir en un mismo documento texto]** con cierto formato, **.bg-purple_light[código R y la salida]** del resultado, permitiéndonos generar informes (ya veremos como incluir gráficas). De hecho, lo más práctico para **.bg-purple_light[tomar apuntes de R]** es ir anotando en un archivo `.Rmd`.

Los chunks pueden tener un **.bg-purple_light[nombre o etiqueta]**, de forma que podamos referenciarlos de nuevo para no repetir código.

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/chunk_repe_tag.jpg" alt="Etiquetando un chunk y reciclándolo" width="40%" /&gt;
&lt;p class="caption"&gt;Etiquetando un chunk y reciclándolo&lt;/p&gt;
&lt;/div&gt;



---

# .orange[PRIMER INFORME]: .green[ORGANIZANDO]

Con todo incluido en el documento podemos **.bg-purple_light[dividirlo en secciones y subsecciones]**. Para ello usaremos la sintaxis de markdown, poniendo **.bg-purple_light[almohadillas]**: una `#` para secciones, `##` para subsecciones, `###` para subsubsecciones, etc. Por ejemplo, vamos a

* Hacer una sección principal que sea `# Primer informe`
* Tras ello añadiremos la parte de texto.
* Creamos una subsección que se titule `## Chunks de código` donde incluiremos los dos chunks que tenemos hasta ahora.


.pull-left[

&lt;div class="figure" style="text-align: right"&gt;
&lt;img src="./img/secciones_rmd.jpg" alt="Secciones en el rmd" width="80%" /&gt;
&lt;p class="caption"&gt;Secciones en el rmd&lt;/p&gt;
&lt;/div&gt;


]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/secciones_html.jpg" alt="Secciones en el html" width="80%" /&gt;
&lt;p class="caption"&gt;Secciones en el html&lt;/p&gt;
&lt;/div&gt;


]

---


# .orange[PRIMER INFORME]: .green[ORGANIZANDO]

Además podemos incluir tras el título (y entre llaves `{}`) **.bg-purple_light[etiquetas]** (con `{#etiqueta}`) para luego **.bg-purple_light[referenciar dichas secciones]** en el documento.

.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/ref_rmd.jpg" alt="Referencias a secciones y subsecciones" width="75%" /&gt;
&lt;p class="caption"&gt;Referencias a secciones y subsecciones&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

También podemos organizar nuestro código **.bg-purple_light[creando listas]**, usando `*` como ítems.

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/items_rmd.jpg" alt="Creando listas con ítems" width="85%" /&gt;
&lt;p class="caption"&gt;Creando listas con ítems&lt;/p&gt;
&lt;/div&gt;

]

---

# .orange[PRIMER INFORME]: .green[PERSONALIZAR]

En cada chunk aparece una **.bg-purple_light[botón de play]**: pulsándolo podemos tener la **ejecución y salida** de cada chunk en nuestro `.Rmd`, sin tener que esperar a «tejer» (con Knit) todo el documento para ver lo que vamos ejecutando.


.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/play_chunk.jpg" alt="Pulsando al botón play" width="99%" /&gt;
&lt;p class="caption"&gt;Pulsando al botón play&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/chunk_ejecutado.jpg" alt="Chunk ejecutado in-line" width="99%" /&gt;
&lt;p class="caption"&gt;Chunk ejecutado in-line&lt;/p&gt;
&lt;/div&gt;

]

---

# .orange[PRIMER INFORME]: .green[PERSONALIZAR]


Además podemos **.bg-purple_light[incluir código R dentro de la línea de texto]** (en lugar de mostrar el texto x ejecuta el código R mostrando la variable).



.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/codigo_inline_rmd.jpg" alt="Código R inline" width="99%" /&gt;
&lt;p class="caption"&gt;Código R inline&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/codigo_inline_html.jpg" alt="Salida del código in-line" width="99%" /&gt;
&lt;p class="caption"&gt;Salida del código in-line&lt;/p&gt;
&lt;/div&gt;

]

---

# .orange[PRIMER INFORME]: .green[PERSONALIZAR]


Los chunk podemos **.bg-purple_light[personalizar su salida]** con algunas opciones, pasándolos como argumentos dentro de las llaves ({r etiqueta, ...}).

* `include = FALSE`: **.bg-green_light[ejecuta código]** pero **.bg-red_light[no se muestra (ni resultados)]** en la salida.

* `echo = FALSE`: **.bg-green_light[ejecuta código]** y se **.bg-green_light[muestra resultado]** pero **.bg-red_light[no el código]** en la salida.

* `eval = FALSE`: se **.bg-green_light[muestra el código]** pero **.bg-red_light[no se ejecuta]** en la salida final.

* `message = FALSE`: se **.bg-green_light[ejecuta el código]** pero **.bg-red_light[no se muestran mensajes]** de salida que tendríamos en consola.

* `warning = FALSE`: **.bg-green_light[ejecuta código]** pero **.bg-red_light[no se muestran warning]**.

* `error = TRUE`: se **.bg-green_light[ejecuta el código]** pero permite ejecutar el código **.bg-green_light[con errores]** mostrando los mensajes de error.
 
--

Estas opciones podemos aplicarlas chunk a chunk o fijar los parámetros de forma global con `knitr::opts_chunk$set()` (dentro de un chunk), pasándole como argumentos dichas opciones (por ejemplo, `knitr::opts_chunk$set(echo = FALSE)`).

---

# .orange[PRIMER INFORME]: .green[VARIABLES/ECUACIONES]

Por último en este primer documento vamos a añadir una subsección `## Variables y ecuaciones` donde añadiremos un chunk asignando la suma `x + y` a una variable `z`, escribiendo antes en texto el nombre de la variable y la **.bg-purple_light[fórmula]** ($z = x + y$ entre dólares).


.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/variables_rmd.jpg" alt="Añadiendo variables en el .rmd" width="90%" /&gt;
&lt;p class="caption"&gt;Añadiendo variables en el .rmd&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="./img/variables_html.jpg" alt="Añadiendo variables en el .rmd" width="110%" /&gt;
&lt;p class="caption"&gt;Añadiendo variables en el .rmd&lt;/p&gt;
&lt;/div&gt;

]


---

class: inverse center middle
name: clase-5

# CLASE 5: ESTRUCTURAS DE CONTROL.

&amp;nbsp;

### [Estructuras condicionales: if-else](#estructuras-condicionales)

### [Bucles: for, while](#bucles)

### [Replicate. Sample](#replicate)

### [Ejercicios](#ejercicios-5)


---

name: estructuras-condicionales

# Estructuras de control: .orange[IF-ELSE]


Una **.bg-purple_light[expresión de control]** será un conjunto de órdenes que nos permiten **.bg-purple_light[decidir el camino]** por el que queremos que avance nuestro código:

* ¿Qué hacemos si sucede A?

* ¿Y si sucede B?

* ¿Tengo que programar X veces lo mismo si quiere que se repita?

&amp;nbsp;

Si has programado en algún otro lenguaje, estarás familiarizado/a con **.bg-purple_light[estructuras condicionales]** como un `if (blabla) {...} else {...}` (que los usaremos a veces) o **.bg-purple_light[bucles]** `for/while` (que intentaremos evitarlos lo máximo posible).

---

# Estructuras de control: .orange[IF]

Una de las estructuras de control más famosas de cualquier lenguaje de programación es la **.bg-purple_light[estructura condicional]** `if`

&gt; SI las condiciones impuestas se cumplen (TRUE), ejecuta las órdenes que tengamos dentro de la misma.

Por ejemplo, la estructura `if (x == 1) { código A }` lo que hará será **.bg-purple_light[ejecutar el código entre llaves]** pero **.bg-orange[SI Y SOLO SI]** la **.bg-purple_light[condición es cierta]** (en este caso, solo si `x` es igual 1). En **caso contrario, no hace nada**.

--

Definamos por ejemplo una variable sencilla, las edades de 8 personas y comprobemos cuales son menores de edad.


```r
edades &lt;- c(14, 17, 24, 56, 31, 20, 87, 73)
edades &lt; 18
```

```
&gt; [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
```

---

# Estructuras de control: .orange[IF]


Recuerda que con las funciones `any()` y `all()` podemos saber si **.bg-purple_light[todos o alguno de los elementos]** de un vector cumplen una condición.


```r
any(edades &lt; 18) # existe algun menor de edad
```

```
&gt; [1] TRUE
```

--

Con dichos elementos vamos a construir nuestra primera estructura condicional: queremos que, **.bg-purple_light[SI existe algún menor de edad, nos imprima un mensaje]**.


```r
if (any(edades &lt; 18)) { 
  
  print("existe alguna persona mayor de edad")
  
}
```

```
&gt; [1] "existe alguna persona mayor de edad"
```

---

# Estructuras de control: .orange[IF]


```r
if (any(edades &lt; 18)) { 
  
  print("existe alguna persona mayor de edad")
  
}
```


En caso de que **.bg-purple_light[no se cumplan las condiciones]** dentro del `if()` (FALSE), no sucederá nada. 



```r
if (all(edades &gt;= 18)) { 
  
  print("todas las personas son mayores de edad")
  
}
```

Fíjate que en este caso **no hemos obtenido ningún mensaje** porque la condición `all(edades &gt;= 18)` no es cierta (no son todos mayores de 18 años), así que **no ha ejecutado el código**.

---

# Estructuras de control: .orange[IF-ELSE]

La estructura `if (condicion) { }` puede ser combinada con un `else { }`: cuando la **.bg-purple_light[condición no se cumpla]** (como en el último ejemplo), se **.bg-purple_light[ejecutará el código alternativo]** que haya dentro del `else { }`, permitiéndonos decidir que sucede cuando SÍ se cumple y cuando NO se cumple.

--

Por ejemplo, la estructura `if (x == 1) { código A } else { código B }` ejecutará A si `x` es 1 y B en cualquier otro caso.


```r
if (all(edades &gt;= 18)) { 
  
  print("todas las personas son mayores de edad")
  
*} else {
  
  print("existe alguna persona menor de edad")
}
```

```
&gt; [1] "existe alguna persona menor de edad"
```

---

# Estructuras de control: .orange[IF-ELSE]

Dicha estructura `if - else` puede **.bg-purple_light[anidarse]**: imagina que queremos realizar una acción si todos fuesen mayores de edad; en caso contrario, pero si todos los menores tienen 16 años o más, realizar otra acción; en caso contrario, otra acción


```r
if (all(edades &gt;= 18)) { 
  
  print("todas las personas son mayores de edad")
  
} else if (all(edades &gt;= 16)) {
  
  print("Existe alguna persona menor de edad pero todos con 16 años o más")
  
} else { print("Existe alguna persona menor de 16 años") }
```

```
&gt; [1] "Existe alguna persona menor de 16 años"
```

**.bg-green_light[CONSEJO]**: puedes **colapsar las estructuras de control** pulsando en la flecha que aparece a la izquierda de ellas en tu script.


---

# Estructuras de control: .orange[IFELSE()]


Esta estructura condicional puede ser **.bg-purple_light[vectorizada]**: reunir en una sola fila un número elevado de estructuras de comparación con la función `ifelse()`, cuyos argumentos de entrada serán

* la condición a evaluar
* lo que sucede cuando se cumple
* lo que sucede cuando no se cumple

Con el ejemplo de las edades, vamos a dejar el dato ausente si son menores de edad, y si son mayores de edad se queda como está.


```r
# NA si no cumple la condición, la edad si se cumple.
*ifelse(edades &gt;= 18, edades, NA)
```

```
&gt; [1] NA NA 24 56 31 20 87 73
```

---

# Estructuras de control: .orange[IFELSE()]


Todas estas estructuras **.bg-purple_light[no solo sirven para datos numéricos]**. Vamos a definir un vector de nombres con algunos ausentes, y vamos a sustituir los ausentes por el texto `"nombre_desconocido"` (los que no sean ausentes, es decir los que `is.na()` devuelva FALSE, se quedan como están).


```r
nombres &lt;- c("Juan", "María", NA, NA, "Lucía",
             "Carmen", "Javier", NA, "Carlos", 
             NA, "Gregorio", "Paloma")

# Si tiene ausente --&gt; "nombre_desconocido"
# Si no tiene ausente --&gt; nombres originales
nombres &lt;-
  ifelse(is.na(nombres), "nombre_desconocido", nombres)
nombres
```

```
&gt;  [1] "Juan"               "María"              "nombre_desconocido"
&gt;  [4] "nombre_desconocido" "Lucía"              "Carmen"            
&gt;  [7] "Javier"             "nombre_desconocido" "Carlos"            
&gt; [10] "nombre_desconocido" "Gregorio"           "Paloma"
```

---

name: bucles

# Estructuras de control: .orange[BUCLES]

Aunque la mayoría de veces son sustituibles por otras expresiones más legibles y eficientes, es importante que conozcamos otra archiconocida expresion de control: **.bg-purple_light[los bucles]**.

* `for { }`: permite **.bg-purple_light[repetir el mismo código]** un **.bg-orange[número fijo y conocido]** de veces (normalmente en función de un índice).

* `while { }`: permite **.bg-purple_light[repetir el mismo código]** un **.bg-orange[número indeterminado de veces]**, hasta que una **condición** dada se deje de cumplir.

---

# Estructuras de control: .orange[BUCLES FOR]

Un **.bg-purple_light[bucle for]** es una estructura que nos permite **.bg-purple_light[repetir]** un conjunto de órdenes un **.bg-orange[número finito y conocido]** de veces: dado un **conjunto de índices**, el bucle irá recorriendo cada uno de ellos.

Vamos a definir un vector `x`. Si quisiéramos el primer elemento al cuadrado escribiríamos `x[1]^2`; si quisiéramos el segundo elemento al cuadrado `x[2]^2`; si lo quisiéramos hacer en general, para el elemento i-ésimo, `x[i]^2`. Lo que haremos dentro del `for (indices) { órdenes }` es indicarle que valores irá tomando `i` (**.bg-purple_light[vector de índices]**).


```r
x &lt;- c(0, -7, 1, 4)
*for (i in 1:4) {
  
  print(x[i]^2) # órdenes
  
}
```

```
&gt; [1] 0
&gt; [1] 49
&gt; [1] 1
&gt; [1] 16
```

---

# Estructuras de control: .orange[BUCLES FOR]


```r
*for (i in 1:4) {
  print(x[i]^2) # órdenes
}
```

Lo que tenemos dentro de los paréntesis `for ()` no es más que la **.bg-purple_light[secuencia de números]** que hemos aprendido a construir. Si quisiéramos que haga lo mismo pero excluyendo por ejemplo el segundo elemento bastaría con definir los índices a recorrer como `c(1, 3, 4)`.


```r
for (i in c(1, 3, 4)) {
  
  print(x[i]^2) # que lo imprima
  
}
```

```
&gt; [1] 0
&gt; [1] 1
&gt; [1] 16
```

---

# Estructuras de control: .orange[BUCLES FOR]

Podemos definir también una variable `y &lt;- rep(0, 4)` (un **vector «vacío»** lleno de ceros), y hacer que el **.bg-purple_light[elemento i-ésimo del vector]** se defina como `x[i]^2`


```r
y &lt;- rep(0, 4)
for (i in 1:4) {
  
  y[i] &lt;- x[i]^2
  
}
y
```

```
&gt; [1]  0 49  1 16
```

--

Lo anterior es equivalente a esto


```r
y &lt;- x^2
y
```

```
&gt; [1]  0 49  1 16
```

---

# .orange[BUCLES] suelen ser .red[INEFICIENTES]


Haciendo uso del paquete `microbenchmark` podemos comprobar como los **.bg-purple_light[bucles son menos eficientes]** (de ahí que la mayoría de veces los intentemos evitar si existe otra alternativa)


```r
library(microbenchmark)
x &lt;- 1:100
microbenchmark(x^2, 
               for (i in 1:100) { y[i] &lt;- x[i]^2 },
               times = 1000)
```

```
&gt; Unit: nanoseconds
&gt;                                     expr     min      lq        mean  median
&gt;                                      x^2     354     465    1262.828     915
&gt;  for (i in 1:100) {     y[i] &lt;- x[i]^2 } 1692419 1866028 2228493.248 1997654
&gt;         uq      max neval cld
&gt;     1844.5    20210  1000  a 
&gt;  2376439.0 21210528  1000   b
```

---
 
# Estructuras de control: .orange[BUCLES FOR]


Veamos otro ejemplo **.bg-purple_light[combinando vectores numéricos y de caracteres]**: vamos a definir de nuevo un vector de edades y nombres, y vamos a recorrer cada uno imprimiento un mensaje por pantalla.


```r
nombres &lt;- c("Javi", "Laura", "Carlos", "Lucía", "Mar")
edades &lt;- c(33, 51, 18, 43, 29)

# Recorremos cada uno de los 5 elementos e imprimimos un
# mensaje que depende de ese índice i
for (i in 1:5) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} años")) 
  
}
```

```
&gt; Javi tiene 33 años
&gt; Laura tiene 51 años
&gt; Carlos tiene 18 años
&gt; Lucía tiene 43 años
&gt; Mar tiene 29 años
```

---

# Estructuras de control: .orange[BUCLES FOR]

Fíjate que **.bg-purple_light[si no nos queremos preocupar de si añadimos otra persona]**, podemos hacer que el bucle empiece en 1 y termine en el **.bg-purple_light[último lugar]** (sea el que sea), usando `length()`.


```r
for (i in 1:length(nombres)) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} años")) 
  
}
```

```
&gt; Javi tiene 33 años
&gt; Laura tiene 51 años
&gt; Carlos tiene 18 años
&gt; Lucía tiene 43 años
&gt; Mar tiene 29 años
```

---

# Estructuras de control: .orange[BUCLES FOR]

Aunque normalmente el conjunto que recorre el bucle suelen ser índices numéricos, podemos **.bg-purple_light[recorrer cualquier tipo de objeto]**, por ejemplo días e la semana


```r
library(stringr)
dias_semana &lt;- c("lunes", "martes", "miércoles", "jueves",
                 "viernes", "sábado", "domingo")

for (dias in dias_semana) { # dias recorre los días de la semana
  
  print(str_to_upper(dias)) # Imprimimos en mayúsculas el día
}
```

```
&gt; [1] "LUNES"
&gt; [1] "MARTES"
&gt; [1] "MIÉRCOLES"
&gt; [1] "JUEVES"
&gt; [1] "VIERNES"
&gt; [1] "SÁBADO"
&gt; [1] "DOMINGO"
```

---

# Estructuras de control: .orange[BUCLES FOR]

Un último ejemplo: vamos a recorrer nuestro conjunto de datos `swiss` del paquete `{datasets}` y vamos a **pasar a dato ausente** todos los valores de fertilidad superiores a 80. Para ello recorreremos cada fila para después ejecutar un `if`.


```r
for (i in 1:nrow(swiss)) {
  
  # si cumple la condición dicha fila, ponemos ausente.
  if (swiss$Fertility[i] &gt; 80) { 
    
    swiss$Fertility[i] &lt;- NA
    
  }
}
```

--

Esto sería exactamente equivalente al `ifelse()` vectorizado que vimos en el tema anterior


```r
data("swiss") # lo cargamos de 0
swiss$Fertility &lt;- ifelse(swiss$Fertility &gt; 80, NA, swiss$Fertility)
```


---

# Estructuras de control: .orange[BUCLES WHILE]

Otra manera de diseñar un bucle es con la estructura `while { }`, que ejecutará el bucle un **.bg-purple_light[número de veces a priori  desconocido]**, lo hará hasta que la **.bg-purple_light[condición impuesta deje de ser cierta]**. Por ejemplo, vamos a inicializar una variable `ciclos &lt;- 1`, y en cada paso aumentaremos una unidad, y no saldremos del bucle hasta que `ciclos &gt; 4`


```r
ciclos &lt;- 1

# Mientras el número de ciclos sea inferior 4, imprime
while(ciclos &lt;= 4) {
  
  print(paste("Todavía no, vamos por el ciclo ", ciclos)) # Pegamos la frase al número de ciclo por el que vayamos con paste
  ciclos &lt;- ciclos + 1
  
}
```

```
&gt; [1] "Todavía no, vamos por el ciclo  1"
&gt; [1] "Todavía no, vamos por el ciclo  2"
&gt; [1] "Todavía no, vamos por el ciclo  3"
&gt; [1] "Todavía no, vamos por el ciclo  4"
```


---
  
# Estructuras de control: .orange[BUCLES WHILE]


¿Y qué sucede cuando la **.bg-purple_light[condición nunca llega a ser FALSE]**? Compruébalo tú mismo/a.


```r
while (1 &gt; 0) { # Nunca va a dejar de ser cierto
  
  print("Presiona ESC para salir del bucle")
  
}
```

&amp;nbsp;

**.bg-red_light[CUIDADO]**: un bucle `while { }` puede ser muy peligroso sino se controla bien que el bucle acaba en algún momento.

---

# Estructuras de control: .orange[BUCLES WHILE]

Tenemos dos comandos reservados para poder **.bg-purple_light[abortar un bucle o avanzar forzosamente]**:

* `break`: os habilita para **.bg-purple_light[parar un bucle]** aunque no haya llegado al final de su conjunto de índices a recorrer (o se siga cumpliendo la condición).


```r
for(i in 1:10) {
  if (i == 3) {
    
    break # si i es 3, el bucle frena aquí
    
  }
  print(i)
}
```

```
&gt; [1] 1
&gt; [1] 2
```

---

# Estructuras de control: .orange[BUCLES WHILE]

Tenemos dos comandos reservados para poder **.bg-purple_light[abortar un bucle o avanzar forzosamente]**:

* `next`: **.bg-purple_light[obliga al bucle a avanzar]** a la siguiente iteracción, abortando la iteración actual en la que se encuentra. 


```r
for(i in 1:5) {
  if (i == 3) {
    
    next # si i es 3, pasará a la siguiente
    
  }
  print(i)
}
```

```
&gt; [1] 1
&gt; [1] 2
&gt; [1] 4
&gt; [1] 5
```

---

# Estructuras de control: .orange[BUCLES REPEAT]

Aunque es una opción muy poco usada, existe una estructura de control llamada `repeat { }` que nos ejecuta un **.bg-purple_light[bucle de forma infinita hasta que le ordenemos parar]** con un break.


```r
conteo &lt;- 0
repeat { 
  
  conteo &lt;- conteo + 1
  if (conteo &gt;= 100) { break }
  
}
conteo
```

```
&gt; [1] 100
```


---


name: replicate

# Replicando código: .orange[REPLICATE]

Otra forma de **.bg-purple_light[repetir o replicar]** código, al margen de las estructuras de bucle ya vistas, es haciendo uso de `replicate()`, que de momento no lo haremos depender de un índice: simplemente **.bg-purple_light[repetira n veces]** el mismo código.


```r
x &lt;- 1:3
replicate(n = 3, x^2)
```

```
&gt;      [,1] [,2] [,3]
&gt; [1,]    1    1    1
&gt; [2,]    4    4    4
&gt; [3,]    9    9    9
```
          
---

# Simulando muestras: .orange[SAMPLE]

Es habitual que `replicate()` se use conjuntamente con la función `sample()` que nos permitirá **.bg-purple_light[generar muestras aleatorias]** indicando cuál es la **.bg-purple_light[función de probabilidad]** asociada] (generar **«tiradas de dados»** indicando cuál es la **probabilidad** de cada cara).

* `x`: **.bg-purple_light[soporte]** (valores permitidos, caras del dado).
* `size`: **.bg-purple_light[tamaño]** (número de tiradas)
* `replace`: **.bg-purple_light[¿con reemplazamiento?]** (¿puede salir un elemento que ya ha salido?)
* `prob`: **.bg-purple_light[vector de probabilidades]** (probabilidad de cada cara)

--

Por ejempo, vamos a simular **.bg-purple_light[2 tiradas de una moneda]**, indicando el soporte (0 y 1, cara y cruz), y `size = 2`


```r
sample(x = 0:1, size = 2)
```

```
&gt; [1] 1 0
```

**.bg-red_light[IMPORTANTE]**: si no indicamos nada en el vector de probabilidades `prob`, asume que son equiprobables (en este caso, `\(1/2\)` para cada cara).


---

# Simulando muestras: .orange[SAMPLE]

Fíjate que tampoco le hemos indicado nada en `replace`, ya que por defecto toma el valor `FALSE`. ¿Qué sucede si hubiésemos querido generar 10 tiradas de una moneda?


```r
sample(x = 0:1, size = 10)
```

```
&gt; Error in sample.int(length(x), size, replace, prob): cannot take a sample larger than the population when 'replace = FALSE'
```

--

&amp;nbsp;

Dado que solo tenemos 2 posibles valores a elegir, y le hemos pedido 10 tiradas, al llegar a la segunda **.bg-purple_light[no tiene opciones de seguir eligiendo]**. Para poder generarlas deberemos asignar `replace = TRUE` (ahora podrán repetirse las caras).



```r
# 30 tiradas
sample(x = 0:1, size = 30, replace = TRUE)
```

```
&gt;  [1] 1 1 1 0 0 1 0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 1 0 0 1
```

---

# Simulando muestras: .orange[SAMPLE]

El soporte no solo tiene porqué ser numérico, sino que podríamos definir un **.bg-purple_light[soporte de valores de texto]**, de forma que asignemos en los posibles valores directamente `"cara"` y `"cruz"`


```r
sample(x = c("cara", "cruz"), size = 10, replace = TRUE)
```

```
&gt;  [1] "cara" "cruz" "cara" "cruz" "cara" "cara" "cara" "cara" "cara" "cruz"
```

--

El comando `sample()` nos genera **.bg-purple_light[valores (pseudo) aleatorios]**, por lo que si volvemos a ejecutar la misma órden tendremos (seguramente) **.bg-red_light[valores diferentes]**.


```r
sample(x = c("cara", "cruz"), size = 10, replace = TRUE)
```

```
&gt;  [1] "cruz" "cruz" "cara" "cara" "cara" "cruz" "cara" "cruz" "cara" "cara"
```

---

# Simulando muestras: .orange[SAMPLE]

Si quisiéramos generar resultados que no dependiesen de la aleatoriedad de una muestra simulada (por ejemplo, para ver si un método es mejor que otro), tenemos la opción de **.bg-purple_light[fijar semilla]** (valor inicial usado para generar el mecanismo de pseudoaleatoriedad).


```r
set.seed(1234567)
sample(x = c("cara", "cruz"), size = 10, replace = TRUE)
```

```
&gt;  [1] "cara" "cruz" "cruz" "cara" "cruz" "cara" "cara" "cara" "cruz" "cruz"
```



```r
set.seed(1234567)
sample(x = c("cara", "cruz"), size = 10, replace = TRUE)
```

```
&gt;  [1] "cara" "cruz" "cruz" "cara" "cruz" "cara" "cara" "cara" "cruz" "cruz"
```


```r
set.seed(1234567)
sample(x = c("cara", "cruz"), size = 10, replace = TRUE)
```

```
&gt;  [1] "cara" "cruz" "cruz" "cara" "cruz" "cara" "cara" "cara" "cruz" "cruz"
```

---


# Simulando muestras: .orange[SAMPLE]


De esta manera podemos **.bg-purple_light[simular una gran cantidad de datos]** y ver cómo evoluciona por ejemplo la media muestral.

&gt; ¿Cómo hacer uso de un bucle para generar 1 tirada, 2 tiradas, 3 tiradas, ..., 25 tiradas (con `sample()`), y guardar la media de caras?

--


```r
tiradas &lt;- 1:25
media &lt;- rep(0, length(tiradas))

for (i in tiradas) {
  
  tirada &lt;- sample(x = c("cara", "cruz"), size = i, replace = TRUE)
  media[i] &lt;- sum(tirada == "cruz") / i

}
media
```

```
&gt;  [1] 0.0000000 0.5000000 0.3333333 0.7500000 0.6000000 0.8333333 0.1428571
&gt;  [8] 0.5000000 0.5555556 0.5000000 0.3636364 0.7500000 0.6153846 0.4285714
&gt; [15] 0.5333333 0.3750000 0.4705882 0.4444444 0.4210526 0.4500000 0.5238095
&gt; [22] 0.5000000 0.6086957 0.5833333 0.3600000
```

---


# Simulando muestras: .orange[SAMPLE]


Esto nos permite comprobar de primera mano algo muy importante a la hora de simular: nuestra muestra será (seguramente) distinta pero según  **.bg-purple_light[aumenta el tamaño muestral]**, los **.bg-purple_light[parámetros muestrales]** (media, por ejemplo) tenderán a los **.bg-purple_light[parámetros teóricos o poblacionales]** (la media si aumentamos el tamaño debería tender a `\(0.5\)`).



```r
tiradas &lt;- c(1, 5, 10, 15, 25, 50, 100, 500, 1000, 5000,
             10000, 25000, 50000, 100000, 200000, 500000)
media &lt;- rep(0, length(tiradas))

for (i in 1:length(tiradas)) {
  
  tirada &lt;- sample(x = c(0, 1), size = tiradas[i], 
                   replace = TRUE)
  media[i] &lt;- mean(tirada)

}
media
```

```
&gt;  [1] 1.000000 0.200000 0.600000 0.600000 0.440000 0.500000 0.560000 0.490000
&gt;  [9] 0.502000 0.496800 0.491800 0.499960 0.499400 0.499740 0.498540 0.498536
```


Lo anterior se debe al **.bg-purple_light[TEOREMA CENTRAL DEL LÍMITE]**

---

# Simulando muestras: .orange[SAMPLE]

Como has podido ver, aunque el parámetro poblacional tienda al muestral, rara vez será justo igual (dado que `\(n\)` nunca podrá ser infinito en el ordenador). ¿Y si **.bg-purple_light[repetimos]** el experimento de `\(n\)` tiradas `\(m\)` veces? ¿Cuál será la media de las medias obtenidas?

Para ello nos sirve `replicate()`. ¿Se te ocurre cómo, por ejemplo repitiendo `\(m = 1000\)` veces `\(n=10000\)` tiradas?


--


```r
tiradas &lt;- replicate(1000, sample(x = c(0, 1), size = 10000,
                                 replace = TRUE))
dim(tiradas)
```

```
&gt; [1] 10000  1000
```

```r
medias &lt;- apply(tiradas, MARGIN = 2, FUN = mean)
mean(medias)
```

```
&gt; [1] 0.500114
```


---

# Simulando muestras: .orange[SAMPLE]

¿Y si lo hiciésemos con la **.bg-purple_light[varianza]**? Sabemos que la varianza (teórica) debe ser `\(\sigma^2  = 0.25\)` (varianza de una binomial de parámetro `\(p\)` es igual a `\(p^2\)`)

.pull-left[


```r
tirada &lt;- sample(x = c(0, 1), size = 100, replace = TRUE)
mean(tirada^2) - mean(tirada)^2
```

```
&gt; [1] 0.2451
```

```r
tirada &lt;- sample(x = c(0, 1), size = 100, replace = TRUE)
mean(tirada^2) - mean(tirada)^2
```

```
&gt; [1] 0.2484
```

]

.pull-right[


```r
tirada &lt;- sample(x = c(0, 1), size = 100, replace = TRUE)
mean(tirada^2) - mean(tirada)^2
```

```
&gt; [1] 0.2475
```

```r
tirada &lt;- sample(x = c(0, 1), size = 100, replace = TRUE)
mean(tirada^2) - mean(tirada)^2
```

```
&gt; [1] 0.2496
```

]

Parece como si siempre se **quedase un poco por debajo**, de forma sistemática (con un sesgo), de forma que la media también quedará por debajo.

--

Un estimador (muestral) `\(T\)` de un parámetro poblacional se dice **.bg-purple_light[ESTIMADOR INSESGADO]** si cumple que la media (esperanza) `\(E[T]\)` es igual a dicho parámetro.


---

name: ejercicios-5

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: modifica el código inferior para imprimir un mensaje por pantalla si todos los datos del conjunto `airquality` son de meses que no sean enero.


```r
# install.packages("dataset") # solo la primera vez
library(datasets) # paquete con los datos
mes &lt;- airquality$Month

if (mes == 2) {
  
  print("Ningún dato es del mes de enero")
  
}
```

]

.panel[.panel-name[Solución ej. 1]

* 📝 **Ejercicio 1**: modifica el código inferior para imprimir un mensaje por pantalla si todos los datos del conjunto `airquality` son de meses que no sean enero.


```r
# install.packages("dataset") # solo la primera vez
library(datasets) # paquete con los datos
mes &lt;- airquality$Month

if (all(mes != 1)) {
  
  print("Ningún dato es del mes de enero")
  
}
```

```
&gt; [1] "Ningún dato es del mes de enero"
```

]

]


---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]

* 📝 **Ejercicio 2**: modifica el código inferior para guardar en una variable llamada `temperatura_alta` un valor `TRUE` si alguno de los registros tiene una temperatura mayor a 90 (están en Farenheit) y un `FALSE` en caso contrario.
 

```r
temperatura &lt;- airquality$Temp

if (temperatura == 100) {
  
  print("Alguno de los registros tiene temperatura superior a 90 Farenheit")
  
}
```

]

.panel[.panel-name[Solución ej. 2]

* 📝 **Ejercicio 2**: modifica el código inferior para guardar en una variable llamada `temperatura_alta` un valor `TRUE` si alguno de los registros tiene una temperatura mayor a 90 (están en Farenheit) y un `FALSE` en caso contrario.
 

```r
# Opción 1
temperatura &lt;- airquality$Temp
temperatura_alta &lt;- FALSE
if (any(temperatura &gt; 90)) {
  
   temperatura_alta &lt;- TRUE
  
}

# Opción 2
temperatura_alta &lt;- any(airquality$Temp &gt; 90)
```


]

]

---


# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]

* 📝 **Ejercicio 3**: modifica el código inferior para diseñar un bucle `for` de 5 iteraciones que recorra los 5 primeros impares y les sume uno.


```r
for (i in 1:5) {
  
  print(i)
}
```

* 📝 **Ejercicio 4**: modifica el código inferior para diseñar un bucle `while` que parta con una variable `conteo &lt;- 1` y pare cuando llegue a 6.


```r
conteo &lt;- 1
while (conteo == 2) {
  
  print(conteo)
}
```

]

.panel[.panel-name[Solución ej. 3]

* 📝 **Ejercicio 3**: modifica el código inferior para diseñar un bucle `for` de 5 iteraciones que recorra los 5 primeros impares y les sume uno.


```r
for (i in c(1, 3, 5, 7, 9)) {
  
  print(i + 1)
}
```

```
&gt; [1] 2
&gt; [1] 4
&gt; [1] 6
&gt; [1] 8
&gt; [1] 10
```

]

.panel[.panel-name[Solución ej. 4]

* 📝 **Ejercicio 4**: modifica el código inferior para diseñar un bucle `while` que parta con una variable `conteo &lt;- 1` y pare cuando llegue a 6.


```r
conteo &lt;- 1
while (conteo &lt; 6) {
  
  print(conteo)
  conteo &lt;- conteo + 1
  
}
```

```
&gt; [1] 1
&gt; [1] 2
&gt; [1] 3
&gt; [1] 4
&gt; [1] 5
```

]

]

---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]

* 📝 **Ejercicio 5**: diseña un bucle `for` de 200 iteraciones que, empezando en un valor inicial de 100 (euros), te sume 3€ (actualizando el valor) si el número actual de la iteración es par, y te reste 5€ si es impar (investiga la función `%%`).

* 📝 **Ejercicio 6**: diseña el anterior bucle pero guardando el dinero de cada iteración en alguna variable
 

* 📝 **Ejercicio 7**: diseña el bucle del ejercicio 5 pero parando cuando no nos quede dinero.

* 📝 **Ejercicio 8**: haciendo uso de `sample()`, simula la tirada de 100 dados (cada uno de 6 caras), pero de forma que el dado esté trucado, y calcula la media de las tiradas.

* 📝 **Ejercicio 9**: repite el ejercicio anterior para 1,2,...,200 dados (haz uso de un `for()`), y guarda la media de las tiradas en cada caso.

]

.panel[.panel-name[Sol. ej. 5]

Un número par será todo aquel número que al dividir entre 2, la división es exacta, es decir, que su resto es nulo. Para calcular ese resto usaremos la función `%%`.



```r
# dinero inicial
dinero &lt;- 100

for (i in 1:200) {
  
  dinero &lt;- ifelse(i %% 2 == 0, dinero + 3, dinero  - 5)
  
}
dinero
```

```
&gt; [1] -100
```

]

.panel[.panel-name[Sol. ej. 6]


```r
# vector inicial de importes
dinero &lt;- rep(0, 201)
dinero[1] &lt;- 100 # dinero inicial

# Bucle for
for (i in 2:201) {
  
  # si i es par o  impar
  dinero[i] &lt;- ifelse(i %% 2 == 0, dinero[i - 1] + 3,
                      dinero[i - 1]  - 5)
  
}
dinero
```

```
&gt;   [1]  100  103   98  101   96   99   94   97   92   95   90   93   88   91   86
&gt;  [16]   89   84   87   82   85   80   83   78   81   76   79   74   77   72   75
&gt;  [31]   70   73   68   71   66   69   64   67   62   65   60   63   58   61   56
&gt;  [46]   59   54   57   52   55   50   53   48   51   46   49   44   47   42   45
&gt;  [61]   40   43   38   41   36   39   34   37   32   35   30   33   28   31   26
&gt;  [76]   29   24   27   22   25   20   23   18   21   16   19   14   17   12   15
&gt;  [91]   10   13    8   11    6    9    4    7    2    5    0    3   -2    1   -4
&gt; [106]   -1   -6   -3   -8   -5  -10   -7  -12   -9  -14  -11  -16  -13  -18  -15
&gt; [121]  -20  -17  -22  -19  -24  -21  -26  -23  -28  -25  -30  -27  -32  -29  -34
&gt; [136]  -31  -36  -33  -38  -35  -40  -37  -42  -39  -44  -41  -46  -43  -48  -45
&gt; [151]  -50  -47  -52  -49  -54  -51  -56  -53  -58  -55  -60  -57  -62  -59  -64
&gt; [166]  -61  -66  -63  -68  -65  -70  -67  -72  -69  -74  -71  -76  -73  -78  -75
&gt; [181]  -80  -77  -82  -79  -84  -81  -86  -83  -88  -85  -90  -87  -92  -89  -94
&gt; [196]  -91  -96  -93  -98  -95 -100
```

]

.panel[.panel-name[Sol. ej. 7]


```r
dinero &lt;- 100 # dinero inicial

# Bucle while
while (dinero &gt; 0) {
  
  dinero &lt;- ifelse(i %% 2 == 0, dinero + 3, dinero - 5)
  
}
dinero
```

```
&gt; [1] 0
```

]

.panel[.panel-name[Sol. ej. 8]


* 📝 **Ejercicio 8**: haciendo uso de `sample()`, simula la tirada de 100 dados (cada uno de 6 caras), pero de forma que el dado esté trucado (decide tú cómo), y calcula la media de las tiradas.


```r
# dado sin trucar
tiradas &lt;- sample(x = 1:6, size = 100, replace = TRUE)
mean(tiradas)
```

```
&gt; [1] 3.54
```

```r
# dado trucado (por ejemplo 1/2 la primera cara)
tiradas &lt;-
  sample(x = 1:6, size = 100, replace = TRUE,
         prob = c(1/2, 1/10, 1/10, 1/10, 1/10, 1/10))
mean(tiradas)
```

```
&gt; [1] 2.33
```

]

.panel[.panel-name[Sol. ej. 9]


* 📝 **Ejercicio 9**: repite el ejercicio anterior para 1,2,...,200 dados (haz uso de un `for()`), y guarda la media de las tiradas en cada caso.


```r
medias &lt;- rep(0, 200)
for (i in 1:200) {
  
  medias[i] &lt;-
    mean(sample(x = 1:6, size = i, replace = TRUE))
}
medias
```

```
&gt;   [1] 3.000000 5.000000 4.000000 2.750000 2.800000 3.500000 4.428571 4.000000
&gt;   [9] 3.888889 3.600000 3.272727 3.416667 3.538462 3.785714 3.800000 2.875000
&gt;  [17] 3.117647 3.555556 3.684211 3.500000 3.095238 3.090909 2.652174 3.666667
&gt;  [25] 3.240000 3.807692 3.703704 3.107143 3.689655 3.266667 3.612903 3.593750
&gt;  [33] 3.575758 3.441176 3.257143 4.055556 3.783784 3.263158 3.717949 3.550000
&gt;  [41] 3.243902 3.000000 4.023256 3.363636 3.466667 3.369565 3.787234 3.500000
&gt;  [49] 3.612245 3.140000 3.607843 3.961538 3.245283 3.740741 3.727273 3.767857
&gt;  [57] 2.982456 3.310345 3.898305 3.650000 3.098361 3.612903 3.730159 3.375000
&gt;  [65] 3.723077 3.666667 3.522388 3.235294 3.449275 3.328571 3.619718 4.083333
&gt;  [73] 3.424658 3.310811 3.373333 3.434211 3.532468 3.538462 3.518987 3.525000
&gt;  [81] 3.716049 3.475610 3.530120 3.357143 3.705882 3.697674 3.804598 3.727273
&gt;  [89] 3.089888 3.544444 3.549451 3.619565 3.462366 3.553191 3.515789 3.260417
&gt;  [97] 3.402062 3.367347 3.565657 3.490000 3.623762 3.333333 3.398058 3.490385
&gt; [105] 3.419048 3.547170 3.504673 3.435185 3.577982 3.390909 3.396396 3.625000
&gt; [113] 3.283186 3.254386 3.695652 3.318966 3.401709 3.474576 3.285714 3.725000
&gt; [121] 3.504132 3.754098 3.560976 3.653226 3.560000 3.658730 3.456693 3.476562
&gt; [129] 3.279070 3.415385 3.519084 3.477273 3.451128 3.582090 3.362963 3.308824
&gt; [137] 3.233577 3.623188 3.539568 3.492857 3.843972 3.366197 3.566434 3.583333
&gt; [145] 3.682759 3.328767 3.476190 3.554054 3.651007 3.800000 3.562914 3.328947
&gt; [153] 3.450980 3.487013 3.393548 3.352564 3.407643 3.613924 3.566038 3.506250
&gt; [161] 3.670807 3.487654 3.374233 3.506098 3.636364 3.445783 3.473054 3.440476
&gt; [169] 3.242604 3.711765 3.508772 3.558140 3.341040 3.264368 3.548571 3.761364
&gt; [177] 3.491525 3.348315 3.329609 3.538889 3.464088 3.489011 3.754098 3.418478
&gt; [185] 3.529730 3.510753 3.491979 3.436170 3.343915 3.505263 3.502618 3.453125
&gt; [193] 3.611399 3.376289 3.558974 3.571429 3.492386 3.303030 3.472362 3.515000
```


]

]


---

class: inverse center middle
name: clase-6

# CLASE 6: TIDYDATA. ENTREGA I

&amp;nbsp;

### [Tidydata: datos limpios](#tidydata)

### [Entrega I](#entrega-I)

---

name: tidydata

# Datos limpios: .orange[TIDY DATA]

.pull-left[

&lt;img src="./img/tidyverrse_universe.jpg" width="99%" style="display: block; margin: auto;" /&gt;

]

.pull-right[
&lt;img src="./img/flow_tidyverse.jpg" width="99%" style="display: block; margin: auto;" /&gt;
]

Universo de **.bg-purple_light[paquetes tidyverse]**: un conjunto de paquetes para un flujo de **trabajo eficiente, coherente y lexicográficamente** sencillo de entender.

---

# Datos limpios: .orange[TIDY DATA]

&gt; Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

Hasta ahora solo le hemos dado importancia al «qué» pero no al **.bg-purple_light[«cómo» manejamos los datos]**. La organización de nuestros datos es fundamental para que su **.bg-purple_light[preparación y explotación]** sea lo más eficiente posible.

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/tidy_flow.jpg" alt="Flujo deseable de datos según Hadley Wickham, extraída de https://r4ds.had.co.nz/wrangle-intro.html" width="60%" /&gt;
&lt;p class="caption"&gt;Flujo deseable de datos según Hadley Wickham, extraída de https://r4ds.had.co.nz/wrangle-intro.html&lt;/p&gt;
&lt;/div&gt;


---

# Datos limpios: .orange[TIDY DATA]

El concepto **.bg-purple_light[tidy data]** fue introducido por **Hadley Wickham** (Wickham, 2014) como el primer paso de un flujo de trabajo eficiente. Para ello haremos uso del paquete `{tidyr}` (dentro de `{tidyverse}`) que nos proporciona herramientas eficientes y sencillaspara su manejo.

--

&amp;nbsp;

Los **.bg-purple_light[conjuntos tidy u ordenados]** tienen tres objetivos

* **.bg-orange[Estandarización]** en su estructura para una depuración y análisis eficiente.
* **.bg-orange[Sencillez]** en su manipulación.
* Listos para ser **.bg-orange[modelizados y visualizados]**.

&amp;nbsp;

📚 Ver Wickham (2014) en **.bg-green_light[bibliografía]** en &lt;https://github.com/dadosdelaplace/teaching/tree/main/bioestad/biblio&gt;

---

# Datos limpios: .orange[TIDY DATA]



.pull-left[

Los **.bg-purple_light[datos ordenados o tidy data]** deben cumplir:

1. Cada **.bg-green_light[variable en una columna]**.

2. Cada **.bg-orange[observación/individuo en una fila]** diferente.

3. Cada **.bg-green_light[celda con un único valor]**.

4. Cada **.bg-orange[conjunto en un tibble]** (tabla).

5. Si usamos múltiples tablas a la vez debemos tener una **.bg-green_light[columna común para poder cruzarlas]**.

]

.pull-right[

&lt;img src="./img/tidy_def.jpg" width="85%" style="display: block; margin: auto;" /&gt;

&amp;nbsp;

&lt;img src="./img/tidyr_1.jpg" width="50%" style="display: block; margin: auto;" /&gt;


]


---

# Tubería .orange[PIPE]

En este entorno de trabajo tendremos un **.bg-purple_light[operador clave]**: el **.bg-purple_light[operador pipeline]** `%&gt;%` (podemos usar el atajo con `ctrl+shift+M` o `command+shift+M`). Dicho operador lo debemos interpretar como una **.bg-purple_light[tubería]** que va pasando por los datos y los va transformando.

--

Por ejemplo, si tuviésemos tres funciones `first()`, `second()` y `third()`, la opción más inmediata sería anidar las tres funciones tal que `third(second(first(x)))`, algo que dificulta la lectura posterior del código

--

Con `%&gt;%` podremos escribir (y leer) la concetanción de acciones como una **.bg-purple_light[tubería de izquierda a derecha]**:


```r
first(x) %&gt;% second(x) %&gt;% third(x)
```

--

Dicho operador viene del paquete `{magrittr}`. Para **evitar esta dependencia** (cuantos menos paquetes tengamos que cargar, mejor), desde la versión 4.1.0 de R, disponemos de un pipeline nativo de R, el **operador** `|&gt;` (disponible además fuera del entorno tidyverse).

---

# Tubería .orange[PIPE]

.pull-left[


```r
datos %&gt;%
  limpio(...) %&gt;%
  selecciono(...) %&gt;%
  filtro(...) %&gt;%
  ordeno(...) %&gt;%
  agrupo(...) %&gt;%
  cuento(...) %&gt;%
  resumo(...) %&gt;% 
  pinto(...)
```


```r
datos |&gt;
  limpio(...) |&gt;
  selecciono(...) |&gt;
  filtro(...) |&gt;
  ordeno(...) |&gt;
  agrupo(...) |&gt;
  cuento(...) |&gt;
  resumo(...) |&gt;
  pinto(...)
```

]

.pull-right[

&lt;img src="./img/tuberia.jpg" width="90%" style="display: block; margin: auto;" /&gt;

]

---

# Datos .orange[SUCIOS]: messy data

Por ejemplo, vamos a cargar la tabla `table4a` del paquete `{tidyr}` (que ya lo tenemos cargado del entorno `{tidyverse}`).




```r
table4a
```

```
&gt; # A tibble: 3 × 3
&gt;   country     `1999` `2000`
&gt; * &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;
&gt; 1 Afghanistan    745   2666
&gt; 2 Brazil       37737  80488
&gt; 3 China       212258 213766
```

**.bg-purple_light[¿Qué falla?]**

---


# Datos .orange[SUCIOS]: messy data

.pull-left[




```r
table4a
```

```
&gt; # A tibble: 3 × 3
&gt;   country     `1999` `2000`
&gt; * &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;
&gt; 1 Afghanistan    745   2666
&gt; 2 Brazil       37737  80488
&gt; 3 China       212258 213766
```

**.bg-purple_light[¿Qué falla?]**

]

.pull-right[


❎ Cada **.bg-green_light[variable en una columna]**.

❎ Cada **.bg-orange[observación/individuo en una fila]** diferente.

❎ Cada **.bg-green_light[celda con un único valor]**.

]

Aunque la columna `$country` representa una variable, las otras columnas no: **.bg-purple_light[ambas son la misma variable]**, solo que medida en años distintos (que debería ser a su vez otra variable), de forma que **.bg-purple_light[cada fila está representando dos observaciones]** (1999, 2000).


---

# Datos .orange[SUCIOS]: messy data


.pull-left[

Lo que haremos será incluir una nueva columna llamada (por ejemplo) `year` que nos marque el año y otra llamada `cases` que nos diga el valor de la variable de interés en cada uno de esos años.

]

.pull-right[

&lt;img src="./img/table4a.jpg" width="65%" style="display: block; margin: auto;" /&gt;


]

--

Con la función `pivot_longer()` pivotaremos la tabla para pasarla a **formato long**:


```r
table4a %&gt;%
* pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```

```
&gt; # A tibble: 6 × 3
&gt;   country     year   cases
&gt;   &lt;chr&gt;       &lt;chr&gt;  &lt;int&gt;
&gt; 1 Afghanistan 1999     745
&gt; 2 Afghanistan 2000    2666
&gt; 3 Brazil      1999   37737
&gt; 4 Brazil      2000   80488
&gt; 5 China       1999  212258
&gt; 6 China       2000  213766
```

---

# Datos .orange[SUCIOS]: messy data

.pull-left[


```r
table4a %&gt;%
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year", 
*              values_to = "cases")
```

```
&gt; # A tibble: 6 × 3
&gt;   country     year   cases
&gt;   &lt;chr&gt;       &lt;chr&gt;  &lt;int&gt;
&gt; 1 Afghanistan 1999     745
&gt; 2 Afghanistan 2000    2666
&gt; 3 Brazil      1999   37737
&gt; 4 Brazil      2000   80488
&gt; 5 China       1999  212258
&gt; 6 China       2000  213766
```

]

.pull-right[

&lt;img src="./img/table4a_2.png" width="99%" style="display: block; margin: auto;" /&gt;


]


* `cols`: el **.bg-purple_light[nombre de las columnas a pivotar]** (con comillas por ser números y no caracteres).
* `names_to`: el **.bg-purple_light[nombre de la nueva columna]** a la mandamos los **.bg-purple_light[nombres]** de las columnas.
* `values_to`: el **.bg-purple_light[nombre de la nueva columna]** a la que vamos a mandar los **.bg-purple_light[datos]**.


---

# Datos .orange[SUCIOS]: messy data


.panelset[
.panel[.panel-name[table4b]

Echa un vistazo a la tabla `{table4b}`


```r
table4b
```

```
&gt; # A tibble: 3 × 3
&gt;   country         `1999`     `2000`
&gt; * &lt;chr&gt;            &lt;int&gt;      &lt;int&gt;
&gt; 1 Afghanistan   19987071   20595360
&gt; 2 Brazil       172006362  174504898
&gt; 3 China       1272915272 1280428583
```

**.bg-purple_light[TODO TUYO]**: ¿es tidy o messy? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?

]

.panel[.panel-name[Solución]


```r
table4b %&gt;% pivot_longer(cols = "1999":"2000",
                         names_to = "year",
                         values_to = "cases")
```

```
&gt; # A tibble: 6 × 3
&gt;   country     year       cases
&gt;   &lt;chr&gt;       &lt;chr&gt;      &lt;int&gt;
&gt; 1 Afghanistan 1999    19987071
&gt; 2 Afghanistan 2000    20595360
&gt; 3 Brazil      1999   172006362
&gt; 4 Brazil      2000   174504898
&gt; 5 China       1999  1272915272
&gt; 6 China       2000  1280428583
```

]

]



---

# Datos .orange[SUCIOS]: messy data

.panelset[
.panel[.panel-name[relig_income]


Echa un vistazo a la tabla `{relig_income}`


```r
relig_income
```

```
&gt; # A tibble: 18 × 11
&gt;    religion      `&lt;$10k` $10-2…¹ $20-3…² $30-4…³ $40-5…⁴ $50-7…⁵ $75-1…⁶ $100-…⁷
&gt;    &lt;chr&gt;           &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
&gt;  1 Agnostic           27      34      60      81      76     137     122     109
&gt;  2 Atheist            12      27      37      52      35      70      73      59
&gt;  3 Buddhist           27      21      30      34      33      58      62      39
&gt;  4 Catholic          418     617     732     670     638    1116     949     792
&gt;  5 Don’t know/r…      15      14      15      11      10      35      21      17
&gt;  6 Evangelical …     575     869    1064     982     881    1486     949     723
&gt;  7 Hindu               1       9       7       9      11      34      47      48
&gt;  8 Historically…     228     244     236     238     197     223     131      81
&gt;  9 Jehovah's Wi…      20      27      24      24      21      30      15      11
&gt; 10 Jewish             19      19      25      25      30      95      69      87
&gt; 11 Mainline Prot     289     495     619     655     651    1107     939     753
&gt; 12 Mormon             29      40      48      51      56     112      85      49
&gt; 13 Muslim              6       7       9      10       9      23      16       8
&gt; 14 Orthodox           13      17      23      32      32      47      38      42
&gt; 15 Other Christ…       9       7      11      13      13      14      18      14
&gt; 16 Other Faiths       20      33      40      46      49      63      46      40
&gt; 17 Other World …       5       2       3       4       2       7       3       4
&gt; 18 Unaffiliated      217     299     374     365     341     528     407     321
&gt; # … with 2 more variables: `&gt;150k` &lt;dbl&gt;, `Don't know/refused` &lt;dbl&gt;, and
&gt; #   abbreviated variable names ¹​`$10-20k`, ²​`$20-30k`, ³​`$30-40k`, ⁴​`$40-50k`,
&gt; #   ⁵​`$50-75k`, ⁶​`$75-100k`, ⁷​`$100-150k`
&gt; # ℹ Use `colnames()` to see all variable names
```

**.bg-purple_light[TODO TUYO]**: ¿es tidy o messy? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?

]

.panel[.panel-name[Solución]


```r
relig_income %&gt;%
  pivot_longer(cols = "&lt;$10k":"Don't know/refused",
               names_to = "income",
               values_to = "people")
```

```
&gt; # A tibble: 180 × 3
&gt;    religion income             people
&gt;    &lt;chr&gt;    &lt;chr&gt;               &lt;dbl&gt;
&gt;  1 Agnostic &lt;$10k                  27
&gt;  2 Agnostic $10-20k                34
&gt;  3 Agnostic $20-30k                60
&gt;  4 Agnostic $30-40k                81
&gt;  5 Agnostic $40-50k                76
&gt;  6 Agnostic $50-75k               137
&gt;  7 Agnostic $75-100k              122
&gt;  8 Agnostic $100-150k             109
&gt;  9 Agnostic &gt;150k                  84
&gt; 10 Agnostic Don't know/refused     96
&gt; # … with 170 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

]
]


---

# Datos .orange[SUCIOS]: messy data

Veamos un segundo tipo de dato sucio: vamos a cargar la tabla `table2` del paquete `{tidyr}` (que ya lo tenemos cargado del entorno `{tidyverse}`). **.bg-purple_light[¿Qué falla?]**



```r
table2
```

```
&gt; # A tibble: 12 × 4
&gt;    country      year type            count
&gt;    &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;           &lt;int&gt;
&gt;  1 Afghanistan  1999 cases             745
&gt;  2 Afghanistan  1999 population   19987071
&gt;  3 Afghanistan  2000 cases            2666
&gt;  4 Afghanistan  2000 population   20595360
&gt;  5 Brazil       1999 cases           37737
&gt;  6 Brazil       1999 population  172006362
&gt;  7 Brazil       2000 cases           80488
&gt;  8 Brazil       2000 population  174504898
&gt;  9 China        1999 cases          212258
&gt; 10 China        1999 population 1272915272
&gt; 11 China        2000 cases          213766
&gt; 12 China        2000 population 1280428583
```


---

# Datos .orange[SUCIOS]: messy data

.pull-left[



```r
head(table2)
```

```
&gt; # A tibble: 6 × 4
&gt;   country      year type           count
&gt;   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;          &lt;int&gt;
&gt; 1 Afghanistan  1999 cases            745
&gt; 2 Afghanistan  1999 population  19987071
&gt; 3 Afghanistan  2000 cases           2666
&gt; 4 Afghanistan  2000 population  20595360
&gt; 5 Brazil       1999 cases          37737
&gt; 6 Brazil       1999 population 172006362
```

]

.pull-right[


&lt;img src="./img/table2.jpg" width="69%" style="display: block; margin: auto;" /&gt;
]


❎ Cada **.bg-orange[observación/individuo en una fila]** diferente.


Fíjate en las cuatro primeras filas: los registros con el mismo año deberían ser el mismo, es la misma información, **.bg-purple_light[debería estar en la misma fila]**, pero está dividada en dos. 

---


# Datos .orange[SUCIOS]: messy data

Lo que haremos será lo opuesto a antes: con `pivot_wider()` «ampliaremos» la **.bg-purple_light[tabla a lo ancho]**, con menos filas pero con más columnas.


```r
table2 %&gt;%
* pivot_wider(names_from = type, values_from = count)
```

```
&gt; # A tibble: 6 × 4
&gt;   country      year  cases population
&gt;   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
&gt; 1 Afghanistan  1999    745   19987071
&gt; 2 Afghanistan  2000   2666   20595360
&gt; 3 Brazil       1999  37737  172006362
&gt; 4 Brazil       2000  80488  174504898
&gt; 5 China        1999 212258 1272915272
&gt; 6 China        2000 213766 1280428583
```

* `names_from`: el **.bg-purple_light[nombre de la columna original]** de la que vamos a sacar las **.bg-purple_light[nuevas columnas]** que vamos a crear (`cases` y `population`).
* `values_from`: el **.bg-purple_light[nombre de la columna orignal]** de la que vamos a sacar los **.bg-purple_light[datos]**.


---

# Datos .orange[SUCIOS]: messy data


Por último veamos un tercer tipo de dato sucio: vamos a cargar la tabla `table3` del paquete `{tidyr}` (que ya lo tenemos cargado del entorno `{tidyverse}`). **.bg-purple_light[¿Qué falla?]**



```r
table3
```

```
&gt; # A tibble: 6 × 3
&gt;   country      year rate             
&gt; * &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;            
&gt; 1 Afghanistan  1999 745/19987071     
&gt; 2 Afghanistan  2000 2666/20595360    
&gt; 3 Brazil       1999 37737/172006362  
&gt; 4 Brazil       2000 80488/174504898  
&gt; 5 China        1999 212258/1272915272
&gt; 6 China        2000 213766/1280428583
```

--

❎ Cada **.bg-green_light[celda con un único valor]**.


---

# Datos .orange[SUCIOS]: messy data

Lo que haremos será hacer uso de la función `separate()` para mandar **.bg-purple_light[cada valor a una columna diferente]**.


```r
table3 %&gt;%
* separate(rate, into = c("cases", "pop"))
```

```
&gt; # A tibble: 6 × 4
&gt;   country      year cases  pop       
&gt;   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     
&gt; 1 Afghanistan  1999 745    19987071  
&gt; 2 Afghanistan  2000 2666   20595360  
&gt; 3 Brazil       1999 37737  172006362 
&gt; 4 Brazil       2000 80488  174504898 
&gt; 5 China        1999 212258 1272915272
&gt; 6 China        2000 213766 1280428583
```

* `into`: **.bg-purple_light[nombre de nuevas columnas]** donde separaremos valores.



&lt;img src="./img/seperate.jpg" width="50%" style="display: block; margin: auto;" /&gt;

---

# Datos .orange[SUCIOS]: messy data


Por defecto lo que hace es **.bg-purple_light[localizar como separador cualquier caracter que no sea alfa-numérico]**. Si queremos un caracter concreto para dividir podemos indicárselo explícitamente. Si usas un separador que no está en los datos te devolverá dichas columnas vacías ya que no ha podido dividirlas.



```r
table3 %&gt;% separate(rate, into = c("cases", "population"), sep = ".")
```

```
&gt; Warning: Expected 2 pieces. Additional pieces discarded in 6 rows [1, 2, 3, 4,
&gt; 5, 6].
```

```
&gt; # A tibble: 6 × 4
&gt;   country      year cases population
&gt;   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt; &lt;chr&gt;     
&gt; 1 Afghanistan  1999 ""    ""        
&gt; 2 Afghanistan  2000 ""    ""        
&gt; 3 Brazil       1999 ""    ""        
&gt; 4 Brazil       2000 ""    ""        
&gt; 5 China        1999 ""    ""        
&gt; 6 China        2000 ""    ""
```

---

# Datos .orange[SUCIOS]: messy data

De la misma manera que podemos separar columnas también podemos **.bg-purple_light[unir columnas]**. Para ello vamos a usar la tabla `table5` del ya mencionado paquete.


```r
table5
```

```
&gt; # A tibble: 6 × 4
&gt;   country     century year  rate             
&gt; * &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;            
&gt; 1 Afghanistan 19      99    745/19987071     
&gt; 2 Afghanistan 20      00    2666/20595360    
&gt; 3 Brazil      19      99    37737/172006362  
&gt; 4 Brazil      20      00    80488/174504898  
&gt; 5 China       19      99    212258/1272915272
&gt; 6 China       20      00    213766/1280428583
```

---

# Datos .orange[SUCIOS]: messy data

.pull-left[

Con la función `unite()` vamos a **.bg-purple_light[unir]** el siglo (en `century`) y el año (en `year`), y al inicio le indicaremos como se llamará la nueva variable `year_ok`


```r
table5 %&gt;%
  unite(col = year_ok,
        century, year, sep = "")
```

```
&gt; # A tibble: 6 × 3
&gt;   country     year_ok rate             
&gt;   &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt;            
&gt; 1 Afghanistan 1999    745/19987071     
&gt; 2 Afghanistan 2000    2666/20595360    
&gt; 3 Brazil      1999    37737/172006362  
&gt; 4 Brazil      2000    80488/174504898  
&gt; 5 China       1999    212258/1272915272
&gt; 6 China       2000    213766/1280428583
```

]

.pull-right[

&lt;img src="./img/unite.jpg" width="99%" style="display: block; margin: auto;" /&gt;

]


---

# Eliminando .orange[AUSENTES]

El paquete `{tidyr}` también dispone de algunas herramientas útiles para **.bg-purple_light[quitar ausentes]**


```r
datos &lt;- tibble(x = c(1, 2, NA), y = c("a", NA, "b"))
datos
```

```
&gt; # A tibble: 3 × 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 &lt;NA&gt; 
&gt; 3    NA b
```

---

# Eliminando .orange[AUSENTES]


Con `drop_na()` podemos indicarle que nos **.bg-purple_light[elimine las filas con algún ausente]** en alguna de las variables (o especificarle la variable concreta).


.pull-left[


```r
datos %&gt;% drop_na()
```

```
&gt; # A tibble: 1 × 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a
```

]


.pull-right[


```r
datos %&gt;% drop_na(x)
```

```
&gt; # A tibble: 2 × 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 &lt;NA&gt;
```

]

---

# Eliminando .orange[AUSENTES]

A veces no querremos eliminarlos sino **.bg-purple_light[imputar por el valor previo/siguiente]**  con `fill()`

.pull-left[


```r
datos %&gt;% fill(x)
```

```
&gt; # A tibble: 3 × 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 &lt;NA&gt; 
&gt; 3     2 b
```

```r
datos %&gt;% fill(x, .direction = c("up"))
```

```
&gt; # A tibble: 3 × 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 &lt;NA&gt; 
&gt; 3    NA b
```

]

.pull-right[


```r
datos %&gt;% fill(y)
```

```
&gt; # A tibble: 3 × 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 a    
&gt; 3    NA b
```

```r
datos %&gt;% fill(y, .direction = c("up"))
```

```
&gt; # A tibble: 3 × 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 b    
&gt; 3    NA b
```

]


---

# Eliminando .orange[AUSENTES]

Los **.bg-purple_light[ausentes]** también pueden ser **.bg-purple_light[eliminados al pivotar]** con `values_drop_na`.



```r
stocks &lt;-
  tibble(qtr = 1:4,
         "2015" = c(1.88, 0.59, 0.35, NA),
         "2016" = c(NA, 0.92, 0.17, 2.66))
stocks
```

```
&gt; # A tibble: 4 × 3
&gt;     qtr `2015` `2016`
&gt;   &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;
&gt; 1     1   1.88  NA   
&gt; 2     2   0.59   0.92
&gt; 3     3   0.35   0.17
&gt; 4     4  NA      2.66
```

---

# Eliminando .orange[AUSENTES]

Los **.bg-purple_light[ausentes]** también pueden ser **.bg-purple_light[eliminados al pivotar]** con `values_drop_na`.


```r
stocks %&gt;%
  pivot_longer(cols = c("2015", "2016"), names_to = "year",
               values_to = "return", values_drop_na = TRUE)
```

```
&gt; # A tibble: 6 × 3
&gt;     qtr year  return
&gt;   &lt;int&gt; &lt;chr&gt;  &lt;dbl&gt;
&gt; 1     1 2015    1.88
&gt; 2     2 2015    0.59
&gt; 3     2 2016    0.92
&gt; 4     3 2015    0.35
&gt; 5     3 2016    0.17
&gt; 6     4 2016    2.66
```

---

# Reemplazando .orange[AUSENTES]

Otras veces querremos **.bg-purple_light[imputar los ausentes por un valor fijo]**, algo que podemos hacer con `replace_na()`

.pull-left[


```r
datos
```

```
&gt; # A tibble: 3 × 2
&gt;       x y    
&gt;   &lt;dbl&gt; &lt;chr&gt;
&gt; 1     1 a    
&gt; 2     2 &lt;NA&gt; 
&gt; 3    NA b
```

]

.pull-right[


```r
datos %&gt;%
  replace_na(list(x = -1,
                  y = "unknown"))
```

```
&gt; # A tibble: 3 × 2
&gt;       x y      
&gt;   &lt;dbl&gt; &lt;chr&gt;  
&gt; 1     1 a      
&gt; 2     2 unknown
&gt; 3    -1 b
```

]

---


# Completando .orange[AUSENTES]

Por último, también podemos **.bg-purple_light[crear todas las combinaciones posibles de variables]** (para completar datos ausentes que se hayan podido eliminar).



```r
stocks &lt;- tibble(year = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),
                 qtr = c(1, 2, 3, 4, 2, 3, 4),
                 return = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66))
```

.pull-left[


```r
stocks
```

```
&gt; # A tibble: 7 × 3
&gt;    year   qtr return
&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
&gt; 1  2015     1   1.88
&gt; 2  2015     2   0.59
&gt; 3  2015     3   0.35
&gt; 4  2015     4  NA   
&gt; 5  2016     2   0.92
&gt; 6  2016     3   0.17
&gt; 7  2016     4   2.66
```

]

.pull-right[


```r
stocks %&gt;% complete(year, qtr)
```

```
&gt; # A tibble: 8 × 3
&gt;    year   qtr return
&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
&gt; 1  2015     1   1.88
&gt; 2  2015     2   0.59
&gt; 3  2015     3   0.35
&gt; 4  2015     4  NA   
&gt; 5  2016     1  NA   
&gt; 6  2016     2   0.92
&gt; 7  2016     3   0.17
&gt; 8  2016     4   2.66
```

]

---

name: entrega-I

# .orange[CASO PRÁCTICO 1]: datos de la OMS

Instala el paquete `{tidyr}` y usa el conjunto `who` contenido en él mismo (dataset sobre casos de tuberculosis). Deberás **.bg-purple_light[entregar completado]** el archivo `.Rmd` que tienes disponible en &lt;https://github.com/dadosdelaplace/teaching/tree/main/bioestad/eval&gt; **.bg-purple_light[antes de las 23:59 del 1 de octubre]**, siguiendo las instrucciones contenidas en el mismo.


```r
install.packages("tidyr")
library(tidyr)
who
```

&amp;nbsp;

🔎 Mira antes &lt;https://github.com/dadosdelaplace/teaching/blob/main/bioestad/scripts/segundo_rmarkdown.Rmd&gt; para ver algunas opciones extras que puedes usar para personalizar.


---


# .orange[CASO PRÁCTICO 1]: datos de la OMS

.panelset[
.panel[.panel-name[Paso 1]

]

.panel[.panel-name[Paso 2]

]

.panel[.panel-name[Paso 4]

]

.panel[.panel-name[Paso 5]

]
]

---

# .orange[CASO PRÁCTICO 2]: análisis de Star Wars

Instala el paquete `{dplyr}` y usa el conjunto `starwars` contenido en él mismo (dataset con los personajes de las películas de la saga Star Wars). Deberás **.bg-purple_light[entregar completado]** el archivo `.Rmd` que tienes disponible en &lt;https://github.com/dadosdelaplace/teaching/tree/main/bioestad/eval&gt; **.bg-purple_light[antes de las 23:59 del 1 de octubre]**, siguiendo las instrucciones contenidas en el mismo.



```r
install.packages("dplyr")
library(dplyr)
starwars
```

&amp;nbsp;

🔎 Mira antes &lt;https://github.com/dadosdelaplace/teaching/blob/main/bioestad/scripts/segundo_rmarkdown.Rmd&gt; para ver algunas opciones extras que puedes usar para personalizar.

---

# .orange[CASO PRÁCTICO 3]: análisis de gapminder

Instala el paquete `{gapminder}` y usa el conjunto `gapminder` contenido en él mismo (dataset con datos económicos de distintos países). Deberás **.bg-purple_light[entregar completado]** el archivo `.Rmd` que tienes disponible en &lt;https://github.com/dadosdelaplace/teaching/tree/main/bioestad/eval&gt; **.bg-purple_light[antes de las 23:59 del 1 de octubre]**, siguiendo las instrucciones contenidas en el mismo.


```r
install.packages("gapminder")
library(gapminder)
gapminder
```


&amp;nbsp;


🔎 Mira antes &lt;https://github.com/dadosdelaplace/teaching/blob/main/bioestad/scripts/segundo_rmarkdown.Rmd&gt; para ver algunas opciones extras que puedes usar para personalizar.

---


class: inverse center middle

# CLASES

&amp;nbsp;

#### [CLASE 7](#clase-7)

#### [CLASE 8](#clase-8)

#### [ENTREGA II (clase 9)](#clase-9)


---

class: inverse center middle
name: clase-7

# CLASE 7: funciones y listas

&amp;nbsp;

### [Listas](#listas)

### [Creando nuestras propias funciones](#funciones)

### [Ejercicios](#ejercicios-7)

---

name: listas

# Último tipo de variable: .orange[LISTAS]

Veamos un pequeño resumen de los datos que ya conocemos:

* **.bg-purple_light[vectores]**: colección de elementos de igual tipo. Pueden ser números, caracteres o valores lógicos, entre otros.

* **.bg-purple_light[matrices]**: colección BIDIMENSIONAL de elementos de igual tipo e igual longitud.

* **.bg-purple_light[data.frame / tibble]**: colección BIDIMENSIONAL de elementos de igual longitud pero de cualquier tipo, lo más parecido a lo que conocemos como una tabla en Excel.

&amp;nbsp;

--

Con todos estos ingredientes estamos preparados/as para ver el que probablemente sea el tipo de dato más importante en R: las **.bg-purple_light[listas]**: **.bg-purple_light[colecciones de variables de diferente tipo]** (ya lo teníamos con `data.frame` y `tibble`) pero además también de **.bg-purple_light[diferente longitud]**, con estructuras totalmente heterógeneas (incluso una lista puede tener dentro a su vez otra lista).

---

# Último tipo de variable: .orange[LISTAS]


Vamos a crear **.bg-purple_light[nuestra primera lista]** con `list()` con tres elementos: el nombre de nuestros padres/madres, nuestro lugar de nacimiento y edades de nuestros hermanos.


```r
variable_1 &lt;- c("Paloma", "Gregorio")
variable_2 &lt;- "Madrid"
variable_3 &lt;- c(25, 30, 26)

lista &lt;- list("progenitores" = variable_1, "lugar_nacimiento" = variable_2,
              "edades_hermanos" = variable_3)
lista
```

```
&gt; $progenitores
&gt; [1] "Paloma"   "Gregorio"
&gt; 
&gt; $lugar_nacimiento
&gt; [1] "Madrid"
&gt; 
&gt; $edades_hermanos
&gt; [1] 25 30 26
```

---

# Último tipo de variable: .orange[LISTAS]


```r
length(lista)
```

```
&gt; [1] 3
```

Si observas el objeto que hemos definido como lista, su longitud del es de 3 ya que tenemos **.bg-purple_light[guardados tres elementos]**: vector de caracteres (de longitud 2), caracter (vector de longitud 1), vector de números (de longitud 3)

--

Tenemos guardados elementos de **.bg-purple_light[distinto tipo]** (algo que ya podíamos hacer) pero, además, de **.bg-purple_light[longitudes dispares]**.


```r
dim(lista) # devolverá NULL al no tener dos dimensiones
```

```
&gt; NULL
```

```r
class(lista) # de tipo lista
```

```
&gt; [1] "list"
```

---

# Último tipo de variable: .orange[LISTAS]

Si los juntásemos con un `tibble()`, al tener distinta longitud, obtendríamos un **.bg-red_light[error]**.


```r
library(tibble)
tibble("progenitores" = variable_1,
       "lugar_nacimiento" = variable_2,
       "edades_hermanos" = variable_3)
```

```
&gt; Error:
&gt; ! Tibble columns must have compatible sizes.
&gt; • Size 2: Existing data.
&gt; • Size 3: Column `edades_hermanos`.
&gt; ℹ Only values of size one are recycled.
```

---


# Último tipo de variable: .orange[LISTAS]

.pull-left[

* **.bg-purple_light[Acceder por índice]**: con el operador `[[i]]` accedemos al **elemento i-ésimo** de la lista.


```r
lista[[1]]
```

```
&gt; [1] "Paloma"   "Gregorio"
```

]

.pull-right[
* **.bg-purple_light[Acceder por nombre]**: con el operador `$nombre_elemento` accedemos por su nombre.


```r
lista$progenitores
```

```
&gt; [1] "Paloma"   "Gregorio"
```

]

--

En contraposición, el **.bg-purple_light[corchete simple]** nos permite acceder a **.bg-purple_light[varios elementos]** a la vez


```r
# Varios elementos
lista[1:2]
```

```
&gt; $progenitores
&gt; [1] "Paloma"   "Gregorio"
&gt; 
&gt; $lugar_nacimiento
&gt; [1] "Madrid"
```

---

# Último tipo de variable: .orange[LISTAS]

Las listas nos dan tanta flexibilidad que es el formato natural para guardar **.bg-purple_light[datos que no están estructurados]**, como pueden ser los datos almacenados de una persona.



```r
library(lubridate)
nacimiento &lt;- as_date("1989-09-10")

notas &lt;- data.frame("biología" = c(5, 7), "física" = c(4, 5),
                    "matemáticas" = c(8, 9.5))
row.names(notas) &lt;- c("primer_parcial", "segundo_parcial")

tlf &lt;- c("914719567", "617920765", "716505013")

padres &lt;- c("Juan", "Julia")

# Guardamos TODO en una lista (con nombres de cada elemento)
datos &lt;- list("nacimiento" = nacimiento, "notas_insti" = notas,
              "teléfonos" = tlf, "nombre_padres" = padres)
datos
```

```
&gt; $nacimiento
&gt; [1] "1989-09-10"
&gt; 
&gt; $notas_insti
&gt;                 biología física matemáticas
&gt; primer_parcial         5      4         8.0
&gt; segundo_parcial        7      5         9.5
&gt; 
&gt; $teléfonos
&gt; [1] "914719567" "617920765" "716505013"
&gt; 
&gt; $nombre_padres
&gt; [1] "Juan"  "Julia"
```



---

# Último tipo de variable: .orange[LISTAS]

Hemos creado una lista algo más compleja de 4 elementos, a los cuales podemos acceder por índice o por nombre.


```r
datos[[1]]
```

```
&gt; [1] "1989-09-10"
```

```r
datos$nacimiento
```

```
&gt; [1] "1989-09-10"
```


```r
datos$notas_insti
```

```
&gt;                 biología física matemáticas
&gt; primer_parcial         5      4         8.0
&gt; segundo_parcial        7      5         9.5
```

---

# Último tipo de variable: .orange[LISTAS]


También podemos hacer **.bg-purple_light[listas con otras listas dentro]**, de forma que para acceder a cada nivel deberemos usar el operador `[[]]`.


```r
lista_de_listas &lt;- list("lista_1" = datos[3:4], "lista_2" = datos[1:2])

names(lista_de_listas) # Nombres de los elementos del primer nivel
```

```
&gt; [1] "lista_1" "lista_2"
```

```r
names(lista_de_listas[[1]]) # Nombres de los elementos guardados en el primer elemento, que es a su vez una lista
```

```
&gt; [1] "teléfonos"     "nombre_padres"
```

```r
lista_de_listas[[1]][[1]] # Elemento 1 de la lista guardada como elemento 1 de la lista superior
```

```
&gt; [1] "914719567" "617920765" "716505013"
```

¡Nos permiten guardar **.bg-purple_light[datos n-dimensionales]**!.

---

# .green[OPERACIONES] con .orange[LISTAS]

Una lista **.bg-purple_light[no se puede vectorizar]** de forma inmediata, por lo cualquier operación aritmética aplicada a una lista dará **.bg-red_light[error]**


```r
datos &lt;- list("a" = 1:5, "b" = 10:20)
datos / 2
```

```
&gt; Error in datos/2: argumento no-numérico para operador binario
```

--


Para ello una de las opciones es hacer uso de la familia `lapply()`


```r
lapply(datos, FUN = function(x) { x / 2})
```

```
&gt; $a
&gt; [1] 0.5 1.0 1.5 2.0 2.5
&gt; 
&gt; $b
&gt;  [1]  5.0  5.5  6.0  6.5  7.0  7.5  8.0  8.5  9.0  9.5 10.0
```

La salida de `lapply()` por defecto siempre es una **.bg-purple_light[lista de igual longitud]**.

---

# .green[OPERACIONES] con .orange[LISTAS]

.pull-left[

Una opción más flexible y versatil es hacer uso del paquete `{purrr}` del entorno `{tidyverse}`.


```r
# install.packages("purrr")
library(purrr)
```

Dicho paquete pretende imitar la **.bg-purple_light[programación funcional]** de otros lenguajes como Scala o la **estrategia map-reduce de Hadoop** (de Google).

]


.pull-right[

&lt;img src="./img/purrr.png" width="110%" style="display: block; margin: auto auto auto 0;" /&gt;

]

---

# .green[OPERACIONES] con .orange[LISTAS]

La función más simple del paquete `{purrr}` es la función `map()`, que nos **.bg-purple_light[aplica una función vectorizada]** a cada uno de los elementos de una lista. Veamos un primer ejemplo aplicada a vectores


```r
library(microbenchmark)
x &lt;- 1:1000
y &lt;- sqrt(x) # vectorizado

# bucle
for (i in 1:1000) { y[i] &lt;- sqrt(x[i]) }

microbenchmark(sqrt(x), for (i in 1:1000) { y[i] &lt;- sqrt(x[i]) }, times = 1e3)
```

```
&gt; Unit: microseconds
&gt;                                          expr      min        lq        mean
&gt;                                       sqrt(x)    2.458    3.0545    4.591981
&gt;  for (i in 1:1000) {     y[i] &lt;- sqrt(x[i]) } 1931.053 2170.3080 2821.407567
&gt;     median       uq       max neval cld
&gt;     3.9545    4.700    20.723  1000  a 
&gt;  2302.5430 2642.676 75800.343  1000   b
```



---


# .green[OPERACIONES] con .orange[LISTAS]

Con `map()` podemos **.bg-purple_light[«mapear» cada lista]** y aplicar la función elemento a elemento (si fuese el caso).

.pull-left[


```r
library(purrr)
x &lt;- rep(list(1:2), 3)
x
```

```
&gt; [[1]]
&gt; [1] 1 2
&gt; 
&gt; [[2]]
&gt; [1] 1 2
&gt; 
&gt; [[3]]
&gt; [1] 1 2
```

]

.pull-right[


```r
# purrr
map(x, sqrt) 
```

```
&gt; [[1]]
&gt; [1] 1.000000 1.414214
&gt; 
&gt; [[2]]
&gt; [1] 1.000000 1.414214
&gt; 
&gt; [[3]]
&gt; [1] 1.000000 1.414214
```

]

**.bg-green_light[IMPORTANTE]**: en vectores disponemos de una vectorización por defecto porque `R` realiza operaciones elemento a elemento.

---

# .green[OPERACIONES] con .orange[LISTAS]


```r
x &lt;- list(rnorm(n = 1e3, mean = 0, sd = 1), rnorm(n = 1e3, mean = 2, sd = 1))
map(x, mean)
```

```
&gt; [[1]]
&gt; [1] 0.01976477
&gt; 
&gt; [[2]]
&gt; [1] 1.991007
```


```r
x &lt;- rep(list(rnorm(n = 1e3, mean = 0, sd = 1)), 1000)
microbenchmark(map(x, .f = function(x) { mean(x^2) }), lapply(x, FUN = function(x) { mean(x^2) }), times = 1e3)
```

```
&gt; Unit: milliseconds
&gt;                                            expr      min       lq     mean
&gt;      map(x, .f = function(x) {     mean(x^2) }) 5.475186 6.212955 8.258662
&gt;  lapply(x, FUN = function(x) {     mean(x^2) }) 5.163057 6.094283 8.165035
&gt;    median       uq       max neval cld
&gt;  7.096030 7.886214  46.25971  1000   a
&gt;  7.030539 7.833374 187.34669  1000   a
```


---

# .green[OPERACIONES] con .orange[LISTAS]

Además de ser **.bg-purple_light[más legible y eficiente]**, con `{purrr}` podemos **.bg-purple_light[decidir el formato de salida]** tras la operación (por ejemplo, en formato de vector con `map_dbl()` para números - en general - y  `map_int()` para enteros), sin necesidad de hacer uso de `unlist()` (deshace formato lista).


```r
x &lt;- list(rnorm(n = 1e3, mean = 0, sd = 1), rnorm(n = 1e3, mean = 2, sd = 1))
map_dbl(x, mean)
```

```
&gt; [1] 0.02348016 2.00226182
```

--

Además, si se le pasa un **.bg-purple_light[número]** en lugar de una función, nos devolverá el elemento i-ésimo de cada lista de forma inmediata.

.pull-left[


```r
c(x[[1]][3], x[[2]][3])
```

```
&gt; [1] 0.170459 2.025621
```

]

.pull-right[

```r
map_dbl(x, 3)
```

```
&gt; [1] 0.170459 2.025621
```
]


---


# .green[OPERACIONES] con .orange[LISTAS]

Tenemos además de pasar más de un argumento, realizando **.bg-purple_light[operaciones binarias]** con `map2()`


```r
x &lt;- list("a" = 1:3, "b" = 4:7)
y &lt;- list("c" = c(-1, 4, 0), "b" = c(5, -4, -1, 2))

map2(x, y, .f = function(x, y) { x^2 + y^2})
```

```
&gt; $a
&gt; [1]  2 20  9
&gt; 
&gt; $b
&gt; [1] 41 41 37 53
```

---

name: funciones

# Creando .orange[FUNCIONES]

No solo podemos usar **.bg-purple_light[funciones predeterminadas]** que vienen ya cargadas en paquetes, además podemos **.bg-purple_light[crear nuestras propias funciones]** para **automatizar tareas**.

¿Cómo **.bg-purple_light[crear nuestra propia función]**? Veamos su **.bg-orange[esquema básico]**:

--

.pull-left[

* **.bg-purple_light[Nombre]**, por ejemplo `name_fun` (sin espacios ni caracteres extraños).

* Al nombre le **.bg-purple_light[asignamos la palabra reservada]** `function()`.

* Definir **.bg-purple_light[argumentos de entrada]** (dentro de `function()`).

* **.bg-purple_light[Cuerpo]** de la función dentro de `{ }`.

* Finalizamos la función con los **.bg-purple_light[argumentos de salida]** con `return()`.

]

.pull-right[


```r
# No ejecutar --&gt; esquema conceptual
name_fun &lt;- function(arg1, arg2, ...) {
  
  # Código que queramos ejecutar
  código
  
  # Salida
  return(var_salida)
}
```

]


---

# Creando .orange[FUNCIONES]


.pull-left[

* `arg1, arg2, ...`: serán los **.bg-purple_light[argumentos de entrada]**, los argumentos que toma la función para ejecutar el código que tiene dentro

* `código`: líneas de código que queramos que **.bg-purple_light[ejecute la función]**. 

* `return(var_salida)`: dentro del comando `return()` se introducirán los **.bg-purple_light[argumentos de salida]**.

]

.pull-right[


```r
# No ejecutar --&gt; esquema conceptual
name_fun &lt;- function(arg1, arg2, ...) {
  
  # Código que queramos ejecutar
  código
  
  # Salida
  return(var_salida)
}
```

]

&amp;nbsp;

**.bg-red_light[IMPORTANTE]**: todas las variables que definamos dentro de la función son **.bg-purple_light[variables locales: solo existirán dentro de la función]** salvo que especifiquemos lo contrario.

---

# Creando .orange[FUNCIONES]

Veamos un ejemplo muy simple de función para **.bg-purple_light[calcular el área de un rectángulo]**.

--

Dado que el área de un rectángulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serán los **.bg-purple_light[argumentos de entrada]** y el **.bg-purple_light[valor a devolver]** será justo su **.bg-purple_light[área]**, calculada como `\(lado_1 * lado_2\)`.

--


```r
# Definición del nombre de función y argumentos de entrada
calcular_area &lt;- function(lado_1, lado_2) {
  
  area &lt;- lado_1 * lado_2
  
  return(area)
  
}
```

---

# Creando .orange[FUNCIONES]


También podemos hacer una definición directa, sin almacenar variables por el camino


```r
# Definición del nombre de función y argumentos de entrada
calcular_area &lt;- function(lado_1, lado_2) {
  
  return(lado_1 * lado_2)
  
}
```

--

**.bg-purple_light[¿Cómo aplicar la función?]**


```r
calcular_area(5, 3) # área de un rectángulo 5 x 3 
```

```
&gt; [1] 15
```

```r
calcular_area(1, 5) # área de un rectángulo 1 x 5
```

```
&gt; [1] 5
```

---

# Argumentos .orange[POR DEFECTO]

Imagina ahora que nos damos cuenta que el 90% de las veces usamos dicha función para **.bg-purple_light[calcular el área de un cuadrado]** (es decir, solo necesitamos un lado). Para ello, podemos definir **.bg-purple_light[argumentos por defecto]** en la función: tomarán dicho valor salvo que le asignemos otro.

¿Por qué no asignar `lado_2 = lado_1` por defecto, para ahorrar líneas de código y tiempo?

--


```r
# Definición del nombre de función y
# argumentos de entrada por defecto lado_2 = lado_1
calcular_area &lt;- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area &lt;- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

---

# Argumentos .orange[POR DEFECTO]



```r
calcular_area &lt;- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area &lt;- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```


Ahora **.bg-purple_light[por defecto]** el segundo lado será igual al primero (si se lo añadimos usará ambos).



```r
calcular_area(lado_1 = 5) # cuadrado
```

```
&gt; [1] 25
```

```r
calcular_area(lado_1 = 5, lado_2 = 7) # rectángulo
```

```
&gt; [1] 35
```

---
 
# .orange[SALIDA MÚLTIPLE]

Compliquemos un poco la función y añadamos en la salida los valores de cada lado, etiquetados como `lado_1` y `lado_2`, **.bg-purple_light[empaquetando la salida en una lista]**.


```r
# Definición del nombre de función y argumentos de entrada
calcular_area &lt;- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area &lt;- lado_1 * lado_2
  
  # Resultado
  return(list("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
  
}
```

Veamos que nos devuelve ahora


---

# .orange[SALIDA MÚLTIPLE]



```r
salida &lt;- calcular_area(5, 3)
salida
```

```
&gt; $area
&gt; [1] 15
&gt; 
&gt; $lado_1
&gt; [1] 5
&gt; 
&gt; $lado_2
&gt; [1] 3
```

```r
salida["area"]
```

```
&gt; $area
&gt; [1] 15
```

```r
salida["lado_1"]
```

```
&gt; $lado_1
&gt; [1] 5
```

---

# .orange[SALIDA MÚLTIPLE]

Antes nos daba igual el orden de los argumentos pero ahora **.bg-purple_light[el orden de los argumentos de entrada importa]**, ya que en la salida incluimos `lado_1` y `lado_2`. 

--

&amp;nbsp;

**.bg-green_light[CONSEJO]**: es altamente recomendable hacer la llamada a la función **.bg-purple_light[indicando explícitamente los argumentos]** para mejorar la **legibilidad e interpretabilidad**.


```r
# Equivalente a calcular_area(5, 3)
calcular_area(lado_1 = 5, lado_2 = 3)
```

```
&gt; $area
&gt; [1] 15
&gt; 
&gt; $lado_1
&gt; [1] 5
&gt; 
&gt; $lado_2
&gt; [1] 3
```

---

# Creando .orange[FUNCIONES]

Parece una tontería lo que hemos hecho pero hemos cruzado una frontera importante: hemos pasado de **.bg-purple_light[consumir conocimiento]** (código de otros paquetes, elaborado por otros/as), a **.bg-green_light[generar conocimiento]**, creando nuestras propias funciones.

&amp;nbsp;

En este caso no ganaremos el Nobel por nuestro aporte, pero en un futuro… Si la Unión Europea lo ganó, hay opciones :)

---

# Variables .orange[LOCALES VS GLOBALES]

Un aspecto importante sobre el que reflexionar con las funciones: ¿qué sucede si **.bg-purple_light[nombramos a una variable dentro]** de una función a la que se nos ha **.bg-purple_light[olvidado asignar]** un valor dentro de la misma?

--

Debemos ser cautos al usar funciones en `R`, ya que debido a la **.bg-purple_light[«regla lexicográfica»]**, si una variable no se define dentro de la función, `R` **.bg-purple_light[buscará dicha variable en el entorno]** de variables.


```r
x &lt;- 1
funcion_ejemplo &lt;- function() {
    
  print(x) # No devuelve nada, solo realiza la acción 
}
funcion_ejemplo()
```

```
&gt; [1] 1
```

---

# Variables .orange[LOCALES VS GLOBALES]

Si una variable  **.bg-purple_light[ya está definida fuera de la función (entorno global)]**, y además es usada dentro de cambiando su valor, el valor **.bg-purple_light[solo cambia dentro]** pero no en el entorno global.


```r
x &lt;- 1
funcion_ejemplo &lt;- function() {
    
  x &lt;- 2
  print(x) # lo que vale dentro
}
```


```r
# lo que vale dentro
*funcion_ejemplo()
```

```
&gt; [1] 2
```

```r
# lo que vale fuera
*print(x)
```

```
&gt; [1] 1
```

---

# Variables .orange[LOCALES VS GLOBALES]


Si queremos que además de cambiar localmente lo haga **.bg-purple_light[globalmente]** deberemos usar la **.bg-purple_light[doble asignación]** (`&lt;&lt;-`).

.pull-left[


```r
x &lt;- 1
y &lt;- 2
funcion_ejemplo &lt;- function() {
  
  # no cambia globalmente, solo localmente
  x &lt;- 3 
  
  # cambia globalmente
* y &lt;&lt;- 0
  
  print(x)
  print(y)
}
```

]

.pull-right[


```r
funcion_ejemplo() # lo que vale dentro
```

```
&gt; [1] 3
&gt; [1] 0
```

```r
x # lo que vale fuera
```

```
&gt; [1] 1
```

```r
y # lo que vale fuera
```

```
&gt; [1] 0
```

]

---

# Creando .orange[FUNCIONES]

Vamos a practicar un poco las funciones.

**.bg-purple_light[Ejercicio 1]**: crea una función llamada `calculo_IMC` que, dados dos argumentos (peso y estatura en metros), devuelva el IMC de una persona.


--

&amp;nbsp;

**.bg-purple_light[Ejercicio 2]**: crea una función llamada `calculo_IMC` que tenga dos argumentos de entrada (peso y estatura en metros), más otro opcional que se llame `unidades` (por defecto, `unidades = "metros"`). Desarrolla la función de forma que haga lo correcto si `unidades = "metros"` y si `unidades = "centímetros"`.

--

&amp;nbsp;

**.bg-purple_light[Ejercicio 3]**: crea un `tibble` ficticio de 7 personas, con tres variables (nombre, peso, estatura), y aplica la función definida de forma que obtengamos una cuarta colunna con su IMC.

---

name: ejercicios-7

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]

* 📝 **Ejercicio 1**: modifica el código inferior para definir una función llamada `funcion_suma`, de forma que dados dos elementos, devuelve su suma.



```r
# Definimos función
nombre &lt;- function(x, y) {
  
  # Sumamos
  suma &lt;- # código a ejecutar
  
  # ¿Qué devolvemos?
  return()
}
# Aplicamos la función
suma(3, 7)
```
 
]

.panel[.panel-name[Solución ej. 1]


```r
# Definimos función
funcion_suma &lt;- function(x, y) {
  
  # Sumamos
  suma &lt;- x + y
  
  # Devolvemos la salida
  return(suma)
}

# Aplicamos la función
funcion_suma(3, 7)
```

```
&gt; [1] 10
```

]

]

---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 2**: modifica el código inferior para definir una función llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto.
 

```r
# Definimos función
nombre &lt;- function(x, y) {
  
  # Multiplicamos
  producto &lt;- # código de la multiplicación
  
  # ¿Qué devolvemos?
  return()
}

# Aplicamos la función
producto(3, -7)
```

]

.panel[.panel-name[Solución ej. 2]


```r
# Definimos función
funcion_producto &lt;- function(x, y) {
  
  # Multiplicamos
  producto &lt;- x * y
  
  # Devolvemos la salida
  return(producto)
}

# Aplicamos la función
funcion_producto(3, -7)
```

```
&gt; [1] -21
```

]

]


---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 3**: modifica el código inferior para definir una función llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto, pero que por defecto calcule el cuadrado (es decir, por defecto un solo argumento, y el resultado sea el número por sí mismo)
 

```r
# Definimos función
nombre &lt;- function(x, y) {
  
  # Multiplicamos
  producto &lt;- # código de la multiplicación
  
  # ¿Qué devolvemos?
  return()
}

# Aplicamos la función solo con un argumento
producto(3)

# Aplicamos la función con dos argumentos
producto(3, -7)
```

]

.panel[.panel-name[Solución ej. 3]


```r
funcion_producto &lt;- function(x, y = x) {
  
  producto &lt;- x * y
  return(producto)
}
```


```r
funcion_producto(3) # por defecto x = 3, y = 3
```

```
&gt; [1] 9
```

```r
funcion_producto(3, -7)
```

```
&gt; [1] -21
```

]

]


---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 4**:  define una función llamada `igualdad_nombres` que, dados dos nombres, nos diga si son iguales o no. Hazlo considerando importantes las mayúsculas, y sin que importen las mayúsculas. Echa un vistazo al paquete `{stringr}`.
 

* 📝 **Ejercicio 5**:  define una función llamada `pares` que, dados dos números, nos diga si la suma de ambos es par o no.
 

* 📝 **Ejercicio 6**: define una función llamada `pasar_a_celsius` que, dada una temperatura en Fahrenheit, la convierta a grados Celsius. Aplica la función a la columna Temp del conjunto airquality, e incorpórala al fichero en una nueva columna Temp_Celsius.

]

.panel[.panel-name[Solución ej. 4a]



```r
# Distinguiendo mayúsculas
igualdad_nombres &lt;- function(persona_1, persona_2) {
  
  return(persona_1 == persona_2)
}
```


```r
igualdad_nombres("Javi", "javi")
```

```
&gt; [1] FALSE
```

```r
igualdad_nombres("Javi", "Lucía")
```

```
&gt; [1] FALSE
```

]

.panel[.panel-name[Solución ej. 4b]


```r
# Sin importar mayúsculas
igualdad_nombres &lt;- function(persona_1, persona_2) {
  
  return(toupper(persona_1) == toupper(persona_2))
}
```


```r
igualdad_nombres("Javi", "javi")
```

```
&gt; [1] TRUE
```

```r
igualdad_nombres("Javi", "Lucía")
```

```
&gt; [1] FALSE
```

]

.panel[.panel-name[Solución ej. 5]


```r
pares &lt;- function(x, y) {
  
  suma &lt;- x + y
  par &lt;- suma %% 2 == 0
  
  return(par)
}
```


```r
pares(1, 3) # suma 4 (par)
```

```
&gt; [1] TRUE
```

```r
pares(2, 7) # suma 9 (impar)
```

```
&gt; [1] FALSE
```

]

.panel[.panel-name[Solución ej. 6]


```r
pasar_a_celsius &lt;- function(x) {
  x_celsius &lt;- (x - 32) * (5 / 9)
  return(x_celsius)
}
```


```r
pasar_a_celsius(80)
```

```
&gt; [1] 26.66667
```

```r
data.frame(airquality,
           "Temp_Celsius" = pasar_a_celsius(airquality$Temp))
```

```
&gt;     Ozone Solar.R Wind Temp Month Day Temp_Celsius
&gt; 1      41     190  7.4   67     5   1     19.44444
&gt; 2      36     118  8.0   72     5   2     22.22222
&gt; 3      12     149 12.6   74     5   3     23.33333
&gt; 4      18     313 11.5   62     5   4     16.66667
&gt; 5      NA      NA 14.3   56     5   5     13.33333
&gt; 6      28      NA 14.9   66     5   6     18.88889
&gt; 7      23     299  8.6   65     5   7     18.33333
&gt; 8      19      99 13.8   59     5   8     15.00000
&gt; 9       8      19 20.1   61     5   9     16.11111
&gt; 10     NA     194  8.6   69     5  10     20.55556
&gt; 11      7      NA  6.9   74     5  11     23.33333
&gt; 12     16     256  9.7   69     5  12     20.55556
&gt; 13     11     290  9.2   66     5  13     18.88889
&gt; 14     14     274 10.9   68     5  14     20.00000
&gt; 15     18      65 13.2   58     5  15     14.44444
&gt; 16     14     334 11.5   64     5  16     17.77778
&gt; 17     34     307 12.0   66     5  17     18.88889
&gt; 18      6      78 18.4   57     5  18     13.88889
&gt; 19     30     322 11.5   68     5  19     20.00000
&gt; 20     11      44  9.7   62     5  20     16.66667
&gt; 21      1       8  9.7   59     5  21     15.00000
&gt; 22     11     320 16.6   73     5  22     22.77778
&gt; 23      4      25  9.7   61     5  23     16.11111
&gt; 24     32      92 12.0   61     5  24     16.11111
&gt; 25     NA      66 16.6   57     5  25     13.88889
&gt; 26     NA     266 14.9   58     5  26     14.44444
&gt; 27     NA      NA  8.0   57     5  27     13.88889
&gt; 28     23      13 12.0   67     5  28     19.44444
&gt; 29     45     252 14.9   81     5  29     27.22222
&gt; 30    115     223  5.7   79     5  30     26.11111
&gt; 31     37     279  7.4   76     5  31     24.44444
&gt; 32     NA     286  8.6   78     6   1     25.55556
&gt; 33     NA     287  9.7   74     6   2     23.33333
&gt; 34     NA     242 16.1   67     6   3     19.44444
&gt; 35     NA     186  9.2   84     6   4     28.88889
&gt; 36     NA     220  8.6   85     6   5     29.44444
&gt; 37     NA     264 14.3   79     6   6     26.11111
&gt; 38     29     127  9.7   82     6   7     27.77778
&gt; 39     NA     273  6.9   87     6   8     30.55556
&gt; 40     71     291 13.8   90     6   9     32.22222
&gt; 41     39     323 11.5   87     6  10     30.55556
&gt; 42     NA     259 10.9   93     6  11     33.88889
&gt; 43     NA     250  9.2   92     6  12     33.33333
&gt; 44     23     148  8.0   82     6  13     27.77778
&gt; 45     NA     332 13.8   80     6  14     26.66667
&gt; 46     NA     322 11.5   79     6  15     26.11111
&gt; 47     21     191 14.9   77     6  16     25.00000
&gt; 48     37     284 20.7   72     6  17     22.22222
&gt; 49     20      37  9.2   65     6  18     18.33333
&gt; 50     12     120 11.5   73     6  19     22.77778
&gt; 51     13     137 10.3   76     6  20     24.44444
&gt; 52     NA     150  6.3   77     6  21     25.00000
&gt; 53     NA      59  1.7   76     6  22     24.44444
&gt; 54     NA      91  4.6   76     6  23     24.44444
&gt; 55     NA     250  6.3   76     6  24     24.44444
&gt; 56     NA     135  8.0   75     6  25     23.88889
&gt; 57     NA     127  8.0   78     6  26     25.55556
&gt; 58     NA      47 10.3   73     6  27     22.77778
&gt; 59     NA      98 11.5   80     6  28     26.66667
&gt; 60     NA      31 14.9   77     6  29     25.00000
&gt; 61     NA     138  8.0   83     6  30     28.33333
&gt; 62    135     269  4.1   84     7   1     28.88889
&gt; 63     49     248  9.2   85     7   2     29.44444
&gt; 64     32     236  9.2   81     7   3     27.22222
&gt; 65     NA     101 10.9   84     7   4     28.88889
&gt; 66     64     175  4.6   83     7   5     28.33333
&gt; 67     40     314 10.9   83     7   6     28.33333
&gt; 68     77     276  5.1   88     7   7     31.11111
&gt; 69     97     267  6.3   92     7   8     33.33333
&gt; 70     97     272  5.7   92     7   9     33.33333
&gt; 71     85     175  7.4   89     7  10     31.66667
&gt; 72     NA     139  8.6   82     7  11     27.77778
&gt; 73     10     264 14.3   73     7  12     22.77778
&gt; 74     27     175 14.9   81     7  13     27.22222
&gt; 75     NA     291 14.9   91     7  14     32.77778
&gt; 76      7      48 14.3   80     7  15     26.66667
&gt; 77     48     260  6.9   81     7  16     27.22222
&gt; 78     35     274 10.3   82     7  17     27.77778
&gt; 79     61     285  6.3   84     7  18     28.88889
&gt; 80     79     187  5.1   87     7  19     30.55556
&gt; 81     63     220 11.5   85     7  20     29.44444
&gt; 82     16       7  6.9   74     7  21     23.33333
&gt; 83     NA     258  9.7   81     7  22     27.22222
&gt; 84     NA     295 11.5   82     7  23     27.77778
&gt; 85     80     294  8.6   86     7  24     30.00000
&gt; 86    108     223  8.0   85     7  25     29.44444
&gt; 87     20      81  8.6   82     7  26     27.77778
&gt; 88     52      82 12.0   86     7  27     30.00000
&gt; 89     82     213  7.4   88     7  28     31.11111
&gt; 90     50     275  7.4   86     7  29     30.00000
&gt; 91     64     253  7.4   83     7  30     28.33333
&gt; 92     59     254  9.2   81     7  31     27.22222
&gt; 93     39      83  6.9   81     8   1     27.22222
&gt; 94      9      24 13.8   81     8   2     27.22222
&gt; 95     16      77  7.4   82     8   3     27.77778
&gt; 96     78      NA  6.9   86     8   4     30.00000
&gt; 97     35      NA  7.4   85     8   5     29.44444
&gt; 98     66      NA  4.6   87     8   6     30.55556
&gt; 99    122     255  4.0   89     8   7     31.66667
&gt; 100    89     229 10.3   90     8   8     32.22222
&gt; 101   110     207  8.0   90     8   9     32.22222
&gt; 102    NA     222  8.6   92     8  10     33.33333
&gt; 103    NA     137 11.5   86     8  11     30.00000
&gt; 104    44     192 11.5   86     8  12     30.00000
&gt; 105    28     273 11.5   82     8  13     27.77778
&gt; 106    65     157  9.7   80     8  14     26.66667
&gt; 107    NA      64 11.5   79     8  15     26.11111
&gt; 108    22      71 10.3   77     8  16     25.00000
&gt; 109    59      51  6.3   79     8  17     26.11111
&gt; 110    23     115  7.4   76     8  18     24.44444
&gt; 111    31     244 10.9   78     8  19     25.55556
&gt; 112    44     190 10.3   78     8  20     25.55556
&gt; 113    21     259 15.5   77     8  21     25.00000
&gt; 114     9      36 14.3   72     8  22     22.22222
&gt; 115    NA     255 12.6   75     8  23     23.88889
&gt; 116    45     212  9.7   79     8  24     26.11111
&gt; 117   168     238  3.4   81     8  25     27.22222
&gt; 118    73     215  8.0   86     8  26     30.00000
&gt; 119    NA     153  5.7   88     8  27     31.11111
&gt; 120    76     203  9.7   97     8  28     36.11111
&gt; 121   118     225  2.3   94     8  29     34.44444
&gt; 122    84     237  6.3   96     8  30     35.55556
&gt; 123    85     188  6.3   94     8  31     34.44444
&gt; 124    96     167  6.9   91     9   1     32.77778
&gt; 125    78     197  5.1   92     9   2     33.33333
&gt; 126    73     183  2.8   93     9   3     33.88889
&gt; 127    91     189  4.6   93     9   4     33.88889
&gt; 128    47      95  7.4   87     9   5     30.55556
&gt; 129    32      92 15.5   84     9   6     28.88889
&gt; 130    20     252 10.9   80     9   7     26.66667
&gt; 131    23     220 10.3   78     9   8     25.55556
&gt; 132    21     230 10.9   75     9   9     23.88889
&gt; 133    24     259  9.7   73     9  10     22.77778
&gt; 134    44     236 14.9   81     9  11     27.22222
&gt; 135    21     259 15.5   76     9  12     24.44444
&gt; 136    28     238  6.3   77     9  13     25.00000
&gt; 137     9      24 10.9   71     9  14     21.66667
&gt; 138    13     112 11.5   71     9  15     21.66667
&gt; 139    46     237  6.9   78     9  16     25.55556
&gt; 140    18     224 13.8   67     9  17     19.44444
&gt; 141    13      27 10.3   76     9  18     24.44444
&gt; 142    24     238 10.3   68     9  19     20.00000
&gt; 143    16     201  8.0   82     9  20     27.77778
&gt; 144    13     238 12.6   64     9  21     17.77778
&gt; 145    23      14  9.2   71     9  22     21.66667
&gt; 146    36     139 10.3   81     9  23     27.22222
&gt; 147     7      49 10.3   69     9  24     20.55556
&gt; 148    14      20 16.6   63     9  25     17.22222
&gt; 149    30     193  6.9   70     9  26     21.11111
&gt; 150    NA     145 13.2   77     9  27     25.00000
&gt; 151    14     191 14.3   75     9  28     23.88889
&gt; 152    18     131  8.0   76     9  29     24.44444
&gt; 153    20     223 11.5   68     9  30     20.00000
```


]
]

---


# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 7**: define una lista de 4 elementos de tipos distintos y accede al segundo de ellos (yo incluiré uno que sea un data.frame para que veas que en una lista cabe de todo).
 
* 📝 **Ejercicio 8**: accede a los elementos que ocupan los lugares 1 y 4 de la lista definida anteriormente.
 
* 📝 **Ejercicio 9**: define una lista de 4 elementos que contenga, en una sola variable, tu nombre, apellido, edad y si estás soltero/a.

* 📝 **Ejercicio 10**: carga el dataset `starwars` del paquete `{dplyr}` y accede a la segunda película que aparece en `starwars$films` (para cada personaje). Determina cuales no no salen en más de una película.

]

.panel[.panel-name[Solución ej. 7]


```r
# Ejemplo: lista con texto, numérico, lógico y un data.frame
lista_ejemplo &lt;- list("nombre" = "Javier", "cp" = 28019,
                      "soltero" = TRUE,
                      "notas" = data.frame("mates" = c(7.5, 8, 9),
                                           "lengua" = c(10, 5, 6)))
lista_ejemplo
```

```
&gt; $nombre
&gt; [1] "Javier"
&gt; 
&gt; $cp
&gt; [1] 28019
&gt; 
&gt; $soltero
&gt; [1] TRUE
&gt; 
&gt; $notas
&gt;   mates lengua
&gt; 1   7.5     10
&gt; 2   8.0      5
&gt; 3   9.0      6
```

]

.panel[.panel-name[Solución ej. 8]


```r
# Accedemos al 1 y al 4
lista_ejemplo[c(1, 4)]
```

```
&gt; $nombre
&gt; [1] "Javier"
&gt; 
&gt; $notas
&gt;   mates lengua
&gt; 1   7.5     10
&gt; 2   8.0      5
&gt; 3   9.0      6
```

```r
# Accedemos por nombre
lista_ejemplo$nombre
```

```
&gt; [1] "Javier"
```

```r
lista_ejemplo$notas
```

```
&gt;   mates lengua
&gt; 1   7.5     10
&gt; 2   8.0      5
&gt; 3   9.0      6
```

```r
lista_ejemplo[c("nombre", "notas")]
```

```
&gt; $nombre
&gt; [1] "Javier"
&gt; 
&gt; $notas
&gt;   mates lengua
&gt; 1   7.5     10
&gt; 2   8.0      5
&gt; 3   9.0      6
```



]

.panel[.panel-name[Solución ej. 9]


```r
# Creamos lista: con lubridate calculamos la diferencia de años desde la fecha de nuestro nacimiento hasta hoy (sea cuando sea hoy)
lista_personal &lt;- list("nombre" = "Javier",
                       "apellidos" = "Álvarez Liébana",
                       "edad" = 32,
                       "soltero" = TRUE)
lista_personal
```

```
&gt; $nombre
&gt; [1] "Javier"
&gt; 
&gt; $apellidos
&gt; [1] "Álvarez Liébana"
&gt; 
&gt; $edad
&gt; [1] 32
&gt; 
&gt; $soltero
&gt; [1] TRUE
```

]

.panel[.panel-name[Solución ej. 10]


```r
library(dplyr)

# accedemos a la segunda película que aparece
# en cada personaje
segunda_peli &lt;- map(starwars$films, 2)

# ¿Cuáles no salen en más de una película?
map_lgl(segunda_peli, is.null)
```

```
&gt;  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE
&gt; [13] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE
&gt; [25]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE
&gt; [37]  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE
&gt; [49] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE
&gt; [61] FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
&gt; [73] FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
&gt; [85]  TRUE  TRUE FALSE
```

]

]

---

class: inverse center middle
name: clase-8

# CLASE 8: introducción a tidyverse

&amp;nbsp;

### [Paquetes tidyverse](#intro-tidyverse)

### [Operaciones con filas](#filas)



---

name: intro-tidyverse

# Introducción a .orange[TIDYVERSE]


.pull-left[

&lt;img src="./img/tidyverrse_universe.jpg" width="89%" style="display: block; margin: auto;" /&gt;

También tenemos los paquetes `{purrr}` y `{lubridate}` para el manejo de **listas** y **fechas**, `{readxl}` para importar archivos **.xls y .xlsx**, `{haven}` para importar archivos **SPSS, Stata y SAS**, `{httr}` para importar **desde web** y `{rvest}` para **web scraping**.


]

.pull-right[

* `{tibble}`: **.bg-purple_light[optimizando data.frame]**.

* `{tidyr}`: **.bg-purple_light[limpiar datos]**.

* `{readr}`: **.bg-purple_light[carga rápida]** de datos rectangulares (formatos .csv, .tsv, etc). 

* `{dplyr}`: gramática para **.bg-purple_light[depuración de datos]** para facilitar su procesamiento.

* `{stringr}`: manejo de **.bg-purple_light[textos]**. 

* `{forcast}` manejo de **.bg-purple_light[cualitativas]**.

* `{ggplot2}`: una gramática para la **.bg-purple_light[visualización de datos]**.

* `{tidymodels}`: una gramática para la **.bg-purple_light[modelización y predicción]**.


]


Puedes ver su **documentación completa** en &lt;https://www.tidyverse.org/&gt;.


---

# Introducción a .orange[TIDYVERSE]


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/tidy_flow.jpg" alt="Flujo deseable de datos según Hadley Wickham, extraída de https://r4ds.had.co.nz/wrangle-intro.html" width="75%" /&gt;
&lt;p class="caption"&gt;Flujo deseable de datos según Hadley Wickham, extraída de https://r4ds.had.co.nz/wrangle-intro.html&lt;/p&gt;
&lt;/div&gt;

&amp;nbsp;

El paquete vamos a usar para **.bg-purple_light[depurar los datos]** será el paquete `{dplyr}`, una gramática para la manipulación de datos.

---

# Introducción a .orange[TIDYVERSE]


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/dplyr.png" alt="Cheet sheet de las opciones del paquete dplyr" width="60%" /&gt;
&lt;p class="caption"&gt;Cheet sheet de las opciones del paquete dplyr&lt;/p&gt;
&lt;/div&gt;

El paquete vamos a usar para **.bg-purple_light[depurar los datos]** será el paquete `{dplyr}`, una gramática para la manipulación de datos.

---

name: filas

# .orange[FILTRAR] registros: filter()

.pull-left[


```r
datos %&gt;%
  filtro(condicion)
```

]

.pull-right[


```r
starwars %&gt;%
  filter(condicion)
```

]

--

Una de las **operaciones más comunes** es **.bg-purple_light[filtrar registros]** en base a alguna **.bg-purple_light[condición lógica]**: con `filter()` se seleccionarán solo individuos que cumplan ciertas condiciones.

--

&amp;nbsp;

Comparadores habituales:

* `==, !=` igual/distinto que
* `&gt;, &lt;` mayor/menor que
* `&gt;=, &lt;=` mayor/menor o igual que
* `%in%` los valores pertenecen a un listado
* `!is.na()` los valores no son ausentes (mejor usar `drop_na()`)
* `between(variable, val1, val2)`: si los valores (normalmente continuos) están dentro de un rango.

---

# .orange[FILTRAR] registros: filter()

.pull-left[


```r
datos %&gt;%
  filtro(condicion)
```

]

.pull-right[


```r
starwars %&gt;%
  filter(condicion)
```

]

&amp;nbsp;

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/tablas_verdad.jpg" alt="Tablas de verdad de operadores lógicos" width="80%" /&gt;
&lt;p class="caption"&gt;Tablas de verdad de operadores lógicos&lt;/p&gt;
&lt;/div&gt;

---

# .orange[FILTRAR] registros: filter()

.pull-left[


```r
datos %&gt;%
  filtro(condicion)
```

]

.pull-right[


```r
starwars %&gt;%
  filter(condicion)
```

]


Por ejemplo, vamos a **filtrar** aquellos personajes con **.bg-purple_light[ojos marrones]**.


```r
starwars %&gt;%
* filter(eye_color == "brown")
```

```
&gt; # A tibble: 21 × 14
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Leia Organa    150  49   brown   light   brown      19   fema… femin… Aldera…
&gt;  2 Biggs Dark…    183  84   black   light   brown      24   male  mascu… Tatooi…
&gt;  3 Han Solo       180  80   brown   fair    brown      29   male  mascu… Corell…
&gt;  4 Yoda            66  17   white   green   brown     896   male  mascu… &lt;NA&gt;   
&gt;  5 Boba Fett      183  78.2 black   fair    brown      31.5 male  mascu… Kamino 
&gt;  6 Lando Calr…    177  79   black   dark    brown      31   male  mascu… Socorro
&gt;  7 Arvel Cryn…     NA  NA   brown   fair    brown      NA   male  mascu… &lt;NA&gt;   
&gt;  8 Wicket Sys…     88  20   brown   brown   brown       8   male  mascu… Endor  
&gt;  9 Quarsh Pan…    183  NA   black   dark    brown      62   &lt;NA&gt;  &lt;NA&gt;   Naboo  
&gt; 10 Shmi Skywa…    163  NA   black   fair    brown      72   fema… femin… Tatooi…
&gt; # … with 11 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[VISUALIZAR] operaciones con datos


En la web &lt;https://tidydatatutor.com/&gt; podemos visualizar el flujo de datos d las transformaciones que podemos hacer con `dplyr`

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/filter1.jpg" alt="Flujo de https://tidydatatutor.com/" width="90%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

]

---

# .orange[FILTRAR] registros: filter()


De la misma manera podemos **filtrar** los personajes que **.bg-purple_light[no tienen ojos marrones]** (en realidad estamos eliminando filas de alguna manera).



```r
starwars %&gt;%
  filter(eye_color != "brown")
```

```
&gt; # A tibble: 66 × 14
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu… Tatooi…
&gt;  3 R2-D2           96    32 &lt;NA&gt;    white,… red        33   none  mascu… Naboo  
&gt;  4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…
&gt;  5 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…
&gt;  6 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…
&gt;  7 R5-D4           97    32 &lt;NA&gt;    white,… red        NA   none  mascu… Tatooi…
&gt;  8 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon
&gt;  9 Anakin Sky…    188    84 blond   fair    blue       41.9 male  mascu… Tatooi…
&gt; 10 Wilhuff Ta…    180    NA auburn… fair    blue       64   male  mascu… Eriadu 
&gt; # … with 56 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[FILTRAR] registros: filter()



Al ser una variable discreta, sería bastante lógico comprobar si toma algún valor **.bg-purple_light[dentro de una lista permitida]**  (por ejemplo, personjes con ojos marrones o azules).



```r
starwars %&gt;%
  filter(eye_color %in% c("brown", "blue"))
```

```
&gt; # A tibble: 40 × 14
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…
&gt;  2 Leia Organa    150    49 brown   light   brown      19   fema… femin… Aldera…
&gt;  3 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…
&gt;  4 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…
&gt;  5 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…
&gt;  6 Anakin Sky…    188    84 blond   fair    blue       41.9 male  mascu… Tatooi…
&gt;  7 Wilhuff Ta…    180    NA auburn… fair    blue       64   male  mascu… Eriadu 
&gt;  8 Chewbacca      228   112 brown   unknown blue      200   male  mascu… Kashyy…
&gt;  9 Han Solo       180    80 brown   fair    brown      29   male  mascu… Corell…
&gt; 10 Jek Tono P…    180   110 brown   fair    blue       NA   male  mascu… Bestin…
&gt; # … with 30 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[FILTRAR] registros: filter()

Cuando es una variable continua el interés podría estar en comprobar si la variable toma valores **.bg-purple_light[dentro de un intervalo continuo]**.


.pull-left[


```r
starwars %&gt;%
  filter(between(height, 120, 160))
```


```
&gt; # A tibble: 5 × 4
&gt;   name        height  mass eye_color
&gt;   &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;    
&gt; 1 Leia Organa    150    49 brown    
&gt; 2 Mon Mothma     150    NA blue     
&gt; 3 Nien Nunb      160    68 black    
&gt; 4 Watto          137    NA yellow   
&gt; 5 Gasgano        122    NA black
```

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/filter3.jpg" alt="Flujo de https://tidydatatutor.com/" width="150%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

]


---


# .orange[FILTRAR] registros: filter()


Las condiciones también se pueden **.bg-purple_light[concatenar]**, pudiendo en pocas líneas realizar un filtro complejo. Por ejemplo, podemos filtrar los personajes con **.bg-purple_light[ojos marrones Y ADEMÁS NO humanos]**, o **.bg-purple_light[con más de 60 años]**.

.pull-left[


```r
starwars %&gt;%
  filter((eye_color == "brown" &amp;
            species != "Human") |
           birth_year &gt; 60)
```

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/filter5.jpg" alt="Flujo de https://tidydatatutor.com/" width="100%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;


]

---

# .orange[FILTRAR] datos ausentes

Podemos también **.bg-purple_light[filtrar los registros ausentes]** en alguna de sus variables con `drop_na()`. Si no especificamos, elimina todos los registros que tenga alguno de sus campos ausente.


```r
starwars %&gt;% drop_na()
```

--

Podemos indicarle que nos elimine filas con datos ausentes fijándonos solo en **.bg-purple_light[alguna variable particular]**.


```r
starwars %&gt;% drop_na(mass, height, sex, gender)
```

```
&gt; # A tibble: 58 × 14
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu… Tatooi…
&gt;  3 R2-D2           96    32 &lt;NA&gt;    white,… red        33   none  mascu… Naboo  
&gt;  4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…
&gt;  5 Leia Organa    150    49 brown   light   brown      19   fema… femin… Aldera…
&gt;  6 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…
&gt;  7 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…
&gt;  8 R5-D4           97    32 &lt;NA&gt;    white,… red        NA   none  mascu… Tatooi…
&gt;  9 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…
&gt; 10 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon
&gt; # … with 48 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---


# Ejercicios (filtro)

.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: selecciona del conjunto de `starwars` solo los personajes que sean humanos (`species == "Human"`)

* 📝 **Ejercicio 2**: selecciona del conjunto de `starwars` solo los personajes cuyo peso esté entre 65 y 90 kg.

* 📝 **Ejercicio 3**: selecciona del conjunto de `starwars` los personajes con ojos marrones o rojos.

* 📝 **Ejercicio 4**: selecciona del conjunto de `starwars` los personajes no humanos, hombres y que midan más de 170 cm, o los personajes con ojos marrones o rojos.

* 📝 **Ejercicio 5**: selecciona aquellos personajes de `starwars` que hayan pilotado más de 2 naves.

]

.panel[.panel-name[Sol. Ej. 1]


```r
starwars %&gt;%
  filter(species == "Human")
```

```
&gt; # A tibble: 35 × 14
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…
&gt;  2 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…
&gt;  3 Leia Organa    150    49 brown   light   brown      19   fema… femin… Aldera…
&gt;  4 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…
&gt;  5 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…
&gt;  6 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…
&gt;  7 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon
&gt;  8 Anakin Sky…    188    84 blond   fair    blue       41.9 male  mascu… Tatooi…
&gt;  9 Wilhuff Ta…    180    NA auburn… fair    blue       64   male  mascu… Eriadu 
&gt; 10 Han Solo       180    80 brown   fair    brown      29   male  mascu… Corell…
&gt; # … with 25 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 2]


```r
starwars %&gt;%
  filter(between(mass, 65, 90))
```

```
&gt; # A tibble: 32 × 14
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu… Tatooi…
&gt;  3 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…
&gt;  4 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…
&gt;  5 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon
&gt;  6 Anakin Sky…    188    84 blond   fair    blue       41.9 male  mascu… Tatooi…
&gt;  7 Han Solo       180    80 brown   fair    brown      29   male  mascu… Corell…
&gt;  8 Greedo         173    74 &lt;NA&gt;    green   black      44   male  mascu… Rodia  
&gt;  9 Wedge Anti…    170    77 brown   fair    hazel      21   male  mascu… Corell…
&gt; 10 Palpatine      170    75 grey    pale    yellow     82   male  mascu… Naboo  
&gt; # … with 22 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 3]


```r
starwars %&gt;%
  filter(eye_color %in% c("brown", "red"))
```

```
&gt; # A tibble: 26 × 14
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 R2-D2           96  32   &lt;NA&gt;    white,… red        33   none  mascu… Naboo  
&gt;  2 Leia Organa    150  49   brown   light   brown      19   fema… femin… Aldera…
&gt;  3 R5-D4           97  32   &lt;NA&gt;    white,… red        NA   none  mascu… Tatooi…
&gt;  4 Biggs Dark…    183  84   black   light   brown      24   male  mascu… Tatooi…
&gt;  5 Han Solo       180  80   brown   fair    brown      29   male  mascu… Corell…
&gt;  6 Yoda            66  17   white   green   brown     896   male  mascu… &lt;NA&gt;   
&gt;  7 Boba Fett      183  78.2 black   fair    brown      31.5 male  mascu… Kamino 
&gt;  8 IG-88          200 140   none    metal   red        15   none  mascu… &lt;NA&gt;   
&gt;  9 Bossk          190 113   none    green   red        53   male  mascu… Trando…
&gt; 10 Lando Calr…    177  79   black   dark    brown      31   male  mascu… Socorro
&gt; # … with 16 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 4]


```r
starwars %&gt;%
  filter((species != "Human" &amp; sex == "Male" &amp; height &gt; 170) |
           eye_color %in% c("brown", "red"))
```

```
&gt; # A tibble: 26 × 14
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 R2-D2           96  32   &lt;NA&gt;    white,… red        33   none  mascu… Naboo  
&gt;  2 Leia Organa    150  49   brown   light   brown      19   fema… femin… Aldera…
&gt;  3 R5-D4           97  32   &lt;NA&gt;    white,… red        NA   none  mascu… Tatooi…
&gt;  4 Biggs Dark…    183  84   black   light   brown      24   male  mascu… Tatooi…
&gt;  5 Han Solo       180  80   brown   fair    brown      29   male  mascu… Corell…
&gt;  6 Yoda            66  17   white   green   brown     896   male  mascu… &lt;NA&gt;   
&gt;  7 Boba Fett      183  78.2 black   fair    brown      31.5 male  mascu… Kamino 
&gt;  8 IG-88          200 140   none    metal   red        15   none  mascu… &lt;NA&gt;   
&gt;  9 Bossk          190 113   none    green   red        53   male  mascu… Trando…
&gt; 10 Lando Calr…    177  79   black   dark    brown      31   male  mascu… Socorro
&gt; # … with 16 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 5]


```r
library(purrr) # ya está en tidyverse per por si
starwars$n_starships &lt;- starwars$starships %&gt;% map_int(length)
starwars %&gt;% filter(n_starships &gt; 2)
```

```
&gt; # A tibble: 3 × 15
&gt;   name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Obi-Wan Ken…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon
&gt; 2 Anakin Skyw…    188    84 blond   fair    blue       41.9 male  mascu… Tatooi…
&gt; 3 Padmé Amida…    165    45 brown   light   brown      46   fema… femin… Naboo  
&gt; # … with 5 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, n_starships &lt;int&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```



]

]

---

# Ejercicio extra


Veamos un ejercicio extra para comprobar la **potencia y flexibilidad** de `{tidyverse}`, pudiendo hacer muchas cosas en dos líneas de código.

&amp;nbsp;

* 📝 **Ejercicio extra**: selecciona aquellos personajes de `starwars` que hayan salido en la película de la saga "El ataque de los clones" (en inglés, "Attack of the Clones"). Busca información de la función `str_detect()` del paquete `stringr`. Consejo: prueba antes las funciones que vayas a usar con algún vector de prueba para poder comprobar su funcionamiento.

---

# .orange[FILTRAR] registros:  slice()


.pull-left[


```r
datos %&gt;%
  rebanada(posicion)
```

]

.pull-right[


```r
starwars %&gt;%
  slice(posicion)
```

]

--

Normalmente filtraremos registros por alguna condición pero no siempre, a veces nos puede interesar, por ejemplo, sacar las primeras n filas. Para podemos crear **.bg-purple_light[rebanadas de los datos]**, seleccionando filas por su posición con `slice()`.


```r
*starwars %&gt;% slice(1)
```

```
&gt; # A tibble: 1 × 14
&gt;   name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Luke Skywal…    172    77 blond   fair    blue         19 male  mascu… Tatooi…
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```

---

# .orange[FILTRAR] registros:  slice()

.pull-left[


```r
datos %&gt;%
  rebanada(posicion)
```

]

.pull-right[


```r
starwars %&gt;%
  slice(posicion)
```

]


Recuerda que todo lo que podemos hacer con un número (vector de longitud 1) podemos hacerlo con un vector de índices, así que podemos **.bg-purple_light[extraer varias rebanadas]**, a la vez.


```r
# filas de la 1 a la 5
starwars %&gt;% slice(1:5)
```

```
&gt; # A tibble: 5 × 14
&gt;   name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Luke Skywal…    172    77 blond   fair    blue       19   male  mascu… Tatooi…
&gt; 2 C-3PO           167    75 &lt;NA&gt;    gold    yellow    112   none  mascu… Tatooi…
&gt; 3 R2-D2            96    32 &lt;NA&gt;    white,… red        33   none  mascu… Naboo  
&gt; 4 Darth Vader     202   136 none    white   yellow     41.9 male  mascu… Tatooi…
&gt; 5 Leia Organa     150    49 brown   light   brown      19   fema… femin… Aldera…
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```

---

# .orange[FILTRAR] registros:  slice()

También podríamos usar una **.bg-purple_light[secuencia de índices]** a extraer.


```r
# filas 1, 2, 10, 13, 27
starwars %&gt;% slice(c(1, 2, 10, 13, 27))
```

```
&gt; # A tibble: 5 × 14
&gt;   name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Luke Skywal…    172    77 blond   fair    blue         19 male  mascu… Tatooi…
&gt; 2 C-3PO           167    75 &lt;NA&gt;    gold    yellow      112 none  mascu… Tatooi…
&gt; 3 Obi-Wan Ken…    182    77 auburn… fair    blue-g…      57 male  mascu… Stewjon
&gt; 4 Chewbacca       228   112 brown   unknown blue        200 male  mascu… Kashyy…
&gt; 5 Mon Mothma      150    NA auburn  fair    blue         48 fema… femin… Chandr…
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```


---

# .orange[FILTRAR] registros:  slice()


Disponemos además de opciones por defecto de operaciones habituales

* `slice_head(n = ...)`: extraer las n **.bg-purple_light[primeras filas]**.



```r
# las 2 primeras filas
starwars %&gt;% slice_head(n = 2)
```

```
&gt; # A tibble: 2 × 14
&gt;   name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Luke Skywal…    172    77 blond   fair    blue         19 male  mascu… Tatooi…
&gt; 2 C-3PO           167    75 &lt;NA&gt;    gold    yellow      112 none  mascu… Tatooi…
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```

---


# .orange[FILTRAR] registros:  slice()

* `slice_tail(n = ...)`: extraer las n **.bg-purple_light[últimas filas]**.


```r
# los 3 últimas filas
starwars %&gt;% slice_tail(n = 3) 
```

```
&gt; # A tibble: 3 × 14
&gt;   name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 BB8              NA    NA none    none    black        NA none  mascu… &lt;NA&gt;   
&gt; 2 Captain Pha…     NA    NA unknown unknown unknown      NA &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;   
&gt; 3 Padmé Amida…    165    45 brown   light   brown        46 fema… femin… Naboo  
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```

---

# .orange[FILTRAR] registros:  slice()

* `slice_sample(n = ...)`: extraer n **.bg-purple_light[registros aleatoriamente]** (a priori equiprobables). Podemos indicar el número o la proporción




```r
# 3 registros aleatorios
starwars %&gt;% slice_sample(n = 3)
```

```
&gt; # A tibble: 3 × 14
&gt;   name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Captain Pha…     NA    NA unknown unknown unknown      NA &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;   
&gt; 2 Nute Gunray     191    90 none    mottle… red          NA male  mascu… Cato N…
&gt; 3 C-3PO           167    75 &lt;NA&gt;    gold    yellow      112 none  mascu… Tatooi…
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```

---

# .orange[FILTRAR] registros:  slice()

* `slice_sample(n = ...)`: extraer n **.bg-purple_light[registros aleatoriamente]** (a priori equiprobables). Podemos indicar el número o la proporción



```r
# 2.5% de los datos
starwars %&gt;% slice_sample(prop = 0.025)
```

```
&gt; # A tibble: 2 × 14
&gt;   name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Wedge Antil…    170  77   brown   fair    hazel        21 male  mascu… Corell…
&gt; 2 Luminara Un…    170  56.2 black   yellow  blue         58 fema… femin… Mirial 
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```

---

# .orange[FILTRAR] registros:  slice()

En `slice_sample(n = ...)` podemos incluso pasarlo un vector de probabilidades. Vamos a forzar que sea muy improbable sacar una fila que no sean las dos primeras


```r
starwars %&gt;% slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```


```
&gt; # A tibble: 2 × 9
&gt;   name           height  mass hair_color skin_color eye_c…¹ birth…² sex   gender
&gt;   &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt; 1 Luke Skywalker    172    77 blond      fair       blue         19 male  mascu…
&gt; 2 C-3PO             167    75 &lt;NA&gt;       gold       yellow      112 none  mascu…
&gt; # … with abbreviated variable names ¹​eye_color, ²​birth_year
```


```r
starwars %&gt;% slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```


```
&gt; # A tibble: 2 × 9
&gt;   name           height  mass hair_color skin_color eye_c…¹ birth…² sex   gender
&gt;   &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt; 1 Luke Skywalker    172    77 blond      fair       blue         19 male  mascu…
&gt; 2 C-3PO             167    75 &lt;NA&gt;       gold       yellow      112 none  mascu…
&gt; # … with abbreviated variable names ¹​eye_color, ²​birth_year
```

---


# .orange[FILTRAR] registros: slice()


* `slice_min(var, n = ...)` y `slice_max(var, n = ...)`: extrae las n filas con **.bg-purple_light[menor/mayor de una variable]** (si hay empate, mostrará todas salvo que `with_ties = FALSE`). 

.pull-left[


```r
# los 3 más bajitos
starwars %&gt;% slice_min(height, n = 3) 
```


```
&gt; # A tibble: 3 × 4
&gt;   name                  height  mass hair_color
&gt;   &lt;chr&gt;                  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;     
&gt; 1 Yoda                      66    17 white     
&gt; 2 Ratts Tyerell             79    15 none      
&gt; 3 Wicket Systri Warrick     88    20 brown
```

]

.pull-right[


```r
# los 3 más pesados
starwars %&gt;% slice_max(mass, n = 3) 
```


```
&gt; # A tibble: 3 × 4
&gt;   name                  height  mass hair_color
&gt;   &lt;chr&gt;                  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;     
&gt; 1 Jabba Desilijic Tiure    175  1358 &lt;NA&gt;      
&gt; 2 Grievous                 216   159 none      
&gt; 3 IG-88                    200   140 none
```

]

---

# .orange[REORDENAR] filas: rearrange()

.pull-left[


```r
datos %&gt;%
  ordeno(var1, desc(var2))
```

]

.pull-right[


```r
starwars %&gt;%
  arrange(var1, desc(var2))
```

]

--

Otra operación será **.bg-purple_light[ordenar filas]** con `arrange()`, pasándole las variables que usaremos para la ordenación (por defecto de menor a mayor, podemos invertirlo usando `desc()`. Por ejemplo, vamos a **ordenar** por altura, de bajitos a altos, y en caso de empate, por peso (pero al revés, de pesados a ligeros).




```r
starwars %&gt;% arrange(height, desc(mass))
```

```
&gt; # A tibble: 87 × 14
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Yoda            66    17 white   green   brown       896 male  mascu… &lt;NA&gt;   
&gt;  2 Ratts Tyer…     79    15 none    grey, … unknown      NA male  mascu… Aleen …
&gt;  3 Wicket Sys…     88    20 brown   brown   brown         8 male  mascu… Endor  
&gt;  4 Dud Bolt        94    45 none    blue, … yellow       NA male  mascu… Vulpter
&gt;  5 R2-D2           96    32 &lt;NA&gt;    white,… red          33 none  mascu… Naboo  
&gt;  6 R4-P17          96    NA none    silver… red, b…      NA none  femin… &lt;NA&gt;   
&gt;  7 R5-D4           97    32 &lt;NA&gt;    white,… red          NA none  mascu… Tatooi…
&gt;  8 Sebulba        112    40 none    grey, … orange       NA male  mascu… Malast…
&gt;  9 Gasgano        122    NA none    white,… black        NA male  mascu… Troiken
&gt; 10 Watto          137    NA black   blue, … yellow       NA male  mascu… Toydar…
&gt; # … with 77 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[ELIMINAR] duplicados: distinct()

Otra opción es **.bg-purple_light[eliminar filas duplicadas]** con `distinct()`, pasándole como argumentos las variables. Por defecto, solo extrae las columnas en base a las cuales hemos eliminado duplicados. Si queremos que nos **mantenga todas** deberemos explicitarlo con `.keep_all = TRUE`.

.pull-left[


```r
# Elimina filas con igual (color_pelo, color_ojos)
starwars %&gt;% distinct(hair_color, eye_color)
```

```
&gt; # A tibble: 35 × 2
&gt;    hair_color    eye_color
&gt;    &lt;chr&gt;         &lt;chr&gt;    
&gt;  1 blond         blue     
&gt;  2 &lt;NA&gt;          yellow   
&gt;  3 &lt;NA&gt;          red      
&gt;  4 none          yellow   
&gt;  5 brown         brown    
&gt;  6 brown, grey   blue     
&gt;  7 brown         blue     
&gt;  8 black         brown    
&gt;  9 auburn, white blue-gray
&gt; 10 auburn, grey  blue     
&gt; # … with 25 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

]

.pull-left[


```r
# Elimina filas con igual (color_pelo, color_ojos)
starwars %&gt;% distinct(hair_color, eye_color, .keep_all = TRUE)
```

```
&gt; # A tibble: 35 × 14
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu… Tatooi…
&gt;  3 R2-D2           96    32 &lt;NA&gt;    white,… red        33   none  mascu… Naboo  
&gt;  4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…
&gt;  5 Leia Organa    150    49 brown   light   brown      19   fema… femin… Aldera…
&gt;  6 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…
&gt;  7 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…
&gt;  8 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…
&gt;  9 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon
&gt; 10 Wilhuff Ta…    180    NA auburn… fair    blue       64   male  mascu… Eriadu 
&gt; # … with 25 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]
  
---

# .orange[AÑADIR] filas: bind_rows()

Si quisiéramos **.bg-purple_light[añadir un nuevo registro]** manualmente, podremos hacerlo con `bind_rows()`, asegurándonos que las **variables en el nuevo registro son las mismas** que en el original. Por ejemplo, vamos a añadir al fichero original los 3 primeros registros (al final).


```r
starwars_nuevo &lt;- bind_rows(starwars, starwars %&gt;% slice(1:3))
dim(starwars)
```

```
&gt; [1] 87 14
```

```r
dim(starwars_nuevo)
```

```
&gt; [1] 90 14
```

---

# .orange[OPERACIONES] por filas

Con **.bg-purple_light[pocas líneas de código]** podemos manipular ágilmente los registros de nuestros datos, de una manera **.bg-purple_light[muy literal]**

.pull-left[


```r
datos %&gt;%
* filtro(peso &lt; 200 y ojos marrones)
```

]

.pull-right[


```r
starwars %&gt;%
  filter(mass &lt; 200 &amp;
*          eye_color == "brown")
```

```
&gt; # A tibble: 13 × 14
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Leia Organa    150  49   brown   light   brown      19   fema… femin… Aldera…
&gt;  2 Biggs Dark…    183  84   black   light   brown      24   male  mascu… Tatooi…
&gt;  3 Han Solo       180  80   brown   fair    brown      29   male  mascu… Corell…
&gt;  4 Yoda            66  17   white   green   brown     896   male  mascu… &lt;NA&gt;   
&gt;  5 Boba Fett      183  78.2 black   fair    brown      31.5 male  mascu… Kamino 
&gt;  6 Lando Calr…    177  79   black   dark    brown      31   male  mascu… Socorro
&gt;  7 Wicket Sys…     88  20   brown   brown   brown       8   male  mascu… Endor  
&gt;  8 Mace Windu     188  84   none    dark    brown      72   male  mascu… Haruun…
&gt;  9 Gregar Typ…    185  85   black   dark    brown      NA   male  mascu… Naboo  
&gt; 10 Dooku          193  80   white   fair    brown     102   male  mascu… Serenno
&gt; 11 Jango Fett     183  79   black   tan     brown      66   male  mascu… Concor…
&gt; 12 Raymus Ant…    188  79   brown   light   brown      NA   male  mascu… Aldera…
&gt; 13 Padmé Amid…    165  45   brown   light   brown      46   fema… femin… Naboo  
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```

]

---

# .orange[OPERACIONES] por filas

Con **.bg-purple_light[pocas líneas de código]** podemos manipular ágilmente los registros de nuestros datos, de una manera **.bg-purple_light[muy literal]**

.pull-left[


```r
datos %&gt;%
  filtro(peso &lt; 200 y ojos marrones) %&gt;% 
* quito_na(estatura y peso)
```

]

.pull-right[


```r
starwars %&gt;%
  filter(mass &lt; 200 &amp;
           eye_color == "brown") %&gt;% 
* drop_na(mass, height)
```

```
&gt; # A tibble: 13 × 14
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Leia Organa    150  49   brown   light   brown      19   fema… femin… Aldera…
&gt;  2 Biggs Dark…    183  84   black   light   brown      24   male  mascu… Tatooi…
&gt;  3 Han Solo       180  80   brown   fair    brown      29   male  mascu… Corell…
&gt;  4 Yoda            66  17   white   green   brown     896   male  mascu… &lt;NA&gt;   
&gt;  5 Boba Fett      183  78.2 black   fair    brown      31.5 male  mascu… Kamino 
&gt;  6 Lando Calr…    177  79   black   dark    brown      31   male  mascu… Socorro
&gt;  7 Wicket Sys…     88  20   brown   brown   brown       8   male  mascu… Endor  
&gt;  8 Mace Windu     188  84   none    dark    brown      72   male  mascu… Haruun…
&gt;  9 Gregar Typ…    185  85   black   dark    brown      NA   male  mascu… Naboo  
&gt; 10 Dooku          193  80   white   fair    brown     102   male  mascu… Serenno
&gt; 11 Jango Fett     183  79   black   tan     brown      66   male  mascu… Concor…
&gt; 12 Raymus Ant…    188  79   brown   light   brown      NA   male  mascu… Aldera…
&gt; 13 Padmé Amid…    165  45   brown   light   brown      46   fema… femin… Naboo  
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```

]

---

# .orange[OPERACIONES] por filas

Con **.bg-purple_light[pocas líneas de código]** podemos manipular ágilmente los registros de nuestros datos, de una manera **.bg-purple_light[muy literal]**

.pull-left[


```r
datos %&gt;%
  filtro(peso &lt; 200 y ojos marrones) %&gt;% 
  quito_na(estatura y peso) %&gt;%
* rebanada(7 primeras filas)
```

]

.pull-right[


```r
starwars %&gt;%
  filter(mass &lt; 200 &amp;
           eye_color == "brown") %&gt;% 
  drop_na(mass, height) %&gt;%
* slice(1:7)
```

```
&gt; # A tibble: 7 × 14
&gt;   name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Leia Organa     150  49   brown   light   brown      19   fema… femin… Aldera…
&gt; 2 Biggs Darkl…    183  84   black   light   brown      24   male  mascu… Tatooi…
&gt; 3 Han Solo        180  80   brown   fair    brown      29   male  mascu… Corell…
&gt; 4 Yoda             66  17   white   green   brown     896   male  mascu… &lt;NA&gt;   
&gt; 5 Boba Fett       183  78.2 black   fair    brown      31.5 male  mascu… Kamino 
&gt; 6 Lando Calri…    177  79   black   dark    brown      31   male  mascu… Socorro
&gt; 7 Wicket Syst…     88  20   brown   brown   brown       8   male  mascu… Endor  
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```

]


---

# .orange[OPERACIONES] por filas

Con **.bg-purple_light[pocas líneas de código]** podemos manipular ágilmente los registros de nuestros datos, de una manera **.bg-purple_light[muy literal]**

.pull-left[


```r
datos %&gt;%
  filtro(peso &lt; 200 y ojos marrones) %&gt;% 
  quito_na(estatura y peso) %&gt;%
  rebanada(7 primeras filas) %&gt;%
* ordeno(peso, si empate pesados 1º)
```

]

.pull-right[


```r
starwars %&gt;%
  filter(mass &lt; 200 &amp;
           eye_color == "brown") %&gt;% 
  drop_na(mass, height) %&gt;%
  slice(1:7) %&gt;%
* arrange(height, desc(mass))
```

```
&gt; # A tibble: 7 × 14
&gt;   name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Yoda             66  17   white   green   brown     896   male  mascu… &lt;NA&gt;   
&gt; 2 Wicket Syst…     88  20   brown   brown   brown       8   male  mascu… Endor  
&gt; 3 Leia Organa     150  49   brown   light   brown      19   fema… femin… Aldera…
&gt; 4 Lando Calri…    177  79   black   dark    brown      31   male  mascu… Socorro
&gt; 5 Han Solo        180  80   brown   fair    brown      29   male  mascu… Corell…
&gt; 6 Biggs Darkl…    183  84   black   light   brown      24   male  mascu… Tatooi…
&gt; 7 Boba Fett       183  78.2 black   fair    brown      31.5 male  mascu… Kamino 
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```

]


---

# .orange[OPERACIONES] por filas

Con **.bg-purple_light[pocas líneas de código]** podemos manipular ágilmente los registros de nuestros datos, de una manera **.bg-purple_light[muy literal]**

.pull-left[


```r
datos %&gt;%
  filtro(peso &lt; 200 y ojos marrones) %&gt;% 
  quito_na(estatura y peso) %&gt;%
  rebanada(7 primeras filas) %&gt;%
  ordeno(peso, si empate pesados 1º) %&gt;%
* quito_duplicados(color de piel)
```

]

.pull-right[


```r
starwars %&gt;%
  filter(mass &lt; 200 &amp;
           eye_color == "brown") %&gt;% 
  drop_na(mass, height) %&gt;%
  slice(1:7) %&gt;%
  arrange(height, desc(mass)) %&gt;%
  distinct(skin_color,
*          .keep_all = TRUE)
```

```
&gt; # A tibble: 5 × 14
&gt;   name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Yoda             66    17 white   green   brown       896 male  mascu… &lt;NA&gt;   
&gt; 2 Wicket Syst…     88    20 brown   brown   brown         8 male  mascu… Endor  
&gt; 3 Leia Organa     150    49 brown   light   brown        19 fema… femin… Aldera…
&gt; 4 Lando Calri…    177    79 black   dark    brown        31 male  mascu… Socorro
&gt; 5 Han Solo        180    80 brown   fair    brown        29 male  mascu… Corell…
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```

]

---



# Ejercicios (filas)

.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: selecciona solo los personajes que sean humanos y de ojos marrones, para después ordernarlos en altura descendente y peso ascendente.

* 📝 **Ejercicio 2**:  extrae 3 registros aleatoriamente. Vuelve a hacerlo para comprobar que salen diferentes.

* 📝 **Ejercicio 3**:  extrae el 10% de los registros aleatoriamente.

* 📝 **Ejercicio 4**: selecciona los 3 personajes más mayores y los 3 personajes más bajitos.

* 📝 **Ejercicio 5**: para saber que valores únicos hay en el color de pelo, elimina duplicados por dicha variable `hair_color`, eliminando antes los ausentes de dicha variable.


]

.panel[.panel-name[Sol. Ej. 1]


```r
# Podemos combinar varias acciones en pocas líneas
starwars %&gt;%
  filter(eye_color == "brown",
         species == "Human") %&gt;%
  arrange(height, desc(mass))
```

```
&gt; # A tibble: 17 × 14
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Leia Organa    150  49   brown   light   brown      19   fema… femin… Aldera…
&gt;  2 Cordé          157  NA   brown   light   brown      NA   fema… femin… Naboo  
&gt;  3 Shmi Skywa…    163  NA   black   fair    brown      72   fema… femin… Tatooi…
&gt;  4 Padmé Amid…    165  45   brown   light   brown      46   fema… femin… Naboo  
&gt;  5 Dormé          165  NA   brown   light   brown      NA   fema… femin… Naboo  
&gt;  6 Lando Calr…    177  79   black   dark    brown      31   male  mascu… Socorro
&gt;  7 Han Solo       180  80   brown   fair    brown      29   male  mascu… Corell…
&gt;  8 Biggs Dark…    183  84   black   light   brown      24   male  mascu… Tatooi…
&gt;  9 Jango Fett     183  79   black   tan     brown      66   male  mascu… Concor…
&gt; 10 Boba Fett      183  78.2 black   fair    brown      31.5 male  mascu… Kamino 
&gt; 11 Gregar Typ…    185  85   black   dark    brown      NA   male  mascu… Naboo  
&gt; 12 Mace Windu     188  84   none    dark    brown      72   male  mascu… Haruun…
&gt; 13 Raymus Ant…    188  79   brown   light   brown      NA   male  mascu… Aldera…
&gt; 14 Bail Prest…    191  NA   black   tan     brown      67   male  mascu… Aldera…
&gt; 15 Dooku          193  80   white   fair    brown     102   male  mascu… Serenno
&gt; 16 Arvel Cryn…     NA  NA   brown   fair    brown      NA   male  mascu… &lt;NA&gt;   
&gt; 17 Poe Dameron     NA  NA   brown   light   brown      NA   male  mascu… &lt;NA&gt;   
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 2]


```r
starwars %&gt;%
  slice_sample(n = 3)
```

```
&gt; # A tibble: 3 × 14
&gt;   name       height  mass hair_co…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;   &lt;chr&gt;       &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Tarfful       234   136 brown     brown   blue         NA male  mascu… Kashyy…
&gt; 2 Kit Fisto     196    87 none      green   black        NA male  mascu… Glee A…
&gt; 3 Rugor Nass    206    NA none      green   orange       NA male  mascu… Naboo  
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```


```r
starwars %&gt;%
  slice_sample(n = 3)
```

```
&gt; # A tibble: 3 × 14
&gt;   name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Luke Skywal…    172    77 blond   fair    blue         19 male  mascu… Tatooi…
&gt; 2 Taun We         213    NA none    grey    black        NA fema… femin… Kamino 
&gt; 3 Beru Whites…    165    75 brown   light   blue         47 fema… femin… Tatooi…
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```


]

.panel[.panel-name[Sol. Ej. 3]


```r
starwars %&gt;%
  slice_sample(prop = 0.1)
```

```
&gt; # A tibble: 8 × 14
&gt;   name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Greedo          173    74 &lt;NA&gt;    green   black        44 male  mascu… Rodia  
&gt; 2 Jango Fett      183    79 black   tan     brown        66 male  mascu… Concor…
&gt; 3 Tarfful         234   136 brown   brown   blue         NA male  mascu… Kashyy…
&gt; 4 Wicket Syst…     88    20 brown   brown   brown         8 male  mascu… Endor  
&gt; 5 R5-D4            97    32 &lt;NA&gt;    white,… red          NA none  mascu… Tatooi…
&gt; 6 Captain Pha…     NA    NA unknown unknown unknown      NA &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;   
&gt; 7 Han Solo        180    80 brown   fair    brown        29 male  mascu… Corell…
&gt; 8 Wilhuff Tar…    180    NA auburn… fair    blue         64 male  mascu… Eriadu 
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 4]



```r
starwars %&gt;%
  slice_max(birth_year, n = 3)
```

```
&gt; # A tibble: 3 × 14
&gt;   name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Yoda             66    17 white   green   brown       896 male  mascu… &lt;NA&gt;   
&gt; 2 Jabba Desil…    175  1358 &lt;NA&gt;    green-… orange      600 herm… mascu… Nal Hu…
&gt; 3 Chewbacca       228   112 brown   unknown blue        200 male  mascu… Kashyy…
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```


```r
starwars %&gt;%
  slice_min(height, n = 3)
```

```
&gt; # A tibble: 3 × 14
&gt;   name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;   &lt;chr&gt;         &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt; 1 Yoda             66    17 white   green   brown       896 male  mascu… &lt;NA&gt;   
&gt; 2 Ratts Tyere…     79    15 none    grey, … unknown      NA male  mascu… Aleen …
&gt; 3 Wicket Syst…     88    20 brown   brown   brown         8 male  mascu… Endor  
&gt; # … with 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `colnames()` to see all variable names
```
]

.panel[.panel-name[Sol. Ej. 5]



```r
starwars %&gt;%
  drop_na(hair_color) %&gt;%
  distinct(hair_color)
```

```
&gt; # A tibble: 12 × 1
&gt;    hair_color   
&gt;    &lt;chr&gt;        
&gt;  1 blond        
&gt;  2 none         
&gt;  3 brown        
&gt;  4 brown, grey  
&gt;  5 black        
&gt;  6 auburn, white
&gt;  7 auburn, grey 
&gt;  8 white        
&gt;  9 grey         
&gt; 10 auburn       
&gt; 11 blonde       
&gt; 12 unknown
```

]

]

---

# Ejercicio extra


Veamos un ejercicio extra para comprobar la **potencia y flexibilidad** de `{tidyverse}`, pudiendo hacer muchas cosas en dos líneas de código.

&amp;nbsp;

* 📝 **Ejercicio extra**: de los personajes que son humanos y miden más de 160 cm, elimina duplicados en color de ojos, elimina ausentes en peso, selecciona los 5 más altos, y orden de mayor a menor peso. Devuelve la tabla.


---


class: inverse center middle
name: clase-9

# CLASE 9: operaciones con columnas y resúmenes estadísticos (tidyverse)

&amp;nbsp;

### [Operaciones con columnas](#columnas)

### [Modificar columnas](#mutate)

---

name: columnas

# .orange[SELECCIONAR] columnas:  select()

.pull-left[


```r
datos %&gt;%
  selecciono(col1, col2, ...)
```

]

.pull-right[


```r
starwars %&gt;%
  select(col1, col2, ...)
```

]

--

La opción más sencilla para **.bg-purple_light[seleccionar variables]** es `select()`, dando como argumentos los nombres de columnas. Por ejemplo, vamos a seleccionar las variables `names` y `hair_color`


```r
starwars %&gt;%
* select(name, hair_color)
```

```
&gt; # A tibble: 87 × 2
&gt;    name               hair_color   
&gt;    &lt;chr&gt;              &lt;chr&gt;        
&gt;  1 Luke Skywalker     blond        
&gt;  2 C-3PO              &lt;NA&gt;         
&gt;  3 R2-D2              &lt;NA&gt;         
&gt;  4 Darth Vader        none         
&gt;  5 Leia Organa        brown        
&gt;  6 Owen Lars          brown, grey  
&gt;  7 Beru Whitesun lars brown        
&gt;  8 R5-D4              &lt;NA&gt;         
&gt;  9 Biggs Darklighter  black        
&gt; 10 Obi-Wan Kenobi     auburn, white
&gt; # … with 77 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```


---

# .orange[SELECCIONAR] columnas:  select()

.pull-left[


```r
starwars %&gt;% select(name, hair_color)
```

```
&gt; # A tibble: 87 × 2
&gt;    name               hair_color   
&gt;    &lt;chr&gt;              &lt;chr&gt;        
&gt;  1 Luke Skywalker     blond        
&gt;  2 C-3PO              &lt;NA&gt;         
&gt;  3 R2-D2              &lt;NA&gt;         
&gt;  4 Darth Vader        none         
&gt;  5 Leia Organa        brown        
&gt;  6 Owen Lars          brown, grey  
&gt;  7 Beru Whitesun lars brown        
&gt;  8 R5-D4              &lt;NA&gt;         
&gt;  9 Biggs Darklighter  black        
&gt; 10 Obi-Wan Kenobi     auburn, white
&gt; # … with 77 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/select1.jpg" alt="Flujo de https://tidydatatutor.com/" width="140%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

]

---

# .orange[SELECCIONAR] columnas:  select()


Como sucedía al filtrar, la función `select()` es bastante versatil y nos permite:

* Seleccionar **.bg-purple_light[varias variables a la vez]** (concatenando sus nombres).


```r
starwars %&gt;% select(name:skin_color)
```

```
&gt; # A tibble: 87 × 5
&gt;    name               height  mass hair_color    skin_color 
&gt;    &lt;chr&gt;               &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;      
&gt;  1 Luke Skywalker        172    77 blond         fair       
&gt;  2 C-3PO                 167    75 &lt;NA&gt;          gold       
&gt;  3 R2-D2                  96    32 &lt;NA&gt;          white, blue
&gt;  4 Darth Vader           202   136 none          white      
&gt;  5 Leia Organa           150    49 brown         light      
&gt;  6 Owen Lars             178   120 brown, grey   light      
&gt;  7 Beru Whitesun lars    165    75 brown         light      
&gt;  8 R5-D4                  97    32 &lt;NA&gt;          white, red 
&gt;  9 Biggs Darklighter     183    84 black         light      
&gt; 10 Obi-Wan Kenobi        182    77 auburn, white fair       
&gt; # … with 77 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

---

# .orange[SELECCIONAR] columnas:  select()

* **.bg-purple_light[Deseleccionar]** columnas con `-`


```r
starwars %&gt;% select(-c(mass:eye_color), -species, -c(films:starships))
```

```
&gt; # A tibble: 87 × 6
&gt;    name               height birth_year sex    gender    homeworld
&gt;    &lt;chr&gt;               &lt;int&gt;      &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;    
&gt;  1 Luke Skywalker        172       19   male   masculine Tatooine 
&gt;  2 C-3PO                 167      112   none   masculine Tatooine 
&gt;  3 R2-D2                  96       33   none   masculine Naboo    
&gt;  4 Darth Vader           202       41.9 male   masculine Tatooine 
&gt;  5 Leia Organa           150       19   female feminine  Alderaan 
&gt;  6 Owen Lars             178       52   male   masculine Tatooine 
&gt;  7 Beru Whitesun lars    165       47   female feminine  Tatooine 
&gt;  8 R5-D4                  97       NA   none   masculine Tatooine 
&gt;  9 Biggs Darklighter     183       24   male   masculine Tatooine 
&gt; 10 Obi-Wan Kenobi        182       57   male   masculine Stewjon  
&gt; # … with 77 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

---

# .orange[SELECCIONAR] columnas:  select()


* Seleccionar columnas que **.bg-purple_light[comiencen por un prefijo]** (`starts_with()`), **.bg-purple_light[terminen]** con un sufijo (`ends_with()`), **.bg-purple_light[contengan]** un texto (`contains()`) o cumplan una **.bg-purple_light[expresión regular]** (`matches()`)



```r
# nombre acaba en "color"
starwars %&gt;% select(ends_with("color"))
```

```
&gt; # A tibble: 87 × 3
&gt;    hair_color    skin_color  eye_color
&gt;    &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;    
&gt;  1 blond         fair        blue     
&gt;  2 &lt;NA&gt;          gold        yellow   
&gt;  3 &lt;NA&gt;          white, blue red      
&gt;  4 none          white       yellow   
&gt;  5 brown         light       brown    
&gt;  6 brown, grey   light       blue     
&gt;  7 brown         light       blue     
&gt;  8 &lt;NA&gt;          white, red  red      
&gt;  9 black         light       brown    
&gt; 10 auburn, white fair        blue-gray
&gt; # … with 77 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

---

# .orange[SELECCIONAR] columnas:  select()


* Seleccionar columnas que **.bg-purple_light[comiencen por un prefijo]** (`starts_with()`), **.bg-purple_light[terminen]** con un sufijo (`ends_with()`), **.bg-purple_light[contengan]** un texto (`contains()`) o cumplan una **.bg-purple_light[expresión regular]** (`matches()`)


```r
# empiezan por new_sp
who %&gt;% select(country, year, starts_with("new_sp"))
```

```
&gt; # A tibble: 7,240 × 16
&gt;    country  year new_s…¹ new_s…² new_s…³ new_s…⁴ new_s…⁵ new_s…⁶ new_s…⁷ new_s…⁸
&gt;    &lt;chr&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;
&gt;  1 Afghan…  1980      NA      NA      NA      NA      NA      NA      NA      NA
&gt;  2 Afghan…  1981      NA      NA      NA      NA      NA      NA      NA      NA
&gt;  3 Afghan…  1982      NA      NA      NA      NA      NA      NA      NA      NA
&gt;  4 Afghan…  1983      NA      NA      NA      NA      NA      NA      NA      NA
&gt;  5 Afghan…  1984      NA      NA      NA      NA      NA      NA      NA      NA
&gt;  6 Afghan…  1985      NA      NA      NA      NA      NA      NA      NA      NA
&gt;  7 Afghan…  1986      NA      NA      NA      NA      NA      NA      NA      NA
&gt;  8 Afghan…  1987      NA      NA      NA      NA      NA      NA      NA      NA
&gt;  9 Afghan…  1988      NA      NA      NA      NA      NA      NA      NA      NA
&gt; 10 Afghan…  1989      NA      NA      NA      NA      NA      NA      NA      NA
&gt; # … with 7,230 more rows, 6 more variables: new_sp_f1524 &lt;int&gt;,
&gt; #   new_sp_f2534 &lt;int&gt;, new_sp_f3544 &lt;int&gt;, new_sp_f4554 &lt;int&gt;,
&gt; #   new_sp_f5564 &lt;int&gt;, new_sp_f65 &lt;int&gt;, and abbreviated variable names
&gt; #   ¹​new_sp_m014, ²​new_sp_m1524, ³​new_sp_m2534, ⁴​new_sp_m3544, ⁵​new_sp_m4554,
&gt; #   ⁶​new_sp_m5564, ⁷​new_sp_m65, ⁸​new_sp_f014
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[SELECCIONAR] columnas:  select()


* Seleccionar columnas que **.bg-purple_light[comiencen por un prefijo]** (`starts_with()`), **.bg-purple_light[terminen]** con un sufijo (`ends_with()`), **.bg-purple_light[contengan]** un texto (`contains()`) o cumplan una **.bg-purple_light[expresión regular]** (`matches()`)


```r
tb &lt;- tibble("edad" = c(30, 35, 40),
             "color_ojos" = c("azul", "amarillo", "negro"),
             "pelo_color" = c("negro", "marrón", "rubio"))
tb %&gt;% select(contains("color"))
```

```
&gt; # A tibble: 3 × 2
&gt;   color_ojos pelo_color
&gt;   &lt;chr&gt;      &lt;chr&gt;     
&gt; 1 azul       negro     
&gt; 2 amarillo   marrón    
&gt; 3 negro      rubio
```


---

# .orange[SELECCIONAR] columnas:  select()

Incluso podemos seleccionar por rango numérico si tenemos variables conun prefijo y números.


```r
billboard %&gt;% select(num_range("wk", 10:15))
```

```
&gt; # A tibble: 317 × 6
&gt;     wk10  wk11  wk12  wk13  wk14  wk15
&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
&gt;  1    NA    NA    NA    NA    NA    NA
&gt;  2    NA    NA    NA    NA    NA    NA
&gt;  3    51    51    51    47    44    38
&gt;  4    61    61    59    61    66    72
&gt;  5    57    64    70    75    76    78
&gt;  6     6     7    22    29    36    47
&gt;  7    NA    NA    NA    NA    NA    NA
&gt;  8    36    37    37    38    49    61
&gt;  9    10     9     8     6     1     2
&gt; 10    59    66    68    61    67    59
&gt; # … with 307 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

---

# .orange[SELECCIONAR] columnas:  select()

* Seleccionar columnas de un **.bg-purple_light[tipo]** haciendo uso de `where()`.



```r
# Solo columnas numéricas o de trexto
starwars %&gt;% select(where(is.numeric) | where(is.character))
```

```
&gt; # A tibble: 87 × 11
&gt;    height  mass birth_year name     hair_…¹ skin_…² eye_c…³ sex   gender homew…⁴
&gt;     &lt;int&gt; &lt;dbl&gt;      &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1    172    77       19   Luke Sk… blond   fair    blue    male  mascu… Tatooi…
&gt;  2    167    75      112   C-3PO    &lt;NA&gt;    gold    yellow  none  mascu… Tatooi…
&gt;  3     96    32       33   R2-D2    &lt;NA&gt;    white,… red     none  mascu… Naboo  
&gt;  4    202   136       41.9 Darth V… none    white   yellow  male  mascu… Tatooi…
&gt;  5    150    49       19   Leia Or… brown   light   brown   fema… femin… Aldera…
&gt;  6    178   120       52   Owen La… brown,… light   blue    male  mascu… Tatooi…
&gt;  7    165    75       47   Beru Wh… brown   light   blue    fema… femin… Tatooi…
&gt;  8     97    32       NA   R5-D4    &lt;NA&gt;    white,… red     none  mascu… Tatooi…
&gt;  9    183    84       24   Biggs D… black   light   brown   male  mascu… Tatooi…
&gt; 10    182    77       57   Obi-Wan… auburn… fair    blue-g… male  mascu… Stewjon
&gt; # … with 77 more rows, 1 more variable: species &lt;chr&gt;, and abbreviated variable
&gt; #   names ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[RECOLOCAR] columnas: relocate()

Fíjate que con `select()` podrías además **.bg-purple_light[recolocar columnas]**, indícandole el orden, ayudándote también de `everything()`


```r
starwars %&gt;%  select(c(species, name, birth_year, everything()))
```

```
&gt; # A tibble: 87 × 14
&gt;    species name        birth…¹ height  mass hair_…² skin_…³ eye_c…⁴ sex   gender
&gt;    &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Human   Luke Skywa…    19      172    77 blond   fair    blue    male  mascu…
&gt;  2 Droid   C-3PO         112      167    75 &lt;NA&gt;    gold    yellow  none  mascu…
&gt;  3 Droid   R2-D2          33       96    32 &lt;NA&gt;    white,… red     none  mascu…
&gt;  4 Human   Darth Vader    41.9    202   136 none    white   yellow  male  mascu…
&gt;  5 Human   Leia Organa    19      150    49 brown   light   brown   fema… femin…
&gt;  6 Human   Owen Lars      52      178   120 brown,… light   blue    male  mascu…
&gt;  7 Human   Beru White…    47      165    75 brown   light   blue    fema… femin…
&gt;  8 Droid   R5-D4          NA       97    32 &lt;NA&gt;    white,… red     none  mascu…
&gt;  9 Human   Biggs Dark…    24      183    84 black   light   brown   male  mascu…
&gt; 10 Human   Obi-Wan Ke…    57      182    77 auburn… fair    blue-g… male  mascu…
&gt; # … with 77 more rows, 4 more variables: homeworld &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¹​birth_year, ²​hair_color, ³​skin_color, ⁴​eye_color
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[RECOLOCAR] columnas: relocate()


.pull-left[


```r
datos %&gt;% 
  recolocar(col1, col2, .after = ...)
```

]

.pull-right[


```r
starwars %&gt;% 
  relocate(col1, col2, .after = ...)
```

]

--

Para facilitar la **.bg-purple_light[recolocación]** tenemos una función para ello, `relocate()`,  indicándole en `.after` o `.before` detrás o delante de qué columnas queremos moverlas.


```r
starwars %&gt;% relocate(species, .before = name)
```

```
&gt; # A tibble: 87 × 14
&gt;    species name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender
&gt;    &lt;chr&gt;   &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Human   Luke Skywa…    172    77 blond   fair    blue       19   male  mascu…
&gt;  2 Droid   C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu…
&gt;  3 Droid   R2-D2           96    32 &lt;NA&gt;    white,… red        33   none  mascu…
&gt;  4 Human   Darth Vader    202   136 none    white   yellow     41.9 male  mascu…
&gt;  5 Human   Leia Organa    150    49 brown   light   brown      19   fema… femin…
&gt;  6 Human   Owen Lars      178   120 brown,… light   blue       52   male  mascu…
&gt;  7 Human   Beru White…    165    75 brown   light   blue       47   fema… femin…
&gt;  8 Droid   R5-D4           97    32 &lt;NA&gt;    white,… red        NA   none  mascu…
&gt;  9 Human   Biggs Dark…    183    84 black   light   brown      24   male  mascu…
&gt; 10 Human   Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu…
&gt; # … with 77 more rows, 4 more variables: homeworld &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[EXTRAER] columnas: pull()


.pull-left[


```r
datos %&gt;% 
  retirar(variable)
```

]

.pull-right[


```r
starwars %&gt;% 
  pull(variable)
```

]

--

.pull-left[

Si observas la salida de los `select()`, sigue siendo una tabla `tibble`, nos preserva la naturaleza de nuestros datos.


```r
starwars %&gt;% select(name)
```

```
&gt; # A tibble: 87 × 1
&gt;    name              
&gt;    &lt;chr&gt;             
&gt;  1 Luke Skywalker    
&gt;  2 C-3PO             
&gt;  3 R2-D2             
&gt;  4 Darth Vader       
&gt;  5 Leia Organa       
&gt;  6 Owen Lars         
&gt;  7 Beru Whitesun lars
&gt;  8 R5-D4             
&gt;  9 Biggs Darklighter 
&gt; 10 Obi-Wan Kenobi    
&gt; # … with 77 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

]

.pull-right[

A veces no querremos dicha estructura sino **.bg-purple_light[extraer literalmente la columna]**, algo que podemos hacer con `pull()`


```r
starwars %&gt;% pull(name)
```

```
&gt;  [1] "Luke Skywalker"        "C-3PO"                 "R2-D2"                
&gt;  [4] "Darth Vader"           "Leia Organa"           "Owen Lars"            
&gt;  [7] "Beru Whitesun lars"    "R5-D4"                 "Biggs Darklighter"    
&gt; [10] "Obi-Wan Kenobi"        "Anakin Skywalker"      "Wilhuff Tarkin"       
&gt; [13] "Chewbacca"             "Han Solo"              "Greedo"               
&gt; [16] "Jabba Desilijic Tiure" "Wedge Antilles"        "Jek Tono Porkins"     
&gt; [19] "Yoda"                  "Palpatine"             "Boba Fett"            
&gt; [22] "IG-88"                 "Bossk"                 "Lando Calrissian"     
&gt; [25] "Lobot"                 "Ackbar"                "Mon Mothma"           
&gt; [28] "Arvel Crynyd"          "Wicket Systri Warrick" "Nien Nunb"            
&gt; [31] "Qui-Gon Jinn"          "Nute Gunray"           "Finis Valorum"        
&gt; [34] "Jar Jar Binks"         "Roos Tarpals"          "Rugor Nass"           
&gt; [37] "Ric Olié"              "Watto"                 "Sebulba"              
&gt; [40] "Quarsh Panaka"         "Shmi Skywalker"        "Darth Maul"           
&gt; [43] "Bib Fortuna"           "Ayla Secura"           "Dud Bolt"             
&gt; [46] "Gasgano"               "Ben Quadinaros"        "Mace Windu"           
&gt; [49] "Ki-Adi-Mundi"          "Kit Fisto"             "Eeth Koth"            
&gt; [52] "Adi Gallia"            "Saesee Tiin"           "Yarael Poof"          
&gt; [55] "Plo Koon"              "Mas Amedda"            "Gregar Typho"         
&gt; [58] "Cordé"                 "Cliegg Lars"           "Poggle the Lesser"    
&gt; [61] "Luminara Unduli"       "Barriss Offee"         "Dormé"                
&gt; [64] "Dooku"                 "Bail Prestor Organa"   "Jango Fett"           
&gt; [67] "Zam Wesell"            "Dexter Jettster"       "Lama Su"              
&gt; [70] "Taun We"               "Jocasta Nu"            "Ratts Tyerell"        
&gt; [73] "R4-P17"                "Wat Tambor"            "San Hill"             
&gt; [76] "Shaak Ti"              "Grievous"              "Tarfful"              
&gt; [79] "Raymus Antilles"       "Sly Moore"             "Tion Medon"           
&gt; [82] "Finn"                  "Rey"                   "Poe Dameron"          
&gt; [85] "BB8"                   "Captain Phasma"        "Padmé Amidala"
```

]

---

# .orange[RENOMBRAR] columnas: rename()


.pull-left[


```r
datos %&gt;% 
  renombrar(col1, col2)
```

]

.pull-right[


```r
starwars %&gt;% 
  rename(col1, col2)
```

]

--

A veces también podemos querer **modificar la «metainformación»** de los datos, **.bg-purple_light[renombrando columnas]**. Para ello usaremos la función `rename()` poniendo primero el nombre nuevo y luego el antiguo.


```r
starwars %&gt;% 
  rename(nombre = name, altura = height,  peso = mass)
```

```
&gt; # A tibble: 87 × 14
&gt;    nombre      altura  peso hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu… Tatooi…
&gt;  3 R2-D2           96    32 &lt;NA&gt;    white,… red        33   none  mascu… Naboo  
&gt;  4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…
&gt;  5 Leia Organa    150    49 brown   light   brown      19   fema… femin… Aldera…
&gt;  6 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…
&gt;  7 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…
&gt;  8 R5-D4           97    32 &lt;NA&gt;    white,… red        NA   none  mascu… Tatooi…
&gt;  9 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…
&gt; 10 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon
&gt; # … with 77 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```


---

# Ejercicios (columnas)

.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: filtra el conjunto de personajes y quédate solo con aquellos que en la variable `height` no tengan un dato ausente.

* 📝 **Ejercicio 2**: con los datos obtenidos del filtro anterior, selecciona solo las variables `name`, `height`, así como todas aquellas variables que CONTENGAN la palabra `color` en su nombre.

* 📝 **Ejercicio 3**: con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano

* 📝 **Ejercicio 4**: con los datos obtenidos del ejercicio anterior, coloca la variable de color de pelo justo detrás de la variable de nombres.

* 📝 **Ejercicio 5**: con los datos obtenidos del ejercicio, comprueba cuántas modalidades únicas hay en la variable de color de pelo.

]

.panel[.panel-name[Sol. Ej. 1]

**IMPORTANTE**: todo lo que hagas en la tabla original, si el resultado final no se lo asignas `&lt;-` a otra variable, lo verás en consola pero no se guardará en ningún sitio. Lo que no guardes, no existe.



```r
starwars_NA &lt;- starwars %&gt;% drop_na(height)
starwars_NA 
```

```
&gt; # A tibble: 81 × 14
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu… Tatooi…
&gt;  3 R2-D2           96    32 &lt;NA&gt;    white,… red        33   none  mascu… Naboo  
&gt;  4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…
&gt;  5 Leia Organa    150    49 brown   light   brown      19   fema… femin… Aldera…
&gt;  6 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…
&gt;  7 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…
&gt;  8 R5-D4           97    32 &lt;NA&gt;    white,… red        NA   none  mascu… Tatooi…
&gt;  9 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…
&gt; 10 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon
&gt; # … with 71 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 2]


```r
starwars %&gt;%
  drop_na(height) %&gt;%
  select(c(name, height, contains("color")))
```

```
&gt; # A tibble: 81 × 5
&gt;    name               height hair_color    skin_color  eye_color
&gt;    &lt;chr&gt;               &lt;int&gt; &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;    
&gt;  1 Luke Skywalker        172 blond         fair        blue     
&gt;  2 C-3PO                 167 &lt;NA&gt;          gold        yellow   
&gt;  3 R2-D2                  96 &lt;NA&gt;          white, blue red      
&gt;  4 Darth Vader           202 none          white       yellow   
&gt;  5 Leia Organa           150 brown         light       brown    
&gt;  6 Owen Lars             178 brown, grey   light       blue     
&gt;  7 Beru Whitesun lars    165 brown         light       blue     
&gt;  8 R5-D4                  97 &lt;NA&gt;          white, red  red      
&gt;  9 Biggs Darklighter     183 black         light       brown    
&gt; 10 Obi-Wan Kenobi        182 auburn, white fair        blue-gray
&gt; # … with 71 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

]

.panel[.panel-name[Sol. Ej. 3]



```r
starwars %&gt;%
  drop_na(height) %&gt;%
  select(c(name, height, contains("color"))) %&gt;%
  rename(nombre = name, altura = height,
         color_pelo = hair_color,
         color_piel = skin_color,
         color_ojos = eye_color)
```

```
&gt; # A tibble: 81 × 5
&gt;    nombre             altura color_pelo    color_piel  color_ojos
&gt;    &lt;chr&gt;               &lt;int&gt; &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;     
&gt;  1 Luke Skywalker        172 blond         fair        blue      
&gt;  2 C-3PO                 167 &lt;NA&gt;          gold        yellow    
&gt;  3 R2-D2                  96 &lt;NA&gt;          white, blue red       
&gt;  4 Darth Vader           202 none          white       yellow    
&gt;  5 Leia Organa           150 brown         light       brown     
&gt;  6 Owen Lars             178 brown, grey   light       blue      
&gt;  7 Beru Whitesun lars    165 brown         light       blue      
&gt;  8 R5-D4                  97 &lt;NA&gt;          white, red  red       
&gt;  9 Biggs Darklighter     183 black         light       brown     
&gt; 10 Obi-Wan Kenobi        182 auburn, white fair        blue-gray 
&gt; # … with 71 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

]

.panel[.panel-name[Sol. Ej. 4]



```r
starwars %&gt;%
  drop_na(height) %&gt;%
  select(c(name, height, contains("color"))) %&gt;%
  rename(nombre = name, altura = height,
         color_pelo = hair_color,
         color_piel = skin_color,
         color_ojos = eye_color) %&gt;%
  relocate(color_pelo, .after = nombre)
```

```
&gt; # A tibble: 81 × 5
&gt;    nombre             color_pelo    altura color_piel  color_ojos
&gt;    &lt;chr&gt;              &lt;chr&gt;          &lt;int&gt; &lt;chr&gt;       &lt;chr&gt;     
&gt;  1 Luke Skywalker     blond            172 fair        blue      
&gt;  2 C-3PO              &lt;NA&gt;             167 gold        yellow    
&gt;  3 R2-D2              &lt;NA&gt;              96 white, blue red       
&gt;  4 Darth Vader        none             202 white       yellow    
&gt;  5 Leia Organa        brown            150 light       brown     
&gt;  6 Owen Lars          brown, grey      178 light       blue      
&gt;  7 Beru Whitesun lars brown            165 light       blue      
&gt;  8 R5-D4              &lt;NA&gt;              97 white, red  red       
&gt;  9 Biggs Darklighter  black            183 light       brown     
&gt; 10 Obi-Wan Kenobi     auburn, white    182 fair        blue-gray 
&gt; # … with 71 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

]

.panel[.panel-name[Sol. Ej. 5]


```r
starwars %&gt;%
  drop_na(height) %&gt;%
  select(c(name, height, contains("color"))) %&gt;%
  rename(nombre = name, altura = height, color_pelo = hair_color,
         color_piel = skin_color, color_ojos = eye_color) %&gt;%
  relocate(color_pelo, .after = nombre) %&gt;%
  distinct(color_pelo)
```

```
&gt; # A tibble: 12 × 1
&gt;    color_pelo   
&gt;    &lt;chr&gt;        
&gt;  1 blond        
&gt;  2 &lt;NA&gt;         
&gt;  3 none         
&gt;  4 brown        
&gt;  5 brown, grey  
&gt;  6 black        
&gt;  7 auburn, white
&gt;  8 auburn, grey 
&gt;  9 white        
&gt; 10 grey         
&gt; 11 auburn       
&gt; 12 blonde
```

**IMPORTANTE**: recuerda que `distinct()` de mantener todas las columnas añadiendo `.keep_all = TRUE`.

]

]


---

# Ejercicio extra


Veamos un ejercicio extra para comprobar la **potencia y flexibilidad** de `{tidyverse}`, pudiendo hacer muchas cosas en dos líneas de código.

&amp;nbsp;

* 📝 **Ejercicio extra**: selecciona solo las variables `name` y aquellas que sean de tipo numérico y la variable `homeworld`, y selecciona solo los personajes que no sean humanos y que pesen entre 70 y 90 kg.  Tras ello elimina datos ausentes, y elimina duplicados con el mismo valor en `homeworld`. Tras ello, recoloca las variables para que el orden la primera columna sea `name` y la segunda `birth_year`. Para acabar, cambia el nombre  a castellano de las variables.


---

name: mutate


# .orange[MODIFICAR] columnas: mutate()


.pull-left[


```r
datos %&gt;%
  modificar(nueva_var = ...)
```

]

.pull-right[


```r
starwars %&gt;%
  mutate(nueva_var = ...)
```

]

--

En muchas ocasiones querremos **.bg-purple_light[modificar o crear  variables]**. Para ello tenemos la función `mutate()`. Vamos a crear una **nueva variable** `height_m` con la altura en centímetros.


```r
# altura en metros
starwars %&gt;%
* mutate(height_m = height / 100)
```

```
&gt; # A tibble: 87 × 15
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu… Tatooi…
&gt;  3 R2-D2           96    32 &lt;NA&gt;    white,… red        33   none  mascu… Naboo  
&gt;  4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…
&gt;  5 Leia Organa    150    49 brown   light   brown      19   fema… femin… Aldera…
&gt;  6 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…
&gt;  7 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…
&gt;  8 R5-D4           97    32 &lt;NA&gt;    white,… red        NA   none  mascu… Tatooi…
&gt;  9 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…
&gt; 10 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon
&gt; # … with 77 more rows, 5 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, height_m &lt;dbl&gt;, and abbreviated variable
&gt; #   names ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[MODIFICAR] columnas: mutate()



```r
starwars %&gt;% mutate(height_m = height / 100)
```

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/mutate1.jpg" alt="Flujo de https://tidydatatutor.com/" width="90%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

---

# .orange[MODIFICAR] columnas: mutate()

Otra opción es **.bg-purple_light[quedarnos solo con las modificadas]** (por ejemplo, para ver si hace lo que debe) con `transmute()`


```r
starwars %&gt;%
* transmute(height_m = height / 100)
```

```
&gt; # A tibble: 87 × 1
&gt;    height_m
&gt;       &lt;dbl&gt;
&gt;  1     1.72
&gt;  2     1.67
&gt;  3     0.96
&gt;  4     2.02
&gt;  5     1.5 
&gt;  6     1.78
&gt;  7     1.65
&gt;  8     0.97
&gt;  9     1.83
&gt; 10     1.82
&gt; # … with 77 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

---


# .orange[MODIFICAR] columnas: mutate()

También se pueden aplicar **.bg-purple_light[funciones más complejas]** o incluso **.bg-purple_light[funciones propias]** creadas por nosotros mismos (y varias a la vez).


```r
calculo_IMC &lt;- function(peso, estatura, unidades = "metros") {
  
  estatura &lt;- ifelse(unidades == "metros", estatura, estatura / 100)
  IMC &lt;- peso / (estatura^2)
  
  return(IMC)
}
```

---

# .orange[MODIFICAR] columnas: mutate()

También se pueden aplicar **.bg-purple_light[funciones más complejas]** o incluso **.bg-purple_light[funciones propias]** creadas por nosotros mismos (y varias a la vez).


```r
starwars %&gt;%
  mutate(IMC = calculo_IMC(mass, height, unidades = "centímetros"),
         height_m = height / 100) %&gt;%
  relocate(IMC, height_m, .after = mass)
```

```
&gt; # A tibble: 87 × 16
&gt;    name  height  mass   IMC heigh…¹ hair_…² skin_…³ eye_c…⁴ birth…⁵ sex   gender
&gt;    &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Luke…    172    77  26.0    1.72 blond   fair    blue       19   male  mascu…
&gt;  2 C-3PO    167    75  25.4    1.67 &lt;NA&gt;    gold    yellow    112   none  mascu…
&gt;  3 R2-D2     96    32  10.8    0.96 &lt;NA&gt;    white,… red        33   none  mascu…
&gt;  4 Dart…    202   136  46.0    2.02 none    white   yellow     41.9 male  mascu…
&gt;  5 Leia…    150    49  16.6    1.5  brown   light   brown      19   fema… femin…
&gt;  6 Owen…    178   120  40.6    1.78 brown,… light   blue       52   male  mascu…
&gt;  7 Beru…    165    75  25.4    1.65 brown   light   blue       47   fema… femin…
&gt;  8 R5-D4     97    32  10.8    0.97 &lt;NA&gt;    white,… red        NA   none  mascu…
&gt;  9 Bigg…    183    84  28.4    1.83 black   light   brown      24   male  mascu…
&gt; 10 Obi-…    182    77  26.0    1.82 auburn… fair    blue-g…    57   male  mascu…
&gt; # … with 77 more rows, 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable
&gt; #   names ¹​height_m, ²​hair_color, ³​skin_color, ⁴​eye_color, ⁵​birth_year
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

---

# .orange[MODIFICAR] columnas: mutate()

También podemos combinarlo con la función `if_else()`, una modificación dentro de `{tidyverse}` para hacer un `if-else` vectorizado, que nos puede ayudar a **.bg-purple_light[recategorizaciones sencillas]**.


```r
starwars %&gt;%
  mutate(human = if_else(species == "Human", "Human", "Not Human")) %&gt;% 
  relocate(human, .after = name)
```

```
&gt; # A tibble: 87 × 15
&gt;    name  human height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt; &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke… Human    172    77 blond   fair    blue       19   male  mascu… Tatooi…
&gt;  2 C-3PO Not …    167    75 &lt;NA&gt;    gold    yellow    112   none  mascu… Tatooi…
&gt;  3 R2-D2 Not …     96    32 &lt;NA&gt;    white,… red        33   none  mascu… Naboo  
&gt;  4 Dart… Human    202   136 none    white   yellow     41.9 male  mascu… Tatooi…
&gt;  5 Leia… Human    150    49 brown   light   brown      19   fema… femin… Aldera…
&gt;  6 Owen… Human    178   120 brown,… light   blue       52   male  mascu… Tatooi…
&gt;  7 Beru… Human    165    75 brown   light   blue       47   fema… femin… Tatooi…
&gt;  8 R5-D4 Not …     97    32 &lt;NA&gt;    white,… red        NA   none  mascu… Tatooi…
&gt;  9 Bigg… Human    183    84 black   light   brown      24   male  mascu… Tatooi…
&gt; 10 Obi-… Human    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon
&gt; # … with 77 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```


---

# .orange[RECATEGORIZAR]: case_when()

Para **.bg-purple_light[recategorizaciones más complejas]** tenemos a nuestra disposición `case_when()`. Supongamos por ejemplo que queremos crear una **categoría en función de su altura**.

* Si `height &gt; 180` –&gt; serán `"alto"`.
* Si `height &lt;= 180` y `height &gt; 120` –&gt; serán `"bajo"`
* Si `height &lt;= 120` y `height &gt; 0` –&gt; serán `"enano"`
* Si no se cumple lo anterior –&gt; serán `"ausente"`

--


```r
starwars %&gt;% mutate(height = case_when(height &gt; 180 ~ "alto",
                                       height &gt; 120 ~ "bajo",
                                       height &gt; 0 ~ "enano",
                                       TRUE ~ "ausente"))
```

```
&gt; # A tibble: 87 × 14
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa… bajo      77 blond   fair    blue       19   male  mascu… Tatooi…
&gt;  2 C-3PO       bajo      75 &lt;NA&gt;    gold    yellow    112   none  mascu… Tatooi…
&gt;  3 R2-D2       enano     32 &lt;NA&gt;    white,… red        33   none  mascu… Naboo  
&gt;  4 Darth Vader alto     136 none    white   yellow     41.9 male  mascu… Tatooi…
&gt;  5 Leia Organa bajo      49 brown   light   brown      19   fema… femin… Aldera…
&gt;  6 Owen Lars   bajo     120 brown,… light   blue       52   male  mascu… Tatooi…
&gt;  7 Beru White… bajo      75 brown   light   blue       47   fema… femin… Tatooi…
&gt;  8 R5-D4       enano     32 &lt;NA&gt;    white,… red        NA   none  mascu… Tatooi…
&gt;  9 Biggs Dark… alto      84 black   light   brown      24   male  mascu… Tatooi…
&gt; 10 Obi-Wan Ke… alto      77 auburn… fair    blue-g…    57   male  mascu… Stewjon
&gt; # … with 77 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```


---

# Ejercicios (mutate)


.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: crea tres nuevas columnas que nos digan el número de películas en las que han salido, el número de vehículos y el número d naves (pero haciendo uso de mutate()). 

* 📝 **Ejercicio 2**: con las 3 columnas creadas, crea una nueva columna llamada `frequency` que nos ponga `almost_all` en personajes que salen en 5 o más películas, `many` en personajes que salen en más de 2 películas pero en menos de 5 y `some` en personajes que salen 1 o 2 películas.

* 📝 **Ejercicio 3**: elimina registros con datos ausentes en la variable `birth_year` y filtra solo los 20 personajes más jóvenes.

* 📝 **Ejercicio 4**: selecciona solo las variables numéricas y de tipo texto. Define una nueva variable llamada `under_18` que nos recategorice la variable `birth_year`: `TRUE` si es menor de edad y `FALSE` en caso contrario

]

.panel[.panel-name[Sol. Ej. 1]


```r
starwars_nueva &lt;- 
  starwars %&gt;%
  mutate(n_films = films %&gt;% map_int(length),
         n_vehicles = vehicles %&gt;% map_int(length),
         n_starships = starships %&gt;% map_int(length))
starwars_nueva
```

```
&gt; # A tibble: 87 × 17
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu… Tatooi…
&gt;  3 R2-D2           96    32 &lt;NA&gt;    white,… red        33   none  mascu… Naboo  
&gt;  4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…
&gt;  5 Leia Organa    150    49 brown   light   brown      19   fema… femin… Aldera…
&gt;  6 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…
&gt;  7 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…
&gt;  8 R5-D4           97    32 &lt;NA&gt;    white,… red        NA   none  mascu… Tatooi…
&gt;  9 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…
&gt; 10 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon
&gt; # … with 77 more rows, 7 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, n_films &lt;int&gt;, n_vehicles &lt;int&gt;,
&gt; #   n_starships &lt;int&gt;, and abbreviated variable names ¹​hair_color, ²​skin_color,
&gt; #   ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 2]


```r
starwars_nueva &lt;-
  starwars_nueva %&gt;%
  mutate(frequency =
           case_when(n_films &gt;= 5 ~ "almost_all",
                     n_films &gt; 2 ~ "many",
                     TRUE ~ "some"))
starwars_nueva
```

```
&gt; # A tibble: 87 × 18
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…
&gt;  2 C-3PO          167    75 &lt;NA&gt;    gold    yellow    112   none  mascu… Tatooi…
&gt;  3 R2-D2           96    32 &lt;NA&gt;    white,… red        33   none  mascu… Naboo  
&gt;  4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…
&gt;  5 Leia Organa    150    49 brown   light   brown      19   fema… femin… Aldera…
&gt;  6 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…
&gt;  7 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…
&gt;  8 R5-D4           97    32 &lt;NA&gt;    white,… red        NA   none  mascu… Tatooi…
&gt;  9 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…
&gt; 10 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon
&gt; # … with 77 more rows, 8 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, n_films &lt;int&gt;, n_vehicles &lt;int&gt;,
&gt; #   n_starships &lt;int&gt;, frequency &lt;chr&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 3]


```r
starwars_nueva &lt;-
  starwars_nueva %&gt;%
  drop_na(birth_year) %&gt;%
  slice_min(n = 20, birth_year)
starwars_nueva
```

```
&gt; # A tibble: 21 × 18
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Wicket Sys…     88  20   brown   brown   brown       8   male  mascu… Endor  
&gt;  2 IG-88          200 140   none    metal   red        15   none  mascu… &lt;NA&gt;   
&gt;  3 Luke Skywa…    172  77   blond   fair    blue       19   male  mascu… Tatooi…
&gt;  4 Leia Organa    150  49   brown   light   brown      19   fema… femin… Aldera…
&gt;  5 Wedge Anti…    170  77   brown   fair    hazel      21   male  mascu… Corell…
&gt;  6 Plo Koon       188  80   none    orange  black      22   male  mascu… Dorin  
&gt;  7 Biggs Dark…    183  84   black   light   brown      24   male  mascu… Tatooi…
&gt;  8 Han Solo       180  80   brown   fair    brown      29   male  mascu… Corell…
&gt;  9 Lando Calr…    177  79   black   dark    brown      31   male  mascu… Socorro
&gt; 10 Boba Fett      183  78.2 black   fair    brown      31.5 male  mascu… Kamino 
&gt; # … with 11 more rows, 8 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, n_films &lt;int&gt;, n_vehicles &lt;int&gt;,
&gt; #   n_starships &lt;int&gt;, frequency &lt;chr&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 4]


```r
starwars_nueva &lt;-
  starwars_nueva %&gt;%
  select(where(is.numeric) | where(is.character)) %&gt;%
  mutate(under_18 = birth_year &lt; 18)
starwars_nueva
```

```
&gt; # A tibble: 21 × 16
&gt;    height  mass birth_year n_films n_veh…¹ n_sta…² name  hair_…³ skin_…⁴ eye_c…⁵
&gt;     &lt;int&gt; &lt;dbl&gt;      &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  
&gt;  1     88  20          8         1       0       0 Wick… brown   brown   brown  
&gt;  2    200 140         15         1       0       0 IG-88 none    metal   red    
&gt;  3    172  77         19         5       2       2 Luke… blond   fair    blue   
&gt;  4    150  49         19         5       1       0 Leia… brown   light   brown  
&gt;  5    170  77         21         3       1       1 Wedg… brown   fair    hazel  
&gt;  6    188  80         22         3       0       1 Plo … none    orange  black  
&gt;  7    183  84         24         1       0       1 Bigg… black   light   brown  
&gt;  8    180  80         29         4       0       2 Han … brown   fair    brown  
&gt;  9    177  79         31         2       0       1 Land… black   dark    brown  
&gt; 10    183  78.2       31.5       3       0       1 Boba… black   fair    brown  
&gt; # … with 11 more rows, 6 more variables: sex &lt;chr&gt;, gender &lt;chr&gt;,
&gt; #   homeworld &lt;chr&gt;, species &lt;chr&gt;, frequency &lt;chr&gt;, under_18 &lt;lgl&gt;, and
&gt; #   abbreviated variable names ¹​n_vehicles, ²​n_starships, ³​hair_color,
&gt; #   ⁴​skin_color, ⁵​eye_color
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```


]

]


---


# Ejercicios (mutate)


.panelset[
.panel[.panel-name[Ejercicios]

* 📝 **Ejercicio 5**: de la base de datos original, determina el número de modalidades que toma la variable `species` (elimina antes registros con ausente en dicha variable). Después elimina duplicados por dicha variable, dejando el representante más bajito.

* 📝 **Ejercicio 6**: sobre la base de datos original, crea una nueva columna llamada `auburn` (cobrizo/caoba) que nos diga `TRUE` si el color de pelo contiene dicha palabra y `FALSE` en caso contrario.

* 📝 **Ejercicio 7**: sobre la base de datos original, filtra solo aquellos personajes de la familia `"Skywalker"` o `"Antilles"`, selecciona solo las columnas de `name` y `specie`, y renombra a castellano.


]

.panel[.panel-name[Sol. Ej. 5]


```r
starwars %&gt;%
  drop_na(species) %&gt;%
  distinct(species)
```

```
&gt; # A tibble: 37 × 1
&gt;    species       
&gt;    &lt;chr&gt;         
&gt;  1 Human         
&gt;  2 Droid         
&gt;  3 Wookiee       
&gt;  4 Rodian        
&gt;  5 Hutt          
&gt;  6 Yoda's species
&gt;  7 Trandoshan    
&gt;  8 Mon Calamari  
&gt;  9 Ewok          
&gt; 10 Sullustan     
&gt; # … with 27 more rows
&gt; # ℹ Use `print(n = ...)` to see more rows
```

```r
starwars %&gt;%
  drop_na(species) %&gt;%
  arrange(height) %&gt;%
  distinct(species, .keep_all = TRUE)
```

```
&gt; # A tibble: 37 × 14
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Yoda            66    17 white   green   brown       896 male  mascu… &lt;NA&gt;   
&gt;  2 Ratts Tyer…     79    15 none    grey, … unknown      NA male  mascu… Aleen …
&gt;  3 Wicket Sys…     88    20 brown   brown   brown         8 male  mascu… Endor  
&gt;  4 Dud Bolt        94    45 none    blue, … yellow       NA male  mascu… Vulpter
&gt;  5 R2-D2           96    32 &lt;NA&gt;    white,… red          33 none  mascu… Naboo  
&gt;  6 Sebulba        112    40 none    grey, … orange       NA male  mascu… Malast…
&gt;  7 Gasgano        122    NA none    white,… black        NA male  mascu… Troiken
&gt;  8 Watto          137    NA black   blue, … yellow       NA male  mascu… Toydar…
&gt;  9 Leia Organa    150    49 brown   light   brown        19 fema… femin… Aldera…
&gt; 10 Nien Nunb      160    68 none    grey    black        NA male  mascu… Sullust
&gt; # … with 27 more rows, 4 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated variable names
&gt; #   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 6]


```r
starwars %&gt;%
  drop_na(hair_color) %&gt;%
  mutate(auburn = str_detect(hair_color, "auburn"))
```

```
&gt; # A tibble: 82 × 15
&gt;    name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵
&gt;    &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  
&gt;  1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…
&gt;  2 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…
&gt;  3 Leia Organa    150    49 brown   light   brown      19   fema… femin… Aldera…
&gt;  4 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…
&gt;  5 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…
&gt;  6 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…
&gt;  7 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon
&gt;  8 Anakin Sky…    188    84 blond   fair    blue       41.9 male  mascu… Tatooi…
&gt;  9 Wilhuff Ta…    180    NA auburn… fair    blue       64   male  mascu… Eriadu 
&gt; 10 Chewbacca      228   112 brown   unknown blue      200   male  mascu… Kashyy…
&gt; # … with 72 more rows, 5 more variables: species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, auburn &lt;lgl&gt;, and abbreviated variable
&gt; #   names ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld
&gt; # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names
```

]

.panel[.panel-name[Sol. Ej. 6]


```r
starwars %&gt;%
  filter(str_detect(name, "Skywalker") |
           str_detect(name, "Antilles")) %&gt;%
  select(name, species) %&gt;%
  rename(nombre = name, especie = species)
```

```
&gt; # A tibble: 5 × 2
&gt;   nombre           especie
&gt;   &lt;chr&gt;            &lt;chr&gt;  
&gt; 1 Luke Skywalker   Human  
&gt; 2 Anakin Skywalker Human  
&gt; 3 Wedge Antilles   Human  
&gt; 4 Shmi Skywalker   Human  
&gt; 5 Raymus Antilles  Human
```

]
]


---

# CASO PRÁCTICO

* 📝 **Ejercicio extra**: en el paquete `{survival}`, la tabla `heart` contiene los mismos datos de la tabla `jasa` pero ya preprocesados. Haz uso de lo aprendido para pasar de `jasa` a `heart`



```r
survival::heart
```

```
&gt;     start   stop event          age        year surgery transplant  id
&gt; 1     0.0   50.0     1 -17.15537303  0.12320329       0          0   1
&gt; 2     0.0    6.0     1   3.83572895  0.25462012       0          0   2
&gt; 3     0.0    1.0     0   6.29705681  0.26557153       0          0   3
&gt; 4     1.0   16.0     1   6.29705681  0.26557153       0          1   3
&gt; 5     0.0   36.0     0  -7.73716632  0.49007529       0          0   4
&gt; 6    36.0   39.0     1  -7.73716632  0.49007529       0          1   4
&gt; 7     0.0   18.0     1 -27.21423682  0.60780287       0          0   5
&gt; 8     0.0    3.0     1   6.59548255  0.70088980       0          0   6
&gt; 9     0.0   51.0     0   2.86926762  0.78028747       0          0   7
&gt; 10   51.0  675.0     1   2.86926762  0.78028747       0          1   7
&gt; 11    0.0   40.0     1  -2.65023956  0.83504449       0          0   8
&gt; 12    0.0   85.0     1  -0.83778234  0.85694730       0          0   9
&gt; 13    0.0   12.0     0  -5.49760438  0.86242300       0          0  10
&gt; 14   12.0   58.0     1  -5.49760438  0.86242300       0          1  10
&gt; 15    0.0   26.0     0  -0.01916496  0.87337440       0          0  11
&gt; 16   26.0  153.0     1  -0.01916496  0.87337440       0          1  11
&gt; 17    0.0    8.0     1   5.19370294  0.96372348       0          0  12
&gt; 18    0.0   17.0     0   6.57357974  0.96919918       0          0  13
&gt; 19   17.0   81.0     1   6.57357974  0.96919918       0          1  13
&gt; 20    0.0   37.0     0   6.01232033  0.97193703       0          0  14
&gt; 21   37.0 1387.0     1   6.01232033  0.97193703       0          1  14
&gt; 22    0.0    1.0     1   5.81519507  0.99110198       1          0  15
&gt; 23    0.0   28.0     0   1.44832307  1.07049966       0          0  16
&gt; 24   28.0  308.0     1   1.44832307  1.07049966       0          1  16
&gt; 25    0.0   36.0     1 -27.66872005  1.07597536       0          0  17
&gt; 26    0.0   20.0     0   8.84873374  1.08692676       0          0  18
&gt; 27   20.0   43.0     1   8.84873374  1.08692676       0          1  18
&gt; 28    0.0   37.0     1  11.12388775  1.13347023       0          0  19
&gt; 29    0.0   18.0     0   7.27994524  1.33059548       0          0  20
&gt; 30   18.0   28.0     1   7.27994524  1.33059548       0          1  20
&gt; 31    0.0    8.0     0  -4.65708419  1.33880903       0          0  21
&gt; 32    8.0 1032.0     1  -4.65708419  1.33880903       0          1  21
&gt; 33    0.0   12.0     0  -5.21560575  1.46201232       0          0  22
&gt; 34   12.0   51.0     1  -5.21560575  1.46201232       0          1  22
&gt; 35    0.0    3.0     0  10.35728953  1.52772074       0          0  23
&gt; 36    3.0  733.0     1  10.35728953  1.52772074       0          1  23
&gt; 37    0.0   83.0     0   3.80013689  1.56605065       0          0  24
&gt; 38   83.0  219.0     1   3.80013689  1.56605065       0          1  24
&gt; 39    0.0   25.0     0 -14.77618070  1.57426420       0          0  25
&gt; 40   25.0 1800.0     0 -14.77618070  1.57426420       0          1  25
&gt; 41    0.0 1401.0     0 -17.46475017  1.58247775       0          0  26
&gt; 42    0.0  263.0     1 -39.21423682  1.59069131       0          0  27
&gt; 43    0.0   71.0     0   6.02327173  1.68377823       0          0  28
&gt; 44   71.0   72.0     1   6.02327173  1.68377823       0          1  28
&gt; 45    0.0   35.0     1   2.43394935  1.78507871       0          0  29
&gt; 46    0.0   16.0     0  -3.08829569  1.88364134       0          0  30
&gt; 47   16.0  852.0     1  -3.08829569  1.88364134       0          1  30
&gt; 48    0.0   16.0     1   6.88569473  1.89459274       0          0  31
&gt; 49    0.0   17.0     0  16.40793977  1.91101985       0          0  32
&gt; 50   17.0   77.0     1  16.40793977  1.91101985       0          1  32
&gt; 51    0.0   51.0     0   0.90349076  2.15742642       0          0  33
&gt; 52   51.0 1587.0     0   0.90349076  2.15742642       0          1  33
&gt; 53    0.0   23.0     0  -7.44695414  2.19849418       0          0  34
&gt; 54   23.0 1572.0     0  -7.44695414  2.19849418       0          1  34
&gt; 55    0.0   12.0     1  -4.53388090  2.30800821       0          0  35
&gt; 56    0.0   46.0     0   0.92539357  2.50787132       0          0  36
&gt; 57   46.0  100.0     1   0.92539357  2.50787132       0          1  36
&gt; 58    0.0   19.0     0  13.50034223  2.56536619       0          0  37
&gt; 59   19.0   66.0     1  13.50034223  2.56536619       0          1  37
&gt; 60    0.0    4.5     0  -6.52977413  2.59274470       0          0  38
&gt; 61    4.5    5.0     1  -6.52977413  2.59274470       0          1  38
&gt; 62    0.0    2.0     0   2.51882272  2.63381246       0          0  39
&gt; 63    2.0   53.0     1   2.51882272  2.63381246       0          1  39
&gt; 64    0.0   41.0     0   0.48186174  2.64750171       1          0  40
&gt; 65   41.0 1408.0     0   0.48186174  2.64750171       1          1  40
&gt; 66    0.0   58.0     0  -2.69678303  2.88295688       1          0  41
&gt; 67   58.0 1322.0     0  -2.69678303  2.88295688       1          1  41
&gt; 68    0.0    3.0     1 -11.55920602  2.88843258       0          0  42
&gt; 69    0.0    2.0     1  -4.60780287  3.05817933       1          0  43
&gt; 70    0.0   40.0     1  -5.42094456  3.16495551       1          0  44
&gt; 71    0.0    1.0     0 -11.81656400  3.26351814       0          0  45
&gt; 72    1.0   45.0     1 -11.81656400  3.26351814       0          1  45
&gt; 73    0.0    2.0     0   0.61054073  3.27720739       1          0  46
&gt; 74    2.0  996.0     1   0.61054073  3.27720739       1          1  46
&gt; 75    0.0   21.0     0  -0.90075291  3.34017796       0          0  47
&gt; 76   21.0   72.0     1  -0.90075291  3.34017796       0          1  47
&gt; 77    0.0    9.0     1   8.03559206  3.34839151       0          0  48
&gt; 78    0.0   36.0     0 -11.34565366  3.37577002       1          0  49
&gt; 79   36.0 1142.0     0 -11.34565366  3.37577002       1          1  49
&gt; 80    0.0   83.0     0  -2.11362081  3.37577002       1          0  50
&gt; 81   83.0  980.0     1  -2.11362081  3.37577002       1          1  50
&gt; 82    0.0   32.0     0   0.73374401  3.47707050       0          0  51
&gt; 83   32.0  285.0     1   0.73374401  3.47707050       0          1  51
&gt; 84    0.0  102.0     1  -6.75154004  3.56468172       0          0  52
&gt; 85    0.0   41.0     0  -0.65708419  3.75085558       0          0  53
&gt; 86   41.0  188.0     1  -0.65708419  3.75085558       0          1  53
&gt; 87    0.0    3.0     1  -0.20807666  3.75085558       0          0  54
&gt; 88    0.0   10.0     0   4.45448323  3.85489391       0          0  55
&gt; 89   10.0   61.0     1   4.45448323  3.85489391       0          1  55
&gt; 90    0.0   67.0     0  -9.25667351  3.92334018       0          0  56
&gt; 91   67.0  942.0     0  -9.25667351  3.92334018       0          1  56
&gt; 92    0.0  149.0     1  -6.73511294  3.95071869       0          0  57
&gt; 93    0.0   21.0     0   0.01642710  3.97809719       1          0  58
&gt; 94   21.0  343.0     1   0.01642710  3.97809719       1          1  58
&gt; 95    0.0   78.0     0  -6.61738535  3.99452430       1          0  59
&gt; 96   78.0  916.0     0  -6.61738535  3.99452430       1          1  59
&gt; 97    0.0    3.0     0   1.05407255  4.13141684       0          0  60
&gt; 98    3.0   68.0     1   1.05407255  4.13141684       0          1  60
&gt; 99    0.0    2.0     1   4.56399726  4.17522245       0          0  61
&gt; 100   0.0   69.0     1  -8.64613279  4.18891170       0          0  62
&gt; 101   0.0   27.0     0 -15.34017796  4.19712526       0          0  63
&gt; 102  27.0  842.0     0 -15.34017796  4.19712526       0          1  63
&gt; 103   0.0   33.0     0   0.81587953  4.33675565       1          0  64
&gt; 104  33.0  584.0     1   0.81587953  4.33675565       1          1  64
&gt; 105   0.0   12.0     0   3.29363450  4.42984257       0          0  65
&gt; 106  12.0   78.0     1   3.29363450  4.42984257       0          1  65
&gt; 107   0.0   32.0     1   5.21286790  4.46817248       0          0  66
&gt; 108   0.0   57.0     0 -28.44900753  4.47638604       0          0  67
&gt; 109  57.0  285.0     1 -28.44900753  4.47638604       0          1  67
&gt; 110   0.0    3.0     0  -2.75975359  4.51745380       0          0  68
&gt; 111   3.0   68.0     1  -2.75975359  4.51745380       0          1  68
&gt; 112   0.0   10.0     0  -0.01095140  4.66803559       0          0  69
&gt; 113  10.0  670.0     0  -0.01095140  4.66803559       0          1  69
&gt; 114   0.0    5.0     0   5.00205339  4.71184120       0          0  70
&gt; 115   5.0   30.0     1   5.00205339  4.71184120       0          1  70
&gt; 116   0.0   31.0     0  -0.59137577  4.80492813       0          0  71
&gt; 117  31.0  620.0     0  -0.59137577  4.80492813       0          1  71
&gt; 118   0.0    4.0     0 -21.27310062  4.87063655       0          0  72
&gt; 119   4.0  596.0     0 -21.27310062  4.87063655       0          1  72
&gt; 120   0.0   27.0     0   8.33127995  4.94729637       0          0  73
&gt; 121  27.0   90.0     1   8.33127995  4.94729637       0          1  73
&gt; 122   0.0    5.0     0 -18.83367556  4.96646133       0          0  74
&gt; 123   5.0   17.0     1 -18.83367556  4.96646133       0          1  74
&gt; 124   0.0    2.0     1   4.18069815  4.99657769       0          0  75
&gt; 125   0.0   46.0     0   4.08487337  5.01026694       1          0  76
&gt; 126  46.0  545.0     0   4.08487337  5.01026694       1          1  76
&gt; 127   0.0   21.0     1  -6.88843258  5.01574264       0          0  77
&gt; 128   0.0  210.0     0   0.70362765  5.09240246       0          0  78
&gt; 129 210.0  515.0     0   0.70362765  5.09240246       0          1  78
&gt; 130   0.0   67.0     0   5.78234086  5.16632444       0          0  79
&gt; 131  67.0   96.0     1   5.78234086  5.16632444       0          1  79
&gt; 132   0.0   26.0     0  -1.55509925  5.18275154       1          0  80
&gt; 133  26.0  482.0     0  -1.55509925  5.18275154       1          1  80
&gt; 134   0.0    6.0     0   4.89253936  5.28405202       0          0  81
&gt; 135   6.0  445.0     0   4.89253936  5.28405202       0          1  81
&gt; 136   0.0  428.0     0 -18.79808350  4.08487337       0          0  82
&gt; 137   0.0   32.0     0   5.30869268  5.31690623       0          0  83
&gt; 138  32.0   80.0     1   5.30869268  5.31690623       0          1  83
&gt; 139   0.0   37.0     0  -5.28131417  5.33333333       0          0  84
&gt; 140  37.0  334.0     1  -5.28131417  5.33333333       0          1  84
&gt; 141   0.0    5.0     1  -0.01916496  5.35249829       0          0  85
&gt; 142   0.0    8.0     0   0.91991786  5.41546886       0          0  86
&gt; 143   8.0  397.0     0   0.91991786  5.41546886       0          1  86
&gt; 144   0.0   60.0     0  -1.74674880  5.47022587       0          0  87
&gt; 145  60.0  110.0     1  -1.74674880  5.47022587       0          1  87
&gt; 146   0.0   31.0     0   6.36276523  5.48939083       0          0  88
&gt; 147  31.0  370.0     0   6.36276523  5.48939083       0          1  88
&gt; 148   0.0  139.0     0   3.04722793  5.51129363       0          0  89
&gt; 149 139.0  207.0     1   3.04722793  5.51129363       0          1  89
&gt; 150   0.0  160.0     0   4.03285421  5.51403149       1          0  90
&gt; 151 160.0  186.0     1   4.03285421  5.51403149       1          1  90
&gt; 152   0.0  340.0     1  -0.40520192  5.53319644       0          0  91
&gt; 153   0.0  310.0     0  -3.01711157  5.57152635       0          0  92
&gt; 154 310.0  340.0     0  -3.01711157  5.57152635       0          1  92
&gt; 155   0.0   28.0     0  -0.24914442  5.77686516       0          0  93
&gt; 156  28.0  265.0     0  -0.24914442  5.77686516       0          1  93
&gt; 157   0.0    4.0     0  -4.15879535  5.95482546       1          0  94
&gt; 158   4.0  165.0     1  -4.15879535  5.95482546       1          1  94
&gt; 159   0.0    2.0     0  -7.71800137  5.97672827       0          0  95
&gt; 160   2.0   16.0     1  -7.71800137  5.97672827       0          1  95
&gt; 161   0.0   13.0     0 -21.34976044  6.00958248       0          0  96
&gt; 162  13.0  180.0     0 -21.34976044  6.00958248       0          1  96
&gt; 163   0.0   21.0     0 -24.38329911  6.14373717       0          0  97
&gt; 164  21.0  131.0     0 -24.38329911  6.14373717       0          1  97
&gt; 165   0.0   96.0     0 -19.37029432  6.20396988       0          0  98
&gt; 166  96.0  109.0     0 -19.37029432  6.20396988       0          1  98
&gt; 167   0.0   21.0     1   1.83436003  6.23408624       0          0  99
&gt; 168   0.0   38.0     0 -12.93908282  6.39561944       1          0 100
&gt; 169  38.0   39.0     0 -12.93908282  6.39561944       1          1 100
&gt; 170   0.0   31.0     0   1.51676934  6.41752225       0          0 101
&gt; 171   0.0   11.0     0  -7.60848734  6.47227926       0          0 102
&gt; 172   0.0    6.0     1  -8.68446270 -0.04928131       0          0 103
```



---

class: inverse center middle
name: clase-10

# CLASE 10: importar/exportar y cruzando tablas

&amp;nbsp;

---

class: inverse center middle
name: clase-11

# CLASE 11: factores y textos


&amp;nbsp;

---

class: inverse center middle
name: clase-12

# CLASE 12: entrega II


---


# .orange[RECURSOS] y .green[BIBLIOGRAFÍA]

&amp;nbsp;


#### 📚 **.bg-purple_light[Artículos o libros]** científicos que han sido sometidos a revisión por pares.

&amp;nbsp;

#### 🔗 **.bg-green_light[Recursos online]** recomendados

&amp;nbsp;

#### 💻 Recursos para la **.bg-orange[programación en R]**

---

# Bibliografía general

📚 **«Statistical tests, P values, confidence intervals, and power: a guide to misinterpretations»**. Greenland et al. (2016) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bioestad/biblio/p-value_Greenland_etal_2016.pdf&gt;

💻 **Tidy Data Tutor**: para visualizar la mecánica interna de `{tidyverse}`. &lt;https://tidydatatutor.com/&gt;

🔗 Web con recursos para la **introducción a la estadística y Machine Learning en R** &lt;https://artofstat.com/&gt;

💻 **Manual introductorio de R** (Javier Álvarez Liébana): &lt;https://dadosdelaplace.github.io/courses-intro-R/&gt;


---

# Bibliografía general

📚 **«The reproducibility of research and the misinterpretation of p-values»**. Colquhoun (2017) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bioestad/biblio/p-values_Colquhoun_2017.pdf&gt;


📚 **«An Introduction to Multivariate Statistical Analysis»**. Anderson (1958) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bioestad/biblio/introduction_mva_anderson_2003.pdf&gt;

📚 **«A New Measure of Rank Correlation»**. Kendall (1938) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bioestad/biblio/correlation_kendall_1938.pdf&gt;

📚 **«The generalised product moment distribution in samples from a normal multivariate population»**. Wishart (1928) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bioestad/biblio/multivariate_normal_wishart_1928.pdf&gt;

📚 **«On lines and planes of closest fit to systems of points in space»**. Pearson (1901) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bioestad/biblio/fit_pearson_1901.pdf&gt;


---

# Recursos dataviz

### Dataviz

📚 **«Gramática de las gráficas: pistas para mejorar las representaciones de datos»**. Sevilla (2005) &lt;http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf&gt;

📚 **«Quantitative Graphics in Statistics: A Brief History»**. Beniger and Robyn (1978) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/graphics_beniger_robin_1978.pdf&gt;
 
 
💻 **«Analizando datos, visualizando información, contando historias»** (curso de dataviz en R). Álvarez-Liébana y Valverde-Castilla (2022) &lt;https://dadosdelaplace.github.io/curso-dataviz-ECI-2022&gt;

📚 **«40 years of boxplots»**. Wickham and Stryjewski (2011) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/boxplot_Wickham_Stryjewski_2011.pdf&gt;
 
 


---

# Bibliografía componentes principales

💻 **Componentes principales** en `{tidymodels}`. &lt;https://www.tmwr.org/dimensionality.html#beans&gt;


📚 **«Principal Component Analysis»**. Jolliffe (2002) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/pca_jolliffe_2002.pdf&gt;

📚 **«Principal Component Analysis»**. Hervé and Lynne (2010) &lt;http://staff.ustc.edu.cn/~zwp/teach/MVA/abdi-awPCA2010.pdf&gt;

📚 **«Principal Component Analysis: a review and recent developments»**. Jolliffe and Cadima (2016) &lt;https://royalsocietypublishing.org/doi/10.1098/rsta.2015.0202&gt;

🔗 **«The Mathematics Behind Principal Component Analysis»**. Dubey (2018).  &lt;https://towardsdatascience.com/the-mathematics-behind-principal-component-analysis-fff2d7f4b643&gt;


🔗 **«A One-Stop Shop for Principal Component Analysis»**. Brems (2017). &lt;https://towardsdatascience.com/a-one-stop-shop-for-principal-component-analysis-5582fb7e0a9c&gt;

📚 **«On the number of principal components: a test of dimensionality based on measurements of similarity between matrices»**. Dray (2008) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/numer_pca_dray_2008.pdf&gt;


---

# Bibliografía análisis clúster

📚 **«Multiclass classification of dry beans using computer vision and machine learning techniques»**. Koklu y Ozkan (2020) &lt;https://github.com/dadosdelaplace/teaching/blob/main/bdba-pca-clustering-2022/biblio/multiclass_classif_koklu_ozlan_2020.pdf&gt;

💻 **«Clustering y heatmaps: aprendizaje no supervisado»**. Amat (2017). &lt;https://rpubs.com/Joaquin_AR/310338&gt;

💻 **«K-means clustering with tidy data principles»** &lt;https://www.tidymodels.org/learn/statistics/k-means/&gt;

🔗 **«ISLR tidymodels Labs»** &lt;https://emilhvitfeldt.github.io/ISLR-tidymodels-labs/unsupervised-learning.html#kmeans-clustering&gt;


📚 **«Algorithm AS 136: a K-Means Clustering Algorithm»**. Hartigan y Wong (1979) &lt;http://www.jstor.org/stable/2346830&gt;

🔗 **«Machine Learning for Social Scientists»**. Cimentada (2020) &lt;https://cimentadaj.github.io/ml_socsci/unsupervised-methods.html&gt;

---
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"slideNumberFormat": "%current%",
"highlightStyle": "github",
"highlightLines": true,
"ratio": "16:9",
"countIncrementalSlides": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
